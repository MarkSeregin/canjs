/*[system-bundles-config]*/
System.bundles = {"bundles/can/test/test.css!":["qunitjs@1.23.1#qunit/qunit.css!steal-css@1.3.2#css"],"bundles/test-test":["object-assign@4.1.1#index","react@16.8.6#cjs/react.production.min","prop-types@15.7.2#lib/ReactPropTypesSecret","prop-types@15.7.2#checkPropTypes","react@16.8.6#cjs/react.development","react@16.8.6#index","scheduler@0.13.6#cjs/scheduler.production.min","scheduler@0.13.6#cjs/scheduler.development","scheduler@0.13.6#index","react-dom@16.8.6#cjs/react-dom.production.min","scheduler@0.13.6#cjs/scheduler-tracing.production.min","scheduler@0.13.6#cjs/scheduler-tracing.development","scheduler@0.13.6#tracing","react-dom@16.8.6#cjs/react-dom.development","react-dom@16.8.6#index","react-dom@16.8.6#cjs/react-dom-test-utils.production.min","react-dom@16.8.6#cjs/react-dom-test-utils.development","react-dom@16.8.6#test-utils"],"bundles/react-view-model/test/test":["react-is@16.8.6#cjs/react-is.production.min","react-is@16.8.6#cjs/react-is.development","react-is@16.8.6#index","prop-types@15.7.2#factoryWithTypeCheckers","prop-types@15.7.2#factoryWithThrowingShims","prop-types@15.7.2#index","react-view-model@0.5.11#observer","react-view-model@0.5.11#helpers/make-enumerable","react-view-model@0.5.11#helpers/autobind-methods","react-view-model@0.5.11#component","react-view-model@0.5.11#helpers/observable-promise","react-view-model@0.5.11#react-view-model","react-view-model@0.5.11#test/test"],"bundles/can-react-component/test/test":["can-react-component@0.1.11#can-react-component","can-react-component@0.1.11#test/test"]};
/*npm-utils*/
define('npm-utils', function (require, exports, module) {
    (function (global, require, exports, module) {
        var slice = Array.prototype.slice;
        var npmModuleRegEx = /.+@.+\..+\..+#.+/;
        var conditionalModuleRegEx = /#\{[^\}]+\}|#\?.+$/;
        var gitUrlEx = /(git|http(s?)):\/\//;
        var supportsSet = typeof Set === 'function';
        var utils = {
            extend: function (d, s, deep, existingSet) {
                var val;
                var set = existingSet;
                if (deep) {
                    if (!set) {
                        if (supportsSet) {
                            set = new Set();
                        } else {
                            set = [];
                        }
                    }
                    if (supportsSet) {
                        if (set.has(s)) {
                            return s;
                        } else {
                            set.add(s);
                        }
                    } else {
                        if (set.indexOf(s) !== -1) {
                            return s;
                        } else {
                            set.push(s);
                        }
                    }
                }
                for (var prop in s) {
                    val = s[prop];
                    if (deep) {
                        if (utils.isArray(val)) {
                            d[prop] = slice.call(val);
                        } else if (utils.isPlainObject(val)) {
                            d[prop] = utils.extend({}, val, deep, set);
                        } else {
                            d[prop] = s[prop];
                        }
                    } else {
                        d[prop] = s[prop];
                    }
                }
                return d;
            },
            map: function (arr, fn) {
                var i = 0, len = arr.length, out = [];
                for (; i < len; i++) {
                    out.push(fn.call(arr, arr[i]));
                }
                return out;
            },
            filter: function (arr, fn) {
                var i = 0, len = arr.length, out = [], res;
                for (; i < len; i++) {
                    res = fn.call(arr, arr[i]);
                    if (res) {
                        out.push(arr[i]);
                    }
                }
                return out;
            },
            forEach: function (arr, fn) {
                var i = 0, len = arr.length;
                for (; i < len; i++) {
                    fn.call(arr, arr[i], i);
                }
            },
            flow: function (fns) {
                return function () {
                    var res = fns[0].apply(this, arguments);
                    for (var i = 1; i < fns.length; i++) {
                        res = fns[i].call(this, res);
                    }
                    return res;
                };
            },
            isObject: function (obj) {
                return typeof obj === 'object';
            },
            isPlainObject: function (obj) {
                return utils.isObject(obj) && (!obj || obj.__proto__ === Object.prototype);
            },
            isArray: Array.isArray || function (arr) {
                return Object.prototype.toString.call(arr) === '[object Array]';
            },
            isEnv: function (name) {
                return this.isEnv ? this.isEnv(name) : this.env === name;
            },
            isGitUrl: function (str) {
                return gitUrlEx.test(str);
            },
            warnOnce: function (msg) {
                var w = this._warnings = this._warnings || {};
                if (w[msg])
                    return;
                w[msg] = true;
                this.warn(msg);
            },
            warn: function (msg) {
                if (typeof steal !== 'undefined' && typeof console !== 'undefined' && console.warn) {
                    steal.done().then(function () {
                        if (steal.dev && steal.dev.warn) {
                        } else if (console.warn) {
                            console.warn('steal.js WARNING: ' + msg);
                        } else {
                            console.log(msg);
                        }
                    });
                }
            },
            relativeURI: function (baseURL, url) {
                return typeof steal !== 'undefined' ? steal.relativeURI(baseURL, url) : url;
            },
            moduleName: {
                create: function (descriptor, standard) {
                    if (standard) {
                        return descriptor.moduleName;
                    } else {
                        if (descriptor === '@empty') {
                            return descriptor;
                        }
                        var modulePath;
                        if (descriptor.modulePath) {
                            modulePath = descriptor.modulePath.substr(0, 2) === './' ? descriptor.modulePath.substr(2) : descriptor.modulePath;
                        }
                        var version = descriptor.version;
                        if (version && version[0] !== '^') {
                            version = encodeURIComponent(decodeURIComponent(version));
                        }
                        return descriptor.packageName + (version ? '@' + version : '') + (modulePath ? '#' + modulePath : '') + (descriptor.plugin ? descriptor.plugin : '');
                    }
                },
                isNpm: function (moduleName) {
                    return npmModuleRegEx.test(moduleName);
                },
                isConditional: function (moduleName) {
                    return conditionalModuleRegEx.test(moduleName);
                },
                isFullyConvertedNpm: function (parsedModuleName) {
                    return !!(parsedModuleName.packageName && parsedModuleName.version && parsedModuleName.modulePath);
                },
                isScoped: function (moduleName) {
                    return moduleName[0] === '@';
                },
                parse: function (moduleName, currentPackageName, global, context) {
                    var pluginParts = moduleName.split('!');
                    var modulePathParts = pluginParts[0].split('#');
                    var versionParts = modulePathParts[0].split('@');
                    if (!modulePathParts[1] && !versionParts[0]) {
                        versionParts = ['@' + versionParts[1]];
                    }
                    if (versionParts.length === 3 && utils.moduleName.isScoped(moduleName)) {
                        versionParts.splice(0, 1);
                        versionParts[0] = '@' + versionParts[0];
                    }
                    var packageName, modulePath;
                    if (currentPackageName && utils.path.isRelative(moduleName)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0];
                    } else if (currentPackageName && utils.path.isInHomeDir(moduleName, context)) {
                        packageName = currentPackageName;
                        modulePath = versionParts[0].split('/').slice(1).join('/');
                    } else {
                        if (modulePathParts[1]) {
                            packageName = versionParts[0];
                            modulePath = modulePathParts[1];
                        } else {
                            var folderParts = versionParts[0].split('/');
                            if (folderParts.length && folderParts[0][0] === '@') {
                                packageName = folderParts.splice(0, 2).join('/');
                            } else {
                                packageName = folderParts.shift();
                            }
                            modulePath = folderParts.join('/');
                        }
                    }
                    modulePath = utils.path.removeJS(modulePath);
                    return {
                        plugin: pluginParts.length === 2 ? '!' + pluginParts[1] : undefined,
                        version: versionParts[1],
                        modulePath: modulePath,
                        packageName: packageName,
                        moduleName: moduleName,
                        isGlobal: global
                    };
                },
                parseFromPackage: function (loader, refPkg, name, parentName) {
                    var packageName = utils.pkg.name(refPkg), parsedModuleName = utils.moduleName.parse(name, packageName, undefined, { loader: loader }), isRelative = utils.path.isRelative(parsedModuleName.modulePath);
                    if (isRelative && !parentName) {
                        throw new Error('Cannot resolve a relative module identifier ' + 'with no parent module:', name);
                    }
                    if (isRelative) {
                        var parentParsed = utils.moduleName.parse(parentName, packageName);
                        if (parentParsed.packageName === parsedModuleName.packageName && parentParsed.modulePath) {
                            var makePathRelative = true;
                            if (name === '../' || name === './' || name === '..') {
                                var relativePath = utils.path.relativeTo(parentParsed.modulePath, name);
                                var isInRoot = utils.path.isPackageRootDir(relativePath);
                                if (isInRoot) {
                                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                                    makePathRelative = false;
                                } else {
                                    parsedModuleName.modulePath = name + (utils.path.endsWithSlash(name) ? '' : '/') + 'index';
                                }
                            }
                            if (makePathRelative) {
                                parsedModuleName.modulePath = utils.path.makeRelative(utils.path.joinURIs(parentParsed.modulePath, parsedModuleName.modulePath));
                            }
                        }
                    }
                    var mapName = utils.moduleName.create(parsedModuleName), refSteal = utils.pkg.config(refPkg), mappedName;
                    if (refPkg.browser && typeof refPkg.browser !== 'string' && mapName in refPkg.browser && (!refSteal || !refSteal.ignoreBrowser)) {
                        mappedName = refPkg.browser[mapName] === false ? '@empty' : refPkg.browser[mapName];
                    }
                    var global = loader && loader.globalBrowser && loader.globalBrowser[mapName];
                    if (global) {
                        mappedName = global.moduleName === false ? '@empty' : global.moduleName;
                    }
                    if (mappedName) {
                        return utils.moduleName.parse(mappedName, packageName, !!global);
                    } else {
                        return parsedModuleName;
                    }
                },
                nameAndVersion: function (parsedModuleName) {
                    return parsedModuleName.packageName + '@' + parsedModuleName.version;
                },
                isBareIdentifier: function (identifier) {
                    return identifier && identifier[0] !== '.' && identifier[0] !== '@';
                }
            },
            pkg: {
                name: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.name || pkg.name;
                },
                main: function (pkg) {
                    var main;
                    var steal = utils.pkg.config(pkg);
                    if (steal && steal.main) {
                        main = steal.main;
                    } else if (typeof pkg.browser === 'string') {
                        if (utils.path.endsWithSlash(pkg.browser)) {
                            main = pkg.browser + 'index';
                        } else {
                            main = pkg.browser;
                        }
                    } else if (typeof pkg.jam === 'object' && pkg.jam.main) {
                        main = pkg.jam.main;
                    } else if (pkg.main) {
                        main = pkg.main;
                    } else {
                        main = 'index';
                    }
                    return utils.path.removeJS(utils.path.removeDotSlash(main));
                },
                rootDir: function (pkg, isRoot) {
                    var root = isRoot ? utils.path.removePackage(pkg.fileUrl) : utils.path.pkgDir(pkg.fileUrl);
                    var lib = utils.pkg.directoriesLib(pkg);
                    if (lib) {
                        root = utils.path.joinURIs(utils.path.addEndingSlash(root), lib);
                    }
                    return root;
                },
                isRoot: function (loader, pkg) {
                    var root = utils.pkg.getDefault(loader);
                    return pkg && pkg.name === root.name && pkg.version === root.version;
                },
                homeAlias: function (context) {
                    return context && context.loader && context.loader.homeAlias || '~';
                },
                getDefault: function (loader) {
                    return loader.npmPaths.__default;
                },
                findByModuleNameOrAddress: function (loader, moduleName, moduleAddress) {
                    if (loader.npm) {
                        if (moduleName) {
                            var parsed = utils.moduleName.parse(moduleName);
                            if (parsed.version && parsed.packageName) {
                                var name = parsed.packageName + '@' + parsed.version;
                                if (name in loader.npm) {
                                    return loader.npm[name];
                                }
                            }
                        }
                        if (moduleAddress) {
                            var startingAddress = utils.relativeURI(loader.baseURL, moduleAddress);
                            var packageFolder = utils.pkg.folderAddress(startingAddress);
                            return packageFolder ? loader.npmPaths[packageFolder] : utils.pkg.getDefault(loader);
                        } else {
                            return utils.pkg.getDefault(loader);
                        }
                    }
                },
                folderAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                findDep: function (loader, refPkg, name) {
                    if (loader.npm && refPkg && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + refPkg.resolutions[name];
                        var pkg = loader.npm[nameAndVersion];
                        return pkg;
                    }
                },
                findDepWalking: function (loader, refPackage, name) {
                    if (loader.npm && refPackage && !utils.path.startsWithDotSlash(name)) {
                        var curPackage = utils.path.depPackageDir(refPackage.fileUrl, name);
                        while (curPackage) {
                            var pkg = loader.npmPaths[curPackage];
                            if (pkg) {
                                return pkg;
                            }
                            var parentAddress = utils.path.parentNodeModuleAddress(curPackage);
                            if (!parentAddress) {
                                return;
                            }
                            curPackage = parentAddress + '/' + name;
                        }
                    }
                },
                findByName: function (loader, name) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        return loader.npm[name];
                    }
                },
                findByNameAndVersion: function (loader, name, version) {
                    if (loader.npm && !utils.path.startsWithDotSlash(name)) {
                        var nameAndVersion = name + '@' + version;
                        return loader.npm[nameAndVersion];
                    }
                },
                findByUrl: function (loader, url) {
                    if (loader.npm) {
                        var fullUrl = utils.pkg.folderAddress(url);
                        return loader.npmPaths[fullUrl];
                    }
                },
                directoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    var lib = steal && steal.directories && steal.directories.lib;
                    var ignores = [
                            '.',
                            '/'
                        ], ignore;
                    if (!lib)
                        return undefined;
                    while (!!(ignore = ignores.shift())) {
                        if (lib[0] === ignore) {
                            lib = lib.substr(1);
                        }
                    }
                    return lib;
                },
                hasDirectoriesLib: function (pkg) {
                    var steal = utils.pkg.config(pkg);
                    return steal && steal.directories && !!steal.directories.lib;
                },
                findPackageInfo: function (context, pkg) {
                    var pkgInfo = context.pkgInfo;
                    if (pkgInfo) {
                        var out;
                        utils.forEach(pkgInfo, function (p) {
                            if (pkg.name === p.name && pkg.version === p.version) {
                                out = p;
                            }
                        });
                        return out;
                    }
                },
                saveResolution: function (context, refPkg, pkg) {
                    var npmPkg = utils.pkg.findPackageInfo(context, refPkg);
                    npmPkg.resolutions[pkg.name] = refPkg.resolutions[pkg.name] = pkg.version;
                },
                config: function (pkg) {
                    return pkg.steal || pkg.system;
                }
            },
            path: {
                makeRelative: function (path) {
                    if (utils.path.isRelative(path) && path.substr(0, 1) !== '/') {
                        return path;
                    } else {
                        return './' + path;
                    }
                },
                removeJS: function (path) {
                    return path.replace(/\.js(!|$)/, function (whole, part) {
                        return part;
                    });
                },
                removePackage: function (path) {
                    return path.replace(/\/package\.json.*/, '');
                },
                addJS: function (path) {
                    if (/\.js(on)?$/.test(path)) {
                        return path;
                    } else {
                        return path + '.js';
                    }
                },
                isRelative: function (path) {
                    return path.substr(0, 1) === '.';
                },
                isInHomeDir: function (path, context) {
                    return path.substr(0, 2) === utils.pkg.homeAlias(context) + '/';
                },
                joinURIs: function (baseUri, rel) {
                    function removeDotSegments(input) {
                        var output = [];
                        input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                            if (p === '/..') {
                                output.pop();
                            } else {
                                output.push(p);
                            }
                        });
                        return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
                    }
                    var href = parseURI(rel || '');
                    var base = parseURI(baseUri || '');
                    return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
                },
                startsWithDotSlash: function (path) {
                    return path.substr(0, 2) === './';
                },
                removeDotSlash: function (path) {
                    return utils.path.startsWithDotSlash(path) ? path.substr(2) : path;
                },
                endsWithSlash: function (path) {
                    return path[path.length - 1] === '/';
                },
                addEndingSlash: function (path) {
                    return utils.path.endsWithSlash(path) ? path : path + '/';
                },
                depPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return (packageFolderName ? packageFolderName + '/' : '') + 'node_modules/' + childName + '/package.json';
                },
                peerPackage: function (parentPackageAddress, childName) {
                    var packageFolderName = parentPackageAddress.replace(/\/package\.json.*/, '');
                    return packageFolderName.substr(0, packageFolderName.lastIndexOf('/')) + '/' + childName + '/package.json';
                },
                depPackageDir: function (parentPackageAddress, childName) {
                    return utils.path.depPackage(parentPackageAddress, childName).replace(/\/package\.json.*/, '');
                },
                peerNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules);
                    if (nodeModulesIndex >= 0) {
                        return address.substr(0, nodeModulesIndex + nodeModules.length - 1);
                    }
                },
                parentNodeModuleAddress: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), prevModulesIndex = address.lastIndexOf(nodeModules, nodeModulesIndex - 1);
                    if (prevModulesIndex >= 0) {
                        return address.substr(0, prevModulesIndex + nodeModules.length - 1);
                    }
                },
                pkgDir: function (address) {
                    var nodeModules = '/node_modules/', nodeModulesIndex = address.lastIndexOf(nodeModules), nextSlash = address.indexOf('/', nodeModulesIndex + nodeModules.length);
                    if (address[nodeModulesIndex + nodeModules.length] === '@') {
                        nextSlash = address.indexOf('/', nextSlash + 1);
                    }
                    if (nodeModulesIndex >= 0) {
                        return nextSlash >= 0 ? address.substr(0, nextSlash) : address;
                    }
                },
                basename: function (address) {
                    var parts = address.split('/');
                    return parts[parts.length - 1];
                },
                relativeTo: function (modulePath, rel) {
                    var parts = modulePath.split('/');
                    var idx = 1;
                    while (rel[idx] === '.') {
                        parts.pop();
                        idx++;
                    }
                    return parts.join('/');
                },
                isPackageRootDir: function (pth) {
                    return pth.indexOf('/') === -1;
                }
            },
            json: {
                transform: function (loader, load, data) {
                    data.steal = utils.pkg.config(data);
                    var fn = loader.jsonOptions && loader.jsonOptions.transform;
                    if (!fn)
                        return data;
                    return fn.call(loader, load, data);
                }
            },
            includeInBuild: true
        };
        function parseURI(url) {
            var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/]*(?::[^:@\/]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
            return m ? {
                href: m[0] || '',
                protocol: m[1] || '',
                authority: m[2] || '',
                host: m[3] || '',
                hostname: m[4] || '',
                port: m[5] || '',
                pathname: m[6] || '',
                search: m[7] || '',
                hash: m[8] || ''
            } : null;
        }
        module.exports = utils;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*npm-extension*/
define('npm-extension', [
    'require',
    'exports',
    'module',
    '@steal',
    './npm-utils'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        var steal = require('@steal');
        var utils = require('./npm-utils');
        exports.includeInBuild = true;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var isBrowser = typeof window !== 'undefined' && !isNode && !isWorker;
        exports.addExtension = function (System) {
            if (System._extensions) {
                System._extensions.push(exports.addExtension);
            }
            var oldNormalize = System.normalize;
            System.normalize = function (identifier, parentModuleName, parentAddress, pluginNormalize) {
                var name = identifier;
                var parentName = parentModuleName;
                if (parentName && this.npmParentMap && this.npmParentMap[parentName]) {
                    parentName = this.npmParentMap[parentName];
                }
                var hasNoParent = !parentName;
                var nameIsRelative = utils.path.isRelative(name);
                var parentIsNpmModule = utils.moduleName.isNpm(parentName);
                var identifierEndsWithSlash = utils.path.endsWithSlash(name);
                if (parentName && nameIsRelative && !parentIsNpmModule) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                if (utils.moduleName.isConditional(name)) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var hasContextualMap = typeof this.map[parentName] === 'object' && this.map[parentName][name];
                if (hasContextualMap) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var refPkg = utils.pkg.findByModuleNameOrAddress(this, parentName, parentAddress);
                if (!refPkg) {
                    return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                }
                var isPointingAtParentFolder = name === '../' || name === './';
                if (parentIsNpmModule && isPointingAtParentFolder) {
                    var parsedParentModuleName = utils.moduleName.parse(parentName);
                    var parentModulePath = parsedParentModuleName.modulePath || '';
                    var relativePath = utils.path.relativeTo(parentModulePath, name);
                    var isInRoot = utils.path.isPackageRootDir(relativePath);
                    if (isInRoot) {
                        name = refPkg.name + '#' + utils.path.removeJS(refPkg.main);
                    } else {
                        name = name + 'index';
                    }
                }
                var parsedModuleName = utils.moduleName.parseFromPackage(this, refPkg, name, parentName);
                var isRoot = utils.pkg.isRoot(this, refPkg);
                var parsedPackageNameIsReferringPackage = parsedModuleName.packageName === refPkg.name;
                var isRelativeToParentNpmModule = parentIsNpmModule && nameIsRelative && parsedPackageNameIsReferringPackage;
                var depPkg, wantedPkg;
                if (isRelativeToParentNpmModule) {
                    depPkg = refPkg;
                }
                var context = this.npmContext;
                var crawl = context && context.crawl;
                var isDev = !!crawl;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = nameIsRelative ? null : crawl.matchedVersion(context, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            wantedPkg = depMap[parsedModuleName.packageName];
                            if (wantedPkg) {
                                var wantedVersion = refPkg.resolutions && refPkg.resolutions[wantedPkg.name] || wantedPkg.version;
                                var foundPkg = crawl.matchedVersion(this.npmContext, wantedPkg.name, wantedVersion);
                                if (foundPkg) {
                                    depPkg = utils.pkg.findByUrl(this, foundPkg.fileUrl);
                                }
                            }
                        }
                    } else {
                        if (isRoot) {
                            depPkg = utils.pkg.findDepWalking(this, refPkg, parsedModuleName.packageName);
                        } else {
                            depPkg = utils.pkg.findDep(this, refPkg, parsedModuleName.packageName);
                        }
                    }
                }
                if (parsedPackageNameIsReferringPackage) {
                    depPkg = utils.pkg.findByNameAndVersion(this, parsedModuleName.packageName, refPkg.version);
                }
                var lookupByName = parsedModuleName.isGlobal || hasNoParent;
                if (!depPkg) {
                    depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                }
                var isThePackageWeWant = !isDev || !depPkg || (wantedPkg ? crawl.pkgSatisfies(depPkg, wantedPkg.version) : true);
                if (!isThePackageWeWant) {
                    depPkg = undefined;
                } else if (isDev && depPkg) {
                    utils.pkg.saveResolution(context, refPkg, depPkg);
                }
                if (!depPkg) {
                    var browserPackageName = this.globalBrowser[parsedModuleName.packageName];
                    if (browserPackageName) {
                        parsedModuleName.packageName = browserPackageName.moduleName;
                        depPkg = utils.pkg.findByName(this, parsedModuleName.packageName);
                    }
                }
                if (!depPkg && isRoot && name === refPkg.main && utils.pkg.hasDirectoriesLib(refPkg)) {
                    parsedModuleName.version = refPkg.version;
                    parsedModuleName.packageName = refPkg.name;
                    parsedModuleName.modulePath = utils.pkg.main(refPkg);
                    return oldNormalize.call(this, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                }
                var loader = this;
                if (!depPkg) {
                    if (crawl) {
                        var parentPkg = crawl.matchedVersion(this.npmContext, refPkg.name, refPkg.version);
                        if (parentPkg) {
                            var depMap = crawl.getFullDependencyMap(this, parentPkg, isRoot);
                            depPkg = depMap[parsedModuleName.packageName];
                            if (!depPkg) {
                                var parents = crawl.findPackageAndParents(this.npmContext, parsedModuleName.packageName);
                                if (parents) {
                                    depPkg = parents.package;
                                }
                            }
                        }
                    }
                    if (!depPkg) {
                        if (refPkg.browser && refPkg.browser[name]) {
                            return oldNormalize.call(this, refPkg.browser[name], parentName, parentAddress, pluginNormalize);
                        }
                        var steal = utils.pkg.config(refPkg);
                        if (steal && steal.map && typeof steal.map[name] === 'string') {
                            var mappedName = steal.map[name];
                            var envConfig = steal.envs && steal.envs[loader.env];
                            if (envConfig && envConfig.map && typeof envConfig.map[name] === 'string') {
                                mappedName = envConfig.map[name];
                            }
                            return loader.normalize(mappedName, parentName, parentAddress, pluginNormalize);
                        } else {
                            return oldNormalize.call(this, name, parentName, parentAddress, pluginNormalize);
                        }
                    }
                    return crawl.dep(this.npmContext, parentPkg, refPkg, depPkg, isRoot).then(createModuleNameAndNormalize);
                } else {
                    return createModuleNameAndNormalize(depPkg);
                }
                function createModuleNameAndNormalize(depPkg) {
                    parsedModuleName.version = depPkg.version;
                    if (!parsedModuleName.modulePath) {
                        parsedModuleName.modulePath = utils.pkg.main(depPkg);
                    }
                    var p = oldNormalize.call(loader, utils.moduleName.create(parsedModuleName), parentName, parentAddress, pluginNormalize);
                    if (identifierEndsWithSlash) {
                        p.then(function (name) {
                            if (context && context.forwardSlashMap) {
                                context.forwardSlashMap[name] = true;
                            }
                        });
                    }
                    return p;
                }
            };
            var oldLocate = System.locate;
            System.locate = function (load) {
                var parsedModuleName = utils.moduleName.parse(load.name), loader = this;
                var pmn = load.metadata.parsedModuleName = parsedModuleName;
                load.metadata.npmPackage = utils.pkg.findByNameAndVersion(this, pmn.packageName, pmn.version);
                if (parsedModuleName.version && this.npm && !loader.paths[load.name]) {
                    var pkg = this.npm[utils.moduleName.nameAndVersion(parsedModuleName)];
                    if (pkg) {
                        return oldLocate.call(this, load).then(function (locatedAddress) {
                            var address = locatedAddress;
                            var expectedAddress = utils.path.joinURIs(System.baseURL, load.name);
                            if (isBrowser) {
                                expectedAddress = expectedAddress.replace(/#/g, '%23');
                            }
                            if (address !== expectedAddress + '.js' && address !== expectedAddress) {
                                return address;
                            }
                            var root = utils.pkg.rootDir(pkg, utils.pkg.isRoot(loader, pkg));
                            if (parsedModuleName.modulePath) {
                                var npmAddress = utils.path.joinURIs(utils.path.addEndingSlash(root), parsedModuleName.plugin ? parsedModuleName.modulePath : utils.path.addJS(parsedModuleName.modulePath));
                                address = typeof steal !== 'undefined' ? utils.path.joinURIs(loader.baseURL, npmAddress) : npmAddress;
                            }
                            return address;
                        });
                    }
                }
                return oldLocate.call(this, load);
            };
            var oldFetch = System.fetch;
            System.fetch = function (load) {
                if (load.metadata.dryRun) {
                    return oldFetch.apply(this, arguments);
                }
                var loader = this;
                var context = loader.npmContext;
                var fetchPromise = Promise.resolve(oldFetch.apply(this, arguments));
                if (utils.moduleName.isNpm(load.name)) {
                    fetchPromise = fetchPromise.then(null, function (err) {
                        if (err.statusCode !== 404) {
                            return Promise.reject(err);
                        }
                        if (!loader.npmContext) {
                            loader.npmContext = { forwardSlashMap: {} };
                        }
                        var types = [].slice.call(retryTypes);
                        return retryAll(types, err).then(null, function (e) {
                            return Promise.reject(err);
                        });
                        function retryAll(types, err) {
                            if (!types.length) {
                                throw err;
                            }
                            var type = types.shift();
                            if (!type.test(load)) {
                                throw err;
                            }
                            return Promise.resolve(retryFetch.call(loader, load, type)).then(null, function (err) {
                                return retryAll(types, err);
                            });
                        }
                    });
                }
                return fetchPromise.catch(function (error) {
                    if (error.statusCode === 404 && utils.moduleName.isBareIdentifier(load.name) && !utils.pkg.isRoot(loader, load.metadata.npmPackage)) {
                        var newError = new Error([
                            'Could not load \'' + load.name + '\'',
                            'Is this an npm module not saved in your package.json?'
                        ].join('\n'));
                        newError.statusCode = error.statusCode;
                        throw newError;
                    } else {
                        throw error;
                    }
                });
            };
            var convertName = function (loader, name) {
                var pkg = utils.pkg.findByName(loader, name.split('/')[0]);
                if (pkg) {
                    var parsed = utils.moduleName.parse(name, pkg.name);
                    parsed.version = pkg.version;
                    if (!parsed.modulePath) {
                        parsed.modulePath = utils.pkg.main(pkg);
                    }
                    return utils.moduleName.create(parsed);
                }
                return name;
            };
            var configSpecial = {
                map: function (map) {
                    var newMap = {}, val;
                    for (var name in map) {
                        val = map[name];
                        newMap[convertName(this, name)] = typeof val === 'object' ? configSpecial.map(val) : convertName(this, val);
                    }
                    return newMap;
                },
                meta: function (map) {
                    var newMap = {};
                    for (var name in map) {
                        newMap[convertName(this, name)] = map[name];
                    }
                    return newMap;
                },
                paths: function (paths) {
                    var newPaths = {};
                    for (var name in paths) {
                        newPaths[convertName(this, name)] = paths[name];
                    }
                    return newPaths;
                }
            };
            var oldConfig = System.config;
            System.config = function (cfg) {
                var loader = this;
                if (loader.npmContext) {
                    var context = loader.npmContext;
                    var pkg = context.versions.__default;
                    var conv = context.convert.steal(context, pkg, cfg, true);
                    context.convert.updateConfigOnPackageLoad(conv, false, true, context.applyBuildConfig);
                    oldConfig.apply(loader, arguments);
                    return;
                }
                for (var name in cfg) {
                    if (configSpecial[name]) {
                        cfg[name] = configSpecial[name].call(loader, cfg[name]);
                    }
                }
                oldConfig.apply(loader, arguments);
            };
            steal.addNpmPackages = function (npmPackages) {
                var packages = npmPackages || [];
                var loader = this.loader;
                for (var i = 0; i < packages.length; i += 1) {
                    var pkg = packages[i];
                    var path = pkg && pkg.fileUrl;
                    if (path) {
                        loader.npmContext.paths[path] = pkg;
                    }
                }
            };
            steal.getNpmPackages = function () {
                var context = this.loader.npmContext;
                return context ? context.packages || [] : [];
            };
            function retryFetch(load, type) {
                var loader = this;
                var moduleName = typeof type.name === 'function' ? type.name(loader, load) : load.name + type.name;
                var local = utils.extend({}, load);
                local.name = moduleName;
                local.metadata = { dryRun: true };
                return Promise.resolve(loader.locate(local)).then(function (address) {
                    local.address = address;
                    return loader.fetch(local);
                }).then(function (source) {
                    load.metadata.address = local.address;
                    loader.npmParentMap[load.name] = local.name;
                    var npmLoad = loader.npmContext && loader.npmContext.npmLoad;
                    if (npmLoad) {
                        npmLoad.saveLoadIfNeeded(loader.npmContext);
                        if (!isNode) {
                            utils.warnOnce('Some 404s were encountered ' + 'while loading. Don\'t panic! ' + 'These will only happen in dev ' + 'and are harmless.');
                        }
                    }
                    return source;
                });
            }
            var retryTypes = [
                {
                    name: function (loader, load) {
                        var context = loader.npmContext;
                        if (context.forwardSlashMap[load.name]) {
                            var parts = load.name.split('/');
                            parts.pop();
                            return parts.concat(['index']).join('/');
                        }
                        return load.name + '/index';
                    },
                    test: function () {
                        return true;
                    }
                },
                {
                    name: '.json',
                    test: function (load) {
                        return utils.moduleName.isNpm(load.name) && utils.path.basename(load.address) === 'package.js';
                    }
                }
            ];
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*node_modules/steal-conditional/conditional*/
define('node_modules/steal-conditional/conditional', [
    'module',
    'exports'
], function (module, exports) {
    exports.extensionBuilder = 'steal-conditional/slim';
    function addConditionals(loader) {
        var conditionalRegEx = /#\{[^\}]+\}|#\?.+$/;
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        if (loader._extensions) {
            loader._extensions.push(addConditionals);
        }
        loader.set('@@conditional-helpers', loader.newModule({
            isConditionalModuleName: function (moduleName) {
                return conditionalRegEx.test(moduleName);
            }
        }));
        var normalize = loader.normalize;
        function readMemberExpression(p, value) {
            var pParts = p.split('.');
            while (pParts.length) {
                value = value[pParts.shift()];
            }
            return value;
        }
        function includeInBuild(loader, name) {
            var load = loader.getModuleLoad(name);
            load.metadata.includeInBuild = true;
        }
        function getGlob() {
            if (isNode) {
                return loader.import('@node-require', { name: module.id }).then(function (nodeRequire) {
                    return nodeRequire('glob');
                });
            }
            return Promise.resolve();
        }
        function pushIfUnique(array, item) {
            return array.indexOf(item) === -1 ? array.push(item) : array.length;
        }
        function getModuleName(nameWithConditional, variation) {
            var modName;
            var conditionIndex = nameWithConditional.search(conditionalRegEx);
            var lastSlashIndex = nameWithConditional.indexOf('/', nameWithConditional.indexOf('}'));
            if (lastSlashIndex !== -1) {
                modName = nameWithConditional.substr(0, conditionIndex) + variation;
            } else {
                modName = nameWithConditional.replace(conditionalRegEx, variation);
            }
            return modName;
        }
        loader.normalize = function (name, parentName, parentAddress, pluginNormalize) {
            var loader = this;
            var conditionalMatch = name.match(conditionalRegEx);
            if (conditionalMatch) {
                var substitution = conditionalMatch[0][1] !== '?';
                var conditionModule = substitution ? conditionalMatch[0].substr(2, conditionalMatch[0].length - 3) : conditionalMatch[0].substr(2);
                var conditionExport = 'default';
                var conditionExportParts = conditionModule.match(/^(?:\.\/|\.\.\/)+/);
                var conditionExportIndex = conditionModule.indexOf('.', conditionExportParts && conditionExportParts[0].length);
                if (conditionExportIndex !== -1) {
                    conditionExport = conditionModule.substr(conditionExportIndex + 1);
                    conditionModule = conditionModule.substr(0, conditionExportIndex);
                }
                var booleanNegation = !substitution && conditionModule[0] === '~';
                if (booleanNegation) {
                    conditionModule = conditionModule.substr(1);
                }
                var handleConditionalBuild = function () {
                };
                var handleConditionalEval = function (m) {
                    var conditionValue = typeof m === 'object' ? readMemberExpression(conditionExport, m) : m;
                    if (substitution) {
                        if (typeof conditionValue !== 'string') {
                            throw new TypeError('The condition value for ' + conditionalMatch[0] + ' doesn\'t resolve to a string.');
                        }
                        name = name.replace(conditionalRegEx, conditionValue);
                    } else {
                        if (typeof conditionValue !== 'boolean') {
                            throw new TypeError('The condition value for ' + conditionalMatch[0] + ' isn\'t resolving to a boolean.');
                        }
                        if (booleanNegation) {
                            conditionValue = !conditionValue;
                        }
                        if (!conditionValue) {
                            name = '@empty';
                        } else {
                            name = name.replace(conditionalRegEx, '');
                        }
                    }
                    if (name === '@empty') {
                        return normalize.call(loader, name, parentName, parentAddress, pluginNormalize);
                    } else {
                        return loader.normalize.call(loader, name, parentName, parentAddress, pluginNormalize);
                    }
                };
                var isBuild = (loader.env || '').indexOf('build') === 0;
                var pluginLoader = isBuild ? loader : loader.pluginLoader || loader;
                return pluginLoader['import'](conditionModule, {
                    name: parentName,
                    address: parentAddress
                }).then(function (m) {
                    return pluginLoader.normalize(conditionModule, parentName, parentAddress, pluginNormalize).then(function (fullName) {
                        includeInBuild(pluginLoader, fullName);
                        return m;
                    });
                }).then(function (m) {
                    return isBuild ? handleConditionalBuild() : handleConditionalEval(m);
                });
            }
            return Promise.resolve(normalize.call(loader, name, parentName, parentAddress, pluginNormalize));
        };
    }
    if (typeof System !== 'undefined') {
        addConditionals(System);
    }
});
/*npm-load*/
define('npm-load', [], function(){ return {}; });
/*semver*/
define('semver', [], function(){ return {}; });
/*npm-crawl*/
define('npm-crawl', [], function(){ return {}; });
/*npm-convert*/
define('npm-convert', [], function(){ return {}; });
/*npm*/
define('npm', [], function(){ return {}; });
/*package.json!npm*/
define('package.json!npm', [
    '@loader',
    'npm-extension',
    'module',
    './node_modules/steal-conditional/conditional.js'
], function (loader, npmExtension, module) {
    npmExtension.addExtension(loader);
    if (!loader.main) {
        loader.main = 'can@3.14.0#can';
    }
    loader._npmExtensions = [].slice.call(arguments, 2);
    (function (loader, packages, options) {
        var g = loader.global;
        if (!g.process) {
            g.process = {
                argv: [],
                cwd: function () {
                    var baseURL = loader.baseURL;
                    return baseURL;
                },
                browser: true,
                env: { NODE_ENV: loader.env },
                version: '',
                platform: navigator && navigator.userAgent && /Windows/.test(navigator.userAgent) ? 'win' : ''
            };
        }
        if (!loader.npm) {
            loader.npm = {};
            loader.npmPaths = {};
            loader.globalBrowser = {};
        }
        if (!loader.npmParentMap) {
            loader.npmParentMap = options.npmParentMap || {};
        }
        var rootPkg = loader.npmPaths.__default = packages[0];
        var rootConfig = rootPkg.steal || rootPkg.system;
        var lib = rootConfig && rootConfig.directories && rootConfig.directories.lib;
        var setGlobalBrowser = function (globals, pkg) {
            for (var name in globals) {
                loader.globalBrowser[name] = {
                    pkg: pkg,
                    moduleName: globals[name]
                };
            }
        };
        var setInNpm = function (name, pkg) {
            if (!loader.npm[name]) {
                loader.npm[name] = pkg;
            }
            loader.npm[name + '@' + pkg.version] = pkg;
        };
        var forEach = function (arr, fn) {
            var i = 0, len = arr.length;
            for (; i < len; i++) {
                res = fn.call(arr, arr[i], i);
                if (res === false)
                    break;
            }
        };
        var setupLiveReload = function () {
            if (loader.liveReloadInstalled) {
                loader['import']('live-reload', { name: module.id }).then(function (reload) {
                    reload.dispose(function () {
                        var pkgInfo = loader.npmContext.pkgInfo;
                        delete pkgInfo[rootPkg.name + '@' + rootPkg.version];
                        var idx = -1;
                        forEach(pkgInfo, function (pkg, i) {
                            if (pkg.name === rootPkg.name && pkg.version === rootPkg.version) {
                                idx = i;
                                return false;
                            }
                        });
                        pkgInfo.splice(idx, 1);
                    });
                });
            }
        };
        var ignoredConfig = [
            'bundle',
            'configDependencies',
            'transpiler'
        ];
        packages.reverse();
        forEach(packages, function (pkg) {
            var steal = pkg.steal || pkg.system;
            if (steal) {
                var main = steal.main;
                delete steal.main;
                var configDeps = steal.configDependencies;
                if (pkg !== rootPkg) {
                    forEach(ignoredConfig, function (name) {
                        delete steal[name];
                    });
                }
                loader.config(steal);
                if (pkg === rootPkg) {
                    steal.configDependencies = configDeps;
                }
                steal.main = main;
            }
            if (pkg.globalBrowser) {
                var doNotApplyGlobalBrowser = pkg.name === 'steal' && rootConfig.builtins === false;
                if (!doNotApplyGlobalBrowser) {
                    setGlobalBrowser(pkg.globalBrowser, pkg);
                }
            }
            var systemName = steal && steal.name;
            if (systemName) {
                setInNpm(systemName, pkg);
            } else {
                setInNpm(pkg.name, pkg);
            }
            if (!loader.npm[pkg.name]) {
                loader.npm[pkg.name] = pkg;
            }
            loader.npm[pkg.name + '@' + pkg.version] = pkg;
            var pkgAddress = pkg.fileUrl.replace(/\/package\.json.*/, '');
            loader.npmPaths[pkgAddress] = pkg;
        });
        setupLiveReload();
        forEach(loader._npmExtensions || [], function (ext) {
            if (ext.systemConfig) {
                loader.config(ext.systemConfig);
            }
        });
    }(loader, [
        {
            'name': 'can',
            'version': '3.14.0',
            'fileUrl': './package.json',
            'main': 'can.js',
            'steal': {
                'npmAlgorithm': 'flat',
                'main': 'can',
                'npmIgnore': {
                    'bit-docs': true,
                    'testee': true,
                    'async': true,
                    'saucelabs': true,
                    'test-saucelabs': true,
                    'wd': true,
                    'http-server': true
                },
                'meta': { 'socket.io-client/dist/socket.io': { 'format': 'cjs' } },
                'configDependencies': ['./node_modules/steal-conditional/conditional.js']
            },
            'resolutions': {
                'can': '3.14.0',
                'can-construct-super': '3.2.0',
                'can-define': '1.5.7',
                'can-set': '1.6.0',
                'can-stache-bindings': '3.11.12',
                'can-stache-converters': '3.3.1',
                'can-deparam': '1.2.0',
                'can-param': '1.1.0',
                'can-view-target': '3.1.6',
                'can-view-model': '3.5.2',
                'can-simple-observable': '1.0.2',
                'can-symbol': '1.6.1',
                'can-reflect': '1.17.5',
                'can-reflect-promise': '1.1.5',
                'can-ajax': '1.4.0',
                'can-globals': '1.2.0',
                'can-simple-dom': '1.4.2',
                'can-define-lazy-value': '1.1.0',
                'can-dom-events': '1.3.0',
                'can-event-dom-enter': '1.0.4',
                'can-assign': '1.3.1',
                'can-event-dom-radiochange': '1.0.5',
                'can-parse-uri': '1.2.0',
                'can-validate-interface': '0.1.2',
                'can-map-define': '3.1.2',
                'can-map-backup': '3.1.1',
                'can-validate-legacy': '1.4.0',
                'can-fixture': '1.2.2',
                'can-connect-signalr': '0.2.3',
                'can-connect-cloneable': '0.2.4',
                'can-kefir': '0.2.3',
                'can-stream': '0.3.2',
                'can-view-href': '3.1.1',
                'can-ndjson-stream': '0.1.8',
                'can-connect-ndjson': '0.1.3',
                'can-stream-kefir': '0.3.3',
                'can-observe': '1.0.1',
                'can-define-stream-kefir': '0.1.3',
                'can-define-stream': '0.2.2',
                'can-zone-storage': '1.0.1',
                'can-react-component': '0.1.11',
                'react-view-model': '0.5.11',
                'can-construct': '3.5.3',
                'can-component': '3.3.10',
                'can-compute': '3.3.10',
                'can-util': '3.14.0',
                'can-event': '3.7.7',
                'can-list': '3.2.2',
                'can-map': '3.6.1',
                'can-view-live': '3.2.6',
                'can-view-import': '3.2.9',
                'can-view-scope': '3.6.0',
                'can-view-nodelist': '3.1.1',
                'can-view-parser': '3.8.3',
                'can-view-autorender': '3.1.4',
                'can-control': '3.2.4',
                'can-ejs': '3.2.1',
                'funcunit': '3.6.3',
                'steal-qunit': '1.0.2'
            }
        },
        {
            'name': 'steal',
            'version': '1.12.6',
            'fileUrl': './node_modules/steal/package.json',
            'main': 'main',
            'steal': {
                'npmDependencies': {
                    'console-browserify': true,
                    'constants-browserify': true,
                    'crypto-browserify': true,
                    'http-browserify': true,
                    'buffer': true,
                    'os-browserify': true,
                    'vm-browserify': true,
                    'zlib-browserify': true,
                    'assert': true,
                    'domain-browser': true,
                    'events': true,
                    'https-browserify': true,
                    'path-browserify': true,
                    'string_decoder': true,
                    'tty-browserify': true,
                    'process': true,
                    'punycode': true
                }
            },
            'globalBrowser': {
                'console': 'console-browserify',
                'constants': 'constants-browserify',
                'crypto': 'crypto-browserify',
                'http': 'http-browserify',
                'buffer': 'buffer',
                'os': 'os-browserify',
                'vm': 'vm-browserify',
                'zlib': 'zlib-browserify',
                'assert': 'assert',
                'child_process': 'steal#ext/builtin/child_process',
                'cluster': 'steal#ext/builtin/cluster',
                'dgram': 'steal#ext/builtin/dgram',
                'dns': 'steal#ext/builtin/dns',
                'domain': 'domain-browser',
                'events': 'events',
                'fs': 'steal#ext/builtin/fs',
                'https': 'https-browserify',
                'module': 'steal#ext/builtin/module',
                'net': 'steal#ext/builtin/net',
                'path': 'path-browserify',
                'process': 'process',
                'querystring': 'steal#ext/builtin/querystring',
                'readline': 'steal#ext/builtin/readline',
                'repl': 'steal#ext/builtin/repl',
                'stream': 'steal#ext/builtin/stream',
                'string_decoder': 'string_decoder',
                'sys': 'steal#ext/builtin/sys',
                'timers': 'steal#ext/builtin/timers',
                'tls': 'steal#ext/builtin/tls',
                'tty': 'tty-browserify',
                'url': 'steal#ext/builtin/url',
                'util': 'steal#ext/builtin/util',
                '_stream_readable': 'steal#ext/builtin/_stream_readable',
                '_stream_writable': 'steal#ext/builtin/_stream_writable',
                '_stream_duplex': 'steal#ext/builtin/_stream_duplex',
                '_stream_transform': 'steal#ext/builtin/_stream_transform',
                '_stream_passthrough': 'steal#ext/builtin/_stream_passthrough'
            },
            'resolutions': {}
        },
        {
            'name': 'assert',
            'version': '1.4.1',
            'fileUrl': './node_modules/assert/package.json',
            'main': './assert.js',
            'resolutions': {}
        },
        {
            'name': 'buffer',
            'version': '5.0.8',
            'fileUrl': './node_modules/buffer/package.json',
            'main': 'index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'console-browserify',
            'version': '1.1.0',
            'fileUrl': './node_modules/console-browserify/package.json',
            'main': 'index',
            'resolutions': {}
        },
        {
            'name': 'constants-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/constants-browserify/package.json',
            'main': 'constants.json',
            'resolutions': {}
        },
        {
            'name': 'crypto-browserify',
            'version': '3.11.1',
            'fileUrl': './node_modules/crypto-browserify/package.json',
            'browser': { 'crypto': '@empty' },
            'resolutions': {}
        },
        {
            'name': 'domain-browser',
            'version': '1.1.7',
            'fileUrl': './node_modules/domain-browser/package.json',
            'main': './index.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'events',
            'version': '1.1.1',
            'fileUrl': './node_modules/events/package.json',
            'main': './events.js',
            'resolutions': {}
        },
        {
            'name': 'http-browserify',
            'version': '1.7.0',
            'fileUrl': './node_modules/http-browserify/package.json',
            'main': 'index.js',
            'browser': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'https-browserify',
            'version': '1.0.0',
            'fileUrl': './node_modules/https-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'os-browserify',
            'version': '0.3.0',
            'fileUrl': './node_modules/os-browserify/package.json',
            'main': 'main.js',
            'browser': 'browser.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'path-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/path-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'process',
            'version': '0.11.10',
            'fileUrl': './node_modules/process/package.json',
            'main': './index.js',
            'browser': './browser.js',
            'resolutions': {}
        },
        {
            'name': 'punycode',
            'version': '2.1.1',
            'fileUrl': './node_modules/punycode/package.json',
            'main': 'punycode.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '1.1.1',
            'fileUrl': './node_modules/string_decoder/package.json',
            'main': 'lib/string_decoder.js',
            'resolutions': {}
        },
        {
            'name': 'vm-browserify',
            'version': '0.0.4',
            'fileUrl': './node_modules/vm-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'tty-browserify',
            'version': '0.0.1',
            'fileUrl': './node_modules/tty-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'zlib-browserify',
            'version': '0.0.3',
            'fileUrl': './node_modules/zlib-browserify/package.json',
            'main': 'index.js',
            'resolutions': {}
        },
        {
            'name': 'punycode',
            'version': '2.0.1',
            'fileUrl': './node_modules/steal/node_modules/punycode/package.json',
            'main': 'punycode.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'string_decoder',
            'version': '1.0.3',
            'fileUrl': './node_modules/steal/node_modules/string_decoder/package.json',
            'main': 'lib/string_decoder.js',
            'resolutions': {}
        },
        {
            'name': 'can-construct-super',
            'version': '3.2.0',
            'fileUrl': './node_modules/can-construct-super/package.json',
            'main': 'can-construct-super',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-construct-super'
            },
            'resolutions': {
                'can-construct-super': '3.2.0',
                'steal-qunit': '1.0.2',
                'can-reflect': '1.17.5',
                'can-construct': '3.5.3'
            }
        },
        {
            'name': 'can-define',
            'version': '1.5.7',
            'fileUrl': './node_modules/can-define/package.json',
            'main': 'can-define.js',
            'resolutions': {
                'can-define': '1.5.7',
                'can-types': '1.4.0',
                'can-util': '3.14.0',
                'steal-qunit': '1.0.2',
                'can-construct': '3.5.3',
                'can-event': '3.7.7',
                'can-observation': '3.3.6',
                'can-log': '1.0.0',
                'can-namespace': '1.0.0',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-compute': '3.3.10',
                'can-test-helpers': '1.1.2',
                'can-cid': '1.3.0',
                'can-simple-observable': '1.0.2',
                'can-define-lazy-value': '1.1.0'
            }
        },
        {
            'name': 'can-set',
            'version': '1.6.0',
            'fileUrl': './node_modules/can-set/package.json',
            'main': 'src/set.js',
            'steal': { 'plugins': ['steal-qunit'] },
            'resolutions': {
                'can-set': '1.6.0',
                'can-assign': '1.3.1',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-stache-bindings',
            'version': '3.11.12',
            'fileUrl': './node_modules/can-stache-bindings/package.json',
            'main': 'can-stache-bindings',
            'steal': { 'main': 'can-stache-bindings' },
            'resolutions': {
                'can-stache-bindings': '3.11.12',
                'can-view-model': '3.5.2',
                'can-symbol': '1.6.1',
                'can-reflect': '1.17.5',
                'can-globals': '1.2.0',
                'can-compute': '3.3.10',
                'can-event': '3.7.7',
                'can-list': '3.2.2',
                'can-map': '3.6.1',
                'can-stache': '3.15.0',
                'can-view-callbacks': '3.2.5',
                'can-cid': '1.3.0',
                'can-test-helpers': '1.1.2',
                'can-vdom': '3.2.5',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-types': '1.4.0',
                'can-view-live': '3.2.6',
                'can-view-scope': '3.6.0',
                'can-observation': '3.3.6',
                'can-simple-observable': '1.0.2',
                'can-log': '1.0.0',
                'can-event-dom-enter': '1.0.4',
                'can-event-dom-radiochange': '1.0.5',
                'can-define': '1.5.7',
                'can-simple-map': '3.3.2',
                'can-view-nodelist': '3.1.1',
                'can-attribute-encoder': '0.3.4',
                'can-stache-key': '0.1.4'
            }
        },
        {
            'name': 'can-stache-converters',
            'version': '3.3.1',
            'fileUrl': './node_modules/can-stache-converters/package.json',
            'main': 'can-stache-converters',
            'steal': { 'main': 'can-stache-converters' },
            'resolutions': {
                'can-stache-converters': '3.3.1',
                'can-define': '1.5.7',
                'can-util': '3.14.0',
                'can-compute': '3.3.10',
                'can-event': '3.7.7',
                'can-stache': '3.15.0',
                'steal-qunit': '1.0.2',
                'can-stache-bindings': '3.11.12'
            }
        },
        {
            'name': 'can-deparam',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-deparam/package.json',
            'main': 'can-deparam',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-deparam': '1.2.0',
                'can-string-to-any': '1.2.0',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-param',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-param/package.json',
            'main': 'can-param',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-param': '1.1.0',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-target',
            'version': '3.1.6',
            'fileUrl': './node_modules/can-view-target/package.json',
            'main': 'can-view-target',
            'resolutions': {
                'can-view-target': '3.1.6',
                'can-simple-dom': '1.4.2',
                'can-globals': '1.2.0',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-model',
            'version': '3.5.2',
            'fileUrl': './node_modules/can-view-model/package.json',
            'main': 'can-view-model',
            'resolutions': {
                'can-view-model': '3.5.2',
                'can-map': '3.6.1',
                'can-define': '1.5.7',
                'can-types': '1.4.0',
                'can-simple-map': '3.3.2',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-globals': '1.2.0',
                'can-reflect': '1.17.5'
            }
        },
        {
            'name': 'can-simple-observable',
            'version': '1.0.2',
            'fileUrl': './node_modules/can-simple-observable/package.json',
            'main': 'can-simple-observable',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-simple-observable': '1.0.2',
                'can-reflect': '1.17.5',
                'steal-qunit': '1.0.2',
                'can-event': '3.7.7',
                'can-observation': '3.3.6',
                'can-cid': '1.3.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-symbol',
            'version': '1.6.1',
            'fileUrl': './node_modules/can-symbol/package.json',
            'main': 'can-symbol',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-symbol'
            },
            'resolutions': {
                'can-symbol': '1.6.1',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-reflect',
            'version': '1.17.5',
            'fileUrl': './node_modules/can-reflect/package.json',
            'main': 'can-reflect',
            'resolutions': {
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-namespace': '1.0.0',
                'steal-qunit': '1.0.2'
            }
        },
        {
            'name': 'can-reflect-promise',
            'version': '1.1.5',
            'fileUrl': './node_modules/can-reflect-promise/package.json',
            'main': 'can-reflect-promise',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-symbol': '1.6.1',
                'can-reflect-promise': '1.1.5',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-reflect': '1.17.5',
                'can-observation': '3.3.6',
                'can-cid': '1.3.0',
                'can-event': '3.7.7'
            }
        },
        {
            'name': 'can-ajax',
            'version': '1.4.0',
            'fileUrl': './node_modules/can-ajax/package.json',
            'main': 'dist/cjs/can-ajax',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ajax'
            },
            'resolutions': {
                'can-ajax': '1.4.0',
                'can-globals': '1.2.0',
                'can-parse-uri': '1.2.0',
                'can-namespace': '1.0.0',
                'can-make-map': '1.2.0',
                'can-reflect': '1.17.5',
                'can-param': '1.1.0',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.2'
            }
        },
        {
            'name': 'can-globals',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-globals/package.json',
            'main': 'can-globals.js',
            'resolutions': {
                'can-globals': '1.2.0',
                'can-reflect': '1.17.5',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-simple-dom',
            'version': '1.4.2',
            'fileUrl': './node_modules/can-simple-dom/package.json',
            'main': 'can-simple-dom.js',
            'resolutions': {
                'can-simple-dom': '1.4.2',
                'steal-qunit': '1.0.2',
                'he': '1.1.1',
                'simple-html-tokenizer': '0.2.6',
                'micro-location': '0.1.5'
            }
        },
        {
            'name': 'can-define-lazy-value',
            'version': '1.1.0',
            'fileUrl': './node_modules/can-define-lazy-value/package.json',
            'main': 'define-lazy-value',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                }
            },
            'resolutions': {
                'can-define-lazy-value': '1.1.0',
                'steal-qunit': '1.0.2'
            }
        },
        {
            'name': 'can-dom-events',
            'version': '1.3.0',
            'fileUrl': './node_modules/can-dom-events/package.json',
            'main': 'can-dom-events',
            'resolutions': {
                'can-dom-events': '1.3.0',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0',
                'jquery': '3.4.0',
                'can-globals': '1.2.0',
                'can-reflect': '1.17.5',
                'can-key-tree': '1.2.0'
            }
        },
        {
            'name': 'can-event-dom-enter',
            'version': '1.0.4',
            'fileUrl': './node_modules/can-event-dom-enter/package.json',
            'main': 'can-event-dom-enter',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-enter'
            },
            'resolutions': {
                'can-dom-events': '1.3.0',
                'can-event-dom-enter': '1.0.4',
                'steal-qunit': '1.0.2',
                'can-cid': '1.3.0',
                'can-dom-data-state': '0.2.0'
            }
        },
        {
            'name': 'can-assign',
            'version': '1.3.1',
            'fileUrl': './node_modules/can-assign/package.json',
            'main': 'dist/cjs/can-assign',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-assign'
            },
            'resolutions': {
                'can-assign': '1.3.1',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-event-dom-radiochange',
            'version': '1.0.5',
            'fileUrl': './node_modules/can-event-dom-radiochange/package.json',
            'main': 'can-event-dom-radiochange',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-event-dom-radiochange'
            },
            'resolutions': {
                'can-dom-events': '1.3.0',
                'can-event-dom-radiochange': '1.0.5',
                'steal-qunit': '1.0.2',
                'can-globals': '1.2.0',
                'can-cid': '1.3.0',
                'can-dom-data-state': '0.2.0'
            }
        },
        {
            'name': 'can-parse-uri',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-parse-uri/package.json',
            'main': 'can-parse-uri',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-parse-uri'
            },
            'resolutions': {
                'can-parse-uri': '1.2.0',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-validate-interface',
            'version': '0.1.2',
            'fileUrl': './node_modules/can-validate-interface/package.json',
            'main': 'index.js',
            'resolutions': {
                'can-validate-interface': '0.1.2',
                'can-connect': '1.5.18',
                'steal-qunit': '1.0.2'
            }
        },
        {
            'name': 'can-map-define',
            'version': '3.1.2',
            'fileUrl': './node_modules/can-map-define/package.json',
            'main': 'can-map-define',
            'steal': { 'main': 'can-map-define' },
            'resolutions': {
                'can-map-define': '3.1.2',
                'can-compute': '3.3.10',
                'can-list': '3.2.2',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-map': '3.6.1',
                'can-event': '3.7.7'
            }
        },
        {
            'name': 'can-map-backup',
            'version': '3.1.1',
            'fileUrl': './node_modules/can-map-backup/package.json',
            'main': 'can-map-backup',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-map-backup'
            },
            'resolutions': {
                'can-map-backup': '3.1.1',
                'can-map-define': '3.1.2',
                'can-compute': '3.3.10',
                'can-map': '3.6.1',
                'steal-qunit': '1.0.2',
                'can-set': '1.6.0',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-validate-legacy',
            'version': '1.4.0',
            'fileUrl': './node_modules/can-validate-legacy/package.json',
            'main': 'can-validate.js',
            'steal': {
                'ignoreBrowser': true,
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmDependencies': { 'steal-qunit': true },
                'paths': { 'validate.js@0.11.1#validate': './node_modules/validate.js/validate.js' }
            },
            'browser': {
                'can-validate-legacy#can-validate': 'can-validate-legacy#dist/cjs/can-validate/can-validate',
                'can-validate-legacy#map/validate': 'can-validate-legacy#dist/cjs/can-validate/map/validate/validate',
                'can-validate-legacy#validations': 'can-validate-legacy#dist/cjs/can-validate/validations',
                'can-validate-legacy#shims/validatejs.shim': 'can-validate-legacy#dist/cjs/can-validate/shims/validatejs.shim'
            },
            'resolutions': {
                'can-reflect': '1.17.5',
                'can-map-define': '3.1.2',
                'can-validate-legacy': '1.4.0',
                'can-map': '3.6.1',
                'steal-qunit': '1.0.2',
                'can-log': '1.0.0',
                'can-namespace': '1.0.0',
                'can-assign': '1.3.1',
                'can-compute': '3.3.10',
                'validate.js': '0.11.1'
            },
            'system': {
                'ignoreBrowser': true,
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmDependencies': { 'steal-qunit': true },
                'paths': { 'validate.js@0.11.1#validate': './node_modules/validate.js/validate.js' }
            }
        },
        {
            'name': 'can-fixture',
            'version': '1.2.2',
            'fileUrl': './node_modules/can-fixture/package.json',
            'main': 'fixture.js',
            'resolutions': {
                'can-fixture': '1.2.2',
                'can-set': '1.6.0',
                'jquery': '3.4.0',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-connect': '1.5.18',
                'can-deparam': '1.2.0'
            }
        },
        {
            'name': 'can-connect-signalr',
            'version': '0.2.3',
            'fileUrl': './node_modules/can-connect-signalr/package.json',
            'main': 'can-connect-signalr',
            'steal': {},
            'resolutions': {
                'can-define': '1.5.7',
                'can-connect-signalr': '0.2.3',
                'jquery': '3.4.0',
                'can-connect': '1.5.18',
                'steal-qunit': '1.0.2',
                'ms-signalr-client': '2.2.7'
            }
        },
        {
            'name': 'can-connect-cloneable',
            'version': '0.2.4',
            'fileUrl': './node_modules/can-connect-cloneable/package.json',
            'main': 'can-connect-cloneable',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-connect-cloneable': '0.2.4',
                'can-define': '1.5.7',
                'can-map': '3.6.1',
                'can-map-define': '3.1.2',
                'can-list': '3.2.2',
                'can-fixture': '1.2.2',
                'steal-qunit': '1.0.2',
                'can-connect': '1.5.18',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-kefir',
            'version': '0.2.3',
            'fileUrl': './node_modules/can-kefir/package.json',
            'main': 'can-kefir',
            'browser': {},
            'resolutions': {
                'can-kefir': '0.2.3',
                'can-reflect': '1.17.5',
                'can-event': '3.7.7',
                'steal-qunit': '1.0.2',
                'can-symbol': '1.6.1',
                'can-util': '3.14.0',
                'can-observation': '3.3.6',
                'can-cid': '1.3.0',
                'can-define-lazy-value': '1.1.0',
                'kefir': '3.8.6'
            }
        },
        {
            'name': 'can-stream',
            'version': '0.3.2',
            'fileUrl': './node_modules/can-stream/package.json',
            'main': 'can-stream',
            'steal': {},
            'resolutions': {
                'can-define': '1.5.7',
                'can-stream': '0.3.2',
                'can-compute': '3.3.10',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-view-href',
            'version': '3.1.1',
            'fileUrl': './node_modules/can-view-href/package.json',
            'main': 'can-view-href',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-href'
            },
            'resolutions': {
                'can-view-href': '3.1.1',
                'can-route': '3.3.4',
                'steal-qunit': '1.0.2',
                'can-stache': '3.15.0',
                'can-view-callbacks': '3.2.5',
                'can-compute': '3.3.10',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-ndjson-stream',
            'version': '0.1.8',
            'fileUrl': './node_modules/can-ndjson-stream/package.json',
            'main': 'can-ndjson-stream',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ndjson-stream'
            },
            'resolutions': {
                'can-ndjson-stream': '0.1.8',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-connect-ndjson',
            'version': '0.1.3',
            'fileUrl': './node_modules/can-connect-ndjson/package.json',
            'main': 'can-connect-ndjson',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-connect-ndjson'
            },
            'resolutions': {
                'can-connect-ndjson': '0.1.3',
                'can-define': '1.5.7',
                'can-connect': '1.5.18',
                'steal-qunit': '1.0.2',
                'can-ndjson-stream': '0.1.8',
                'can-reflect': '1.17.5',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-stream-kefir',
            'version': '0.3.3',
            'fileUrl': './node_modules/can-stream-kefir/package.json',
            'main': 'can-stream-kefir',
            'steal': {},
            'resolutions': {
                'can-stream-kefir': '0.3.3',
                'can-define': '1.5.7',
                'steal-qunit': '1.0.2',
                'can-compute': '3.3.10',
                'can-stream': '0.3.2',
                'can-namespace': '1.0.0',
                'kefir': '3.8.6'
            }
        },
        {
            'name': 'can-observe',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-observe/package.json',
            'main': 'can-observe.js',
            'resolutions': {
                'can-observe': '1.0.1',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-compute': '3.3.10',
                'can-event': '3.7.7',
                'can-stache': '3.15.0',
                'can-observation': '3.3.6',
                'steal-qunit': '1.0.2',
                'can-cid': '1.3.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-define-stream-kefir',
            'version': '0.1.3',
            'fileUrl': './node_modules/can-define-stream-kefir/package.json',
            'main': 'can-define-stream-kefir',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-define': '1.5.7',
                'can-define-stream-kefir': '0.1.3',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-define-stream': '0.2.2',
                'can-stream-kefir': '0.3.3'
            }
        },
        {
            'name': 'can-define-stream',
            'version': '0.2.2',
            'fileUrl': './node_modules/can-define-stream/package.json',
            'main': 'can-define-stream',
            'steal': {},
            'resolutions': {
                'can-define': '1.5.7',
                'can-define-stream': '0.2.2',
                'can-stream': '0.3.2',
                'steal-qunit': '1.0.2',
                'can-compute': '3.3.10',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-zone-storage',
            'version': '1.0.1',
            'fileUrl': './node_modules/can-zone-storage/package.json',
            'main': 'can-zone-storage.js',
            'steal': { 'main': 'can-zone-storage' },
            'resolutions': {
                'can-zone-storage': '1.0.1',
                'can-zone': '0.6.22',
                'steal-qunit': '1.0.2'
            }
        },
        {
            'name': 'can-react-component',
            'version': '0.1.11',
            'fileUrl': './node_modules/can-react-component/package.json',
            'main': 'can-react-component',
            'steal': {
                'npmIgnore': {
                    'babel-eslint': true,
                    'bit-docs': true,
                    'done-serve': true,
                    'eslint': true,
                    'eslint-plugin-react': true,
                    'testee': true
                },
                'main': 'can-react-component'
            },
            'resolutions': {
                'steal-qunit': '1.0.2',
                'react': '16.8.6',
                'react-dom': '16.8.6',
                'can-define': '1.5.7',
                'can-component': '3.3.10',
                'can-stache': '3.15.0',
                'can-react-component': '0.1.11',
                'can-view-scope': '3.6.0',
                'can-assign': '1.3.1',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'react-view-model',
            'version': '0.5.11',
            'fileUrl': './node_modules/react-view-model/package.json',
            'main': 'react-view-model',
            'resolutions': {
                'steal-qunit': '1.0.2',
                'can-define': '1.5.7',
                'react-view-model': '0.5.11',
                'react': '16.8.6',
                'prop-types': '15.7.2',
                'react-dom': '16.8.6',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-stache-key': '0.1.4',
                'can-observation': '3.3.6'
            }
        },
        {
            'name': 'can-construct',
            'version': '3.5.3',
            'fileUrl': './node_modules/can-construct/package.json',
            'main': 'can-construct',
            'steal': {},
            'resolutions': {
                'can-construct': '3.5.3',
                'can-log': '1.0.0',
                'steal-qunit': '1.0.2',
                'can-reflect': '1.17.5',
                'can-namespace': '1.0.0',
                'can-string': '1.0.0'
            }
        },
        {
            'name': 'can-component',
            'version': '3.3.10',
            'fileUrl': './node_modules/can-component/package.json',
            'main': 'can-component',
            'steal': {},
            'resolutions': {
                'can-component': '3.3.10',
                'can-stache': '3.15.0',
                'steal-qunit': '1.0.2',
                'can-define': '1.5.7',
                'can-view-model': '3.5.2',
                'can-types': '1.4.0',
                'can-util': '3.14.0',
                'can-construct': '3.5.3',
                'can-compute': '3.3.10',
                'can-map': '3.6.1',
                'can-list': '3.2.2',
                'can-event': '3.7.7',
                'can-globals': '1.2.0',
                'can-vdom': '3.2.5',
                'can-view-scope': '3.6.0',
                'can-view-callbacks': '3.2.5',
                'can-namespace': '1.0.0',
                'can-stache-bindings': '3.11.12',
                'can-view-nodelist': '3.1.1',
                'can-reflect': '1.17.5',
                'can-control': '3.2.4',
                'can-stache-key': '0.1.4'
            }
        },
        {
            'name': 'can-compute',
            'version': '3.3.10',
            'fileUrl': './node_modules/can-compute/package.json',
            'main': 'can-compute',
            'resolutions': {
                'can-compute': '3.3.10',
                'steal-qunit': '1.0.2',
                'can-event': '3.7.7',
                'can-observation': '3.3.6',
                'can-util': '3.14.0',
                'can-symbol': '1.6.1',
                'can-reflect': '1.17.5',
                'can-cid': '1.3.0',
                'can-namespace': '1.0.0',
                'can-stache-key': '0.1.4'
            }
        },
        {
            'name': 'steal-qunit',
            'version': '1.0.2',
            'fileUrl': './node_modules/steal-qunit/package.json',
            'main': 'steal-qunit',
            'steal': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            },
            'resolutions': {
                'qunitjs': '1.23.1',
                'steal-css': '1.3.2'
            },
            'system': {
                'plugins': ['steal-css'],
                'meta': {
                    'qunitjs@1.23.1#qunit/qunit': {
                        'format': 'global',
                        'exports': 'QUnit',
                        'deps': ['steal-qunit/add-dom']
                    }
                }
            }
        },
        {
            'name': 'can-types',
            'version': '1.4.0',
            'fileUrl': './node_modules/can-types/package.json',
            'main': 'can-types',
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'can-util',
            'version': '3.14.0',
            'fileUrl': './node_modules/can-util/package.json',
            'main': 'can-util',
            'resolutions': {
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-cid': '1.3.0',
                'can-globals': '1.2.0',
                'can-log': '1.0.0',
                'can-symbol': '1.6.1',
                'can-assign': '1.3.1',
                'can-types': '1.4.0',
                'can-reflect': '1.17.5',
                'can-dom-data-state': '0.2.0',
                'can-vdom': '3.2.5',
                'can-parse-uri': '1.2.0',
                'qunitjs': '2.4.1',
                'steal-qunit': '1.0.2',
                'can-event-dom-enter': '1.0.4'
            }
        },
        {
            'name': 'can-string-to-any',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-string-to-any/package.json',
            'main': 'can-string-to-any',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-string-to-any'
            },
            'resolutions': {}
        },
        {
            'name': 'can-event',
            'version': '3.7.7',
            'fileUrl': './node_modules/can-event/package.json',
            'main': 'can-event',
            'resolutions': {
                'can-event': '3.7.7',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-cid': '1.3.0',
                'can-namespace': '1.0.0',
                'can-types': '1.4.0'
            }
        },
        {
            'name': 'can-list',
            'version': '3.2.2',
            'fileUrl': './node_modules/can-list/package.json',
            'main': 'can-list',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-list': '3.2.2',
                'steal-qunit': '1.0.2',
                'can-observation': '3.3.6',
                'can-map': '3.6.1',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-event': '3.7.7',
                'can-namespace': '1.0.0',
                'can-cid': '1.3.0',
                'can-util': '3.14.0',
                'can-types': '1.4.0'
            }
        },
        {
            'name': 'can-map',
            'version': '3.6.1',
            'fileUrl': './node_modules/can-map/package.json',
            'main': 'can-map',
            'steal': {},
            'resolutions': {
                'can-map': '3.6.1',
                'steal-qunit': '1.0.2',
                'can-observation': '3.3.6',
                'can-construct': '3.5.3',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-compute': '3.3.10',
                'can-event': '3.7.7',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-cid': '1.3.0',
                'can-types': '1.4.0',
                'can-stache-key': '0.1.4'
            }
        },
        {
            'name': 'can-stache',
            'version': '3.15.0',
            'fileUrl': './node_modules/can-stache/package.json',
            'main': 'can-stache',
            'resolutions': {
                'can-view-parser': '3.8.3',
                'can-view-callbacks': '3.2.5',
                'can-stache': '3.15.0',
                'can-log': '1.0.0',
                'can-namespace': '1.0.0',
                'can-globals': '1.2.0',
                'can-util': '3.14.0',
                'can-view-target': '3.1.6',
                'can-view-nodelist': '3.1.1',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-attribute-encoder': '0.3.4',
                'can-compute': '3.3.10',
                'can-view-scope': '3.6.0',
                'can-stache-key': '0.1.4',
                'can-observation': '3.3.6',
                'can-view-live': '3.2.6'
            }
        },
        {
            'name': 'can-view-callbacks',
            'version': '3.2.5',
            'fileUrl': './node_modules/can-view-callbacks/package.json',
            'main': 'can-view-callbacks',
            'steal': {},
            'resolutions': {
                'can-observation': '3.3.6',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-cid',
            'version': '1.3.0',
            'fileUrl': './node_modules/can-cid/package.json',
            'main': 'can-cid',
            'resolutions': {
                'can-cid': '1.3.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-live',
            'version': '3.2.6',
            'fileUrl': './node_modules/can-view-live/package.json',
            'main': 'can-view-live',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-view-live'
            },
            'resolutions': {
                'can-view-live': '3.2.6',
                'can-compute': '3.3.10',
                'can-map': '3.6.1',
                'can-list': '3.2.2',
                'can-view-nodelist': '3.1.1',
                'can-event': '3.7.7',
                'can-observation': '3.3.6',
                'can-util': '3.14.0',
                'can-reflect': '1.17.5',
                'steal-qunit': '1.0.2',
                'can-view-callbacks': '3.2.5',
                'can-types': '1.4.0',
                'can-view-parser': '3.8.3'
            }
        },
        {
            'name': 'can-view-import',
            'version': '3.2.9',
            'fileUrl': './node_modules/can-view-import/package.json',
            'main': 'can-view-import',
            'resolutions': {
                'can-map': '3.6.1',
                'can-component': '3.3.10',
                'can-stache': '3.15.0',
                'can-compute': '3.3.10',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-view-callbacks': '3.2.5',
                'can-test-helpers': '1.1.2',
                'can-view-import': '3.2.9',
                'can-assign': '1.3.1',
                'can-globals': '1.2.0',
                'can-view-nodelist': '3.1.1',
                'can-event': '3.7.7',
                'can-log': '1.0.0',
                'can-dom-data-state': '0.2.0'
            }
        },
        {
            'name': 'can-view-scope',
            'version': '3.6.0',
            'fileUrl': './node_modules/can-view-scope/package.json',
            'main': 'can-view-scope',
            'resolutions': {
                'can-view-scope': '3.6.0',
                'can-map': '3.6.1',
                'can-list': '3.2.2',
                'can-compute': '3.3.10',
                'can-symbol': '1.6.1',
                'steal-qunit': '1.0.2',
                'can-event': '3.7.7',
                'can-reflect': '1.17.5',
                'can-observation': '3.3.6',
                'can-test-helpers': '1.1.2',
                'can-define': '1.5.7',
                'can-stache-key': '0.1.4',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-log': '1.0.0',
                'can-define-lazy-value': '1.1.0',
                'can-simple-map': '3.3.2',
                'can-cid': '1.3.0'
            }
        },
        {
            'name': 'can-view-nodelist',
            'version': '3.1.1',
            'fileUrl': './node_modules/can-view-nodelist/package.json',
            'main': 'can-view-nodelist',
            'resolutions': {
                'can-view-nodelist': '3.1.1',
                'can-util': '3.14.0',
                'steal-qunit': '1.0.2',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-view-parser',
            'version': '3.8.3',
            'fileUrl': './node_modules/can-view-parser/package.json',
            'main': 'can-view-parser',
            'resolutions': {
                'can-view-parser': '3.8.3',
                'steal-qunit': '1.0.2',
                'can-test-helpers': '1.1.2',
                'can-attribute-encoder': '0.3.4',
                'can-log': '1.0.0',
                'can-namespace': '1.0.0'
            }
        },
        {
            'name': 'can-test-helpers',
            'version': '1.1.2',
            'fileUrl': './node_modules/can-test-helpers/package.json',
            'main': 'can-test-helpers.js',
            'resolutions': {
                'can-test-helpers': '1.1.2',
                'can-log': '1.0.0',
                'can-util': '3.14.0'
            }
        },
        {
            'name': 'can-vdom',
            'version': '3.2.5',
            'fileUrl': './node_modules/can-vdom/package.json',
            'main': 'can-vdom.js',
            'steal': {
                'map': { 'can-vdom@3.2.5#assert': 'chai/chai' },
                'meta': {
                    'chai/chai': {
                        'format': 'global',
                        'exports': 'chai.assert'
                    }
                },
                'plugins': ['chai'],
                'main': 'can-vdom'
            },
            'resolutions': {
                'can-simple-dom': '1.4.2',
                'can-vdom': '3.2.5',
                'can-view-parser': '3.8.3'
            }
        },
        {
            'name': 'can-view-autorender',
            'version': '3.1.4',
            'fileUrl': './node_modules/can-view-autorender/package.json',
            'main': 'can-view-autorender',
            'steal': {},
            'resolutions': { 'steal-qunit': '1.0.2' }
        },
        {
            'name': 'can-connect',
            'version': '1.5.18',
            'fileUrl': './node_modules/can-connect/package.json',
            'main': 'can-connect.js',
            'steal': {
                'plugins': [
                    'steal-stache',
                    'steal-css'
                ]
            },
            'resolutions': {
                'can-connect': '1.5.18',
                'can-namespace': '1.0.0',
                'can-util': '3.14.0',
                'can-event': '3.7.7',
                'can-observation': '3.3.6',
                'can-types': '1.4.0',
                'can-reflect': '1.17.5',
                'can-set': '1.6.0',
                'can-ajax': '1.4.0',
                'can-validate-interface': '0.1.2',
                'can-make-rest': '0.1.3'
            }
        },
        {
            'name': 'can-namespace',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-namespace/package.json',
            'main': 'can-namespace',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {}
        },
        {
            'name': 'can-control',
            'version': '3.2.4',
            'fileUrl': './node_modules/can-control/package.json',
            'main': 'can-control',
            'steal': {},
            'resolutions': {
                'can-control': '3.2.4',
                'steal-qunit': '1.0.2',
                'can-util': '3.14.0',
                'can-event': '3.7.7',
                'can-types': '1.4.0',
                'can-map': '3.6.1',
                'can-define': '1.5.7',
                'can-construct': '3.5.3',
                'can-namespace': '1.0.0',
                'can-compute': '3.3.10',
                'can-stache-key': '0.1.4',
                'can-reflect': '1.17.5'
            }
        },
        {
            'name': 'can-route',
            'version': '3.3.4',
            'fileUrl': './node_modules/can-route/package.json',
            'main': 'can-route',
            'steal': {},
            'resolutions': {
                'can-event': '3.7.7',
                'can-observation': '3.3.6',
                'can-compute': '3.3.10',
                'can-namespace': '1.0.0',
                'can-param': '1.1.0',
                'can-deparam': '1.2.0',
                'can-log': '1.0.0',
                'can-util': '3.14.0',
                'can-types': '1.4.0',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1'
            }
        },
        {
            'name': 'jquery',
            'version': '3.4.0',
            'fileUrl': './node_modules/jquery/package.json',
            'main': 'dist/jquery.js',
            'resolutions': {}
        },
        {
            'name': 'can-ejs',
            'version': '3.2.1',
            'fileUrl': './node_modules/can-ejs/package.json',
            'main': 'can-ejs',
            'steal': {
                'ext': { 'ejs': 'can-ejs/steal-ejs.js' },
                'plugins': ['can-ejs'],
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-ejs'
            },
            'resolutions': {
                'steal-qunit': '1.0.2',
                'can-ejs': '3.2.1',
                'can-map': '3.6.1',
                'can-util': '3.14.0',
                'can-list': '3.2.2',
                'can-namespace': '1.0.0',
                'can-compute': '3.3.10',
                'can-legacy-view-helpers': '1.0.0',
                'can-reflect': '1.17.5',
                'can-stache-key': '0.1.4',
                'can-globals': '1.2.0'
            }
        },
        {
            'name': 'can-make-map',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-make-map/package.json',
            'main': 'dist/cjs/can-make-map',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-make-map'
            },
            'resolutions': {}
        },
        {
            'name': 'can-zone',
            'version': '0.6.22',
            'fileUrl': './node_modules/can-zone/package.json',
            'main': 'lib/zone.js',
            'steal': {
                'npmDependencies': {
                    'steal-mocha': true,
                    'mocha': true,
                    'chai': true
                },
                'map': { 'can-zone@0.6.22#assert': 'chai/chai' },
                'meta': {
                    'chai/chai': {
                        'format': 'global',
                        'exports': 'chai.assert'
                    }
                },
                'plugins': ['chai']
            },
            'resolutions': { 'can-zone': '0.6.22' }
        },
        {
            'name': 'can-observation',
            'version': '3.3.6',
            'fileUrl': './node_modules/can-observation/package.json',
            'main': 'can-observation',
            'steal': { 'npmAlgorithm': 'flat' },
            'resolutions': {
                'can-event': '3.7.7',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-reflect': '1.17.5',
                'can-symbol': '1.6.1',
                'can-cid': '1.3.0'
            }
        },
        {
            'name': 'funcunit',
            'version': '3.6.3',
            'fileUrl': './node_modules/funcunit/package.json',
            'main': 'dist/cjs/funcunit.js',
            'steal': {
                'map': { 'chai': 'chai/chai' },
                'npmIgnore': {
                    'documentjs': true,
                    'steal': true,
                    'steal-tools': true,
                    'testee': true
                },
                'main': 'funcunit'
            },
            'resolutions': {
                'funcunit': '3.6.3',
                'syn': '0.13.0'
            }
        },
        {
            'name': 'steal-css',
            'version': '1.3.2',
            'fileUrl': './node_modules/steal-css/package.json',
            'main': 'css.js',
            'steal': {
                'ext': { 'css': 'steal-css' },
                'map': { '$css': 'steal-css@1.3.2#css' }
            },
            'resolutions': {}
        },
        {
            'name': 'can-simple-map',
            'version': '3.3.2',
            'fileUrl': './node_modules/can-simple-map/package.json',
            'main': 'can-simple-map',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-simple-map'
            },
            'resolutions': {
                'can-construct': '3.5.3',
                'can-event': '3.7.7',
                'can-util': '3.14.0',
                'can-types': '1.4.0',
                'can-observation': '3.3.6',
                'can-reflect': '1.17.5'
            }
        },
        {
            'name': 'steal-stache',
            'version': '3.1.3',
            'fileUrl': './node_modules/steal-stache/package.json',
            'main': 'steal-stache.js',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'steal-tools': true
                },
                'npmAlgorithm': 'flat',
                'ext': { 'stache': 'steal-stache' },
                'main': 'steal-stache'
            },
            'resolutions': {}
        },
        {
            'name': 'qunitjs',
            'version': '2.4.1',
            'fileUrl': './node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': {}
        },
        {
            'name': 'can-log',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-log/package.json',
            'main': 'dist/cjs/can-log',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-log'
            },
            'resolutions': { 'can-log': '1.0.0' }
        },
        {
            'name': 'can-stache-key',
            'version': '0.1.4',
            'fileUrl': './node_modules/can-stache-key/package.json',
            'main': 'dist/cjs/can-stache-key',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-stache-key'
            },
            'browser': {},
            'resolutions': {
                'can-observation': '3.3.6',
                'can-log': '1.0.0',
                'can-util': '3.14.0',
                'can-symbol': '1.6.1',
                'can-reflect': '1.17.5',
                'can-reflect-promise': '1.1.5'
            }
        },
        {
            'name': 'can-attribute-encoder',
            'version': '0.3.4',
            'fileUrl': './node_modules/can-attribute-encoder/package.json',
            'main': 'can-attribute-encoder',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'steal-tools': true
                },
                'main': 'can-attribute-encoder'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-log': '1.0.0'
            }
        },
        {
            'name': 'can-legacy-view-helpers',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-legacy-view-helpers/package.json',
            'main': 'can-legacy-view-helpers',
            'steal': {
                'npmIgnore': {
                    'documentjs': true,
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'map': {
                    'can-legacy-view-helpers@1.0.0#deferred': 'can-legacy-view-helpers@1.0.0#src/deferred',
                    'can-legacy-view-helpers@1.0.0#elements': 'can-legacy-view-helpers@1.0.0#src/elements',
                    'can-legacy-view-helpers@1.0.0#live': 'can-legacy-view-helpers@1.0.0#src/live',
                    'can-legacy-view-helpers@1.0.0#node_list': 'can-legacy-view-helpers@1.0.0#src/node_list',
                    'can-legacy-view-helpers@1.0.0#render': 'can-legacy-view-helpers@1.0.0#src/render',
                    'can-legacy-view-helpers@1.0.0#scanner': 'can-legacy-view-helpers@1.0.0#src/scanner',
                    'can-legacy-view-helpers@1.0.0#view': 'can-legacy-view-helpers@1.0.0#src/view'
                },
                'main': 'can-legacy-view-helpers'
            },
            'resolutions': {
                'can-legacy-view-helpers': '1.0.0',
                'can-util': '3.14.0',
                'can-namespace': '1.0.0',
                'can-observation': '3.3.6',
                'can-ajax': '1.4.0',
                'can-log': '1.0.0',
                'can-compute': '3.3.10',
                'can-view-callbacks': '3.2.5',
                'can-view-parser': '3.8.3',
                'can-event': '3.7.7',
                'can-cid': '1.3.0'
            }
        },
        {
            'name': 'qunitjs',
            'version': '1.23.1',
            'fileUrl': './node_modules/steal-qunit/node_modules/qunitjs/package.json',
            'main': 'qunit/qunit.js',
            'resolutions': { 'steal-qunit': '1.0.2' }
        },
        {
            'name': 'can-dom-data-state',
            'version': '0.2.0',
            'fileUrl': './node_modules/can-dom-data-state/package.json',
            'main': 'dist/cjs/can-dom-data-state',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'main': 'can-dom-data-state'
            },
            'resolutions': {
                'can-namespace': '1.0.0',
                'can-cid': '1.3.0'
            }
        },
        {
            'name': 'kefir',
            'version': '3.8.6',
            'fileUrl': './node_modules/kefir/package.json',
            'main': 'dist/kefir.js',
            'resolutions': {}
        },
        {
            'name': 'validate.js',
            'version': '0.11.1',
            'fileUrl': './node_modules/validate.js/package.json',
            'main': 'validate.js',
            'resolutions': {}
        },
        {
            'name': 'he',
            'version': '1.1.1',
            'fileUrl': './node_modules/he/package.json',
            'main': 'he.js',
            'resolutions': {}
        },
        {
            'name': 'simple-html-tokenizer',
            'version': '0.2.6',
            'fileUrl': './node_modules/simple-html-tokenizer/package.json',
            'main': 'dist/simple-html-tokenizer.js',
            'resolutions': { 'simple-html-tokenizer': '0.2.6' }
        },
        {
            'name': 'ms-signalr-client',
            'version': '2.2.7',
            'fileUrl': './node_modules/ms-signalr-client/package.json',
            'main': 'jquery.signalR.js',
            'jspm': {},
            'resolutions': {}
        },
        {
            'name': 'can-make-rest',
            'version': '0.1.3',
            'fileUrl': './node_modules/can-make-rest/package.json',
            'main': './can-make-rest.js',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-make-rest'
            },
            'browser': {},
            'resolutions': { 'can-util': '3.14.0' }
        },
        {
            'name': 'can-string',
            'version': '1.0.0',
            'fileUrl': './node_modules/can-string/package.json',
            'main': 'can-string',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ]
            },
            'resolutions': {}
        },
        {
            'name': 'can-key-tree',
            'version': '1.2.0',
            'fileUrl': './node_modules/can-key-tree/package.json',
            'main': 'dist/cjs/can-key-tree',
            'steal': {
                'npmIgnore': {
                    'testee': true,
                    'generator-donejs': true,
                    'donejs-cli': true,
                    'steal-tools': true
                },
                'plugins': [
                    'steal-less',
                    'steal-stache'
                ],
                'main': 'can-key-tree'
            },
            'resolutions': { 'can-reflect': '1.17.5' }
        },
        {
            'name': 'syn',
            'version': '0.13.0',
            'fileUrl': './node_modules/syn/package.json',
            'main': 'dist/cjs/syn.js',
            'steal': {
                'directories': { 'lib': 'src' },
                'map': {},
                'ignoreBrowser': true,
                'main': 'syn'
            },
            'resolutions': { 'syn': '0.13.0' }
        },
        {
            'name': 'micro-location',
            'version': '0.1.5',
            'fileUrl': './node_modules/micro-location/package.json',
            'main': 'lib/micro-location.js',
            'resolutions': {}
        },
        {
            'name': 'react',
            'version': '16.8.6',
            'fileUrl': './node_modules/react/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'react': '16.8.6',
                'prop-types': '15.7.2',
                'object-assign': '4.1.1'
            }
        },
        {
            'name': 'prop-types',
            'version': '15.7.2',
            'fileUrl': './node_modules/prop-types/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': {
                'prop-types': '15.7.2',
                'react-is': '16.8.6',
                'object-assign': '4.1.1'
            }
        },
        {
            'name': 'react-dom',
            'version': '16.8.6',
            'fileUrl': './node_modules/react-dom/package.json',
            'main': 'index.js',
            'browser': {
                'react-dom#server': 'react-dom#server.browser',
                'react-dom#unstable-fizz': 'react-dom#unstable-fizz.browser'
            },
            'resolutions': {
                'react-dom': '16.8.6',
                'react': '16.8.6',
                'object-assign': '4.1.1',
                'prop-types': '15.7.2',
                'scheduler': '0.13.6'
            }
        },
        {
            'name': 'react-is',
            'version': '16.8.6',
            'fileUrl': './node_modules/react-is/package.json',
            'main': 'index.js',
            'resolutions': { 'react-is': '16.8.6' }
        },
        {
            'name': 'object-assign',
            'version': '4.1.1',
            'fileUrl': './node_modules/react/node_modules/object-assign/package.json',
            'resolutions': {}
        },
        {
            'name': 'scheduler',
            'version': '0.13.6',
            'fileUrl': './node_modules/scheduler/package.json',
            'main': 'index.js',
            'browser': { 'transform': ['loose-envify'] },
            'resolutions': { 'scheduler': '0.13.6' }
        }
    ], { 'npmParentMap': {} }));
});
/*can@3.14.0#test/browser-supports-react*/
define('can@3.14.0#test/browser-supports-react', function (require, exports, module) {
    module.exports = typeof Map !== 'undefined' && typeof Set !== 'undefined' && typeof window.requestAnimationFrame !== 'undefined';
});
/*can-namespace@1.0.0#can-namespace*/
define('can-namespace@1.0.0#can-namespace', function (require, exports, module) {
    module.exports = {};
});
/*can-symbol@1.6.1#can-symbol*/
define('can-symbol@1.6.1#can-symbol', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var namespace = require('can-namespace');
        var CanSymbol;
        if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
            CanSymbol = Symbol;
        } else {
            var symbolNum = 0;
            CanSymbol = function CanSymbolPolyfill(description) {
                var symbolValue = '@@symbol' + symbolNum++ + description;
                var symbol = {};
                Object.defineProperties(symbol, {
                    toString: {
                        value: function () {
                            return symbolValue;
                        }
                    }
                });
                return symbol;
            };
            var descriptionToSymbol = {};
            var symbolToDescription = {};
            CanSymbol.for = function (description) {
                var symbol = descriptionToSymbol[description];
                if (!symbol) {
                    symbol = descriptionToSymbol[description] = CanSymbol(description);
                    symbolToDescription[symbol] = description;
                }
                return symbol;
            };
            CanSymbol.keyFor = function (symbol) {
                return symbolToDescription[symbol];
            };
            [
                'hasInstance',
                'isConcatSpreadable',
                'iterator',
                'match',
                'prototype',
                'replace',
                'search',
                'species',
                'split',
                'toPrimitive',
                'toStringTag',
                'unscopables'
            ].forEach(function (name) {
                CanSymbol[name] = CanSymbol('Symbol.' + name);
            });
        }
        [
            'isMapLike',
            'isListLike',
            'isValueLike',
            'isFunctionLike',
            'getOwnKeys',
            'getOwnKeyDescriptor',
            'proto',
            'getOwnEnumerableKeys',
            'hasOwnKey',
            'hasKey',
            'size',
            'getName',
            'getIdentity',
            'assignDeep',
            'updateDeep',
            'getValue',
            'setValue',
            'getKeyValue',
            'setKeyValue',
            'updateValues',
            'addValue',
            'removeValues',
            'apply',
            'new',
            'onValue',
            'offValue',
            'onKeyValue',
            'offKeyValue',
            'getKeyDependencies',
            'getValueDependencies',
            'keyHasDependencies',
            'valueHasDependencies',
            'onKeys',
            'onKeysAdded',
            'onKeysRemoved',
            'onPatches'
        ].forEach(function (name) {
            CanSymbol.for('can.' + name);
        });
        module.exports = namespace.Symbol = CanSymbol;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-reflect@1.17.5#reflections/helpers*/
define('can-reflect@1.17.5#reflections/helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = {
        makeGetFirstSymbolValue: function (symbolNames) {
            var symbols = symbolNames.map(function (name) {
                return canSymbol.for(name);
            });
            var length = symbols.length;
            return function getFirstSymbol(obj) {
                var index = -1;
                while (++index < length) {
                    if (obj[symbols[index]] !== undefined) {
                        return obj[symbols[index]];
                    }
                }
            };
        },
        hasLength: function (list) {
            var type = typeof list;
            if (type === 'string' || Array.isArray(list)) {
                return true;
            }
            var length = list && (type !== 'boolean' && type !== 'number' && 'length' in list) && list.length;
            return typeof list !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in list);
        }
    };
});
/*can-reflect@1.17.5#reflections/type/type*/
define('can-reflect@1.17.5#reflections/type/type', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var helpers = require('../helpers');
    var plainFunctionPrototypePropertyNames = Object.getOwnPropertyNames(function () {
    }.prototype);
    var plainFunctionPrototypeProto = Object.getPrototypeOf(function () {
    }.prototype);
    function isConstructorLike(func) {
        var value = func[canSymbol.for('can.new')];
        if (value !== undefined) {
            return value;
        }
        if (typeof func !== 'function') {
            return false;
        }
        var prototype = func.prototype;
        if (!prototype) {
            return false;
        }
        if (plainFunctionPrototypeProto !== Object.getPrototypeOf(prototype)) {
            return true;
        }
        var propertyNames = Object.getOwnPropertyNames(prototype);
        if (propertyNames.length === plainFunctionPrototypePropertyNames.length) {
            for (var i = 0, len = propertyNames.length; i < len; i++) {
                if (propertyNames[i] !== plainFunctionPrototypePropertyNames[i]) {
                    return true;
                }
            }
            return false;
        } else {
            return true;
        }
    }
    var getNewOrApply = helpers.makeGetFirstSymbolValue([
        'can.new',
        'can.apply'
    ]);
    function isFunctionLike(obj) {
        var result, symbolValue = !!obj && obj[canSymbol.for('can.isFunctionLike')];
        if (symbolValue !== undefined) {
            return symbolValue;
        }
        result = getNewOrApply(obj);
        if (result !== undefined) {
            return !!result;
        }
        return typeof obj === 'function';
    }
    function isPrimitive(obj) {
        var type = typeof obj;
        if (obj == null || type !== 'function' && type !== 'object') {
            return true;
        } else {
            return false;
        }
    }
    function isBuiltIn(obj) {
        if (isPrimitive(obj) || Array.isArray(obj) || isPlainObject(obj) || Object.prototype.toString.call(obj) !== '[object Object]' && Object.prototype.toString.call(obj).indexOf('[object ') !== -1) {
            return true;
        } else {
            return false;
        }
    }
    function isValueLike(obj) {
        var symbolValue;
        if (isPrimitive(obj)) {
            return true;
        }
        symbolValue = obj[canSymbol.for('can.isValueLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = obj[canSymbol.for('can.getValue')];
        if (value !== undefined) {
            return !!value;
        }
    }
    function isMapLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        var isMapLike = obj[canSymbol.for('can.isMapLike')];
        if (typeof isMapLike !== 'undefined') {
            return !!isMapLike;
        }
        var value = obj[canSymbol.for('can.getKeyValue')];
        if (value !== undefined) {
            return !!value;
        }
        return true;
    }
    var onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), onPatchesSymbol = canSymbol.for('can.onPatches');
    function isObservableLike(obj) {
        if (isPrimitive(obj)) {
            return false;
        }
        return Boolean(obj[onValueSymbol] || obj[onKeyValueSymbol] || obj[onPatchesSymbol]);
    }
    function isListLike(list) {
        var symbolValue, type = typeof list;
        if (type === 'string') {
            return true;
        }
        if (isPrimitive(list)) {
            return false;
        }
        symbolValue = list[canSymbol.for('can.isListLike')];
        if (typeof symbolValue !== 'undefined') {
            return symbolValue;
        }
        var value = list[canSymbol.iterator];
        if (value !== undefined) {
            return !!value;
        }
        if (Array.isArray(list)) {
            return true;
        }
        return helpers.hasLength(list);
    }
    var supportsSymbols = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function';
    var isSymbolLike;
    if (supportsSymbols) {
        isSymbolLike = function (symbol) {
            return typeof symbol === 'symbol';
        };
    } else {
        var symbolStart = '@@symbol';
        isSymbolLike = function (symbol) {
            if (typeof symbol === 'object' && !Array.isArray(symbol)) {
                return symbol.toString().substr(0, symbolStart.length) === symbolStart;
            } else {
                return false;
            }
        };
    }
    var coreHasOwn = Object.prototype.hasOwnProperty;
    var funcToString = Function.prototype.toString;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        var proto = Object.getPrototypeOf(obj);
        if (proto === Object.prototype || proto === null) {
            return true;
        }
        var Constructor = coreHasOwn.call(proto, 'constructor') && proto.constructor;
        return typeof Constructor === 'function' && Constructor instanceof Constructor && funcToString.call(Constructor) === objectCtorString;
    }
    module.exports = {
        isConstructorLike: isConstructorLike,
        isFunctionLike: isFunctionLike,
        isListLike: isListLike,
        isMapLike: isMapLike,
        isObservableLike: isObservableLike,
        isPrimitive: isPrimitive,
        isBuiltIn: isBuiltIn,
        isValueLike: isValueLike,
        isSymbolLike: isSymbolLike,
        isMoreListLikeThanMapLike: function (obj) {
            if (Array.isArray(obj)) {
                return true;
            }
            if (obj instanceof Array) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            var value = obj[canSymbol.for('can.isMoreListLikeThanMapLike')];
            if (value !== undefined) {
                return value;
            }
            var isListLike = this.isListLike(obj), isMapLike = this.isMapLike(obj);
            if (isListLike && !isMapLike) {
                return true;
            } else if (!isListLike && isMapLike) {
                return false;
            }
        },
        isIteratorLike: function (obj) {
            return obj && typeof obj === 'object' && typeof obj.next === 'function' && obj.next.length === 0;
        },
        isPromise: function (obj) {
            return obj instanceof Promise || Object.prototype.toString.call(obj) === '[object Promise]';
        },
        isPlainObject: isPlainObject
    };
});
/*can-reflect@1.17.5#reflections/call/call*/
define('can-reflect@1.17.5#reflections/call/call', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    module.exports = {
        call: function (func, context) {
            var args = [].slice.call(arguments, 2);
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        apply: function (func, context, args) {
            var apply = func[canSymbol.for('can.apply')];
            if (apply) {
                return apply.call(func, context, args);
            } else {
                return func.apply(context, args);
            }
        },
        'new': function (func) {
            var args = [].slice.call(arguments, 1);
            var makeNew = func[canSymbol.for('can.new')];
            if (makeNew) {
                return makeNew.apply(func, args);
            } else {
                var context = Object.create(func.prototype);
                var ret = func.apply(context, args);
                if (typeReflections.isPrimitive(ret)) {
                    return context;
                } else {
                    return ret;
                }
            }
        }
    };
});
/*can-reflect@1.17.5#reflections/get-set/get-set*/
define('can-reflect@1.17.5#reflections/get-set/get-set', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), getValueSymbol = canSymbol.for('can.getValue'), setValueSymbol = canSymbol.for('can.setValue');
    var reflections = {
        setKeyValue: function (obj, key, value) {
            if (typeReflections.isSymbolLike(key)) {
                if (typeof key === 'symbol') {
                    obj[key] = value;
                } else {
                    Object.defineProperty(obj, key, {
                        enumerable: false,
                        configurable: true,
                        value: value,
                        writable: true
                    });
                }
                return;
            }
            var setKeyValue = obj[setKeyValueSymbol];
            if (setKeyValue !== undefined) {
                return setKeyValue.call(obj, key, value);
            } else {
                obj[key] = value;
            }
        },
        getKeyValue: function (obj, key) {
            var getKeyValue = obj[getKeyValueSymbol];
            if (getKeyValue) {
                return getKeyValue.call(obj, key);
            }
            return obj[key];
        },
        deleteKeyValue: function (obj, key) {
            var deleteKeyValue = obj[canSymbol.for('can.deleteKeyValue')];
            if (deleteKeyValue) {
                return deleteKeyValue.call(obj, key);
            }
            delete obj[key];
        },
        getValue: function (value) {
            if (typeReflections.isPrimitive(value)) {
                return value;
            }
            var getValue = value[getValueSymbol];
            if (getValue) {
                return getValue.call(value);
            }
            return value;
        },
        setValue: function (item, value) {
            var setValue = item && item[setValueSymbol];
            if (setValue) {
                return setValue.call(item, value);
            } else {
                throw new Error('can-reflect.setValue - Can not set value.');
            }
        },
        splice: function (obj, index, removing, adding) {
            var howMany;
            if (typeof removing !== 'number') {
                var updateValues = obj[canSymbol.for('can.updateValues')];
                if (updateValues) {
                    return updateValues.call(obj, index, removing, adding);
                }
                howMany = removing.length;
            } else {
                howMany = removing;
            }
            if (arguments.length <= 3) {
                adding = [];
            }
            var splice = obj[canSymbol.for('can.splice')];
            if (splice) {
                return splice.call(obj, index, howMany, adding);
            }
            return [].splice.apply(obj, [
                index,
                howMany
            ].concat(adding));
        },
        addValues: function (obj, adding, index) {
            var add = obj[canSymbol.for('can.addValues')];
            if (add) {
                return add.call(obj, adding, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                return obj.push.apply(obj, adding);
            }
            return reflections.splice(obj, index, [], adding);
        },
        removeValues: function (obj, removing, index) {
            var removeValues = obj[canSymbol.for('can.removeValues')];
            if (removeValues) {
                return removeValues.call(obj, removing, index);
            }
            if (Array.isArray(obj) && index === undefined) {
                removing.forEach(function (item) {
                    var index = obj.indexOf(item);
                    if (index >= 0) {
                        obj.splice(index, 1);
                    }
                });
                return;
            }
            return reflections.splice(obj, index, removing, []);
        }
    };
    reflections.get = reflections.getKeyValue;
    reflections.set = reflections.setKeyValue;
    reflections['delete'] = reflections.deleteKeyValue;
    module.exports = reflections;
});
/*can-reflect@1.17.5#reflections/observe/observe*/
define('can-reflect@1.17.5#reflections/observe/observe', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var slice = [].slice;
    function makeFallback(symbolName, fallbackName) {
        return function (obj, event, handler, queueName) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                return method.call(obj, event, handler, queueName);
            }
            return this[fallbackName].apply(this, arguments);
        };
    }
    function makeErrorIfMissing(symbolName, errorMessage) {
        return function (obj) {
            var method = obj[canSymbol.for(symbolName)];
            if (method !== undefined) {
                var args = slice.call(arguments, 1);
                return method.apply(obj, args);
            }
            throw new Error(errorMessage);
        };
    }
    module.exports = {
        onKeyValue: makeFallback('can.onKeyValue', 'onEvent'),
        offKeyValue: makeFallback('can.offKeyValue', 'offEvent'),
        onKeys: makeErrorIfMissing('can.onKeys', 'can-reflect: can not observe an onKeys event'),
        onKeysAdded: makeErrorIfMissing('can.onKeysAdded', 'can-reflect: can not observe an onKeysAdded event'),
        onKeysRemoved: makeErrorIfMissing('can.onKeysRemoved', 'can-reflect: can not unobserve an onKeysRemoved event'),
        getKeyDependencies: makeErrorIfMissing('can.getKeyDependencies', 'can-reflect: can not determine dependencies'),
        getWhatIChange: makeErrorIfMissing('can.getWhatIChange', 'can-reflect: can not determine dependencies'),
        getChangesDependencyRecord: function getChangesDependencyRecord(handler) {
            var fn = handler[canSymbol.for('can.getChangesDependencyRecord')];
            if (typeof fn === 'function') {
                return fn();
            }
        },
        keyHasDependencies: makeErrorIfMissing('can.keyHasDependencies', 'can-reflect: can not determine if this has key dependencies'),
        onValue: makeErrorIfMissing('can.onValue', 'can-reflect: can not observe value change'),
        offValue: makeErrorIfMissing('can.offValue', 'can-reflect: can not unobserve value change'),
        getValueDependencies: makeErrorIfMissing('can.getValueDependencies', 'can-reflect: can not determine dependencies'),
        valueHasDependencies: makeErrorIfMissing('can.valueHasDependencies', 'can-reflect: can not determine if value has dependencies'),
        onPatches: makeErrorIfMissing('can.onPatches', 'can-reflect: can not observe patches on object'),
        offPatches: makeErrorIfMissing('can.offPatches', 'can-reflect: can not unobserve patches on object'),
        onInstancePatches: makeErrorIfMissing('can.onInstancePatches', 'can-reflect: can not observe onInstancePatches on Type'),
        offInstancePatches: makeErrorIfMissing('can.offInstancePatches', 'can-reflect: can not unobserve onInstancePatches on Type'),
        onInstanceBoundChange: makeErrorIfMissing('can.onInstanceBoundChange', 'can-reflect: can not observe bound state change in instances.'),
        offInstanceBoundChange: makeErrorIfMissing('can.offInstanceBoundChange', 'can-reflect: can not unobserve bound state change'),
        isBound: makeErrorIfMissing('can.isBound', 'can-reflect: cannot determine if object is bound'),
        onEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var onEvent = obj[canSymbol.for('can.onEvent')];
                if (onEvent !== undefined) {
                    return onEvent.call(obj, eventName, callback, queue);
                } else if (obj.addEventListener) {
                    obj.addEventListener(eventName, callback, queue);
                }
            }
        },
        offEvent: function (obj, eventName, callback, queue) {
            if (obj) {
                var offEvent = obj[canSymbol.for('can.offEvent')];
                if (offEvent !== undefined) {
                    return offEvent.call(obj, eventName, callback, queue);
                } else if (obj.removeEventListener) {
                    obj.removeEventListener(eventName, callback, queue);
                }
            }
        },
        setPriority: function (obj, priority) {
            if (obj) {
                var setPriority = obj[canSymbol.for('can.setPriority')];
                if (setPriority !== undefined) {
                    setPriority.call(obj, priority);
                    return true;
                }
            }
            return false;
        },
        getPriority: function (obj) {
            if (obj) {
                var getPriority = obj[canSymbol.for('can.getPriority')];
                if (getPriority !== undefined) {
                    return getPriority.call(obj);
                }
            }
            return undefined;
        }
    };
});
/*can-reflect@1.17.5#reflections/shape/shape*/
define('can-reflect@1.17.5#reflections/shape/shape', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../get-set/get-set',
    '../type/type',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var getSetReflections = require('../get-set/get-set');
    var typeReflections = require('../type/type');
    var helpers = require('../helpers');
    var getPrototypeOfWorksWithPrimitives = true;
    try {
        Object.getPrototypeOf(1);
    } catch (e) {
        getPrototypeOfWorksWithPrimitives = false;
    }
    var ArrayMap;
    if (typeof Map === 'function') {
        ArrayMap = Map;
    } else {
        var isEven = function isEven(num) {
            return !(num % 2);
        };
        ArrayMap = function () {
            this.contents = [];
        };
        ArrayMap.prototype = {
            _getIndex: function (key) {
                var idx;
                do {
                    idx = this.contents.indexOf(key, idx);
                } while (idx !== -1 && !isEven(idx));
                return idx;
            },
            has: function (key) {
                return this._getIndex(key) !== -1;
            },
            get: function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    return this.contents[idx + 1];
                }
            },
            set: function (key, value) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents[idx + 1] = value;
                } else {
                    this.contents.push(key);
                    this.contents.push(value);
                }
            },
            'delete': function (key) {
                var idx = this._getIndex(key);
                if (idx !== -1) {
                    this.contents.splice(idx, 2);
                }
            }
        };
    }
    var shapeReflections;
    var shiftFirstArgumentToThis = function (func) {
        return function () {
            var args = [this];
            args.push.apply(args, arguments);
            return func.apply(null, args);
        };
    };
    var getKeyValueSymbol = canSymbol.for('can.getKeyValue');
    var shiftedGetKeyValue = shiftFirstArgumentToThis(getSetReflections.getKeyValue);
    var setKeyValueSymbol = canSymbol.for('can.setKeyValue');
    var shiftedSetKeyValue = shiftFirstArgumentToThis(getSetReflections.setKeyValue);
    var sizeSymbol = canSymbol.for('can.size');
    var hasUpdateSymbol = helpers.makeGetFirstSymbolValue([
        'can.updateDeep',
        'can.assignDeep',
        'can.setKeyValue'
    ]);
    var shouldUpdateOrAssign = function (obj) {
        return typeReflections.isPlainObject(obj) || Array.isArray(obj) || !!hasUpdateSymbol(obj);
    };
    function isSerializedHelper(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return true;
        }
        if (hasUpdateSymbol(obj)) {
            return false;
        }
        return typeReflections.isBuiltIn(obj) && !typeReflections.isPlainObject(obj) && !Array.isArray(obj);
    }
    var Object_Keys;
    try {
        Object.keys(1);
        Object_Keys = Object.keys;
    } catch (e) {
        Object_Keys = function (obj) {
            if (typeReflections.isPrimitive(obj)) {
                return [];
            } else {
                return Object.keys(obj);
            }
        };
    }
    function makeSerializer(methodName, symbolsToCheck) {
        var serializeMap = null;
        function SerializeOperation(MapType) {
            this.first = !serializeMap;
            if (this.first) {
                serializeMap = createSerializeMap(MapType);
            }
            this.map = serializeMap;
            this.result = null;
        }
        SerializeOperation.prototype.end = function () {
            if (this.first) {
                serializeMap = null;
            }
            return this.result;
        };
        function createSerializeMap(Type) {
            var MapType = Type || ArrayMap;
            return {
                unwrap: new MapType(),
                serialize: new MapType(),
                isSerializing: {
                    unwrap: new MapType(),
                    serialize: new MapType()
                },
                circularReferenceIsSerializing: {
                    unwrap: new MapType(),
                    serialize: new MapType()
                }
            };
        }
        return function serializer(value, MapType) {
            if (isSerializedHelper(value)) {
                return value;
            }
            var operation = new SerializeOperation(MapType);
            if (typeReflections.isValueLike(value)) {
                operation.result = this[methodName](getSetReflections.getValue(value));
            } else {
                var isListLike = typeReflections.isIteratorLike(value) || typeReflections.isMoreListLikeThanMapLike(value);
                operation.result = isListLike ? [] : {};
                if (operation.map[methodName].has(value)) {
                    if (operation.map.isSerializing[methodName].has(value)) {
                        operation.map.circularReferenceIsSerializing[methodName].set(value, true);
                    }
                    return operation.map[methodName].get(value);
                } else {
                    operation.map[methodName].set(value, operation.result);
                }
                for (var i = 0, len = symbolsToCheck.length; i < len; i++) {
                    var serializer = value[symbolsToCheck[i]];
                    if (serializer) {
                        operation.map.isSerializing[methodName].set(value, true);
                        var oldResult = operation.result;
                        operation.result = serializer.call(value, oldResult);
                        operation.map.isSerializing[methodName].delete(value);
                        if (operation.result !== oldResult) {
                            if (operation.map.circularReferenceIsSerializing[methodName].has(value)) {
                                operation.end();
                                throw new Error('Cannot serialize cirular reference!');
                            }
                            operation.map[methodName].set(value, operation.result);
                        }
                        return operation.end();
                    }
                }
                if (typeof obj === 'function') {
                    operation.map[methodName].set(value, value);
                    operation.result = value;
                } else if (isListLike) {
                    this.eachIndex(value, function (childValue, index) {
                        operation.result[index] = this[methodName](childValue);
                    }, this);
                } else {
                    this.eachKey(value, function (childValue, prop) {
                        operation.result[prop] = this[methodName](childValue);
                    }, this);
                }
            }
            return operation.end();
        };
    }
    var makeMap;
    if (typeof Map !== 'undefined') {
        makeMap = function (keys) {
            var map = new Map();
            shapeReflections.eachIndex(keys, function (key) {
                map.set(key, true);
            });
            return map;
        };
    } else {
        makeMap = function (keys) {
            var map = {};
            keys.forEach(function (key) {
                map[key] = true;
            });
            return {
                get: function (key) {
                    return map[key];
                },
                set: function (key, value) {
                    map[key] = value;
                },
                keys: function () {
                    return keys;
                }
            };
        };
    }
    var fastHasOwnKey = function (obj) {
        var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
        if (hasOwnKey) {
            return hasOwnKey.bind(obj);
        } else {
            var map = makeMap(shapeReflections.getOwnEnumerableKeys(obj));
            return function (key) {
                return map.get(key);
            };
        }
    };
    function addPatch(patches, patch) {
        var lastPatch = patches[patches.length - 1];
        if (lastPatch) {
            if (lastPatch.deleteCount === lastPatch.insert.length && patch.index - lastPatch.index === lastPatch.deleteCount) {
                lastPatch.insert.push.apply(lastPatch.insert, patch.insert);
                lastPatch.deleteCount += patch.deleteCount;
                return;
            }
        }
        patches.push(patch);
    }
    function updateDeepList(target, source, isAssign) {
        var sourceArray = this.toArray(source);
        var patches = [], lastIndex = -1;
        this.eachIndex(target, function (curVal, index) {
            lastIndex = index;
            if (index >= sourceArray.length) {
                if (!isAssign) {
                    addPatch(patches, {
                        index: index,
                        deleteCount: target.length - index + 1,
                        insert: []
                    });
                }
                return false;
            }
            var newVal = sourceArray[index];
            if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                addPatch(patches, {
                    index: index,
                    deleteCount: 1,
                    insert: [newVal]
                });
            } else {
                if (isAssign === true) {
                    this.assignDeep(curVal, newVal);
                } else {
                    this.updateDeep(curVal, newVal);
                }
            }
        }, this);
        if (sourceArray.length > lastIndex) {
            addPatch(patches, {
                index: lastIndex + 1,
                deleteCount: 0,
                insert: sourceArray.slice(lastIndex + 1)
            });
        }
        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
            var patch = patches[i];
            getSetReflections.splice(target, patch.index, patch.deleteCount, patch.insert);
        }
        return target;
    }
    shapeReflections = {
        each: function (obj, callback, context) {
            if (typeReflections.isIteratorLike(obj) || typeReflections.isMoreListLikeThanMapLike(obj)) {
                return shapeReflections.eachIndex(obj, callback, context);
            } else {
                return shapeReflections.eachKey(obj, callback, context);
            }
        },
        eachIndex: function (list, callback, context) {
            if (Array.isArray(list)) {
                return shapeReflections.eachListLike(list, callback, context);
            } else {
                var iter, iterator = list[canSymbol.iterator];
                if (typeReflections.isIteratorLike(list)) {
                    iter = list;
                } else if (iterator) {
                    iter = iterator.call(list);
                }
                if (iter) {
                    var res, index = 0;
                    while (!(res = iter.next()).done) {
                        if (callback.call(context || list, res.value, index++, list) === false) {
                            break;
                        }
                    }
                } else {
                    shapeReflections.eachListLike(list, callback, context);
                }
            }
            return list;
        },
        eachListLike: function (list, callback, context) {
            var index = -1;
            var length = list.length;
            if (length === undefined) {
                var size = list[sizeSymbol];
                if (size) {
                    length = size.call(list);
                } else {
                    throw new Error('can-reflect: unable to iterate.');
                }
            }
            while (++index < length) {
                var item = list[index];
                if (callback.call(context || item, item, index, list) === false) {
                    break;
                }
            }
            return list;
        },
        toArray: function (obj) {
            var arr = [];
            shapeReflections.each(obj, function (value) {
                arr.push(value);
            });
            return arr;
        },
        eachKey: function (obj, callback, context) {
            if (obj) {
                var enumerableKeys = shapeReflections.getOwnEnumerableKeys(obj);
                var getKeyValue = obj[getKeyValueSymbol] || shiftedGetKeyValue;
                return shapeReflections.eachIndex(enumerableKeys, function (key) {
                    var value = getKeyValue.call(obj, key);
                    return callback.call(context || obj, value, key, obj);
                });
            }
            return obj;
        },
        'hasOwnKey': function (obj, key) {
            var hasOwnKey = obj[canSymbol.for('can.hasOwnKey')];
            if (hasOwnKey) {
                return hasOwnKey.call(obj, key);
            }
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                var found = false;
                shapeReflections.eachIndex(getOwnKeys.call(obj), function (objKey) {
                    if (objKey === key) {
                        found = true;
                        return false;
                    }
                });
                return found;
            }
            return obj.hasOwnProperty(key);
        },
        getOwnEnumerableKeys: function (obj) {
            var getOwnEnumerableKeys = obj[canSymbol.for('can.getOwnEnumerableKeys')];
            if (getOwnEnumerableKeys) {
                return getOwnEnumerableKeys.call(obj);
            }
            if (obj[canSymbol.for('can.getOwnKeys')] && obj[canSymbol.for('can.getOwnKeyDescriptor')]) {
                var keys = [];
                shapeReflections.eachIndex(shapeReflections.getOwnKeys(obj), function (key) {
                    var descriptor = shapeReflections.getOwnKeyDescriptor(obj, key);
                    if (descriptor.enumerable) {
                        keys.push(key);
                    }
                }, this);
                return keys;
            } else {
                return Object_Keys(obj);
            }
        },
        getOwnKeys: function (obj) {
            var getOwnKeys = obj[canSymbol.for('can.getOwnKeys')];
            if (getOwnKeys) {
                return getOwnKeys.call(obj);
            } else {
                return Object.getOwnPropertyNames(obj);
            }
        },
        getOwnKeyDescriptor: function (obj, key) {
            var getOwnKeyDescriptor = obj[canSymbol.for('can.getOwnKeyDescriptor')];
            if (getOwnKeyDescriptor) {
                return getOwnKeyDescriptor.call(obj, key);
            } else {
                return Object.getOwnPropertyDescriptor(obj, key);
            }
        },
        unwrap: makeSerializer('unwrap', [canSymbol.for('can.unwrap')]),
        serialize: makeSerializer('serialize', [
            canSymbol.for('can.serialize'),
            canSymbol.for('can.unwrap')
        ]),
        assignMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (value, key) {
                if (!hasOwnKey(key) || getKeyValue.call(target, key) !== value) {
                    setKeyValue.call(target, key, value);
                }
            });
            return target;
        },
        assignList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, inserting, inserting);
            return target;
        },
        assign: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignList(target, source);
            } else {
                shapeReflections.assignMap(target, source);
            }
            return target;
        },
        assignDeepMap: function (target, source) {
            var hasOwnKey = fastHasOwnKey(target);
            var getKeyValue = target[getKeyValueSymbol] || shiftedGetKeyValue;
            var setKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(source, function (newVal, key) {
                if (!hasOwnKey(key)) {
                    getSetReflections.setKeyValue(target, key, newVal);
                } else {
                    var curVal = getKeyValue.call(target, key);
                    if (newVal === curVal) {
                    } else if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                        setKeyValue.call(target, key, newVal);
                    } else {
                        shapeReflections.assignDeep(curVal, newVal);
                    }
                }
            }, this);
            return target;
        },
        assignDeepList: function (target, source) {
            return updateDeepList.call(this, target, source, true);
        },
        assignDeep: function (target, source) {
            var assignDeep = target[canSymbol.for('can.assignDeep')];
            if (assignDeep) {
                assignDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.assignDeepList(target, source);
            } else {
                shapeReflections.assignDeepMap(target, source);
            }
            return target;
        },
        updateMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (newVal !== curVal) {
                    targetSetKeyValue.call(target, key, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateList: function (target, source) {
            var inserting = shapeReflections.toArray(source);
            getSetReflections.splice(target, 0, target, inserting);
            return target;
        },
        update: function (target, source) {
            if (typeReflections.isIteratorLike(source) || typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateList(target, source);
            } else {
                shapeReflections.updateMap(target, source);
            }
            return target;
        },
        updateDeepMap: function (target, source) {
            var sourceKeyMap = makeMap(shapeReflections.getOwnEnumerableKeys(source));
            var sourceGetKeyValue = source[getKeyValueSymbol] || shiftedGetKeyValue;
            var targetSetKeyValue = target[setKeyValueSymbol] || shiftedSetKeyValue;
            shapeReflections.eachKey(target, function (curVal, key) {
                if (!sourceKeyMap.get(key)) {
                    getSetReflections.deleteKeyValue(target, key);
                    return;
                }
                sourceKeyMap.set(key, false);
                var newVal = sourceGetKeyValue.call(source, key);
                if (typeReflections.isPrimitive(curVal) || typeReflections.isPrimitive(newVal) || shouldUpdateOrAssign(curVal) === false) {
                    targetSetKeyValue.call(target, key, newVal);
                } else {
                    shapeReflections.updateDeep(curVal, newVal);
                }
            }, this);
            shapeReflections.eachIndex(sourceKeyMap.keys(), function (key) {
                if (sourceKeyMap.get(key)) {
                    targetSetKeyValue.call(target, key, sourceGetKeyValue.call(source, key));
                }
            });
            return target;
        },
        updateDeepList: function (target, source) {
            return updateDeepList.call(this, target, source);
        },
        updateDeep: function (target, source) {
            var updateDeep = target[canSymbol.for('can.updateDeep')];
            if (updateDeep) {
                updateDeep.call(target, source);
            } else if (typeReflections.isMoreListLikeThanMapLike(source)) {
                shapeReflections.updateDeepList(target, source);
            } else {
                shapeReflections.updateDeepMap(target, source);
            }
            return target;
        },
        hasKey: function (obj, key) {
            if (obj == null) {
                return false;
            }
            if (typeReflections.isPrimitive(obj)) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    return true;
                } else {
                    var proto;
                    if (getPrototypeOfWorksWithPrimitives) {
                        proto = Object.getPrototypeOf(obj);
                    } else {
                        proto = obj.__proto__;
                    }
                    ;
                    if (proto !== undefined) {
                        return key in proto;
                    } else {
                        return obj[key] !== undefined;
                    }
                }
            }
            var hasKey = obj[canSymbol.for('can.hasKey')];
            if (hasKey) {
                return hasKey.call(obj, key);
            }
            var found = shapeReflections.hasOwnKey(obj, key);
            return found || key in obj;
        },
        getAllEnumerableKeys: function () {
        },
        getAllKeys: function () {
        },
        assignSymbols: function (target, source) {
            shapeReflections.eachKey(source, function (value, key) {
                var symbol = typeReflections.isSymbolLike(canSymbol[key]) ? canSymbol[key] : canSymbol.for(key);
                getSetReflections.setKeyValue(target, symbol, value);
            });
            return target;
        },
        isSerialized: isSerializedHelper,
        size: function (obj) {
            if (obj == null) {
                return 0;
            }
            var size = obj[sizeSymbol];
            var count = 0;
            if (size) {
                return size.call(obj);
            } else if (helpers.hasLength(obj)) {
                return obj.length;
            } else if (typeReflections.isListLike(obj)) {
                shapeReflections.eachIndex(obj, function () {
                    count++;
                });
                return count;
            } else if (obj) {
                return shapeReflections.getOwnEnumerableKeys(obj).length;
            } else {
                return undefined;
            }
        },
        defineInstanceKey: function (cls, key, properties) {
            var defineInstanceKey = cls[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                return defineInstanceKey.call(cls, key, properties);
            }
            var proto = cls.prototype;
            defineInstanceKey = proto[canSymbol.for('can.defineInstanceKey')];
            if (defineInstanceKey) {
                defineInstanceKey.call(proto, key, properties);
            } else {
                Object.defineProperty(proto, key, shapeReflections.assign({
                    configurable: true,
                    enumerable: !typeReflections.isSymbolLike(key),
                    writable: true
                }, properties));
            }
        }
    };
    shapeReflections.isSerializable = shapeReflections.isSerialized;
    shapeReflections.keys = shapeReflections.getOwnEnumerableKeys;
    module.exports = shapeReflections;
});
/*can-reflect@1.17.5#reflections/shape/schema/schema*/
define('can-reflect@1.17.5#reflections/shape/schema/schema', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../../type/type',
    '../../get-set/get-set',
    '../shape'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../../type/type');
    var getSetReflections = require('../../get-set/get-set');
    var shapeReflections = require('../shape');
    var getSchemaSymbol = canSymbol.for('can.getSchema'), isMemberSymbol = canSymbol.for('can.isMember'), newSymbol = canSymbol.for('can.new');
    function comparator(a, b) {
        return a.localeCompare(b);
    }
    function sort(obj) {
        if (typeReflections.isPrimitive(obj)) {
            return obj;
        }
        var out;
        if (typeReflections.isListLike(obj)) {
            out = [];
            shapeReflections.eachKey(obj, function (item) {
                out.push(sort(item));
            });
            return out;
        }
        if (typeReflections.isMapLike(obj)) {
            out = {};
            shapeReflections.getOwnKeys(obj).sort(comparator).forEach(function (key) {
                out[key] = sort(getSetReflections.getKeyValue(obj, key));
            });
            return out;
        }
        return obj;
    }
    function isPrimitiveConverter(Type) {
        return Type === Number || Type === String || Type === Boolean;
    }
    var schemaReflections = {
        getSchema: function (type) {
            if (type === undefined) {
                return undefined;
            }
            var getSchema = type[getSchemaSymbol];
            if (getSchema === undefined) {
                type = type.constructor;
                getSchema = type && type[getSchemaSymbol];
            }
            return getSchema !== undefined ? getSchema.call(type) : undefined;
        },
        getIdentity: function (value, schema) {
            schema = schema || schemaReflections.getSchema(value);
            if (schema === undefined) {
                throw new Error('can-reflect.getIdentity - Unable to find a schema for the given value.');
            }
            var identity = schema.identity;
            if (!identity || identity.length === 0) {
                throw new Error('can-reflect.getIdentity - Provided schema lacks an identity property.');
            } else if (identity.length === 1) {
                return getSetReflections.getKeyValue(value, identity[0]);
            } else {
                var id = {};
                identity.forEach(function (key) {
                    id[key] = getSetReflections.getKeyValue(value, key);
                });
                return JSON.stringify(schemaReflections.cloneKeySort(id));
            }
        },
        cloneKeySort: function (obj) {
            return sort(obj);
        },
        convert: function (value, Type) {
            if (isPrimitiveConverter(Type)) {
                return Type(value);
            }
            var isMemberTest = Type[isMemberSymbol], isMember = false, type = typeof Type, createNew = Type[newSymbol];
            if (isMemberTest !== undefined) {
                isMember = isMemberTest.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    isMember = value instanceof Type;
                }
            }
            if (isMember) {
                return value;
            }
            if (createNew !== undefined) {
                return createNew.call(Type, value);
            } else if (type === 'function') {
                if (typeReflections.isConstructorLike(Type)) {
                    return new Type(value);
                } else {
                    return Type(value);
                }
            } else {
                throw new Error('can-reflect: Can not convert values into type. Type must provide `can.new` symbol.');
            }
        }
    };
    module.exports = schemaReflections;
});
/*can-reflect@1.17.5#reflections/get-name/get-name*/
define('can-reflect@1.17.5#reflections/get-name/get-name', [
    'require',
    'exports',
    'module',
    'can-symbol',
    '../type/type'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    var typeReflections = require('../type/type');
    var getNameSymbol = canSymbol.for('can.getName');
    function setName(obj, nameGetter) {
        if (typeof nameGetter !== 'function') {
            var value = nameGetter;
            nameGetter = function () {
                return value;
            };
        }
        Object.defineProperty(obj, getNameSymbol, { value: nameGetter });
    }
    function getName(obj) {
        var type = typeof obj;
        if (obj === null || type !== 'object' && type !== 'function') {
            return '' + obj;
        }
        var nameGetter = obj[getNameSymbol];
        if (nameGetter) {
            return nameGetter.call(obj);
        }
        if (type === 'function') {
            return obj.name;
        }
        if (obj.constructor && obj !== obj.constructor) {
            var parent = getName(obj.constructor);
            if (parent) {
                if (typeReflections.isValueLike(obj)) {
                    return parent + '<>';
                }
                if (typeReflections.isMoreListLikeThanMapLike(obj)) {
                    return parent + '[]';
                }
                if (typeReflections.isMapLike(obj)) {
                    return parent + '{}';
                }
            }
        }
        return undefined;
    }
    module.exports = {
        setName: setName,
        getName: getName
    };
});
/*can-reflect@1.17.5#types/map*/
define('can-reflect@1.17.5#types/map', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    function keysPolyfill() {
        var keys = [];
        var currentIndex = 0;
        this.forEach(function (val, key) {
            keys.push(key);
        });
        return {
            next: function () {
                return {
                    value: keys[currentIndex],
                    done: currentIndex++ === keys.length
                };
            }
        };
    }
    if (typeof Map !== 'undefined') {
        shape.assignSymbols(Map.prototype, {
            'can.getOwnEnumerableKeys': Map.prototype.keys,
            'can.setKeyValue': Map.prototype.set,
            'can.getKeyValue': Map.prototype.get,
            'can.deleteKeyValue': Map.prototype['delete'],
            'can.hasOwnKey': Map.prototype.has
        });
        if (typeof Map.prototype.keys !== 'function') {
            Map.prototype.keys = Map.prototype[CanSymbol.for('can.getOwnEnumerableKeys')] = keysPolyfill;
        }
    }
    if (typeof WeakMap !== 'undefined') {
        shape.assignSymbols(WeakMap.prototype, {
            'can.getOwnEnumerableKeys': function () {
                throw new Error('can-reflect: WeakMaps do not have enumerable keys.');
            },
            'can.setKeyValue': WeakMap.prototype.set,
            'can.getKeyValue': WeakMap.prototype.get,
            'can.deleteKeyValue': WeakMap.prototype['delete'],
            'can.hasOwnKey': WeakMap.prototype.has
        });
    }
});
/*can-reflect@1.17.5#types/set*/
define('can-reflect@1.17.5#types/set', [
    'require',
    'exports',
    'module',
    '../reflections/shape/shape',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var shape = require('../reflections/shape/shape');
    var CanSymbol = require('can-symbol');
    if (typeof Set !== 'undefined') {
        shape.assignSymbols(Set.prototype, {
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                return this.size;
            }
        });
        if (typeof Set.prototype[CanSymbol.iterator] !== 'function') {
            Set.prototype[CanSymbol.iterator] = function () {
                var arr = [];
                var currentIndex = 0;
                this.forEach(function (val) {
                    arr.push(val);
                });
                return {
                    next: function () {
                        return {
                            value: arr[currentIndex],
                            done: currentIndex++ === arr.length
                        };
                    }
                };
            };
        }
    }
    if (typeof WeakSet !== 'undefined') {
        shape.assignSymbols(WeakSet.prototype, {
            'can.isListLike': true,
            'can.isMoreListLikeThanMapLike': true,
            'can.updateValues': function (index, removing, adding) {
                if (removing !== adding) {
                    shape.each(removing, function (value) {
                        this.delete(value);
                    }, this);
                }
                shape.each(adding, function (value) {
                    this.add(value);
                }, this);
            },
            'can.size': function () {
                throw new Error('can-reflect: WeakSets do not have enumerable keys.');
            }
        });
    }
});
/*can-reflect@1.17.5#can-reflect*/
define('can-reflect@1.17.5#can-reflect', [
    'require',
    'exports',
    'module',
    './reflections/call/call',
    './reflections/get-set/get-set',
    './reflections/observe/observe',
    './reflections/shape/shape',
    './reflections/shape/schema/schema',
    './reflections/type/type',
    './reflections/get-name/get-name',
    'can-namespace',
    './types/map',
    './types/set'
], function (require, exports, module) {
    'use strict';
    var functionReflections = require('./reflections/call/call');
    var getSet = require('./reflections/get-set/get-set');
    var observe = require('./reflections/observe/observe');
    var shape = require('./reflections/shape/shape');
    var schema = require('./reflections/shape/schema/schema');
    var type = require('./reflections/type/type');
    var getName = require('./reflections/get-name/get-name');
    var namespace = require('can-namespace');
    var reflect = {};
    [
        functionReflections,
        getSet,
        observe,
        shape,
        type,
        getName,
        schema
    ].forEach(function (reflections) {
        for (var prop in reflections) {
            reflect[prop] = reflections[prop];
        }
    });
    require('./types/map');
    require('./types/set');
    module.exports = namespace.Reflect = reflect;
});
/*can-log@1.0.0#can-log*/
define('can-log@1.0.0#can-log', function (require, exports, module) {
    'use strict';
    exports.warnTimeout = 5000;
    exports.logLevel = 0;
    exports.warn = function () {
        var ll = this.logLevel;
        if (ll < 2) {
            if (typeof console !== 'undefined' && console.warn) {
                this._logger('warn', Array.prototype.slice.call(arguments));
            } else if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.log = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.log) {
                this._logger('log', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports.error = function () {
        var ll = this.logLevel;
        if (ll < 1) {
            if (typeof console !== 'undefined' && console.error) {
                this._logger('error', Array.prototype.slice.call(arguments));
            }
        }
    };
    exports._logger = function (type, arr) {
        try {
            console[type].apply(console, arr);
        } catch (e) {
            console[type](arr);
        }
    };
});
/*can-log@1.0.0#dev/dev*/
define('can-log@1.0.0#dev/dev', [
    'require',
    'exports',
    'module',
    '../can-log'
], function (require, exports, module) {
    'use strict';
    var canLog = require('../can-log');
    module.exports = {
        warnTimeout: 5000,
        logLevel: 0,
        stringify: function (value) {
            var flagUndefined = function flagUndefined(key, value) {
                return value === undefined ? '/* void(undefined) */' : value;
            };
            return JSON.stringify(value, flagUndefined, '  ').replace(/"\/\* void\(undefined\) \*\/"/g, 'undefined');
        },
        warn: function () {
        },
        log: function () {
        },
        error: function () {
        },
        _logger: canLog._logger
    };
});
/*can-string@1.0.0#can-string*/
define('can-string@1.0.0#can-string', function (require, exports, module) {
    'use strict';
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        capitalize: function (s) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        undHash: strUndHash
    };
    module.exports = string;
});
/*can-construct@3.5.3#can-construct*/
define('can-construct@3.5.3#can-construct', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-log/dev/dev',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var namespace = require('can-namespace');
    var initializing = 0;
    var Construct = function () {
        if (arguments.length) {
            return Construct.extend.apply(Construct, arguments);
        }
    };
    var canGetDescriptor;
    try {
        Object.getOwnPropertyDescriptor({});
        canGetDescriptor = true;
    } catch (e) {
        canGetDescriptor = false;
    }
    var getDescriptor = function (newProps, name) {
            var descriptor = Object.getOwnPropertyDescriptor(newProps, name);
            if (descriptor && (descriptor.get || descriptor.set)) {
                return descriptor;
            }
            return null;
        }, inheritGetterSetter = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            var descriptor;
            for (var name in newProps) {
                if (descriptor = getDescriptor(newProps, name)) {
                    this._defineProperty(addTo, oldProps, name, descriptor);
                } else {
                    Construct._overwrite(addTo, oldProps, name, newProps[name]);
                }
            }
        }, simpleInherit = function (newProps, oldProps, addTo) {
            addTo = addTo || newProps;
            for (var name in newProps) {
                Construct._overwrite(addTo, oldProps, name, newProps[name]);
            }
        }, defineNonEnumerable = function (obj, prop, value) {
            Object.defineProperty(obj, prop, {
                configurable: true,
                writable: true,
                enumerable: false,
                value: value
            });
        };
    canReflect.assignMap(Construct, {
        constructorExtends: true,
        newInstance: function () {
            var inst = this.instance(), args;
            if (inst.setup) {
                Object.defineProperty(inst, '__inSetup', {
                    configurable: true,
                    enumerable: false,
                    value: true,
                    writable: true
                });
                args = inst.setup.apply(inst, arguments);
                if (args instanceof Construct.ReturnValue) {
                    return args.value;
                }
                inst.__inSetup = false;
            }
            if (inst.init) {
                inst.init.apply(inst, args || arguments);
            }
            return inst;
        },
        _inherit: canGetDescriptor ? inheritGetterSetter : simpleInherit,
        _defineProperty: function (what, oldProps, propName, descriptor) {
            Object.defineProperty(what, propName, descriptor);
        },
        _overwrite: function (what, oldProps, propName, val) {
            Object.defineProperty(what, propName, {
                value: val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        },
        setup: function (base) {
            var defaults = canReflect.assignDeepMap({}, base.defaults);
            this.defaults = canReflect.assignDeepMap(defaults, this.defaults);
        },
        instance: function () {
            initializing = 1;
            var inst = new this();
            initializing = 0;
            return inst;
        },
        extend: function (name, staticProperties, instanceProperties) {
            var shortName = name, klass = staticProperties, proto = instanceProperties;
            if (typeof shortName !== 'string') {
                proto = klass;
                klass = shortName;
                shortName = null;
            }
            if (!proto) {
                proto = klass;
                klass = null;
            }
            proto = proto || {};
            var _super_class = this, _super = this.prototype, Constructor, prototype;
            prototype = this.instance();
            Construct._inherit(proto, _super, prototype);
            if (shortName) {
            } else if (klass && klass.shortName) {
                shortName = klass.shortName;
            } else if (this.shortName) {
                shortName = this.shortName;
            }
            function init() {
                if (!initializing) {
                    return (!this || this.constructor !== Constructor) && arguments.length && Constructor.constructorExtends ? Constructor.extend.apply(Constructor, arguments) : Constructor.newInstance.apply(Constructor, arguments);
                }
            }
            Constructor = typeof namedCtor === 'function' ? namedCtor(constructorName, init) : function () {
                return init.apply(this, arguments);
            };
            for (var propName in _super_class) {
                if (_super_class.hasOwnProperty(propName)) {
                    Constructor[propName] = _super_class[propName];
                }
            }
            Construct._inherit(klass, _super_class, Constructor);
            canReflect.assignMap(Constructor, {
                constructor: Constructor,
                prototype: prototype
            });
            if (shortName !== undefined) {
                if (Object.getOwnPropertyDescriptor) {
                    var desc = Object.getOwnPropertyDescriptor(Constructor, 'name');
                    if (!desc || desc.configurable) {
                        Object.defineProperty(Constructor, 'name', {
                            writable: true,
                            value: shortName,
                            configurable: true
                        });
                    }
                }
                Constructor.shortName = shortName;
            }
            defineNonEnumerable(Constructor.prototype, 'constructor', Constructor);
            var t = [_super_class].concat(Array.prototype.slice.call(arguments)), args = Constructor.setup.apply(Constructor, t);
            if (Constructor.init) {
                Constructor.init.apply(Constructor, args || t);
            }
            return Constructor;
        },
        ReturnValue: function (value) {
            this.value = value;
        }
    });
    defineNonEnumerable(Construct.prototype, 'setup', function () {
    });
    defineNonEnumerable(Construct.prototype, 'init', function () {
    });
    module.exports = namespace.Construct = Construct;
});
/*can-util@3.14.0#js/is-container/is-container*/
define('can-util@3.14.0#js/is-container/is-container', function (require, exports, module) {
    'use strict';
    module.exports = function (current) {
        return /^f|^o/.test(typeof current);
    };
});
/*can-util@3.14.0#js/get/get*/
define('can-util@3.14.0#js/get/get', [
    'require',
    'exports',
    'module',
    '../is-container/is-container'
], function (require, exports, module) {
    'use strict';
    var isContainer = require('../is-container/is-container');
    function get(obj, name) {
        var parts = typeof name !== 'undefined' ? (name + '').replace(/\[/g, '.').replace(/]/g, '').split('.') : [], length = parts.length, current, i, container;
        if (!length) {
            return obj;
        }
        current = obj;
        for (i = 0; i < length && isContainer(current) && current !== null; i++) {
            container = current;
            current = container[parts[i]];
        }
        return current;
    }
    module.exports = get;
});
/*can-util@3.14.0#js/is-array/is-array*/
define('can-util@3.14.0#js/is-array/is-array', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var dev = require('can-log/dev/dev');
    var namespace = require('can-namespace');
    var hasWarned = false;
    module.exports = namespace.isArray = function (arr) {
        return Array.isArray(arr);
    };
});
/*can-util@3.14.0#js/string/string*/
define('can-util@3.14.0#js/string/string', [
    'require',
    'exports',
    'module',
    '../get/get',
    '../is-container/is-container',
    'can-log/dev/dev',
    '../is-array/is-array',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var get = require('../get/get');
    var isContainer = require('../is-container/is-container');
    var canDev = require('can-log/dev/dev');
    var isArray = require('../is-array/is-array');
    var namespace = require('can-namespace');
    var strUndHash = /_|-/, strColons = /\=\=/, strWords = /([A-Z]+)([A-Z][a-z])/g, strLowUp = /([a-z\d])([A-Z])/g, strDash = /([a-z\d])([A-Z])/g, strReplacer = /\{([^\}]+)\}/g, strQuote = /"/g, strSingleQuote = /'/g, strHyphenMatch = /-+(.)?/g, strCamelMatch = /[a-z][A-Z]/g, convertBadValues = function (content) {
            var isInvalid = content === null || content === undefined || isNaN(content) && '' + content === 'NaN';
            return '' + (isInvalid ? '' : content);
        }, deleteAtPath = function (data, path) {
            var parts = path ? path.replace(/\[/g, '.').replace(/]/g, '').split('.') : [];
            var current = data;
            for (var i = 0; i < parts.length - 1; i++) {
                if (current) {
                    current = current[parts[i]];
                }
            }
            if (current) {
                delete current[parts[parts.length - 1]];
            }
        };
    var string = {
        esc: function (content) {
            return convertBadValues(content).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(strQuote, '&#34;').replace(strSingleQuote, '&#39;');
        },
        getObject: function (name, roots) {
            roots = isArray(roots) ? roots : [roots || window];
            var result, l = roots.length;
            for (var i = 0; i < l; i++) {
                result = get(roots[i], name);
                if (result) {
                    return result;
                }
            }
        },
        capitalize: function (s, cache) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        },
        camelize: function (str) {
            return convertBadValues(str).replace(strHyphenMatch, function (match, chr) {
                return chr ? chr.toUpperCase() : '';
            });
        },
        hyphenate: function (str) {
            return convertBadValues(str).replace(strCamelMatch, function (str, offset) {
                return str.charAt(0) + '-' + str.charAt(1).toLowerCase();
            });
        },
        underscore: function (s) {
            return s.replace(strColons, '/').replace(strWords, '$1_$2').replace(strLowUp, '$1_$2').replace(strDash, '_').toLowerCase();
        },
        sub: function (str, data, remove) {
            var obs = [];
            str = str || '';
            obs.push(str.replace(strReplacer, function (whole, inside) {
                var ob = get(data, inside);
                if (remove === true) {
                    deleteAtPath(data, inside);
                }
                if (ob === undefined || ob === null) {
                    obs = null;
                    return '';
                }
                if (isContainer(ob) && obs) {
                    obs.push(ob);
                    return '';
                }
                return '' + ob;
            }));
            return obs === null ? obs : obs.length <= 1 ? obs[0] : obs;
        },
        replaceWith: function (str, data, replacer, shouldRemoveMatchedPaths) {
            return str.replace(strReplacer, function (whole, path) {
                var value = get(data, path);
                if (shouldRemoveMatchedPaths) {
                    deleteAtPath(data, path);
                }
                return replacer(path, value);
            });
        },
        replacer: strReplacer,
        undHash: strUndHash
    };
    module.exports = namespace.string = string;
});
/*can-assign@1.3.1#can-assign*/
define('can-assign@1.3.1#can-assign', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    module.exports = namespace.assign = function (d, s) {
        for (var prop in s) {
            var desc = Object.getOwnPropertyDescriptor(d, prop);
            if (!desc || desc.writable !== false) {
                d[prop] = s[prop];
            }
        }
        return d;
    };
});
/*can-util@3.14.0#js/assign/assign*/
define('can-util@3.14.0#js/assign/assign', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.assign = require('can-assign');
});
/*can-util@3.14.0#js/is-function/is-function*/
define('can-util@3.14.0#js/is-function/is-function', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var isFunction = function () {
        if (typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function') {
            return function (value) {
                return Object.prototype.toString.call(value) === '[object Function]';
            };
        }
        return function (value) {
            return typeof value === 'function';
        };
    }();
    module.exports = namespace.isFunction = isFunction;
});
/*can-util@3.14.0#js/is-array-like/is-array-like*/
define('can-util@3.14.0#js/is-array-like/is-array-like', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    function isArrayLike(obj) {
        var type = typeof obj;
        if (type === 'string') {
            return true;
        } else if (type === 'number') {
            return false;
        }
        var length = obj && type !== 'boolean' && typeof obj !== 'number' && 'length' in obj && obj.length;
        return typeof obj !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
    }
    module.exports = namespace.isArrayLike = isArrayLike;
});
/*can-util@3.14.0#js/is-iterable/is-iterable*/
define('can-util@3.14.0#js/is-iterable/is-iterable', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var canSymbol = require('can-symbol');
    module.exports = function (obj) {
        return obj && !!obj[canSymbol.iterator || canSymbol.for('iterator')];
    };
});
/*can-util@3.14.0#js/each/each*/
define('can-util@3.14.0#js/each/each', [
    'require',
    'exports',
    'module',
    '../is-array-like/is-array-like',
    '../is-iterable/is-iterable',
    'can-symbol',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var isArrayLike = require('../is-array-like/is-array-like');
    var has = Object.prototype.hasOwnProperty;
    var isIterable = require('../is-iterable/is-iterable');
    var canSymbol = require('can-symbol');
    var namespace = require('can-namespace');
    function each(elements, callback, context) {
        var i = 0, key, len, item;
        if (elements) {
            if (isArrayLike(elements)) {
                for (len = elements.length; i < len; i++) {
                    item = elements[i];
                    if (callback.call(context || item, item, i, elements) === false) {
                        break;
                    }
                }
            } else if (isIterable(elements)) {
                var iter = elements[canSymbol.iterator || canSymbol.for('iterator')]();
                var res, value;
                while (!(res = iter.next()).done) {
                    value = res.value;
                    callback.call(context || elements, Array.isArray(value) ? value[1] : value, value[0]);
                }
            } else if (typeof elements === 'object') {
                for (key in elements) {
                    if (has.call(elements, key) && callback.call(context || elements[key], elements[key], key, elements) === false) {
                        break;
                    }
                }
            }
        }
        return elements;
    }
    module.exports = namespace.each = each;
});
/*can-util@3.14.0#js/dev/dev*/
define('can-util@3.14.0#js/dev/dev', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.dev = require('can-log/dev/dev');
});
/*can-types@1.4.0#can-types*/
define('can-types@1.4.0#can-types', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-log/dev/dev'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-log/dev/dev');
    var types = {
        isMapLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isMapLike(obj);
        },
        isListLike: function (obj) {
            return canReflect.isObservableLike(obj) && canReflect.isListLike(obj);
        },
        isPromise: function (obj) {
            return canReflect.isPromise(obj);
        },
        isConstructor: function (func) {
            return canReflect.isConstructorLike(func);
        },
        isCallableForValue: function (obj) {
            return obj && canReflect.isFunctionLike(obj) && !canReflect.isConstructorLike(obj);
        },
        isCompute: function (obj) {
            return obj && obj.isComputed;
        },
        get iterator() {
            return canSymbol.iterator || canSymbol.for('iterator');
        },
        DefaultMap: null,
        DefaultList: null,
        queueTask: function (task) {
            var args = task[2] || [];
            task[0].apply(task[1], args);
        },
        wrapElement: function (element) {
            return element;
        },
        unwrapElement: function (element) {
            return element;
        }
    };
    if (namespace.types) {
        throw new Error('You can\'t have two versions of can-types, check your dependencies');
    } else {
        module.exports = namespace.types = types;
    }
});
/*can-cid@1.3.0#can-cid*/
define('can-cid@1.3.0#can-cid', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var _cid = 0;
    var domExpando = 'can' + new Date();
    var cid = function (object, name) {
        var propertyName = object.nodeName ? domExpando : '_cid';
        if (!object[propertyName]) {
            _cid++;
            object[propertyName] = (name || '') + _cid;
        }
        return object[propertyName];
    };
    cid.domExpando = domExpando;
    cid.get = function (object) {
        var type = typeof object;
        var isObject = type !== null && (type === 'object' || type === 'function');
        return isObject ? cid(object) : type + ':' + object;
    };
    if (namespace.cid) {
        throw new Error('You can\'t have two versions of can-cid, check your dependencies');
    } else {
        module.exports = namespace.cid = cid;
    }
});
/*can-dom-data-state@0.2.0#can-dom-data-state*/
define('can-dom-data-state@0.2.0#can-dom-data-state', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var CID = require('can-cid');
    var data = {};
    var isEmptyObject = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
    var setData = function (name, value) {
        var id = CID(this);
        var store = data[id] || (data[id] = {});
        if (name !== undefined) {
            store[name] = value;
        }
        return store;
    };
    var deleteNode = function () {
        var id = CID.get(this);
        var nodeDeleted = false;
        if (id && data[id]) {
            nodeDeleted = true;
            delete data[id];
        }
        return nodeDeleted;
    };
    var domDataState = {
        _data: data,
        getCid: function () {
            return CID.get(this);
        },
        cid: function () {
            return CID(this);
        },
        expando: CID.domExpando,
        get: function (key) {
            var id = CID.get(this), store = id && data[id];
            return key === undefined ? store : store && store[key];
        },
        set: setData,
        clean: function (prop) {
            var id = CID.get(this);
            var itemData = data[id];
            if (itemData && itemData[prop]) {
                delete itemData[prop];
            }
            if (isEmptyObject(itemData)) {
                deleteNode.call(this);
            }
        },
        delete: deleteNode
    };
    if (namespace.domDataState) {
        throw new Error('You can\'t have two versions of can-dom-data-state, check your dependencies');
    } else {
        module.exports = namespace.domDataState = domDataState;
    }
});
/*can-globals@1.2.0#can-globals-proto*/
define('can-globals@1.2.0#can-globals-proto', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        function dispatch(key) {
            var handlers = this.eventHandlers[key];
            if (handlers) {
                var handlersCopy = handlers.slice();
                var value = this.getKeyValue(key);
                for (var i = 0; i < handlersCopy.length; i++) {
                    handlersCopy[i](value);
                }
            }
        }
        function Globals() {
            this.eventHandlers = {};
            this.properties = {};
        }
        Globals.prototype.define = function (key, value, enableCache) {
            if (enableCache === undefined) {
                enableCache = true;
            }
            if (!this.properties[key]) {
                this.properties[key] = {
                    default: value,
                    value: value,
                    enableCache: enableCache
                };
            }
            return this;
        };
        Globals.prototype.getKeyValue = function (key) {
            var property = this.properties[key];
            if (property) {
                if (typeof property.value === 'function') {
                    if (property.cachedValue) {
                        return property.cachedValue;
                    }
                    if (property.enableCache) {
                        property.cachedValue = property.value();
                        return property.cachedValue;
                    } else {
                        return property.value();
                    }
                }
                return property.value;
            }
        };
        Globals.prototype.makeExport = function (key) {
            return function (value) {
                if (arguments.length === 0) {
                    return this.getKeyValue(key);
                }
                if (typeof value === 'undefined' || value === null) {
                    this.deleteKeyValue(key);
                } else {
                    if (typeof value === 'function') {
                        this.setKeyValue(key, function () {
                            return value;
                        });
                    } else {
                        this.setKeyValue(key, value);
                    }
                    return value;
                }
            }.bind(this);
        };
        Globals.prototype.offKeyValue = function (key, handler) {
            if (this.properties[key]) {
                var handlers = this.eventHandlers[key];
                if (handlers) {
                    var i = handlers.indexOf(handler);
                    handlers.splice(i, 1);
                }
            }
            return this;
        };
        Globals.prototype.onKeyValue = function (key, handler) {
            if (this.properties[key]) {
                if (!this.eventHandlers[key]) {
                    this.eventHandlers[key] = [];
                }
                this.eventHandlers[key].push(handler);
            }
            return this;
        };
        Globals.prototype.deleteKeyValue = function (key) {
            var property = this.properties[key];
            if (property !== undefined) {
                property.value = property.default;
                property.cachedValue = undefined;
                dispatch.call(this, key);
            }
            return this;
        };
        Globals.prototype.setKeyValue = function (key, value) {
            if (!this.properties[key]) {
                return this.define(key, value);
            }
            var property = this.properties[key];
            property.value = value;
            property.cachedValue = undefined;
            dispatch.call(this, key);
            return this;
        };
        Globals.prototype.reset = function () {
            for (var key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    this.properties[key].value = this.properties[key].default;
                    this.properties[key].cachedValue = undefined;
                    dispatch.call(this, key);
                }
            }
            return this;
        };
        canReflect.assignSymbols(Globals.prototype, {
            'can.getKeyValue': Globals.prototype.getKeyValue,
            'can.setKeyValue': Globals.prototype.setKeyValue,
            'can.deleteKeyValue': Globals.prototype.deleteKeyValue,
            'can.onKeyValue': Globals.prototype.onKeyValue,
            'can.offKeyValue': Globals.prototype.offKeyValue
        });
        module.exports = Globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#can-globals-instance*/
define('can-globals@1.2.0#can-globals-instance', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './can-globals-proto'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var Globals = require('./can-globals-proto');
        var globals = new Globals();
        if (namespace.globals) {
            throw new Error('You can\'t have two versions of can-globals, check your dependencies');
        } else {
            module.exports = namespace.globals = globals;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#global/global*/
define('can-globals@1.2.0#global/global', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('global', function () {
            return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : typeof process === 'object' && {}.toString.call(process) === '[object process]' ? global : window;
        });
        module.exports = globals.makeExport('global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#document/document*/
define('can-globals@1.2.0#document/document', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('document', function () {
            return globals.getKeyValue('global').document;
        });
        module.exports = globals.makeExport('document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#mutation-observer/mutation-observer*/
define('can-globals@1.2.0#mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('MutationObserver', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.MutationObserver || GLOBAL.WebKitMutationObserver || GLOBAL.MozMutationObserver;
        });
        module.exports = globals.makeExport('MutationObserver');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-cid@1.3.0#helpers*/
define('can-cid@1.3.0#helpers', function (require, exports, module) {
    'use strict';
    module.exports = {
        each: function (obj, cb, context) {
            for (var prop in obj) {
                cb.call(context, obj[prop], prop);
            }
            return obj;
        }
    };
});
/*can-cid@1.3.0#set/set*/
define('can-cid@1.3.0#set/set', [
    'require',
    'exports',
    'module',
    '../can-cid',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var getCID = require('../can-cid').get;
    var helpers = require('../helpers');
    var CIDSet;
    if (typeof Set !== 'undefined') {
        CIDSet = Set;
    } else {
        var CIDSet = function () {
            this.values = {};
        };
        CIDSet.prototype.add = function (value) {
            this.values[getCID(value)] = value;
        };
        CIDSet.prototype['delete'] = function (key) {
            var has = getCID(key) in this.values;
            if (has) {
                delete this.values[getCID(key)];
            }
            return has;
        };
        CIDSet.prototype.forEach = function (cb, thisArg) {
            helpers.each(this.values, cb, thisArg);
        };
        CIDSet.prototype.has = function (value) {
            return getCID(value) in this.values;
        };
        CIDSet.prototype.clear = function () {
            return this.values = {};
        };
        Object.defineProperty(CIDSet.prototype, 'size', {
            get: function () {
                var size = 0;
                helpers.each(this.values, function () {
                    size++;
                });
                return size;
            }
        });
    }
    module.exports = CIDSet;
});
/*can-util@3.14.0#js/make-array/make-array*/
define('can-util@3.14.0#js/make-array/make-array', [
    'require',
    'exports',
    'module',
    '../each/each',
    '../is-array-like/is-array-like',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    var isArrayLike = require('../is-array-like/is-array-like');
    var namespace = require('can-namespace');
    function makeArray(element) {
        var ret = [];
        if (isArrayLike(element)) {
            each(element, function (a, i) {
                ret[i] = a;
            });
        } else if (element === 0 || element) {
            ret.push(element);
        }
        return ret;
    }
    module.exports = namespace.makeArray = makeArray;
});
/*can-util@3.14.0#dom/mutation-observer/document/document*/
define('can-util@3.14.0#dom/mutation-observer/document/document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-dom-data-state',
    'can-globals/mutation-observer/mutation-observer',
    '../../../js/each/each',
    'can-cid/set/set',
    '../../../js/make-array/make-array',
    '../../../js/string/string'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var domDataState = require('can-dom-data-state');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var each = require('../../../js/each/each');
        var CIDStore = require('can-cid/set/set');
        var makeArray = require('../../../js/make-array/make-array');
        var string = require('../../../js/string/string');
        var dispatchIfListening = function (mutatedNode, nodes, dispatched) {
            if (dispatched.has(mutatedNode)) {
                return true;
            }
            dispatched.add(mutatedNode);
            if (nodes.name === 'removedNodes') {
                var documentElement = getDocument().documentElement;
                if (documentElement.contains(mutatedNode)) {
                    return;
                }
            }
            nodes.handlers.forEach(function (handler) {
                handler(mutatedNode);
            });
            nodes.afterHandlers.forEach(function (handler) {
                handler(mutatedNode);
            });
        };
        var mutationObserverDocument = {
            add: function (handler) {
                var MO = getMutationObserver();
                if (MO) {
                    var documentElement = getDocument().documentElement;
                    var globalObserverData = domDataState.get.call(documentElement, 'globalObserverData');
                    if (!globalObserverData) {
                        var observer = new MO(function (mutations) {
                            globalObserverData.handlers.forEach(function (handler) {
                                handler(mutations);
                            });
                        });
                        observer.observe(documentElement, {
                            childList: true,
                            subtree: true
                        });
                        globalObserverData = {
                            observer: observer,
                            handlers: []
                        };
                        domDataState.set.call(documentElement, 'globalObserverData', globalObserverData);
                    }
                    globalObserverData.handlers.push(handler);
                }
            },
            remove: function (handler) {
                var documentElement = getDocument().documentElement;
                var globalObserverData = domDataState.get.call(documentElement, 'globalObserverData');
                if (globalObserverData) {
                    var index = globalObserverData.handlers.indexOf(handler);
                    if (index >= 0) {
                        globalObserverData.handlers.splice(index, 1);
                    }
                    if (globalObserverData.handlers.length === 0) {
                        globalObserverData.observer.disconnect();
                        domDataState.clean.call(documentElement, 'globalObserverData');
                    }
                }
            }
        };
        var makeMutationMethods = function (name) {
            var mutationName = name.toLowerCase() + 'Nodes';
            var getMutationData = function () {
                var documentElement = getDocument().documentElement;
                var mutationData = domDataState.get.call(documentElement, mutationName + 'MutationData');
                if (!mutationData) {
                    mutationData = {
                        name: mutationName,
                        handlers: [],
                        afterHandlers: [],
                        hander: null
                    };
                    if (getMutationObserver()) {
                        domDataState.set.call(documentElement, mutationName + 'MutationData', mutationData);
                    }
                }
                return mutationData;
            };
            var setup = function () {
                var mutationData = getMutationData();
                if (mutationData.handlers.length === 0 || mutationData.afterHandlers.length === 0) {
                    mutationData.handler = function (mutations) {
                        var dispatched = new CIDStore();
                        mutations.forEach(function (mutation) {
                            each(mutation[mutationName], function (mutatedNode) {
                                var children = mutatedNode.getElementsByTagName && makeArray(mutatedNode.getElementsByTagName('*'));
                                var alreadyChecked = dispatchIfListening(mutatedNode, mutationData, dispatched);
                                if (children && !alreadyChecked) {
                                    for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                                        dispatchIfListening(child, mutationData, dispatched);
                                    }
                                }
                            });
                        });
                    };
                    this.add(mutationData.handler);
                }
                return mutationData;
            };
            var teardown = function () {
                var documentElement = getDocument().documentElement;
                var mutationData = getMutationData();
                if (mutationData.handlers.length === 0 && mutationData.afterHandlers.length === 0) {
                    this.remove(mutationData.handler);
                    domDataState.clean.call(documentElement, mutationName + 'MutationData');
                }
            };
            var createOnOffHandlers = function (name, handlerList) {
                mutationObserverDocument['on' + name] = function (handler) {
                    var mutationData = setup.call(this);
                    mutationData[handlerList].push(handler);
                };
                mutationObserverDocument['off' + name] = function (handler) {
                    var mutationData = getMutationData();
                    var index = mutationData[handlerList].indexOf(handler);
                    if (index >= 0) {
                        mutationData[handlerList].splice(index, 1);
                    }
                    teardown.call(this);
                };
            };
            var createHandlers = function (name) {
                createOnOffHandlers(name, 'handlers');
                createOnOffHandlers('After' + name, 'afterHandlers');
            };
            createHandlers(string.capitalize(mutationName));
        };
        makeMutationMethods('added');
        makeMutationMethods('removed');
        module.exports = mutationObserverDocument;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/data/data*/
define('can-util@3.14.0#dom/data/data', [
    'require',
    'exports',
    'module',
    'can-dom-data-state',
    '../mutation-observer/document/document',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var domDataState = require('can-dom-data-state');
    var mutationDocument = require('../mutation-observer/document/document');
    var namespace = require('can-namespace');
    var elementSetCount = 0;
    var deleteNode = function () {
        elementSetCount -= 1;
        return domDataState.delete.call(this);
    };
    var cleanupDomData = function (node) {
        if (domDataState.get.call(node) !== undefined) {
            deleteNode.call(node);
        }
        if (elementSetCount === 0) {
            mutationDocument.offAfterRemovedNodes(cleanupDomData);
        }
    };
    module.exports = namespace.data = {
        getCid: domDataState.getCid,
        cid: domDataState.cid,
        expando: domDataState.expando,
        clean: domDataState.clean,
        get: domDataState.get,
        set: function (name, value) {
            if (elementSetCount === 0) {
                mutationDocument.onAfterRemovedNodes(cleanupDomData);
            }
            elementSetCount += domDataState.get.call(this) ? 0 : 1;
            domDataState.set.call(this, name, value);
        },
        delete: deleteNode,
        _getElementSetCount: function () {
            return elementSetCount;
        }
    };
});
/*can-util@3.14.0#dom/class-name/class-name*/
define('can-util@3.14.0#dom/class-name/class-name', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var has = function (className) {
        if (this.classList) {
            return this.classList.contains(className);
        } else {
            return !!this.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
        }
    };
    module.exports = namespace.className = {
        has: has,
        add: function (className) {
            if (this.classList) {
                this.classList.add(className);
            } else if (!has.call(this, className)) {
                this.className += ' ' + className;
            }
        },
        remove: function (className) {
            if (this.classList) {
                this.classList.remove(className);
            } else if (has.call(this, className)) {
                var reg = new RegExp('(\\s|^)' + className + '(\\s|$)');
                this.className = this.className.replace(reg, ' ');
            }
        }
    };
});
/*can-globals@1.2.0#is-node/is-node*/
define('can-globals@1.2.0#is-node/is-node', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        globals.define('isNode', function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        });
        module.exports = globals.makeExport('isNode');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#is-browser-window/is-browser-window*/
define('can-globals@1.2.0#is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    '../is-node/is-node'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('../is-node/is-node');
        globals.define('isBrowserWindow', function () {
            var isNode = globals.getKeyValue('isNode');
            return typeof window !== 'undefined' && typeof document !== 'undefined' && isNode === false;
        });
        module.exports = globals.makeExport('isBrowserWindow');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/is-plain-object/is-plain-object*/
define('can-util@3.14.0#js/is-plain-object/is-plain-object', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var core_hasOwn = Object.prototype.hasOwnProperty;
    function isWindow(obj) {
        return obj !== null && obj == obj.window;
    }
    function isPlainObject(obj) {
        if (!obj || typeof obj !== 'object' || obj.nodeType || isWindow(obj) || obj.constructor && obj.constructor.shortName) {
            return false;
        }
        try {
            if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                return false;
            }
        } catch (e) {
            return false;
        }
        var key;
        for (key in obj) {
        }
        return key === undefined || core_hasOwn.call(obj, key);
    }
    module.exports = namespace.isPlainObject = isPlainObject;
});
/*can-util@3.14.0#dom/events/events*/
define('can-util@3.14.0#dom/events/events', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window',
    '../../js/is-plain-object/is-plain-object',
    'can-log/dev/dev',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        var isPlainObject = require('../../js/is-plain-object/is-plain-object');
        var fixSyntheticEventsOnDisabled = false;
        var dev = require('can-log/dev/dev');
        var namespace = require('can-namespace');
        function isDispatchingOnDisabled(element, ev) {
            var isInsertedOrRemoved = isPlainObject(ev) ? ev.type === 'inserted' || ev.type === 'removed' : ev === 'inserted' || ev === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        module.exports = namespace.events = {
            addEventListener: function () {
                this.addEventListener.apply(this, arguments);
            },
            removeEventListener: function () {
                this.removeEventListener.apply(this, arguments);
            },
            canAddEventListener: function () {
                return this.nodeName && (this.nodeType === 1 || this.nodeType === 9) || this === window;
            },
            dispatch: function (event, args, bubbles) {
                var ret;
                var dispatchingOnDisabled = fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(this, event);
                var doc = this.ownerDocument || getDocument();
                var ev = doc.createEvent('HTMLEvents');
                var isString = typeof event === 'string';
                ev.initEvent(isString ? event : event.type, bubbles === undefined ? true : bubbles, false);
                if (!isString) {
                    for (var prop in event) {
                        if (ev[prop] === undefined) {
                            ev[prop] = event[prop];
                        }
                    }
                }
                if (this.disabled === true && ev.type !== 'fix_synthetic_events_on_disabled_test') {
                }
                ev.args = args;
                if (dispatchingOnDisabled) {
                    this.disabled = false;
                }
                ret = this.dispatchEvent(ev);
                if (dispatchingOnDisabled) {
                    this.disabled = true;
                }
                return ret;
            }
        };
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                module.exports.removeEventListener.call(input, testEventName, onTest);
            };
            module.exports.addEventListener.call(input, testEventName, onTest);
            try {
                module.exports.dispatch.call(input, testEventName, [], false);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/is-empty-object/is-empty-object*/
define('can-util@3.14.0#js/is-empty-object/is-empty-object', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.isEmptyObject = function (obj) {
        for (var prop in obj) {
            return false;
        }
        return true;
    };
});
/*can-util@3.14.0#dom/dispatch/dispatch*/
define('can-util@3.14.0#dom/dispatch/dispatch', [
    'require',
    'exports',
    'module',
    '../events/events',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events/events');
    var namespace = require('can-namespace');
    module.exports = namespace.dispatch = function () {
        return domEvents.dispatch.apply(this, arguments);
    };
});
/*can-util@3.14.0#dom/matches/matches*/
define('can-util@3.14.0#dom/matches/matches', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var matchesMethod = function (element) {
        return element.matches || element.webkitMatchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;
    };
    module.exports = namespace.matches = function () {
        var method = matchesMethod(this);
        return method ? method.apply(this, arguments) : false;
    };
});
/*can-util@3.14.0#dom/events/delegate/delegate*/
define('can-util@3.14.0#dom/events/delegate/delegate', [
    'require',
    'exports',
    'module',
    '../events',
    '../../data/data',
    '../../matches/matches',
    '../../../js/each/each',
    '../../../js/is-empty-object/is-empty-object',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events');
    var domData = require('../../data/data');
    var domMatches = require('../../matches/matches');
    var each = require('../../../js/each/each');
    var isEmptyObject = require('../../../js/is-empty-object/is-empty-object');
    var canCid = require('can-cid');
    var dataName = 'delegateEvents';
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    var handleEvent = function (overrideEventType, ev) {
        var events = domData.get.call(this, dataName);
        var eventTypeEvents = events[overrideEventType || ev.type];
        var matches = [];
        if (eventTypeEvents) {
            var selectorDelegates = [];
            each(eventTypeEvents, function (delegates) {
                selectorDelegates.push(delegates);
            });
            var cur = ev.target;
            do {
                selectorDelegates.forEach(function (delegates) {
                    if (domMatches.call(cur, delegates[0].selector)) {
                        matches.push({
                            target: cur,
                            delegates: delegates
                        });
                    }
                });
                cur = cur.parentNode;
            } while (cur && cur !== ev.currentTarget);
        }
        var oldStopProp = ev.stopPropagation;
        ev.stopPropagation = function () {
            oldStopProp.apply(this, arguments);
            this.cancelBubble = true;
        };
        for (var i = 0; i < matches.length; i++) {
            var match = matches[i];
            var delegates = match.delegates;
            for (var d = 0, dLen = delegates.length; d < dLen; d++) {
                if (delegates[d].handler.call(match.target, ev) === false) {
                    return false;
                }
                if (ev.cancelBubble) {
                    return;
                }
            }
        }
    };
    domEvents.addDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName), eventTypeEvents;
        if (!events) {
            domData.set.call(this, dataName, events = {});
        }
        if (!(eventTypeEvents = events[eventType])) {
            eventTypeEvents = events[eventType] = {};
            var delegateHandler = handleEvent.bind(this, eventType);
            domData.set.call(this, canCid(handler), delegateHandler);
            domEvents.addEventListener.call(this, eventType, delegateHandler, useCapture(eventType));
        }
        if (!eventTypeEvents[selector]) {
            eventTypeEvents[selector] = [];
        }
        eventTypeEvents[selector].push({
            handler: handler,
            selector: selector
        });
    };
    domEvents.removeDelegateListener = function (eventType, selector, handler) {
        var events = domData.get.call(this, dataName);
        if (events && events[eventType] && events[eventType][selector]) {
            var eventTypeEvents = events[eventType], delegates = eventTypeEvents[selector], i = 0;
            while (i < delegates.length) {
                if (delegates[i].handler === handler) {
                    delegates.splice(i, 1);
                } else {
                    i++;
                }
            }
            if (delegates.length === 0) {
                delete eventTypeEvents[selector];
                if (isEmptyObject(eventTypeEvents)) {
                    var delegateHandler = domData.get.call(this, canCid(handler));
                    domEvents.removeEventListener.call(this, eventType, delegateHandler, useCapture(eventType));
                    delete events[eventType];
                    if (isEmptyObject(events)) {
                        domData.clean.call(this, dataName);
                    }
                }
            }
        }
    };
});
/*can-util@3.14.0#js/single-reference/single-reference*/
define('can-util@3.14.0#js/single-reference/single-reference', [
    'require',
    'exports',
    'module',
    'can-cid'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var CID = require('can-cid');
        var singleReference;
        function getKeyName(key, extraKey) {
            var keyCID = key != null && (typeof key === 'object' || typeof key === 'function') ? CID(key) : '' + key;
            var keyName = extraKey ? keyCID + ':' + extraKey : keyCID;
            return keyName || key;
        }
        singleReference = {
            set: function (obj, key, value, extraKey) {
                obj[getKeyName(key, extraKey)] = value;
            },
            getAndDelete: function (obj, key, extraKey) {
                var keyName = getKeyName(key, extraKey);
                var value = obj[keyName];
                delete obj[keyName];
                return value;
            }
        };
        module.exports = singleReference;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/cid/get-cid*/
define('can-util@3.14.0#js/cid/get-cid', [
    'require',
    'exports',
    'module',
    'can-cid',
    'can-dom-data-state'
], function (require, exports, module) {
    'use strict';
    var CID = require('can-cid');
    var domDataState = require('can-dom-data-state');
    module.exports = function (obj) {
        if (typeof obj.nodeType === 'number') {
            return domDataState.cid.call(obj);
        } else {
            var type = typeof obj;
            var isObject = type !== null && (type === 'object' || type === 'function');
            return type + ':' + (isObject ? CID(obj) : obj);
        }
    };
});
/*can-util@3.14.0#dom/events/delegate/enter-leave*/
define('can-util@3.14.0#dom/events/delegate/enter-leave', [
    'require',
    'exports',
    'module',
    '../events',
    '../../../js/single-reference/single-reference',
    '../../../js/cid/get-cid'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events'), singleRef = require('../../../js/single-reference/single-reference'), cid = require('../../../js/cid/get-cid');
    var eventMap = {
            mouseenter: 'mouseover',
            mouseleave: 'mouseout',
            pointerenter: 'pointerover',
            pointerleave: 'pointerout'
        }, classMap = {
            mouseenter: 'MouseEvent',
            mouseleave: 'MouseEvent',
            pointerenter: 'PointerEvent',
            pointerleave: 'PointerEvent'
        }, _addDelegateListener = domEvents.addDelegateListener, _removeDelegateListener = domEvents.removeDelegateListener;
    domEvents.addDelegateListener = function (eventType, selector, handler) {
        if (eventMap[eventType] !== undefined) {
            var origHandler = handler, origType = eventType;
            eventType = eventMap[eventType];
            handler = function (event) {
                var target = this, related = event.relatedTarget;
                if (!related || related !== target && !target.contains(related)) {
                    var eventClass = classMap[origType];
                    if (eventClass === 'MouseEvent') {
                        var newEv = document.createEvent(eventClass);
                        newEv.initMouseEvent(origType, false, false, event.view, event.detail, event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
                        event = newEv;
                    } else if (eventClass === 'PointerEvent') {
                        event = new PointerEvent(origType, event);
                    }
                    return origHandler.call(this, event);
                }
            };
            singleRef.set(origHandler, cid(this) + eventType, handler);
        }
        _addDelegateListener.call(this, eventType, selector, handler);
    };
    domEvents.removeDelegateListener = function (eventType, selector, handler) {
        if (eventMap[eventType] !== undefined) {
            eventType = eventMap[eventType];
            handler = singleRef.getAndDelete(handler, cid(this) + eventType);
        }
        _removeDelegateListener.call(this, eventType, selector, handler);
    };
});
/*can-event@3.7.7#can-event*/
define('can-event@3.7.7#can-event', [
    'require',
    'exports',
    'module',
    'can-util/dom/events/events',
    'can-cid',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/dom/dispatch/dispatch',
    'can-namespace',
    'can-util/dom/events/delegate/delegate',
    'can-util/dom/events/delegate/enter-leave'
], function (require, exports, module) {
    var domEvents = require('can-util/dom/events/events');
    var CID = require('can-cid');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var namespace = require('can-namespace');
    require('can-util/dom/events/delegate/delegate');
    require('can-util/dom/events/delegate/enter-leave');
    function makeHandlerArgs(event, args) {
        if (typeof event === 'string') {
            event = { type: event };
        }
        var handlerArgs = [event];
        if (args) {
            handlerArgs.push.apply(handlerArgs, args);
        }
        return handlerArgs;
    }
    function getHandlers(eventName) {
        var events = this.__bindEvents;
        if (!events) {
            return;
        }
        return events[eventName];
    }
    var canEvent = {
        addEventListener: function (event, handler) {
            var allEvents = this.__bindEvents || (this.__bindEvents = {}), eventList = allEvents[event] || (allEvents[event] = []);
            eventList.push(handler);
            return this;
        },
        removeEventListener: function (event, fn) {
            if (!this.__bindEvents) {
                return this;
            }
            if (!arguments.length) {
                for (var bindEvent in this.__bindEvents) {
                    if (bindEvent === '_lifecycleBindings') {
                        this.__bindEvents._lifecycleBindings = null;
                    } else if (this.__bindEvents.hasOwnProperty(bindEvent)) {
                        canEvent.removeEventListener.call(this, bindEvent);
                    }
                }
                return this;
            }
            var handlers = this.__bindEvents[event] || [], i = 0, handler, isFunction = typeof fn === 'function';
            while (i < handlers.length) {
                handler = handlers[i];
                if (isFunction && handler === fn || !isFunction && (handler.cid === fn || !fn)) {
                    handlers.splice(i, 1);
                } else {
                    i++;
                }
            }
            return this;
        },
        dispatchSync: function (event, args) {
            var handlerArgs = makeHandlerArgs(event, args);
            var handlers = getHandlers.call(this, handlerArgs[0].type);
            if (!handlers) {
                return;
            }
            handlers = handlers.slice(0);
            for (var i = 0, len = handlers.length; i < len; i++) {
                handlers[i].apply(this, handlerArgs);
            }
            return handlerArgs[0];
        },
        on: function (eventName, selector, handler) {
            var method = typeof selector === 'string' ? 'addDelegateListener' : 'addEventListener';
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];
            return eventBinder.apply(this, arguments);
        },
        off: function (eventName, selector, handler) {
            var method = typeof selector === 'string' ? 'removeDelegateListener' : 'removeEventListener';
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var eventBinder = listenWithDOM ? domEvents[method] : this[method] || canEvent[method];
            return eventBinder.apply(this, arguments);
        },
        trigger: function () {
            var listenWithDOM = domEvents.canAddEventListener.call(this);
            var dispatch = listenWithDOM ? domDispatch : canEvent.dispatch;
            return dispatch.apply(this, arguments);
        },
        one: function (event, handler) {
            var one = function () {
                canEvent.off.call(this, event, one);
                return handler.apply(this, arguments);
            };
            canEvent.on.call(this, event, one);
            return this;
        },
        listenTo: function (other, event, handler) {
            var idedEvents = this.__listenToEvents;
            if (!idedEvents) {
                idedEvents = this.__listenToEvents = {};
            }
            var otherId = CID(other);
            var othersEvents = idedEvents[otherId];
            if (!othersEvents) {
                othersEvents = idedEvents[otherId] = {
                    obj: other,
                    events: {}
                };
            }
            var eventsEvents = othersEvents.events[event];
            if (!eventsEvents) {
                eventsEvents = othersEvents.events[event] = [];
            }
            eventsEvents.push(handler);
            canEvent.on.call(other, event, handler);
        },
        stopListening: function (other, event, handler) {
            var idedEvents = this.__listenToEvents, iterIdedEvents = idedEvents, i = 0;
            if (!idedEvents) {
                return this;
            }
            if (other) {
                var othercid = CID(other);
                (iterIdedEvents = {})[othercid] = idedEvents[othercid];
                if (!idedEvents[othercid]) {
                    return this;
                }
            }
            for (var cid in iterIdedEvents) {
                var othersEvents = iterIdedEvents[cid], eventsEvents;
                other = idedEvents[cid].obj;
                if (!event) {
                    eventsEvents = othersEvents.events;
                } else {
                    (eventsEvents = {})[event] = othersEvents.events[event];
                }
                for (var eventName in eventsEvents) {
                    var handlers = eventsEvents[eventName] || [];
                    i = 0;
                    while (i < handlers.length) {
                        if (handler && handler === handlers[i] || !handler) {
                            canEvent.off.call(other, eventName, handlers[i]);
                            handlers.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                    if (!handlers.length) {
                        delete othersEvents.events[eventName];
                    }
                }
                if (isEmptyObject(othersEvents.events)) {
                    delete idedEvents[cid];
                }
            }
            return this;
        }
    };
    canEvent.addEvent = canEvent.bind = function () {
        return canEvent.addEventListener.apply(this, arguments);
    };
    canEvent.unbind = canEvent.removeEvent = function () {
        return canEvent.removeEventListener.apply(this, arguments);
    };
    canEvent.delegate = canEvent.on;
    canEvent.undelegate = canEvent.off;
    canEvent.dispatch = canEvent.dispatchSync;
    Object.defineProperty(canEvent, 'makeHandlerArgs', {
        enumerable: false,
        value: makeHandlerArgs
    });
    Object.defineProperty(canEvent, 'handlers', {
        enumerable: false,
        value: getHandlers
    });
    Object.defineProperty(canEvent, 'flush', {
        enumerable: false,
        writable: true,
        value: function () {
        }
    });
    module.exports = namespace.event = canEvent;
});
/*can-util@3.14.0#js/last/last*/
define('can-util@3.14.0#js/last/last', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.last = function (arr) {
        return arr && arr[arr.length - 1];
    };
});
/*can-util@3.14.0#js/log/log*/
define('can-util@3.14.0#js/log/log', [
    'require',
    'exports',
    'module',
    'can-log'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-log');
});
/*can-event@3.7.7#batch/batch*/
define('can-event@3.7.7#batch/batch', [
    'require',
    'exports',
    'module',
    '../can-event',
    'can-util/js/last/last',
    'can-namespace',
    'can-types',
    'can-util/js/dev/dev',
    'can-util/js/log/log'
], function (require, exports, module) {
    'use strict';
    var canEvent = require('../can-event');
    var last = require('can-util/js/last/last');
    var namespace = require('can-namespace');
    var canTypes = require('can-types');
    var canDev = require('can-util/js/dev/dev');
    var canLog = require('can-util/js/log/log');
    var batchNum = 1, collectionQueue = null, queues = [], dispatchingQueues = false, makeHandlerArgs = canEvent.makeHandlerArgs, getHandlers = canEvent.handlers;
    function addToCollectionQueue(item, event, args, handlers) {
        var handlerArgs = makeHandlerArgs(event, args);
        var tasks = [];
        for (var i = 0, len = handlers.length; i < len; i++) {
            tasks[i] = [
                handlers[i],
                item,
                handlerArgs
            ];
        }
        [].push.apply(collectionQueue.tasks, tasks);
    }
    var canBatch = {
        transactions: 0,
        start: function (batchStopHandler) {
            canBatch.transactions++;
            if (canBatch.transactions === 1) {
                var queue = {
                    number: batchNum++,
                    index: 0,
                    tasks: [],
                    batchEnded: false,
                    callbacksIndex: 0,
                    callbacks: [],
                    complete: false
                };
                if (batchStopHandler) {
                    queue.callbacks.push(batchStopHandler);
                }
                collectionQueue = queue;
            }
        },
        collecting: function () {
            return collectionQueue;
        },
        dispatching: function () {
            return queues[0];
        },
        stop: function (force, callStart) {
            if (force) {
                canBatch.transactions = 0;
            } else {
                canBatch.transactions--;
            }
            if (canBatch.transactions === 0) {
                queues.push(collectionQueue);
                collectionQueue = null;
                if (!dispatchingQueues) {
                    canEvent.flush();
                }
            }
        },
        flush: function () {
            dispatchingQueues = true;
            while (queues.length) {
                var queue = queues[0];
                var tasks = queue.tasks, callbacks = queue.callbacks;
                canBatch.batchNum = queue.number;
                var len = tasks.length;
                while (queue.index < len) {
                    var task = tasks[queue.index++];
                    task[0].apply(task[1], task[2]);
                }
                if (!queue.batchEnded) {
                    queue.batchEnded = true;
                    canEvent.dispatchSync.call(canBatch, 'batchEnd', [queue.number]);
                }
                while (queue.callbacksIndex < callbacks.length) {
                    callbacks[queue.callbacksIndex++]();
                }
                if (!queue.complete) {
                    queue.complete = true;
                    canBatch.batchNum = undefined;
                    queues.shift();
                }
            }
            dispatchingQueues = false;
        },
        dispatch: function (event, args) {
            var item = this, handlers;
            if (!item.__inSetup) {
                event = typeof event === 'string' ? { type: event } : event;
                if (event.batchNum) {
                    canBatch.batchNum = event.batchNum;
                    canEvent.dispatchSync.call(item, event, args);
                } else if (collectionQueue) {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                    }
                } else if (queues.length) {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        canBatch.start();
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                        last(queues).callbacks.push(canBatch.stop);
                    }
                } else {
                    handlers = getHandlers.call(this, event.type);
                    if (handlers) {
                        canBatch.start();
                        event.batchNum = collectionQueue.number;
                        addToCollectionQueue(item, event, args, handlers);
                        canBatch.stop();
                    }
                }
            }
        },
        queue: function (task, inCurrentBatch) {
            if (collectionQueue) {
                collectionQueue.tasks.push(task);
            } else if (queues.length) {
                if (inCurrentBatch && queues[0].index < queues.tasks.length) {
                    queues[0].tasks.push(task);
                } else {
                    canBatch.start();
                    collectionQueue.tasks.push(task);
                    last(queues).callbacks.push(canBatch.stop);
                }
            } else {
                canBatch.start();
                collectionQueue.tasks.push(task);
                canBatch.stop();
            }
        },
        queues: function () {
            return queues;
        },
        afterPreviousEvents: function (handler) {
            this.queue([handler]);
        },
        after: function (handler) {
            var queue = collectionQueue || queues[0];
            if (queue) {
                queue.callbacks.push(handler);
            } else {
                handler({});
            }
        }
    };
    Object.defineProperty(canBatch, 'debounce', {
        enumerable: false,
        value: function (handler) {
            var that = null;
            var args = null;
            return function () {
                if (!that) {
                    canEvent.addEventListener.call(canBatch, 'batchEnd', function listener() {
                        canEvent.removeEventListener.call(canBatch, 'batchEnd', listener);
                        handler.apply(that, args);
                        that = null;
                        args = null;
                    });
                }
                that = this;
                args = arguments;
            };
        }
    });
    canEvent.flush = canBatch.flush;
    canEvent.dispatch = canBatch.dispatch;
    canBatch.trigger = function () {
        canLog.warn('use canEvent.dispatch instead');
        return canEvent.dispatch.apply(this, arguments);
    };
    canTypes.queueTask = canBatch.queue;
    if (namespace.batch) {
        throw new Error('You can\'t have two versions of can-event/batch/batch, check your dependencies');
    } else {
        module.exports = namespace.batch = canBatch;
    }
});
/*can-cid@1.3.0#map/map*/
define('can-cid@1.3.0#map/map', [
    'require',
    'exports',
    'module',
    '../can-cid',
    '../helpers'
], function (require, exports, module) {
    'use strict';
    var getCID = require('../can-cid').get;
    var helpers = require('../helpers');
    var CIDMap;
    if (typeof Map !== 'undefined') {
        CIDMap = Map;
    } else {
        var CIDMap = function () {
            this.values = {};
        };
        CIDMap.prototype.set = function (key, value) {
            this.values[getCID(key)] = {
                key: key,
                value: value
            };
        };
        CIDMap.prototype['delete'] = function (key) {
            var has = getCID(key) in this.values;
            if (has) {
                delete this.values[getCID(key)];
            }
            return has;
        };
        CIDMap.prototype.forEach = function (cb, thisArg) {
            helpers.each(this.values, function (pair) {
                return cb.call(thisArg || this, pair.value, pair.key, this);
            }, this);
        };
        CIDMap.prototype.has = function (key) {
            return getCID(key) in this.values;
        };
        CIDMap.prototype.get = function (key) {
            var obj = this.values[getCID(key)];
            return obj && obj.value;
        };
        CIDMap.prototype.clear = function () {
            return this.values = {};
        };
        Object.defineProperty(CIDMap.prototype, 'size', {
            get: function () {
                var size = 0;
                helpers.each(this.values, function () {
                    size++;
                });
                return size;
            }
        });
    }
    module.exports = CIDMap;
});
/*can-util@3.14.0#js/cid-map/cid-map*/
define('can-util@3.14.0#js/cid-map/cid-map', [
    'require',
    'exports',
    'module',
    'can-cid/map/map'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-cid/map/map');
});
/*can-util@3.14.0#js/cid-set/cid-set*/
define('can-util@3.14.0#js/cid-set/cid-set', [
    'require',
    'exports',
    'module',
    'can-cid/set/set'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-cid/set/set');
});
/*can-observation@3.3.6#can-observation*/
define('can-observation@3.3.6#can-observation', [
    'require',
    'exports',
    'module',
    'can-event',
    'can-event',
    'can-event/batch/batch',
    'can-util/js/assign/assign',
    'can-util/js/is-empty-object/is-empty-object',
    'can-namespace',
    'can-util/js/log/log',
    'can-reflect',
    'can-symbol',
    'can-cid',
    'can-util/js/cid-map/cid-map',
    'can-util/js/cid-set/cid-set'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        require('can-event');
        var canEvent = require('can-event');
        var canBatch = require('can-event/batch/batch');
        var assign = require('can-util/js/assign/assign');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var namespace = require('can-namespace');
        var canLog = require('can-util/js/log/log');
        var canReflect = require('can-reflect');
        var canSymbol = require('can-symbol');
        var CID = require('can-cid');
        var CIDMap = require('can-util/js/cid-map/cid-map');
        var CIDSet = require('can-util/js/cid-set/cid-set');
        function Observation(func, context, compute) {
            this.newObserved = {};
            this.oldObserved = null;
            this.func = func;
            this.context = context;
            this.compute = compute && (compute.updater || 'isObservable' in compute) ? compute : { updater: compute };
            this.isObservable = typeof compute === 'object' ? compute.isObservable : true;
            var observation = this;
            this.onDependencyChange = function (value, legacyValue) {
                observation.dependencyChange(this, value, legacyValue);
            };
            this.ignore = 0;
            this.needsUpdate = false;
            this.handlers = null;
            CID(this);
        }
        var observationStack = [];
        Observation.observationStack = observationStack;
        var remaining = {
            updates: 0,
            notifications: 0
        };
        Observation.remaining = remaining;
        assign(Observation.prototype, {
            get: function () {
                if (this.isObservable && Observation.isRecording()) {
                    Observation.add(this);
                    if (!this.bound) {
                        Observation.temporarilyBind(this);
                    }
                }
                if (this.bound === true) {
                    canEvent.flush();
                    if (remaining.updates > 0) {
                        Observation.updateChildrenAndSelf(this);
                    }
                    return this.value;
                } else {
                    return this.func.call(this.context);
                }
            },
            getPrimaryDepth: function () {
                return this.compute._primaryDepth || 0;
            },
            addEdge: function (objEv) {
                if (objEv.event === 'undefined') {
                    canReflect.onValue(objEv.obj, this.onDependencyChange);
                } else {
                    canReflect.onKeyValue(objEv.obj, objEv.event, this.onDependencyChange);
                }
            },
            removeEdge: function (objEv) {
                if (objEv.event === 'undefined') {
                    canReflect.offValue(objEv.obj, this.onDependencyChange);
                } else {
                    canReflect.offKeyValue(objEv.obj, objEv.event, this.onDependencyChange);
                }
            },
            dependencyChange: function () {
                if (this.bound === true) {
                    if (canBatch.batchNum === undefined || canBatch.batchNum !== this.batchNum) {
                        Observation.registerUpdate(this, canBatch.batchNum);
                        this.batchNum = canBatch.batchNum;
                    }
                }
            },
            onDependencyChange: function (value) {
                this.dependencyChange(value);
            },
            update: function (batchNum) {
                if (this.needsUpdate === true) {
                    remaining.updates--;
                }
                this.needsUpdate = false;
                if (this.bound === true) {
                    var oldValue = this.value;
                    this.oldValue = null;
                    this.start();
                    if (oldValue !== this.value) {
                        this.compute.updater(this.value, oldValue, batchNum);
                        return true;
                    }
                }
            },
            getValueAndBind: function () {
                canLog.warn('can-observation: call start instead of getValueAndBind');
                return this.start();
            },
            start: function () {
                this.bound = true;
                this.oldObserved = this.newObserved || {};
                this.ignore = 0;
                this.newObserved = {};
                observationStack.push(this);
                this.value = this.func.call(this.context);
                observationStack.pop();
                this.updateBindings();
            },
            updateBindings: function () {
                var newObserved = this.newObserved, oldObserved = this.oldObserved, name, obEv;
                for (name in newObserved) {
                    obEv = newObserved[name];
                    if (!oldObserved[name]) {
                        this.addEdge(obEv);
                    } else {
                        oldObserved[name] = undefined;
                    }
                }
                for (name in oldObserved) {
                    obEv = oldObserved[name];
                    if (obEv !== undefined) {
                        this.removeEdge(obEv);
                    }
                }
            },
            teardown: function () {
                canLog.warn('can-observation: call stop instead of teardown');
                return this.stop();
            },
            stop: function () {
                this.bound = false;
                for (var name in this.newObserved) {
                    var ob = this.newObserved[name];
                    this.removeEdge(ob);
                }
                this.newObserved = {};
            }
        });
        var updateOrder = [], curPrimaryDepth = Infinity, maxPrimaryDepth = 0, currentBatchNum, isUpdating = false;
        var updateUpdateOrder = function (observation) {
            var primaryDepth = observation.getPrimaryDepth();
            if (primaryDepth < curPrimaryDepth) {
                curPrimaryDepth = primaryDepth;
            }
            if (primaryDepth > maxPrimaryDepth) {
                maxPrimaryDepth = primaryDepth;
            }
            var primary = updateOrder[primaryDepth] || (updateOrder[primaryDepth] = []);
            return primary;
        };
        Observation.registerUpdate = function (observation, batchNum) {
            if (observation.needsUpdate === true) {
                return;
            }
            remaining.updates++;
            observation.needsUpdate = true;
            var objs = updateUpdateOrder(observation);
            objs.push(observation);
        };
        var afterCallbacks = [];
        Observation.updateAndNotify = function (ev, batchNum) {
            currentBatchNum = batchNum;
            if (isUpdating === true) {
                return;
            }
            isUpdating = true;
            while (true) {
                if (curPrimaryDepth <= maxPrimaryDepth) {
                    var primary = updateOrder[curPrimaryDepth];
                    var lastUpdate = primary && primary.pop();
                    if (lastUpdate !== undefined) {
                        lastUpdate.update(currentBatchNum);
                    } else {
                        curPrimaryDepth++;
                    }
                } else {
                    updateOrder = [];
                    curPrimaryDepth = Infinity;
                    maxPrimaryDepth = 0;
                    isUpdating = false;
                    var afterCB = afterCallbacks;
                    afterCallbacks = [];
                    afterCB.forEach(function (cb) {
                        cb();
                    });
                    return;
                }
            }
        };
        canEvent.addEventListener.call(canBatch, 'batchEnd', Observation.updateAndNotify);
        Observation.afterUpdateAndNotify = function (callback) {
            canBatch.after(function () {
                if (isUpdating === true) {
                    afterCallbacks.push(callback);
                } else {
                    callback();
                }
            });
        };
        Observation.updateChildrenAndSelf = function (observation) {
            if (observation.needsUpdate === true) {
                return Observation.unregisterAndUpdate(observation);
            }
            var childHasChanged = false;
            for (var prop in observation.newObserved) {
                if (observation.newObserved[prop].obj.observation) {
                    if (Observation.updateChildrenAndSelf(observation.newObserved[prop].obj.observation)) {
                        childHasChanged = true;
                    }
                }
            }
            if (childHasChanged === true) {
                return observation.update(currentBatchNum);
            }
        };
        Observation.unregisterAndUpdate = function (observation) {
            var primaryDepth = observation.getPrimaryDepth();
            var primary = updateOrder[primaryDepth];
            if (primary !== undefined) {
                var index = primary.indexOf(observation);
                if (index !== -1) {
                    primary.splice(index, 1);
                }
            }
            return observation.update(currentBatchNum);
        };
        Observation.add = function (obj, event) {
            var top = observationStack[observationStack.length - 1];
            if (top !== undefined && !top.ignore) {
                var evStr = event + '', name = obj._cid + '|' + evStr;
                if (top.traps !== undefined) {
                    top.traps.push({
                        obj: obj,
                        event: evStr,
                        name: name
                    });
                } else {
                    top.newObserved[name] = {
                        obj: obj,
                        event: evStr
                    };
                }
            }
        };
        Observation.addAll = function (observes) {
            var top = observationStack[observationStack.length - 1];
            if (top !== undefined) {
                if (top.traps !== undefined) {
                    top.traps.push.apply(top.traps, observes);
                } else {
                    for (var i = 0, len = observes.length; i < len; i++) {
                        var trap = observes[i], name = trap.name;
                        if (top.newObserved[name] === undefined) {
                            top.newObserved[name] = trap;
                        }
                    }
                }
            }
        };
        Observation.ignore = function (fn) {
            return function () {
                if (observationStack.length > 0) {
                    var top = observationStack[observationStack.length - 1];
                    top.ignore++;
                    var res = fn.apply(this, arguments);
                    top.ignore--;
                    return res;
                } else {
                    return fn.apply(this, arguments);
                }
            };
        };
        Observation.trap = function () {
            if (observationStack.length > 0) {
                var top = observationStack[observationStack.length - 1];
                var oldTraps = top.traps;
                var traps = top.traps = [];
                return function () {
                    top.traps = oldTraps;
                    return traps;
                };
            } else {
                return function () {
                    return [];
                };
            }
        };
        Observation.trapsCount = function () {
            if (observationStack.length > 0) {
                var top = observationStack[observationStack.length - 1];
                return top.traps.length;
            } else {
                return 0;
            }
        };
        Observation.isRecording = function () {
            var len = observationStack.length;
            var last = len > 0 && observationStack[len - 1];
            return last && last.ignore === 0;
        };
        var noop = function () {
        };
        var observables;
        var unbindComputes = function () {
            for (var i = 0, len = observables.length; i < len; i++) {
                canReflect.offValue(observables[i], noop);
            }
            observables = null;
        };
        Observation.temporarilyBind = function (compute) {
            var computeInstance = compute.computeInstance || compute;
            canReflect.onValue(computeInstance, noop);
            if (!observables) {
                observables = [];
                setTimeout(unbindComputes, 10);
            }
            observables.push(computeInstance);
        };
        var callHandlers = function (newValue) {
            this.handlers.forEach(function (handler) {
                handler.call(this.compute, newValue);
            }, this);
        };
        canReflect.set(Observation.prototype, canSymbol.for('can.onValue'), function (handler) {
            if (!this.handlers) {
                this.handlers = [];
                this.compute.updater = callHandlers.bind(this);
            }
            if (!this.handlers.length) {
                this.start();
            }
            this.handlers.push(handler);
        });
        canReflect.set(Observation.prototype, canSymbol.for('can.offValue'), function (handler) {
            if (this.handlers) {
                var index = this.handlers.indexOf(handler);
                this.handlers.splice(index, 1);
                if (this.handlers.length === 0) {
                    this.stop();
                }
            }
        });
        canReflect.set(Observation.prototype, canSymbol.for('can.getValue'), Observation.prototype.get);
        Observation.prototype.hasDependencies = function () {
            return this.bound ? !isEmptyObject(this.newObserved) : undefined;
        };
        canReflect.set(Observation.prototype, canSymbol.for('can.isValueLike'), true);
        canReflect.set(Observation.prototype, canSymbol.for('can.isMapLike'), false);
        canReflect.set(Observation.prototype, canSymbol.for('can.isListLike'), false);
        canReflect.set(Observation.prototype, canSymbol.for('can.valueHasDependencies'), Observation.prototype.hasDependencies);
        canReflect.set(Observation.prototype, canSymbol.for('can.getValueDependencies'), function () {
            var rets;
            if (this.bound === true) {
                rets = {};
                canReflect.eachKey(this.newObserved || {}, function (dep) {
                    if (canReflect.isValueLike(dep.obj)) {
                        rets.valueDependencies = rets.valueDependencies || new CIDSet();
                        rets.valueDependencies.add(dep.obj);
                    } else {
                        rets.keyDependencies = rets.keyDependencies || new CIDMap();
                        if (rets.keyDependencies.get(dep.obj)) {
                            rets.keyDependencies.get(dep.obj).push(dep.event);
                        } else {
                            rets.keyDependencies.set(dep.obj, [dep.event]);
                        }
                    }
                });
            }
            return rets;
        });
        if (namespace.Observation) {
            throw new Error('You can\'t have two versions of can-observation, check your dependencies');
        } else {
            module.exports = namespace.Observation = Observation;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event@3.7.7#lifecycle/lifecycle*/
define('can-event@3.7.7#lifecycle/lifecycle', [
    'require',
    'exports',
    'module',
    'can-event'
], function (require, exports, module) {
    var canEvent = require('can-event');
    var lifecycle = function (prototype) {
        var baseAddEventListener = prototype.addEventListener;
        var baseRemoveEventListener = prototype.removeEventListener;
        prototype.addEventListener = function () {
            var ret = baseAddEventListener.apply(this, arguments);
            if (!this.__inSetup) {
                this.__bindEvents = this.__bindEvents || {};
                if (!this.__bindEvents._lifecycleBindings) {
                    this.__bindEvents._lifecycleBindings = 1;
                    if (this._eventSetup) {
                        this._eventSetup();
                    }
                } else {
                    this.__bindEvents._lifecycleBindings++;
                }
            }
            return ret;
        };
        prototype.removeEventListener = function (event, handler) {
            if (!this.__bindEvents) {
                return this;
            }
            var handlers = this.__bindEvents[event] || [];
            var handlerCount = handlers.length;
            var ret = baseRemoveEventListener.apply(this, arguments);
            if (this.__bindEvents._lifecycleBindings === null) {
                this.__bindEvents._lifecycleBindings = 0;
            } else {
                this.__bindEvents._lifecycleBindings -= handlerCount - handlers.length;
            }
            if (!this.__bindEvents._lifecycleBindings && this._eventTeardown) {
                this._eventTeardown();
            }
            return ret;
        };
        return prototype;
    };
    var baseEvents = lifecycle({
        addEventListener: canEvent.addEventListener,
        removeEventListener: canEvent.removeEventListener
    });
    lifecycle.addAndSetup = baseEvents.addEventListener;
    lifecycle.removeAndTeardown = baseEvents.removeEventListener;
    module.exports = lifecycle;
});
/*can-util@3.14.0#js/is-promise-like/is-promise-like*/
define('can-util@3.14.0#js/is-promise-like/is-promise-like', function (require, exports, module) {
    'use strict';
    module.exports = function (obj) {
        return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
    };
});
/*can-reflect-promise@1.1.5#can-reflect-promise*/
define('can-reflect-promise@1.1.5#can-reflect-promise', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-util/js/dev/dev',
    'can-observation',
    'can-cid',
    'can-util/js/assign/assign',
    'can-event',
    'can-util/js/single-reference/single-reference'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-util/js/dev/dev');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canEvent = require('can-event');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var getValueSymbol = canSymbol.for('can.getValue'), getKeyValueSymbol = canSymbol.for('can.getKeyValue'), onValueSymbol = canSymbol.for('can.onValue'), onKeyValueSymbol = canSymbol.for('can.onKeyValue'), offKeyValueSymbol = canSymbol.for('can.offKeyValue'), observeDataSymbol = canSymbol.for('can.observeData');
    var promiseDataPrototype = {
        isPending: true,
        state: 'pending',
        isResolved: false,
        isRejected: false,
        value: undefined,
        reason: undefined
    };
    assign(promiseDataPrototype, canEvent);
    canReflect.set(promiseDataPrototype, onKeyValueSymbol, function (key, handler) {
        var observeData = this;
        var translated = function () {
            handler(observeData[key]);
        };
        singleReference.set(handler, this, translated, key);
        canEvent.on.call(this, 'state', translated);
    });
    canReflect.set(promiseDataPrototype, offKeyValueSymbol, function (key, handler) {
        var translated = singleReference.getAndDelete(handler, this, key);
        canEvent.off.call(this, 'state', translated);
    });
    function initPromise(promise) {
        var observeData = promise[observeDataSymbol];
        if (!observeData) {
            Object.defineProperty(promise, observeDataSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: Object.create(promiseDataPrototype)
            });
            observeData = promise[observeDataSymbol];
            CID(observeData);
        }
        promise.then(function (value) {
            observeData.isPending = false;
            observeData.isResolved = true;
            observeData.value = value;
            observeData.state = 'resolved';
            observeData.dispatch('state', [
                'resolved',
                'pending'
            ]);
        }, function (reason) {
            observeData.isPending = false;
            observeData.isRejected = true;
            observeData.reason = reason;
            observeData.state = 'rejected';
            observeData.dispatch('state', [
                'rejected',
                'pending'
            ]);
        });
    }
    function setupPromise(value) {
        var oldPromiseFn;
        var proto = 'getPrototypeOf' in Object ? Object.getPrototypeOf(value) : value.__proto__;
        if (value[getKeyValueSymbol] && value[observeDataSymbol]) {
            return;
        }
        if (proto === null || proto === Object.prototype) {
            proto = value;
            if (typeof proto.promise === 'function') {
                oldPromiseFn = proto.promise;
                proto.promise = function () {
                    var result = oldPromiseFn.call(proto);
                    setupPromise(result);
                    return result;
                };
            }
        }
        [
            getKeyValueSymbol,
            function (key) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                Observation.add(this[observeDataSymbol], 'state');
                switch (key) {
                case 'state':
                case 'isPending':
                case 'isResolved':
                case 'isRejected':
                case 'value':
                case 'reason':
                    return this[observeDataSymbol][key];
                default:
                    return this[key];
                }
            },
            getValueSymbol,
            function () {
                return this[getKeyValueSymbol]('value');
            },
            canSymbol.for('can.isValueLike'),
            false,
            onValueSymbol,
            function (handler) {
                return this[onKeyValueSymbol]('value', handler);
            },
            onKeyValueSymbol,
            function (key, handler) {
                if (!this[observeDataSymbol]) {
                    initPromise(this);
                }
                var promise = this;
                var translated = function () {
                    handler(promise[getKeyValueSymbol](key));
                };
                singleReference.set(handler, this, translated, key);
                canEvent.on.call(this[observeDataSymbol], 'state', translated);
            },
            canSymbol.for('can.offValue'),
            function (handler) {
                return this[offKeyValueSymbol]('value', handler);
            },
            offKeyValueSymbol,
            function (key, handler) {
                var translated = singleReference.getAndDelete(handler, this, key);
                if (translated) {
                    canEvent.off.call(this[observeDataSymbol], 'state', translated);
                }
            }
        ].forEach(function (symbol, index, list) {
            if (index % 2 === 0) {
                canReflect.set(proto, symbol, list[index + 1]);
            }
        });
    }
    module.exports = setupPromise;
});
/*can-stache-key@0.1.4#can-stache-key*/
define('can-stache-key@0.1.4#can-stache-key', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-log/dev/dev',
    'can-util/js/each/each',
    'can-symbol',
    'can-reflect',
    'can-util/js/is-promise-like/is-promise-like',
    'can-reflect-promise'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var dev = require('can-log/dev/dev');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isPromiseLike = require('can-util/js/is-promise-like/is-promise-like');
    var canReflectPromise = require('can-reflect-promise');
    var getValueSymbol = canSymbol.for('can.getValue');
    var setValueSymbol = canSymbol.for('can.setValue');
    var isValueLikeSymbol = canSymbol.for('can.isValueLike');
    var observeReader;
    var isAt = function (index, reads) {
        var prevRead = reads[index - 1];
        return prevRead && prevRead.at;
    };
    var readValue = function (value, index, reads, options, state, prev) {
        var usedValueReader;
        do {
            usedValueReader = false;
            for (var i = 0, len = observeReader.valueReaders.length; i < len; i++) {
                if (observeReader.valueReaders[i].test(value, index, reads, options)) {
                    value = observeReader.valueReaders[i].read(value, index, reads, options, state, prev);
                }
            }
        } while (usedValueReader);
        return value;
    };
    var specialRead = {
        index: true,
        key: true,
        event: true,
        element: true,
        viewModel: true
    };
    var checkForObservableAndNotify = function (options, state, getObserves, value, index) {
        if (options.foundObservable && !state.foundObservable) {
            if (Observation.trapsCount()) {
                Observation.addAll(getObserves());
                options.foundObservable(value, index);
                state.foundObservable = true;
            }
        }
    };
    observeReader = {
        read: function (parent, reads, options) {
            options = options || {};
            var state = { foundObservable: false };
            var getObserves;
            if (options.foundObservable) {
                getObserves = Observation.trap();
            }
            var cur = readValue(parent, 0, reads, options, state), type, prev, readLength = reads.length, i = 0, last;
            checkForObservableAndNotify(options, state, getObserves, parent, 0);
            while (i < readLength) {
                prev = cur;
                for (var r = 0, readersLength = observeReader.propertyReaders.length; r < readersLength; r++) {
                    var reader = observeReader.propertyReaders[r];
                    if (reader.test(cur)) {
                        cur = reader.read(cur, reads[i], i, options, state);
                        break;
                    }
                }
                checkForObservableAndNotify(options, state, getObserves, prev, i);
                last = cur;
                i = i + 1;
                cur = readValue(cur, i, reads, options, state, prev);
                checkForObservableAndNotify(options, state, getObserves, prev, i - 1);
                type = typeof cur;
                if (i < reads.length && (cur === null || cur === undefined)) {
                    if (options.earlyExit) {
                        options.earlyExit(prev, i - 1, cur);
                    }
                    return {
                        value: undefined,
                        parent: prev
                    };
                }
            }
            if (cur === undefined) {
                if (options.earlyExit) {
                    options.earlyExit(prev, i - 1);
                }
            }
            return {
                value: cur,
                parent: prev
            };
        },
        get: function (parent, reads, options) {
            return observeReader.read(parent, observeReader.reads(reads), options || {}).value;
        },
        valueReadersMap: {},
        valueReaders: [
            {
                name: 'function',
                test: function (value) {
                    return value && canReflect.isFunctionLike(value) && !canReflect.isConstructorLike(value);
                },
                read: function (value, i, reads, options, state, prev) {
                    if (isAt(i, reads)) {
                        return i === reads.length ? value.bind(prev) : value;
                    }
                    if (options.callMethodsOnObservables && canReflect.isObservableLike(prev) && canReflect.isMapLike(prev)) {
                        return value.apply(prev, options.args || []);
                    } else if (options.isArgument && i === reads.length) {
                        if (options.proxyMethods === false) {
                            return value;
                        }
                        return value.bind(prev);
                    }
                    return value.apply(prev, options.args || []);
                }
            },
            {
                name: 'isValueLike',
                test: function (value, i, reads, options) {
                    return value && value[getValueSymbol] && value[isValueLikeSymbol] !== false && (options.foundAt || !isAt(i, reads));
                },
                read: function (value, i, reads, options) {
                    if (options.readCompute === false && i === reads.length) {
                        return value;
                    }
                    return canReflect.getValue(value);
                },
                write: function (base, newVal) {
                    if (base[setValueSymbol]) {
                        base[setValueSymbol](newVal);
                    } else if (base.set) {
                        base.set(newVal);
                    } else {
                        base(newVal);
                    }
                }
            }
        ],
        propertyReadersMap: {},
        propertyReaders: [
            {
                name: 'map',
                test: function (value) {
                    if (isPromiseLike(value) || typeof value === 'object' && value && typeof value.then === 'function') {
                        canReflectPromise(value);
                    }
                    return canReflect.isObservableLike(value) && canReflect.isMapLike(value);
                },
                read: function (value, prop) {
                    var res = canReflect.getKeyValue(value, prop.key);
                    if (res !== undefined) {
                        return res;
                    } else {
                        return value[prop.key];
                    }
                },
                write: canReflect.setKeyValue
            },
            {
                name: 'object',
                test: function () {
                    return true;
                },
                read: function (value, prop, i, options) {
                    if (value == null) {
                        return undefined;
                    } else {
                        if (typeof value === 'object') {
                            if (prop.key in value) {
                                return value[prop.key];
                            } else if (prop.at && specialRead[prop.key] && '@' + prop.key in value) {
                                options.foundAt = true;
                                return value['@' + prop.key];
                            }
                        } else {
                            return value[prop.key];
                        }
                    }
                },
                write: function (base, prop, newVal) {
                    base[prop] = newVal;
                }
            }
        ],
        reads: function (keyArg) {
            var key = '' + keyArg;
            var keys = [];
            var last = 0;
            var at = false;
            if (key.charAt(0) === '@') {
                last = 1;
                at = true;
            }
            var keyToAdd = '';
            for (var i = last; i < key.length; i++) {
                var character = key.charAt(i);
                if (character === '.' || character === '@') {
                    if (key.charAt(i - 1) !== '\\') {
                        keys.push({
                            key: keyToAdd,
                            at: at
                        });
                        at = character === '@';
                        keyToAdd = '';
                    } else {
                        keyToAdd = keyToAdd.substr(0, keyToAdd.length - 1) + '.';
                    }
                } else {
                    keyToAdd += character;
                }
            }
            keys.push({
                key: keyToAdd,
                at: at
            });
            return keys;
        },
        write: function (parent, key, value, options) {
            var keys = typeof key === 'string' ? observeReader.reads(key) : key;
            var last;
            options = options || {};
            if (keys.length > 1) {
                last = keys.pop();
                parent = observeReader.read(parent, keys, options).value;
                keys.push(last);
            } else {
                last = keys[0];
            }
            if (observeReader.valueReadersMap.isValueLike.test(parent[last.key], keys.length - 1, keys, options)) {
                observeReader.valueReadersMap.isValueLike.write(parent[last.key], value, options);
            } else {
                if (observeReader.valueReadersMap.isValueLike.test(parent, keys.length - 1, keys, options)) {
                    parent = parent[getValueSymbol]();
                }
                if (observeReader.propertyReadersMap.map.test(parent)) {
                    observeReader.propertyReadersMap.map.write(parent, last.key, value, options);
                } else if (observeReader.propertyReadersMap.object.test(parent)) {
                    observeReader.propertyReadersMap.object.write(parent, last.key, value, options);
                    if (options.observation) {
                        options.observation.update();
                    }
                }
            }
        }
    };
    each(observeReader.propertyReaders, function (reader) {
        observeReader.propertyReadersMap[reader.name] = reader;
    });
    each(observeReader.valueReaders, function (reader) {
        observeReader.valueReadersMap[reader.name] = reader;
    });
    observeReader.set = observeReader.write;
    module.exports = observeReader;
});
/*can-compute@3.3.10#proto-compute*/
define('can-compute@3.3.10#proto-compute', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-event',
    'can-event/lifecycle/lifecycle',
    'can-event/batch/batch',
    'can-stache-key',
    'can-util/js/get/get',
    'can-cid',
    'can-util/js/assign/assign',
    'can-util/js/log/log',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/single-reference/single-reference'
], function (require, exports, module) {
    var Observation = require('can-observation');
    var canEvent = require('can-event');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    require('can-event/batch/batch');
    var observeReader = require('can-stache-key');
    var getObject = require('can-util/js/get/get');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canLog = require('can-util/js/log/log');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var Compute = function (getterSetter, context, eventName, bindOnce) {
        CID(this, 'compute');
        var args = [];
        for (var i = 0, arglen = arguments.length; i < arglen; i++) {
            args[i] = arguments[i];
        }
        var contextType = typeof args[1];
        if (typeof args[0] === 'function') {
            this._setupGetterSetterFn(args[0], args[1], args[2], args[3]);
        } else if (args[1] !== undefined) {
            if (contextType === 'string' || contextType === 'number') {
                var isListLike = canReflect.isObservableLike(args[0]) && canReflect.isListLike(args[0]);
                var isMapLike = canReflect.isObservableLike(args[0]) && canReflect.isMapLike(args[0]);
                if (isMapLike || isListLike) {
                    var map = args[0];
                    var propertyName = args[1];
                    var mapGetterSetter = function (newValue) {
                        if (arguments.length) {
                            observeReader.set(map, propertyName, newValue);
                        } else {
                            if (isListLike) {
                                observeReader.get(map, 'length');
                            }
                            return observeReader.get(map, '' + propertyName);
                        }
                    };
                    this._setupGetterSetterFn(mapGetterSetter, args[1], args[2], args[3]);
                } else {
                    this._setupProperty(args[0], args[1], args[2]);
                }
            } else if (contextType === 'function') {
                this._setupSetter(args[0], args[1], args[2]);
            } else {
                if (args[1] && args[1].fn) {
                    this._setupAsyncCompute(args[0], args[1]);
                } else {
                    this._setupSettings(args[0], args[1]);
                }
            }
        } else {
            this._setupSimpleValue(args[0]);
        }
        this._args = args;
        this._primaryDepth = 0;
        this.isComputed = true;
    };
    var updateOnChange = function (compute, newValue, oldValue, batchNum) {
        var valueChanged = newValue !== oldValue && !(newValue !== newValue && oldValue !== oldValue);
        if (valueChanged) {
            canEvent.dispatch.call(compute, {
                type: 'change',
                batchNum: batchNum
            }, [
                newValue,
                oldValue
            ]);
        }
    };
    var setupComputeHandlers = function (compute, func, context) {
        var observation = new Observation(func, context, compute);
        compute.observation = observation;
        return {
            _on: function () {
                observation.start();
                compute.value = observation.value;
            },
            _off: function () {
                observation.stop();
            },
            getDepth: function () {
                return observation.getDepth();
            }
        };
    };
    assign(Compute.prototype, {
        setPrimaryDepth: function (depth) {
            this._primaryDepth = depth;
        },
        _setupGetterSetterFn: function (getterSetter, context, eventName) {
            this._set = context ? getterSetter.bind(context) : getterSetter;
            this._get = context ? getterSetter.bind(context) : getterSetter;
            this._canObserve = eventName === false ? false : true;
            var handlers = setupComputeHandlers(this, getterSetter, context || this);
            assign(this, handlers);
        },
        _setupProperty: function (target, propertyName, eventName) {
            var self = this, handler;
            handler = function () {
                self.updater(self._get(), self.value);
            };
            this._get = function () {
                return getObject(target, propertyName);
            };
            this._set = function (value) {
                var properties = propertyName.split('.'), leafPropertyName = properties.pop();
                if (properties.length) {
                    var targetProperty = getObject(target, properties.join('.'));
                    targetProperty[leafPropertyName] = value;
                } else {
                    target[propertyName] = value;
                }
            };
            this._on = function (update) {
                canEvent.on.call(target, eventName || propertyName, handler);
                this.value = this._get();
            };
            this._off = function () {
                return canEvent.off.call(target, eventName || propertyName, handler);
            };
        },
        _setupSetter: function (initialValue, setter, eventName) {
            this.value = initialValue;
            this._set = setter;
            assign(this, eventName);
        },
        _setupSettings: function (initialValue, settings) {
            this.value = initialValue;
            this._set = settings.set || this._set;
            this._get = settings.get || this._get;
            if (!settings.__selfUpdater) {
                var self = this, oldUpdater = this.updater;
                this.updater = function () {
                    oldUpdater.call(self, self._get(), self.value);
                };
            }
            this._on = settings.on ? settings.on : this._on;
            this._off = settings.off ? settings.off : this._off;
        },
        _setupAsyncCompute: function (initialValue, settings) {
            var self = this;
            var getter = settings.fn;
            var bindings;
            this.value = initialValue;
            this._setUpdates = true;
            this.lastSetValue = new Compute(initialValue);
            this._set = function (newVal) {
                if (newVal === self.lastSetValue.get()) {
                    return this.value;
                }
                return self.lastSetValue.set(newVal);
            };
            this._get = function () {
                return getter.call(settings.context, self.lastSetValue.get());
            };
            if (getter.length === 0) {
                bindings = setupComputeHandlers(this, getter, settings.context);
            } else if (getter.length === 1) {
                bindings = setupComputeHandlers(this, function () {
                    return getter.call(settings.context, self.lastSetValue.get());
                }, settings);
            } else {
                var oldUpdater = this.updater, resolve = Observation.ignore(function (newVal) {
                        oldUpdater.call(self, newVal, self.value);
                    });
                this.updater = function (newVal) {
                    oldUpdater.call(self, newVal, self.value);
                };
                bindings = setupComputeHandlers(this, function () {
                    var res = getter.call(settings.context, self.lastSetValue.get(), resolve);
                    return res !== undefined ? res : this.value;
                }, this);
            }
            assign(this, bindings);
        },
        _setupSimpleValue: function (initialValue) {
            this.value = initialValue;
        },
        _eventSetup: Observation.ignore(function () {
            this.bound = true;
            this._on(this.updater);
        }),
        _eventTeardown: function () {
            this._off(this.updater);
            this.bound = false;
        },
        addEventListener: eventLifecycle.addAndSetup,
        removeEventListener: eventLifecycle.removeAndTeardown,
        clone: function (context) {
            if (context && typeof this._args[0] === 'function') {
                this._args[1] = context;
            } else if (context) {
                this._args[2] = context;
            }
            return new Compute(this._args[0], this._args[1], this._args[2], this._args[3]);
        },
        _on: function () {
        },
        _off: function () {
        },
        get: function () {
            var recordingObservation = Observation.isRecording();
            if (recordingObservation && this._canObserve !== false) {
                Observation.add(this, 'change');
                if (!this.bound) {
                    Compute.temporarilyBind(this);
                }
            }
            if (this.bound) {
                if (this.observation) {
                    return this.observation.get();
                } else {
                    return this.value;
                }
            } else {
                return this._get();
            }
        },
        _get: function () {
            return this.value;
        },
        set: function (newVal) {
            var old = this.value;
            var setVal = this._set(newVal, old);
            if (this._setUpdates) {
                return this.value;
            }
            if (this.hasDependencies) {
                return this._get();
            }
            this.updater(setVal === undefined ? this._get() : setVal, old);
            return this.value;
        },
        _set: function (newVal) {
            return this.value = newVal;
        },
        updater: function (newVal, oldVal, batchNum) {
            this.value = newVal;
            if (this.observation) {
                this.observation.value = newVal;
            }
            updateOnChange(this, newVal, oldVal, batchNum);
        },
        toFunction: function () {
            return this._computeFn.bind(this);
        },
        _computeFn: function (newVal) {
            if (arguments.length) {
                return this.set(newVal);
            }
            return this.get();
        }
    });
    var hasDependencies = function () {
        return this.observation && this.observation.hasDependencies();
    };
    Object.defineProperty(Compute.prototype, 'hasDependencies', { get: hasDependencies });
    canReflect.set(Compute.prototype, canSymbol.for('can.valueHasDependencies'), hasDependencies);
    Compute.prototype.on = Compute.prototype.bind = Compute.prototype.addEventListener;
    Compute.prototype.off = Compute.prototype.unbind = Compute.prototype.removeEventListener;
    canReflect.set(Compute.prototype, canSymbol.for('can.onValue'), function (handler) {
        var translationHandler = function (ev, newValue) {
            handler(newValue);
        };
        singleReference.set(handler, this, translationHandler);
        this.addEventListener('change', translationHandler);
    });
    canReflect.set(Compute.prototype, canSymbol.for('can.offValue'), function (handler) {
        this.removeEventListener('change', singleReference.getAndDelete(handler, this));
    });
    canReflect.set(Compute.prototype, canSymbol.for('can.getValue'), Compute.prototype.get);
    canReflect.set(Compute.prototype, canSymbol.for('can.setValue'), Compute.prototype.set);
    Compute.temporarilyBind = Observation.temporarilyBind;
    Compute.async = function (initialValue, asyncComputer, context) {
        return new Compute(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    Compute.truthy = function (compute) {
        return new Compute(function () {
            var res = compute.get();
            if (typeof res === 'function') {
                res = res.get();
            }
            return !!res;
        });
    };
    canReflect.set(Compute.prototype, canSymbol.for('can.setValue'), Compute.prototype.set);
    canReflect.set(Compute.prototype, canSymbol.for('can.isValueLike'), true);
    canReflect.set(Compute.prototype, canSymbol.for('can.isMapLike'), false);
    canReflect.set(Compute.prototype, canSymbol.for('can.isListLike'), false);
    canReflect.set(Compute.prototype, canSymbol.for('can.valueHasDependencies'), function () {
        return !!this.observation;
    });
    canReflect.set(Compute.prototype, canSymbol.for('can.getValueDependencies'), function () {
        var ret;
        if (this.observation) {
            ret = { valueDependencies: new CIDSet() };
            ret.valueDependencies.add(this.observation);
        }
        return ret;
    });
    module.exports = exports = Compute;
});
/*can-compute@3.3.10#can-compute*/
define('can-compute@3.3.10#can-compute', [
    'require',
    'exports',
    'module',
    'can-event',
    'can-event/batch/batch',
    './proto-compute',
    'can-cid',
    'can-namespace',
    'can-util/js/single-reference/single-reference',
    'can-reflect/reflections/get-set/get-set',
    'can-symbol'
], function (require, exports, module) {
    require('can-event');
    require('can-event/batch/batch');
    var Compute = require('./proto-compute');
    var CID = require('can-cid');
    var namespace = require('can-namespace');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var canReflect = require('can-reflect/reflections/get-set/get-set');
    var canSymbol = require('can-symbol');
    var canOnValueSymbol = canSymbol.for('can.onValue'), canOffValueSymbol = canSymbol.for('can.offValue'), canGetValue = canSymbol.for('can.getValue'), canSetValue = canSymbol.for('can.setValue'), isValueLike = canSymbol.for('can.isValueLike'), isMapLike = canSymbol.for('can.isMapLike'), isListLike = canSymbol.for('can.isListLike'), isFunctionLike = canSymbol.for('can.isFunctionLike'), canValueHasDependencies = canSymbol.for('can.valueHasDependencies'), canGetValueDependencies = canSymbol.for('can.getValueDependencies');
    var addEventListener = function (ev, handler) {
        var compute = this;
        var translationHandler;
        if (handler) {
            translationHandler = function () {
                handler.apply(compute, arguments);
            };
            singleReference.set(handler, this, translationHandler);
        }
        return compute.computeInstance.addEventListener(ev, translationHandler);
    };
    var removeEventListener = function (ev, handler) {
        var args = [];
        if (typeof ev !== 'undefined') {
            args.push(ev);
            if (typeof handler !== 'undefined') {
                args.push(singleReference.getAndDelete(handler, this));
            }
        }
        return this.computeInstance.removeEventListener.apply(this.computeInstance, args);
    };
    var onValue = function (handler) {
            return this.computeInstance[canOnValueSymbol](handler);
        }, offValue = function (handler) {
            return this.computeInstance[canOffValueSymbol](handler);
        }, getValue = function () {
            return this.computeInstance.get();
        }, setValue = function (value) {
            return this.computeInstance.set(value);
        }, hasDependencies = function () {
            return this.computeInstance.hasDependencies;
        }, getDependencies = function () {
            return this.computeInstance[canGetValueDependencies]();
        };
    var COMPUTE = function (getterSetter, context, eventName, bindOnce) {
        function compute(val) {
            if (arguments.length) {
                return compute.computeInstance.set(val);
            }
            return compute.computeInstance.get();
        }
        var cid = CID(compute, 'compute');
        compute.computeInstance = new Compute(getterSetter, context, eventName, bindOnce);
        compute.handlerKey = '__handler' + cid;
        compute.on = compute.bind = compute.addEventListener = addEventListener;
        compute.off = compute.unbind = compute.removeEventListener = removeEventListener;
        compute.isComputed = compute.computeInstance.isComputed;
        compute.clone = function (ctx) {
            if (typeof getterSetter === 'function') {
                context = ctx;
            }
            return COMPUTE(getterSetter, context, ctx, bindOnce);
        };
        canReflect.set(compute, canOnValueSymbol, onValue);
        canReflect.set(compute, canOffValueSymbol, offValue);
        canReflect.set(compute, canGetValue, getValue);
        canReflect.set(compute, canSetValue, setValue);
        canReflect.set(compute, isValueLike, true);
        canReflect.set(compute, isMapLike, false);
        canReflect.set(compute, isListLike, false);
        canReflect.set(compute, isFunctionLike, false);
        canReflect.set(compute, canValueHasDependencies, hasDependencies);
        canReflect.set(compute, canGetValueDependencies, getDependencies);
        return compute;
    };
    COMPUTE.truthy = function (compute) {
        return COMPUTE(function () {
            var res = compute();
            return !!res;
        });
    };
    COMPUTE.async = function (initialValue, asyncComputer, context) {
        return COMPUTE(initialValue, {
            fn: asyncComputer,
            context: context
        });
    };
    COMPUTE.temporarilyBind = Compute.temporarilyBind;
    module.exports = namespace.compute = COMPUTE;
});
/*can-control@3.2.4#can-control*/
define('can-control@3.2.4#can-control', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-namespace',
    'can-util/js/string/string',
    'can-util/js/assign/assign',
    'can-util/js/is-function/is-function',
    'can-util/js/each/each',
    'can-util/js/dev/dev',
    'can-types',
    'can-util/js/get/get',
    'can-util/dom/data/data',
    'can-util/dom/class-name/class-name',
    'can-util/dom/events/events',
    'can-event',
    'can-compute',
    'can-stache-key',
    'can-reflect',
    'can-util/dom/dispatch/dispatch',
    'can-util/dom/events/delegate/delegate'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var namespace = require('can-namespace');
    var string = require('can-util/js/string/string');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var each = require('can-util/js/each/each');
    var dev = require('can-util/js/dev/dev');
    var types = require('can-types');
    var get = require('can-util/js/get/get');
    var domData = require('can-util/dom/data/data');
    var className = require('can-util/dom/class-name/class-name');
    var domEvents = require('can-util/dom/events/events');
    var canEvent = require('can-event');
    var canCompute = require('can-compute');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var processors;
    require('can-util/dom/dispatch/dispatch');
    require('can-util/dom/events/delegate/delegate');
    var bind = function (el, ev, callback) {
            canEvent.on.call(el, ev, callback);
            return function () {
                canEvent.off.call(el, ev, callback);
            };
        }, slice = [].slice, paramReplacer = /\{([^\}]+)\}/g, delegate = function (el, selector, ev, callback) {
            canEvent.on.call(el, ev, selector, callback);
            return function () {
                canEvent.off.call(el, ev, selector, callback);
            };
        }, binder = function (el, ev, callback, selector) {
            return selector ? delegate(el, selector.trim(), ev, callback) : bind(el, ev, callback);
        }, basicProcessor;
    var Control = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Control) {
                var control = this, funcName;
                control.actions = {};
                for (funcName in control.prototype) {
                    if (control._isAction(funcName)) {
                        control.actions[funcName] = control._action(funcName);
                    }
                }
            }
        },
        _shifter: function (context, name) {
            var method = typeof name === 'string' ? context[name] : name;
            if (!isFunction(method)) {
                method = context[method];
            }
            return function () {
                var wrapped = types.wrapElement(this);
                context.called = name;
                return method.apply(context, [wrapped].concat(slice.call(arguments, 0)));
            };
        },
        _isAction: function (methodName) {
            var val = this.prototype[methodName], type = typeof val;
            return methodName !== 'constructor' && (type === 'function' || type === 'string' && isFunction(this.prototype[val])) && !!(Control.isSpecial(methodName) || processors[methodName] || /[^\w]/.test(methodName));
        },
        _action: function (methodName, options, controlInstance) {
            var readyCompute;
            paramReplacer.lastIndex = 0;
            if (options || !paramReplacer.test(methodName)) {
                readyCompute = canCompute(function () {
                    var delegate;
                    var name = methodName.replace(paramReplacer, function (matched, key) {
                        var value, parent;
                        if (this._isDelegate(options, key)) {
                            delegate = this._getDelegate(options, key);
                            return '';
                        }
                        key = this._removeDelegateFromKey(key);
                        parent = this._lookup(options)[0];
                        value = observeReader.read(parent, observeReader.reads(key), { readCompute: false }).value;
                        if (value === undefined && typeof window !== 'undefined') {
                            value = get(window, key);
                        }
                        if (!parent || !(canReflect.isObservableLike(parent) && canReflect.isMapLike(parent)) && !value) {
                            return null;
                        }
                        if (typeof value === 'string') {
                            return value;
                        } else {
                            delegate = value;
                            return '';
                        }
                    }.bind(this));
                    name = name.trim();
                    var parts = name.split(/\s+/g), event = parts.pop();
                    return {
                        processor: this.processors[event] || basicProcessor,
                        parts: [
                            name,
                            parts.join(' '),
                            event
                        ],
                        delegate: delegate || undefined
                    };
                }, this);
                if (controlInstance) {
                    var handler = function (ev, ready) {
                        controlInstance._bindings.control[methodName](controlInstance.element);
                        controlInstance._bindings.control[methodName] = ready.processor(ready.delegate || controlInstance.element, ready.parts[2], ready.parts[1], methodName, controlInstance);
                    };
                    readyCompute.bind('change', handler);
                    controlInstance._bindings.readyComputes[methodName] = {
                        compute: readyCompute,
                        handler: handler
                    };
                }
                return readyCompute();
            }
        },
        _lookup: function (options) {
            return [
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key;
        },
        _isDelegate: function (options, key) {
            return key === 'element';
        },
        _getDelegate: function (options, key) {
            return undefined;
        },
        processors: {},
        defaults: {},
        convertElement: function (element) {
            element = typeof element === 'string' ? document.querySelector(element) : element;
            return types.wrapElement(element);
        },
        isSpecial: function (eventName) {
            return eventName === 'inserted' || eventName === 'removed';
        }
    }, {
        setup: function (element, options) {
            var cls = this.constructor, pluginname = cls.pluginName || cls.shortName, arr;
            if (!element) {
                throw new Error('Creating an instance of a named control without passing an element');
            }
            this.element = cls.convertElement(element);
            if (pluginname && pluginname !== 'can_control') {
                className.add.call(this.element, pluginname);
            }
            arr = domData.get.call(this.element, 'controls');
            if (!arr) {
                arr = [];
                domData.set.call(this.element, 'controls', arr);
            }
            arr.push(this);
            if (canReflect.isObservableLike(options) && canReflect.isMapLike(options)) {
                for (var prop in cls.defaults) {
                    if (!options.hasOwnProperty(prop)) {
                        observeReader.set(options, prop, cls.defaults[prop]);
                    }
                }
                this.options = options;
            } else {
                this.options = assign(assign({}, cls.defaults), options);
            }
            this.on();
            return [
                this.element,
                this.options
            ];
        },
        on: function (el, selector, eventName, func) {
            if (!el) {
                this.off();
                var cls = this.constructor, bindings = this._bindings, actions = cls.actions, element = types.unwrapElement(this.element), destroyCB = Control._shifter(this, 'destroy'), funcName, ready;
                for (funcName in actions) {
                    if (actions.hasOwnProperty(funcName)) {
                        ready = actions[funcName] || cls._action(funcName, this.options, this);
                        if (ready) {
                            bindings.control[funcName] = ready.processor(ready.delegate || element, ready.parts[2], ready.parts[1], funcName, this);
                        }
                    }
                }
                domEvents.addEventListener.call(element, 'removed', destroyCB);
                bindings.user.push(function (el) {
                    domEvents.removeEventListener.call(el, 'removed', destroyCB);
                });
                return bindings.user.length;
            }
            if (typeof el === 'string') {
                func = eventName;
                eventName = selector;
                selector = el;
                el = this.element;
            }
            if (func === undefined) {
                func = eventName;
                eventName = selector;
                selector = null;
            }
            if (typeof func === 'string') {
                func = Control._shifter(this, func);
            }
            this._bindings.user.push(binder(el, eventName, func, selector));
            return this._bindings.user.length;
        },
        off: function () {
            var el = types.unwrapElement(this.element), bindings = this._bindings;
            if (bindings) {
                each(bindings.user || [], function (value) {
                    value(el);
                });
                each(bindings.control || {}, function (value) {
                    value(el);
                });
                each(bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            this._bindings = {
                user: [],
                control: {},
                readyComputes: {}
            };
        },
        destroy: function () {
            if (this.element === null) {
                return;
            }
            var Class = this.constructor, pluginName = Class.pluginName || Class.shortName && string.underscore(Class.shortName), controls;
            this.off();
            if (pluginName && pluginName !== 'can_control') {
                className.remove.call(this.element, pluginName);
            }
            controls = domData.get.call(this.element, 'controls');
            if (controls) {
                controls.splice(controls.indexOf(this), 1);
            }
            canEvent.dispatch.call(this, 'destroyed');
            this.element = null;
        }
    });
    processors = Control.processors;
    basicProcessor = function (el, event, selector, methodName, control) {
        return binder(el, event, Control._shifter(control, methodName), selector);
    };
    each([
        'beforeremove',
        'change',
        'click',
        'contextmenu',
        'dblclick',
        'keydown',
        'keyup',
        'keypress',
        'mousedown',
        'mousemove',
        'mouseout',
        'mouseover',
        'mouseup',
        'reset',
        'resize',
        'scroll',
        'select',
        'submit',
        'focusin',
        'focusout',
        'mouseenter',
        'mouseleave',
        'touchstart',
        'touchmove',
        'touchcancel',
        'touchend',
        'touchleave',
        'inserted',
        'removed',
        'dragstart',
        'dragenter',
        'dragover',
        'dragleave',
        'drag',
        'drop',
        'dragend'
    ], function (v) {
        processors[v] = basicProcessor;
    });
    module.exports = namespace.Control = Control;
});
/*can-component@3.3.10#control/control*/
define('can-component@3.3.10#control/control', [
    'require',
    'exports',
    'module',
    'can-control',
    'can-util/js/each/each',
    'can-util/js/string/string',
    'can-compute',
    'can-stache-key'
], function (require, exports, module) {
    var Control = require('can-control');
    var canEach = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var canCompute = require('can-compute');
    var observeReader = require('can-stache-key');
    var paramReplacer = /\{([^\}]+)\}/g;
    var ComponentControl = Control.extend({
        _lookup: function (options) {
            return [
                options.scope,
                options,
                window
            ];
        },
        _removeDelegateFromKey: function (key) {
            return key.replace(/^(scope|^viewModel)\./, '');
        },
        _isDelegate: function (options, key) {
            return key === 'scope' || key === 'viewModel';
        },
        _getDelegate: function (options, key) {
            return options[key];
        },
        _action: function (methodName, options, controlInstance) {
            var hasObjectLookup;
            paramReplacer.lastIndex = 0;
            hasObjectLookup = paramReplacer.test(methodName);
            if (!controlInstance && hasObjectLookup) {
                return;
            } else {
                return Control._action.apply(this, arguments);
            }
        }
    }, {
        setup: function (el, options) {
            this.scope = options.scope;
            this.viewModel = options.viewModel;
            return Control.prototype.setup.call(this, el, options);
        },
        off: function () {
            if (this._bindings) {
                canEach(this._bindings.readyComputes || {}, function (value) {
                    value.compute.unbind('change', value.handler);
                });
            }
            Control.prototype.off.apply(this, arguments);
            this._bindings.readyComputes = {};
        },
        destroy: function () {
            Control.prototype.destroy.apply(this, arguments);
            if (typeof this.options.destroy === 'function') {
                this.options.destroy.apply(this, arguments);
            }
        }
    });
    module.exports = ComponentControl;
});
/*can-stache@3.15.0#expressions/arg*/
define('can-stache@3.15.0#expressions/arg', function (require, exports, module) {
    var Arg = function (expression, modifiers) {
        this.expr = expression;
        this.modifiers = modifiers || {};
        this.isCompute = false;
    };
    Arg.prototype.value = function () {
        return this.expr.value.apply(this.expr, arguments);
    };
    module.exports = Arg;
});
/*can-stache@3.15.0#expressions/literal*/
define('can-stache@3.15.0#expressions/literal', function (require, exports, module) {
    var Literal = function (value) {
        this._value = value;
    };
    Literal.prototype.value = function () {
        return this._value;
    };
    module.exports = Literal;
});
/*can-stache@3.15.0#src/expression-helpers*/
define('can-stache@3.15.0#src/expression-helpers', [
    'require',
    'exports',
    'module',
    '../expressions/arg',
    '../expressions/literal',
    'can-reflect',
    'can-compute',
    'can-stache-key',
    'can-symbol',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var Arg = require('../expressions/arg');
    var Literal = require('../expressions/literal');
    var canReflect = require('can-reflect');
    var compute = require('can-compute');
    var observeReader = require('can-stache-key');
    var canSymbol = require('can-symbol');
    var dev = require('can-util/js/dev/dev');
    var getObservableValue_fromKey = function (key, scope, readOptions) {
        var data = scope.computeData(key, readOptions);
        compute.temporarilyBind(data);
        return data;
    };
    function computeHasDependencies(compute) {
        return compute[canSymbol.for('can.valueHasDependencies')] ? canReflect.valueHasDependencies(compute) : compute.computeInstance.hasDependencies;
    }
    function getObservableValue_fromDynamicKey_fromObservable(key, root, helperOptions, readOptions) {
        var computeValue = compute(function (newVal) {
            var keyValue = canReflect.getValue(key);
            var rootValue = canReflect.getValue(root);
            keyValue = ('' + keyValue).replace('.', '\\.');
            if (arguments.length) {
                observeReader.write(rootValue, observeReader.reads(keyValue), newVal);
            } else {
                return observeReader.get(rootValue, keyValue);
            }
        });
        compute.temporarilyBind(computeValue);
        return computeValue;
    }
    function convertToArgExpression(expr) {
        if (!(expr instanceof Arg) && !(expr instanceof Literal)) {
            return new Arg(expr);
        } else {
            return expr;
        }
    }
    function toComputeOrValue(value) {
        if (canReflect.isObservableLike(value)) {
            if (canReflect.valueHasDependencies(value) === false) {
                return canReflect.getValue(value);
            }
            if (value.compute) {
                return value.compute;
            }
        }
        return value;
    }
    function toCompute(value) {
        if (value) {
            if (value.isComputed) {
                return value;
            }
            if (value.compute) {
                return value.compute;
            }
        }
        return value;
    }
    module.exports = {
        getObservableValue_fromKey: getObservableValue_fromKey,
        computeHasDependencies: computeHasDependencies,
        getObservableValue_fromDynamicKey_fromObservable: getObservableValue_fromDynamicKey_fromObservable,
        convertToArgExpression: convertToArgExpression,
        toComputeOrValue: toComputeOrValue,
        toCompute: toCompute
    };
});
/*can-stache@3.15.0#expressions/hashes*/
define('can-stache@3.15.0#expressions/hashes', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-compute',
    '../src/expression-helpers'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var compute = require('can-compute');
    var expressionHelpers = require('../src/expression-helpers');
    var Hashes = function (hashes) {
        this.hashExprs = hashes;
    };
    Hashes.prototype.value = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = expressionHelpers.convertToArgExpression(this.hashExprs[prop]), value = val.value.apply(val, arguments);
            hash[prop] = {
                call: !val.modifiers || !val.modifiers.compute,
                value: value
            };
        }
        return compute(function () {
            var finalHash = {};
            for (var prop in hash) {
                finalHash[prop] = hash[prop].call ? canReflect.getValue(hash[prop].value) : expressionHelpers.toComputeOrValue(hash[prop].value);
            }
            return finalHash;
        });
    };
    module.exports = Hashes;
});
/*can-stache@3.15.0#expressions/bracket*/
define('can-stache@3.15.0#expressions/bracket', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers'
], function (require, exports, module) {
    var expressionHelpers = require('../src/expression-helpers');
    var Bracket = function (key, root, originalKey) {
        this.root = root;
        this.key = key;
    };
    Bracket.prototype.value = function (scope, helpers) {
        var root = this.root ? this.root.value(scope, helpers) : scope.peek('.');
        return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key.value(scope, helpers), root, scope, helpers, {});
    };
    Bracket.prototype.closingTag = function () {
    };
    module.exports = Bracket;
});
/*can-simple-map@3.3.2#can-simple-map*/
define('can-simple-map@3.3.2#can-simple-map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-event',
    'can-event/batch/batch',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-types',
    'can-observation',
    'can-reflect',
    'can-util/js/single-reference/single-reference',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var types = require('can-types');
    var Observation = require('can-observation');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var SimpleMap = Construct.extend({
        setup: function (initialData) {
            this._data = {};
            this.attr(initialData);
        },
        attr: function (prop, value) {
            var self = this;
            if (arguments.length === 0) {
                Observation.add(this, '__keys');
                var data = {};
                each(this._data, function (value, prop) {
                    Observation.add(this, prop);
                    data[prop] = value;
                }, this);
                return data;
            } else if (arguments.length > 1) {
                var had = this._data.hasOwnProperty(prop);
                var old = this._data[prop];
                this._data[prop] = value;
                canBatch.start();
                if (!had) {
                    canEvent.dispatch.call(this, '__keys', []);
                }
                canEvent.dispatch.call(this, prop, [
                    value,
                    old
                ]);
                canBatch.stop();
            } else if (typeof prop === 'object') {
                canReflect.eachKey(prop, function (value, key) {
                    self.attr(key, value);
                });
            } else {
                if (prop !== 'constructor') {
                    Observation.add(this, prop);
                    return this._data[prop];
                }
                return this.constructor;
            }
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        get: function () {
            return this.attr.apply(this, arguments);
        },
        set: function () {
            return this.attr.apply(this, arguments);
        }
    });
    assign(SimpleMap.prototype, canEvent);
    if (!types.DefaultMap) {
        types.DefaultMap = SimpleMap;
    }
    canReflect.assignSymbols(SimpleMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': SimpleMap.prototype.get,
        'can.setKeyValue': SimpleMap.prototype.set,
        'can.deleteKeyValue': function (prop) {
            return this.attr(prop, undefined);
        },
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignMap(this, source);
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            canReflect.updateMap(this, source);
            canBatch.stop();
        },
        'can.onKeyValue': function (key, handler) {
            var translationHandler = function (ev, newValue, oldValue) {
                handler.call(this, newValue, oldValue);
            };
            singleReference.set(handler, this, translationHandler, key);
            this.addEventListener(key, translationHandler);
        },
        'can.offKeyValue': function (key, handler) {
            this.removeEventListener(key, singleReference.getAndDelete(handler, this, key));
        },
        'can.keyHasDependencies': function (key) {
            return false;
        },
        'can.getKeyDependencies': function (key) {
            return undefined;
        }
    });
    module.exports = SimpleMap;
});
/*can-view-scope@3.6.0#template-context*/
define('can-view-scope@3.6.0#template-context', [
    'require',
    'exports',
    'module',
    'can-simple-map'
], function (require, exports, module) {
    var SimpleMap = require('can-simple-map');
    var TemplateContext = function () {
        this.vars = new SimpleMap({});
    };
    module.exports = TemplateContext;
});
/*can-view-scope@3.6.0#compute_data*/
define('can-view-scope@3.6.0#compute_data', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-stache-key',
    'can-compute',
    'can-util/js/assign/assign',
    'can-util/js/is-function/is-function',
    'can-event/batch/batch',
    'can-cid',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var Observation = require('can-observation');
    var observeReader = require('can-stache-key');
    var makeCompute = require('can-compute');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var canBatch = require('can-event/batch/batch');
    var CID = require('can-cid');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var getFastPathRoot = function (computeData) {
        if (computeData.reads && computeData.reads.length === 1) {
            var root = computeData.root;
            if (root && root[canSymbol.for('can.getValue')]) {
                root = canReflect.getValue(root);
            }
            return root && canReflect.isObservableLike(root) && canReflect.isMapLike(root) && !isFunction(root[computeData.reads[0].key]) && root;
        }
        return;
    };
    var isEventObject = function (obj) {
        return obj && typeof obj.batchNum === 'number' && typeof obj.type === 'string';
    };
    var ScopeKeyData = function (scope, key, options) {
        CID(this);
        this.startingScope = scope;
        this.key = key;
        this.observation = new Observation(this.read, this);
        this.options = assign({ observation: this.observation }, options);
        this.handlers = [];
        this.dispatchHandler = this.dispatch.bind(this);
        this.fastPath = undefined;
        this.root = undefined;
        this.initialValue = undefined;
        this.reads = undefined;
        this.setRoot = undefined;
    };
    ScopeKeyData.prototype.getValue = function () {
        Observation.add(this);
        return this.getObservationValue();
    };
    ScopeKeyData.prototype.getObservationValue = Observation.ignore(function () {
        return this.observation.get();
    });
    ScopeKeyData.prototype.read = function () {
        if (this.root) {
            return observeReader.read(this.root, this.reads, this.options).value;
        }
        var data = this.startingScope.read(this.key, this.options);
        this.scope = data.scope;
        this.reads = data.reads;
        this.root = data.rootObserve;
        this.setRoot = data.setRoot;
        return this.initialValue = data.value;
    };
    ScopeKeyData.prototype.setValue = function (newVal) {
        var root = this.root || this.setRoot;
        if (root) {
            observeReader.write(root, this.reads, newVal, this.options);
        } else {
            this.startingScope.set(this.key, newVal, this.options);
        }
    };
    ScopeKeyData.prototype.hasDependencies = function () {
        return this.observation.hasDependencies();
    };
    var canOnValue = canSymbol.for('can.onValue'), canOffValue = canSymbol.for('can.offValue');
    canReflect.set(ScopeKeyData.prototype, canOnValue, function (handler) {
        if (!this.handlers.length) {
            canReflect.onValue(this.observation, this.dispatchHandler);
            var fastPathRoot = getFastPathRoot(this);
            if (fastPathRoot) {
                var self = this, observation = this.observation;
                this.fastPath = true;
                observation.dependencyChange = function (target, newVal, altNewValue) {
                    if (isEventObject(newVal)) {
                        newVal = altNewValue;
                    }
                    if (target === fastPathRoot && typeof newVal !== 'function') {
                        this.newVal = newVal;
                    } else {
                        observation.dependencyChange = Observation.prototype.dependencyChange;
                        observation.start = Observation.prototype.start;
                        self.fastPath = false;
                    }
                    return Observation.prototype.dependencyChange.call(this, target, newVal, altNewValue);
                };
                observation.start = function () {
                    this.value = this.newVal;
                };
            }
        }
        this.handlers.push(handler);
    });
    ScopeKeyData.prototype.dispatch = function () {
        var handlers = this.handlers.slice(0);
        for (var i = 0, len = handlers.length; i < len; i++) {
            canBatch.batchNum = this.observation.batchNum;
            handlers[i].apply(this, arguments);
        }
    };
    canReflect.set(ScopeKeyData.prototype, canOffValue, function (handler) {
        var index = this.handlers.indexOf(handler);
        this.handlers.splice(index, 1);
        if (!this.handlers.length) {
            canReflect.offValue(this.observation, this.dispatchHandler);
            this.observation.dependencyChange = Observation.prototype.dependencyChange;
            this.observation.start = Observation.prototype.start;
        }
    });
    canReflect.set(ScopeKeyData.prototype, canSymbol.for('can.getValue'), ScopeKeyData.prototype.getValue);
    canReflect.set(ScopeKeyData.prototype, canSymbol.for('can.setValue'), ScopeKeyData.prototype.setValue);
    canReflect.set(ScopeKeyData.prototype, canSymbol.for('can.valueHasDependencies'), ScopeKeyData.prototype.hasDependencies);
    Object.defineProperty(ScopeKeyData.prototype, 'compute', {
        get: function () {
            var scopeKeyData = this;
            var compute = makeCompute(undefined, {
                on: function (updater) {
                    scopeKeyData[canOnValue](updater);
                    this.value = scopeKeyData.observation.value;
                },
                off: function (updater) {
                    scopeKeyData[canOffValue](updater);
                },
                get: function () {
                    return scopeKeyData.observation.get();
                },
                set: function (newValue) {
                    return scopeKeyData.setValue(newValue);
                }
            });
            compute.computeInstance.observation = this.observation;
            compute.computeInstance._canObserve = false;
            Object.defineProperty(this, 'compute', {
                value: compute,
                writable: false,
                configurable: false
            });
            return compute;
        },
        configurable: true
    });
    module.exports = function (scope, key, options) {
        return new ScopeKeyData(scope, key, options || { args: [] });
    };
});
/*can-define-lazy-value@1.1.0#define-lazy-value*/
define('can-define-lazy-value@1.1.0#define-lazy-value', function (require, exports, module) {
    'use strict';
    module.exports = function defineLazyValue(obj, prop, initializer, writable) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            get: function () {
                Object.defineProperty(this, prop, {
                    value: undefined,
                    writable: true
                });
                var value = initializer.call(this, obj, prop);
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            },
            set: function (value) {
                Object.defineProperty(this, prop, {
                    value: value,
                    writable: !!writable
                });
                return value;
            }
        });
    };
});
/*can-view-scope@3.6.0#can-view-scope*/
define('can-view-scope@3.6.0#can-view-scope', [
    'require',
    'exports',
    'module',
    'can-stache-key',
    'can-observation',
    './template-context',
    './compute_data',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-namespace',
    'can-reflect',
    'can-log/dev/dev',
    'can-define-lazy-value'
], function (require, exports, module) {
    var observeReader = require('can-stache-key');
    var Observation = require('can-observation');
    var TemplateContext = require('./template-context');
    var makeComputeData = require('./compute_data');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var canReflect = require('can-reflect');
    var canLog = require('can-log/dev/dev');
    var defineLazyValue = require('can-define-lazy-value');
    var specialKeywords = {
        index: true,
        key: true,
        element: true,
        event: true,
        viewModel: true,
        arguments: true
    };
    function Scope(context, parent, meta) {
        this._context = context;
        this._parent = parent;
        this._meta = meta || {};
        this.__cache = {};
    }
    assign(Scope, {
        read: observeReader.read,
        Refs: TemplateContext,
        refsScope: function () {
            return new Scope(new TemplateContext());
        },
        keyInfo: function (attr) {
            var info = {};
            info.isDotSlash = attr.substr(0, 2) === './';
            info.isThisDot = attr.substr(0, 5) === 'this.';
            info.isThisAt = attr.substr(0, 5) === 'this@';
            info.isInCurrentContext = info.isDotSlash || info.isThisDot || info.isThisAt;
            info.isInParentContext = attr.substr(0, 3) === '../';
            info.isCurrentContext = attr === '.' || attr === 'this';
            info.isParentContext = attr === '..';
            info.isScope = attr === 'scope';
            info.isLegacyView = attr === '*self';
            info.isInLegacyRefsScope = info.isLegacyView || attr.substr(0, 1) === '*' || attr.substr(0, 2) === '@*';
            info.isInTemplateContextVars = info.isInLegacyRefsScope || attr.substr(0, 11) === 'scope.vars.';
            info.isInScopeTop = attr.substr(0, 10) === 'scope.top.';
            info.isInScopeVm = attr.substr(0, 9) === 'scope.vm.';
            info.isInTemplateContext = info.isInScopeTop || info.isInScopeVm || info.isInTemplateContextVars || attr.substr(0, 6) === 'scope.';
            info.isContextBased = info.isInCurrentContext || info.isInParentContext || info.isCurrentContext || info.isParentContext;
            return info;
        }
    });
    assign(Scope.prototype, {
        add: function (context, meta) {
            if (context !== this._context) {
                return new this.constructor(context, this, meta);
            } else {
                return this;
            }
        },
        read: function (attr, options) {
            if (attr === '%root') {
                return { value: this.getRoot() };
            }
            if (attr === '%scope') {
                return { value: this };
            }
            if (attr === './') {
                attr = '.';
            }
            var keyInfo = Scope.keyInfo(attr);
            if (keyInfo.isContextBased && (this._meta.notContext || this._meta.special)) {
                return this._parent.read(attr, options);
            }
            var currentScopeOnly;
            if (keyInfo.isInCurrentContext) {
                currentScopeOnly = true;
                attr = keyInfo.isDotSlash ? attr.substr(2) : attr.substr(5);
            } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                var parent = this._parent;
                while (parent._meta.notContext || parent._meta.special) {
                    parent = parent._parent;
                }
                if (keyInfo.isParentContext) {
                    return observeReader.read(parent._context, [], options);
                }
                return parent.read(attr.substr(3) || '.', options);
            } else if (keyInfo.isCurrentContext) {
                return observeReader.read(this._context, [], options);
            } else if (keyInfo.isScope) {
                return { value: this };
            }
            var keyReads = observeReader.reads(attr);
            if (keyInfo.isInTemplateContext) {
                if (keyInfo.isInLegacyRefsScope) {
                    if (keyInfo.isLegacyView) {
                        keyReads[0].key = 'view';
                    } else {
                        keyReads[0] = {
                            key: keyReads[0].key.substr(1),
                            at: true
                        };
                        keyReads.unshift({ key: 'vars' });
                    }
                } else if (keyInfo.isInScopeVm) {
                    return observeReader.read(this.getViewModel(), keyReads.slice(2), options);
                } else if (keyInfo.isInScopeTop) {
                    return observeReader.read(this.getTop(), keyReads.slice(2), options);
                } else {
                    keyReads = keyReads.slice(1);
                }
                if (specialKeywords[keyReads[0].key]) {
                    return this._read(keyReads, { special: true });
                }
                if (keyReads.length === 1) {
                    return { value: this.templateContext[keyReads[0].key] };
                }
                return this.getTemplateContext()._read(keyReads);
            }
            return this._read(keyReads, options, currentScopeOnly);
        },
        _read: function (keyReads, options, currentScopeOnly) {
            var currentScope = this, currentContext, undefinedObserves = [], currentObserve, currentReads, setObserveDepth = -1, currentSetReads, currentSetObserve, ignoreSpecialContexts, ignoreNonSpecialContexts, readOptions = assign({
                    foundObservable: function (observe, nameIndex) {
                        currentObserve = observe;
                        currentReads = keyReads.slice(nameIndex);
                    },
                    earlyExit: function (parentValue, nameIndex) {
                        if (nameIndex > setObserveDepth || nameIndex === setObserveDepth && (typeof parentValue === 'object' && keyReads[nameIndex].key in parentValue)) {
                            currentSetObserve = currentObserve;
                            currentSetReads = currentReads;
                            setObserveDepth = nameIndex;
                        }
                    }
                }, options);
            while (currentScope) {
                currentContext = currentScope._context;
                ignoreNonSpecialContexts = options && options.special && !currentScope._meta.special;
                ignoreSpecialContexts = (!options || options.special !== true) && currentScope._meta.special;
                if (currentContext !== null && (typeof currentContext === 'object' || typeof currentContext === 'function') && !ignoreNonSpecialContexts && !ignoreSpecialContexts) {
                    var getObserves = Observation.trap();
                    var data = observeReader.read(currentContext, keyReads, readOptions);
                    var observes = getObserves();
                    if (data.value !== undefined) {
                        Observation.addAll(observes);
                        return {
                            scope: currentScope,
                            rootObserve: currentObserve,
                            value: data.value,
                            reads: currentReads
                        };
                    } else {
                        undefinedObserves.push.apply(undefinedObserves, observes);
                    }
                }
                if (currentScopeOnly) {
                    currentScope = null;
                } else {
                    currentScope = currentScope._parent;
                }
            }
            Observation.addAll(undefinedObserves);
            return {
                setRoot: currentSetObserve,
                reads: currentSetReads,
                value: undefined
            };
        },
        get: function (key, options) {
            options = assign({ isArgument: true }, options);
            var res = this.read(key, options);
            return res.value;
        },
        peek: Observation.ignore(function (key, options) {
            return this.get(key, options);
        }),
        peak: Observation.ignore(function (key, options) {
            return this.peek(key, options);
        }),
        getScope: function (tester) {
            var scope = this;
            while (scope) {
                if (tester(scope)) {
                    return scope;
                }
                scope = scope._parent;
            }
        },
        getContext: function (tester) {
            var res = this.getScope(tester);
            return res && res._context;
        },
        getRefs: function () {
            return this.getTemplateContext();
        },
        getTemplateContext: function () {
            var lastScope;
            var templateContext = this.getScope(function (scope) {
                lastScope = scope;
                return scope._context instanceof TemplateContext;
            });
            if (!templateContext) {
                templateContext = new Scope(new TemplateContext());
                lastScope._parent = templateContext;
            }
            return templateContext;
        },
        getRoot: function () {
            var cur = this, child = this;
            while (cur._parent) {
                child = cur;
                cur = cur._parent;
            }
            if (cur._context instanceof Scope.Refs) {
                cur = child;
            }
            return cur._context;
        },
        getViewModel: function () {
            var vmScope = this.getScope(function (scope) {
                return scope._meta.viewModel;
            });
            return vmScope && vmScope._context;
        },
        getTop: function () {
            var top;
            this.getScope(function (scope) {
                if (scope._meta.viewModel) {
                    top = scope;
                }
                return false;
            });
            return top && top._context;
        },
        set: function (key, value, options) {
            options = options || {};
            var keyInfo = Scope.keyInfo(key), parent;
            if (keyInfo.isCurrentContext) {
                return canReflect.setValue(this._context, value);
            } else if (keyInfo.isInParentContext || keyInfo.isParentContext) {
                parent = this._parent;
                while (parent._meta.notContext) {
                    parent = parent._parent;
                }
                if (keyInfo.isParentContext) {
                    return canReflect.setValue(parent._context, value);
                }
                return parent.set(key.substr(3) || '.', value, options);
            } else if (keyInfo.isInTemplateContext) {
                if (keyInfo.isInLegacyRefsScope) {
                    return this.vars.set(key.substr(1), value);
                }
                if (keyInfo.isInTemplateContextVars) {
                    return this.vars.set(key.substr(11), value);
                }
                key = key.substr(6);
                if (key.indexOf('.') < 0) {
                    return this.templateContext[key] = value;
                }
                return this.getTemplateContext().set(key, value);
            }
            var dotIndex = key.lastIndexOf('.'), slashIndex = key.lastIndexOf('/'), contextPath, propName;
            if (slashIndex > dotIndex) {
                contextPath = key.substring(0, slashIndex);
                propName = key.substring(slashIndex + 1, key.length);
            } else {
                if (dotIndex !== -1) {
                    contextPath = key.substring(0, dotIndex);
                    propName = key.substring(dotIndex + 1, key.length);
                } else {
                    contextPath = '.';
                    propName = key;
                }
            }
            var context = this.read(contextPath, options).value;
            if (context === undefined) {
                return;
            }
            if (!canReflect.isObservableLike(context) && canReflect.isObservableLike(context[propName])) {
                if (canReflect.isMapLike(context[propName])) {
                    canLog.warn('can-view-scope: Merging data into "' + propName + '" because its parent is non-observable');
                    canReflect.updateDeep(context[propName], value);
                } else if (canReflect.isValueLike(context[propName])) {
                    canReflect.setValue(context[propName], value);
                } else {
                    observeReader.write(context, propName, value, options);
                }
            } else {
                observeReader.write(context, propName, value, options);
            }
        },
        attr: Observation.ignore(function (key, value, options) {
            canLog.warn('can-view-scope::attr is deprecated, please use peek, get or set');
            options = assign({ isArgument: true }, options);
            if (arguments.length === 2) {
                return this.set(key, value, options);
            } else {
                return this.get(key, options);
            }
        }),
        computeData: function (key, options) {
            return makeComputeData(this, key, options);
        },
        compute: function (key, options) {
            return this.computeData(key, options).compute;
        },
        cloneFromRef: function () {
            var contexts = [];
            var scope = this, context, parent;
            while (scope) {
                context = scope._context;
                if (context instanceof Scope.Refs) {
                    parent = scope._parent;
                    break;
                }
                contexts.unshift(context);
                scope = scope._parent;
            }
            if (parent) {
                each(contexts, function (context) {
                    parent = parent.add(context);
                });
                return parent;
            } else {
                return this;
            }
        }
    });
    defineLazyValue(Scope.prototype, 'templateContext', function () {
        return this.getTemplateContext()._context;
    });
    defineLazyValue(Scope.prototype, 'vars', function () {
        return this.templateContext.vars;
    });
    function Options(data, parent, meta) {
        if (!data.helpers && !data.partials && !data.tags) {
            data = { helpers: data };
        }
        Scope.call(this, data, parent, meta);
    }
    Options.prototype = new Scope();
    Options.prototype.constructor = Options;
    Scope.Options = Options;
    namespace.view = namespace.view || {};
    module.exports = namespace.view.Scope = Scope;
});
/*can-stache@3.15.0#src/set-identifier*/
define('can-stache@3.15.0#src/set-identifier', function (require, exports, module) {
    module.exports = function SetIdentifier(value) {
        this.value = value;
    };
});
/*can-stache@3.15.0#expressions/call*/
define('can-stache@3.15.0#expressions/call', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    './hashes',
    '../src/set-identifier',
    'can-compute',
    'can-reflect',
    'can-symbol',
    'can-util/js/assign/assign',
    'can-util/js/is-empty-object/is-empty-object',
    '../src/expression-helpers'
], function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Hashes = require('./hashes');
    var SetIdentifier = require('../src/set-identifier');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var assign = require('can-util/js/assign/assign');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var expressionHelpers = require('../src/expression-helpers');
    var Call = function (methodExpression, argExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions.map(expressionHelpers.convertToArgExpression);
    };
    Call.prototype.args = function (scope, helperOptions) {
        var hashExprs = {};
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            if (arg.expr instanceof Hashes) {
                assign(hashExprs, arg.expr.hashExprs);
            }
            var value = arg.value.apply(arg, arguments);
            args.push({
                call: !arg.modifiers || !arg.modifiers.compute,
                value: value
            });
        }
        return function (doNotWrapArguments) {
            var finalArgs = [];
            if (!isEmptyObject(hashExprs)) {
                finalArgs.hashExprs = hashExprs;
            }
            for (var i = 0, len = args.length; i < len; i++) {
                if (doNotWrapArguments) {
                    finalArgs[i] = args[i].value;
                } else {
                    finalArgs[i] = args[i].call ? canReflect.getValue(args[i].value) : expressionHelpers.toCompute(args[i].value);
                }
            }
            return finalArgs;
        };
    };
    Call.prototype.value = function (scope, helperScope, helperOptions) {
        var method = this.methodExpr.value(scope, helperScope);
        var metadata = method.metadata || {};
        assign(this, metadata);
        var getArgs = this.args(scope, helperScope);
        var computeValue = compute(function (newVal) {
            var func = canReflect.getValue(method.fn || method);
            if (typeof func === 'function') {
                var args = getArgs(metadata.isLiveBound);
                if (metadata.isHelper && helperOptions) {
                    helperOptions.helpers = helperOptions.helpers || new Scope.Options({});
                    if (args.hashExprs && helperOptions.exprData) {
                        helperOptions.exprData.hashExprs = args.hashExprs;
                    }
                    args.push(helperOptions);
                }
                if (arguments.length) {
                    args.unshift(new SetIdentifier(newVal));
                }
                return func.apply(null, args);
            }
        });
        compute.temporarilyBind(computeValue);
        return computeValue;
    };
    Call.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    module.exports = Call;
});
/*can-attribute-encoder@0.3.4#can-attribute-encoder*/
define('can-attribute-encoder@0.3.4#can-attribute-encoder', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var dev = require('can-log/dev/dev');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    var caseMattersAttributes = makeMap('allowReorder,attributeName,attributeType,autoReverse,baseFrequency,baseProfile,calcMode,clipPathUnits,contentScriptType,contentStyleType,diffuseConstant,edgeMode,externalResourcesRequired,filterRes,filterUnits,glyphRef,gradientTransform,gradientUnits,kernelMatrix,kernelUnitLength,keyPoints,keySplines,keyTimes,lengthAdjust,limitingConeAngle,markerHeight,markerUnits,markerWidth,maskContentUnits,maskUnits,patternContentUnits,patternTransform,patternUnits,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,repeatCount,repeatDur,requiredExtensions,requiredFeatures,specularConstant,specularExponent,spreadMethod,startOffset,stdDeviation,stitchTiles,surfaceScale,systemLanguage,tableValues,textLength,viewBox,viewTarget,xChannelSelector,yChannelSelector');
    function camelCaseToSpinalCase(match, lowerCaseChar, upperCaseChar) {
        return lowerCaseChar + '-' + upperCaseChar.toLowerCase();
    }
    function startsWith(allOfIt, startsWith) {
        return allOfIt.indexOf(startsWith) === 0;
    }
    function endsWith(allOfIt, endsWith) {
        return allOfIt.length - allOfIt.indexOf(endsWith) === endsWith.length;
    }
    var regexes = {
        leftParens: /\(/g,
        rightParens: /\)/g,
        leftBrace: /\{/g,
        rightBrace: /\}/g,
        camelCase: /([a-z])([A-Z])/g,
        forwardSlash: /\//g,
        space: /\s/g,
        uppercase: /[A-Z]/g,
        uppercaseDelimiterThenChar: /:u:([a-z])/g,
        caret: /\^/g,
        dollar: /\$/g,
        at: /@/g
    };
    var delimiters = {
        prependUppercase: ':u:',
        replaceSpace: ':s:',
        replaceForwardSlash: ':f:',
        replaceLeftParens: ':lp:',
        replaceRightParens: ':rp:',
        replaceLeftBrace: ':lb:',
        replaceRightBrace: ':rb:',
        replaceCaret: ':c:',
        replaceDollar: ':d:',
        replaceAt: ':at:'
    };
    var encoder = {};
    encoder.encode = function (name) {
        var encoded = name;
        if (!caseMattersAttributes[encoded] && encoded.match(regexes.camelCase)) {
            if (startsWith(encoded, 'on:') || endsWith(encoded, ':to') || endsWith(encoded, ':from') || endsWith(encoded, ':bind')) {
                encoded = encoded.replace(regexes.uppercase, function (char) {
                    return delimiters.prependUppercase + char.toLowerCase();
                });
            } else {
                encoded = encoded.replace(regexes.camelCase, camelCaseToSpinalCase);
            }
        }
        encoded = encoded.replace(regexes.space, delimiters.replaceSpace).replace(regexes.forwardSlash, delimiters.replaceForwardSlash).replace(regexes.leftParens, delimiters.replaceLeftParens).replace(regexes.rightParens, delimiters.replaceRightParens).replace(regexes.leftBrace, delimiters.replaceLeftBrace).replace(regexes.rightBrace, delimiters.replaceRightBrace).replace(regexes.caret, delimiters.replaceCaret).replace(regexes.dollar, delimiters.replaceDollar).replace(regexes.at, delimiters.replaceAt);
        return encoded;
    };
    encoder.decode = function (name) {
        var decoded = name;
        if (!caseMattersAttributes[decoded] && decoded.match(regexes.uppercaseDelimiterThenChar)) {
            if (startsWith(decoded, 'on:') || endsWith(decoded, ':to') || endsWith(decoded, ':from') || endsWith(decoded, ':bind')) {
                decoded = decoded.replace(regexes.uppercaseDelimiterThenChar, function (match, char) {
                    return char.toUpperCase();
                });
            }
        }
        decoded = decoded.replace(delimiters.replaceLeftParens, '(').replace(delimiters.replaceRightParens, ')').replace(delimiters.replaceLeftBrace, '{').replace(delimiters.replaceRightBrace, '}').replace(delimiters.replaceForwardSlash, '/').replace(delimiters.replaceSpace, ' ').replace(delimiters.replaceCaret, '^').replace(delimiters.replaceDollar, '$').replace(delimiters.replaceAt, '@');
        return decoded;
    };
    if (namespace.encoder) {
        throw new Error('You can\'t have two versions of can-attribute-encoder, check your dependencies');
    } else {
        module.exports = namespace.encoder = encoder;
    }
});
/*can-view-parser@3.8.3#can-view-parser*/
define('can-view-parser@3.8.3#can-view-parser', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-log/dev/dev',
    'can-attribute-encoder'
], function (require, exports, module) {
    var namespace = require('can-namespace'), dev = require('can-log/dev/dev'), encoder = require('can-attribute-encoder');
    function each(items, callback) {
        for (var i = 0; i < items.length; i++) {
            callback(items[i], i);
        }
    }
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    function handleIntermediate(intermediate, handler) {
        for (var i = 0, len = intermediate.length; i < len; i++) {
            var item = intermediate[i];
            handler[item.tokenType].apply(handler, item.args);
        }
        return intermediate;
    }
    var alphaNumeric = 'A-Za-z0-9', alphaNumericHU = '-:_' + alphaNumeric, defaultMagicStart = '{{', endTag = new RegExp('^<\\/([' + alphaNumericHU + ']+)[^>]*>'), defaultMagicMatch = new RegExp('\\{\\{(![\\s\\S]*?!|[\\s\\S]*?)\\}\\}\\}?', 'g'), space = /\s/, alphaRegex = new RegExp('[' + alphaNumeric + ']'), attributeRegexp = new RegExp('[' + alphaNumericHU + ']+s*=s*("[^"]*"|\'[^\']*\')');
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    var caseMattersElements = makeMap('altGlyph,altGlyphDef,altGlyphItem,animateColor,animateMotion,animateTransform,clipPath,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,foreignObject,glyphRef,linearGradient,radialGradient,textPath');
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    var special = makeMap('script');
    var tokenTypes = 'start,end,close,attrStart,attrEnd,attrValue,chars,comment,special,done'.split(',');
    var startOppositesMap = {
        '{': '}',
        '(': ')'
    };
    var fn = function () {
    };
    var HTMLParser = function (html, handler, returnIntermediate) {
        if (typeof html === 'object') {
            return handleIntermediate(html, handler);
        }
        var intermediate = [];
        handler = handler || {};
        if (returnIntermediate) {
            each(tokenTypes, function (name) {
                var callback = handler[name] || fn;
                handler[name] = function () {
                    if (callback.apply(this, arguments) !== false) {
                        var end = arguments.length;
                        if (arguments[end - 1] === undefined) {
                            end = arguments.length - 1;
                        }
                        intermediate.push({
                            tokenType: name,
                            args: [].slice.call(arguments, 0, end)
                        });
                    }
                };
            });
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        if (handler.magicMatch) {
            dev.warn('can-view-parser: magicMatch is deprecated.');
        }
        if (handler.magicStart) {
            dev.warn('can-view-parser: magicStart is deprecated.');
        }
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
            if (closeSelf[tagName] && stack.last() === tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            handler.start(tagName, unary, lineNo);
            if (!unary) {
                stack.push(tagName);
            }
            HTMLParser.parseAttrs(rest, handler, lineNo);
            handler.end(tagName, unary, lineNo);
        }
        function parseEndTag(tag, tagName) {
            var pos;
            if (!tagName) {
                pos = 0;
            } else {
                tagName = caseMattersElements[tagName] ? tagName : tagName.toLowerCase();
                for (pos = stack.length - 1; pos >= 0; pos--) {
                    if (stack[pos] === tagName) {
                        break;
                    }
                }
            }
            if (pos >= 0) {
                for (var i = stack.length - 1; i >= pos; i--) {
                    if (handler.close) {
                        handler.close(stack[i], lineNo);
                    }
                }
                stack.length = pos;
            }
        }
        function parseMustache(mustache, inside) {
            if (handler.special) {
                handler.special(inside, lineNo);
            }
        }
        var callChars = function () {
            if (charsText) {
                if (handler.chars) {
                    handler.chars(charsText, lineNo);
                }
            }
            charsText = '';
        };
        var index, chars, match, lineNo, stack = [], last = html, charsText = '';
        stack.last = function () {
            return this[this.length - 1];
        };
        while (html) {
            chars = true;
            if (!stack.last() || !special[stack.last()]) {
                if (html.indexOf('<!--') === 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        callChars();
                        if (handler.comment) {
                            handler.comment(html.substring(4, index), lineNo);
                        }
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') === 0) {
                    match = html.match(endTag);
                    if (match) {
                        callChars();
                        match[0].replace(endTag, parseEndTag);
                        html = html.substring(match[0].length);
                        chars = false;
                    }
                } else if (html.indexOf('<') === 0) {
                    var res = HTMLParser.searchStartTag(html);
                    if (res) {
                        callChars();
                        parseStartTag.apply(null, res.match);
                        html = res.html;
                        chars = false;
                    }
                } else if (html.indexOf(magicStart) === 0) {
                    match = html.match(magicMatch);
                    if (match) {
                        callChars();
                        match[0].replace(magicMatch, parseMustache);
                        html = html.substring(match[0].length);
                    }
                }
                if (chars) {
                    index = findBreak(html, magicStart);
                    if (index === 0 && html === last) {
                        charsText += html.charAt(0);
                        html = html.substr(1);
                        index = findBreak(html, magicStart);
                    }
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (text) {
                        charsText += text;
                    }
                }
            } else {
                html = html.replace(new RegExp('([\\s\\S]*?)</' + stack.last() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, '$1$2');
                    if (handler.chars) {
                        handler.chars(text, lineNo);
                    }
                    return '';
                });
                parseEndTag('', stack.last());
            }
            if (html === last) {
                throw new Error('Parse Error: ' + html);
            }
            last = html;
        }
        callChars();
        parseEndTag();
        handler.done(lineNo);
        return intermediate;
    };
    var callAttrStart = function (state, curIndex, handler, rest, lineNo) {
        var attrName = rest.substring(typeof state.nameStart === 'number' ? state.nameStart : curIndex, curIndex), newAttrName = encoder.encode(attrName);
        state.attrStart = newAttrName;
        handler.attrStart(state.attrStart, lineNo);
        state.inName = false;
    };
    var callAttrEnd = function (state, curIndex, handler, rest, lineNo) {
        if (state.valueStart !== undefined && state.valueStart < curIndex) {
            var val = rest.substring(state.valueStart, curIndex);
            handler.attrValue(val, lineNo);
        }
        handler.attrEnd(state.attrStart, lineNo);
        state.attrStart = undefined;
        state.valueStart = undefined;
        state.inValue = false;
        state.inName = false;
        state.lookingForEq = false;
        state.inQuote = false;
        state.lookingForName = true;
    };
    var findBreak = function (str, magicStart) {
        var magicLength = magicStart.length;
        for (var i = 0, len = str.length; i < len; i++) {
            if (str[i] === '<' || str.substr(i, magicLength) === magicStart) {
                return i;
            }
        }
        return -1;
    };
    HTMLParser.parseAttrs = function (rest, handler, lineNo) {
        if (!rest) {
            return;
        }
        var magicMatch = handler.magicMatch || defaultMagicMatch, magicStart = handler.magicStart || defaultMagicStart;
        var i = 0;
        var curIndex;
        var state = {
            inName: false,
            nameStart: undefined,
            inValue: false,
            valueStart: undefined,
            inQuote: false,
            attrStart: undefined,
            lookingForName: true,
            lookingForValue: false,
            lookingForEq: false
        };
        while (i < rest.length) {
            curIndex = i;
            var cur = rest.charAt(i);
            i++;
            if (magicStart === rest.substr(curIndex, magicStart.length)) {
                if (state.inValue && curIndex > state.valueStart) {
                    handler.attrValue(rest.substring(state.valueStart, curIndex), lineNo);
                } else if (state.inName && state.nameStart < curIndex) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                } else if (state.lookingForValue) {
                    state.inValue = true;
                } else if (state.lookingForEq && state.attrStart) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
                magicMatch.lastIndex = curIndex;
                var match = magicMatch.exec(rest);
                if (match) {
                    handler.special(match[1], lineNo);
                    i = curIndex + match[0].length;
                    if (state.inValue) {
                        state.valueStart = curIndex + match[0].length;
                    }
                }
            } else if (state.inValue) {
                if (state.inQuote) {
                    if (cur === state.inQuote) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                } else if (space.test(cur)) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            } else if (cur === '=' && (state.lookingForEq || state.lookingForName || state.inName)) {
                if (!state.attrStart) {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                }
                state.lookingForValue = true;
                state.lookingForEq = false;
                state.lookingForName = false;
            } else if (state.inName) {
                var started = rest[state.nameStart], otherStart, otherOpposite;
                if (startOppositesMap[started] === cur) {
                    otherStart = started === '{' ? '(' : '{';
                    otherOpposite = startOppositesMap[otherStart];
                    if (rest[curIndex + 1] === otherOpposite) {
                        callAttrStart(state, curIndex + 2, handler, rest, lineNo);
                        i++;
                    } else {
                        callAttrStart(state, curIndex + 1, handler, rest, lineNo);
                    }
                    state.lookingForEq = true;
                } else if (space.test(cur) && started !== '{' && started !== '(') {
                    callAttrStart(state, curIndex, handler, rest, lineNo);
                    state.lookingForEq = true;
                }
            } else if (state.lookingForName) {
                if (!space.test(cur)) {
                    if (state.attrStart) {
                        callAttrEnd(state, curIndex, handler, rest, lineNo);
                    }
                    state.nameStart = curIndex;
                    state.inName = true;
                }
            } else if (state.lookingForValue) {
                if (!space.test(cur)) {
                    state.lookingForValue = false;
                    state.inValue = true;
                    if (cur === '\'' || cur === '"') {
                        state.inQuote = cur;
                        state.valueStart = curIndex + 1;
                    } else {
                        state.valueStart = curIndex;
                    }
                } else if (i === rest.length) {
                    callAttrEnd(state, curIndex, handler, rest, lineNo);
                }
            }
        }
        if (state.inName) {
            callAttrStart(state, curIndex + 1, handler, rest, lineNo);
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        } else if (state.lookingForEq || state.lookingForValue || state.inValue) {
            callAttrEnd(state, curIndex + 1, handler, rest, lineNo);
        }
        magicMatch.lastIndex = 0;
    };
    HTMLParser.searchStartTag = function (html) {
        var closingIndex = html.indexOf('>');
        var attributeRange = attributeRegexp.exec(html.substring(1));
        var afterAttributeOffset = 1;
        while (attributeRange && closingIndex >= afterAttributeOffset + attributeRange.index) {
            afterAttributeOffset += attributeRange.index + attributeRange[0].length;
            while (closingIndex < afterAttributeOffset) {
                closingIndex += html.substring(closingIndex + 1).indexOf('>') + 1;
            }
            attributeRange = attributeRegexp.exec(html.substring(afterAttributeOffset));
        }
        if (closingIndex === -1 || !alphaRegex.test(html[1])) {
            return null;
        }
        var tagName, tagContent, match, rest = '', unary = '';
        var startTag = html.substring(0, closingIndex + 1);
        var isUnary = startTag[startTag.length - 2] === '/';
        var spaceIndex = startTag.search(space);
        if (isUnary) {
            unary = '/';
            tagContent = startTag.substring(1, startTag.length - 2).trim();
        } else {
            tagContent = startTag.substring(1, startTag.length - 1).trim();
        }
        if (spaceIndex === -1) {
            tagName = tagContent;
        } else {
            spaceIndex--;
            tagName = tagContent.substring(0, spaceIndex);
            rest = tagContent.substring(spaceIndex);
        }
        match = [
            startTag,
            tagName,
            rest,
            unary
        ];
        return {
            match: match,
            html: html.substring(startTag.length)
        };
    };
    module.exports = namespace.HTMLParser = HTMLParser;
});
/*can-util@3.14.0#js/set-immediate/set-immediate*/
define('can-util@3.14.0#js/set-immediate/set-immediate', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var global = require('can-globals/global/global')();
        var namespace = require('can-namespace');
        module.exports = namespace.setImmediate = global.setImmediate || function (cb) {
            return setTimeout(cb, 0);
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/child-nodes/child-nodes*/
define('can-util@3.14.0#dom/child-nodes/child-nodes', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    function childNodes(node) {
        var childNodes = node.childNodes;
        if ('length' in childNodes) {
            return childNodes;
        } else {
            var cur = node.firstChild;
            var nodes = [];
            while (cur) {
                nodes.push(cur);
                cur = cur.nextSibling;
            }
            return nodes;
        }
    }
    module.exports = namespace.childNodes = childNodes;
});
/*can-util@3.14.0#dom/contains/contains*/
define('can-util@3.14.0#dom/contains/contains', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.contains = function (child) {
        return this.contains(child);
    };
});
/*can-util@3.14.0#dom/mutate/mutate*/
define('can-util@3.14.0#dom/mutate/mutate', [
    'require',
    'exports',
    'module',
    '../../js/make-array/make-array',
    'can-namespace',
    '../../js/set-immediate/set-immediate',
    'can-cid',
    'can-globals/mutation-observer/mutation-observer',
    '../child-nodes/child-nodes',
    '../contains/contains',
    '../dispatch/dispatch',
    'can-globals/document/document',
    '../data/data'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var makeArray = require('../../js/make-array/make-array');
        var namespace = require('can-namespace');
        var setImmediate = require('../../js/set-immediate/set-immediate');
        var CID = require('can-cid');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var childNodes = require('../child-nodes/child-nodes');
        var domContains = require('../contains/contains');
        var domDispatch = require('../dispatch/dispatch');
        var getDocument = require('can-globals/document/document');
        var domData = require('../data/data');
        var mutatedElements;
        var checks = {
            inserted: function (root, elem) {
                return domContains.call(root, elem);
            },
            removed: function (root, elem) {
                return !domContains.call(root, elem);
            }
        };
        var fireOn = function (elems, root, check, event, dispatched) {
            if (!elems.length) {
                return;
            }
            var children, cid;
            for (var i = 0, elem; (elem = elems[i]) !== undefined; i++) {
                cid = CID(elem);
                if (elem.getElementsByTagName && check(root, elem) && !dispatched[cid]) {
                    dispatched[cid] = true;
                    children = makeArray(elem.getElementsByTagName('*'));
                    domDispatch.call(elem, event, [], false);
                    if (event === 'removed') {
                        domData.delete.call(elem);
                    }
                    for (var j = 0, child; (child = children[j]) !== undefined; j++) {
                        cid = CID(child);
                        if (!dispatched[cid]) {
                            domDispatch.call(child, event, [], false);
                            if (event === 'removed') {
                                domData.delete.call(child);
                            }
                            dispatched[cid] = true;
                        }
                    }
                }
            }
        };
        var fireMutations = function () {
            var mutations = mutatedElements;
            mutatedElements = null;
            var firstElement = mutations[0][1][0];
            var doc = getDocument() || firstElement.ownerDocument || firstElement;
            var root = doc.contains ? doc : doc.documentElement;
            var dispatched = {
                inserted: {},
                removed: {}
            };
            mutations.forEach(function (mutation) {
                fireOn(mutation[1], root, checks[mutation[0]], mutation[0], dispatched[mutation[0]]);
            });
        };
        var mutated = function (elements, type) {
            if (!getMutationObserver() && elements.length) {
                var firstElement = elements[0];
                var doc = getDocument() || firstElement.ownerDocument || firstElement;
                var root = doc.contains ? doc : doc.documentElement;
                if (checks.inserted(root, firstElement)) {
                    if (!mutatedElements) {
                        mutatedElements = [];
                        setImmediate(fireMutations);
                    }
                    mutatedElements.push([
                        type,
                        elements
                    ]);
                }
            }
        };
        module.exports = namespace.mutate = {
            appendChild: function (child) {
                if (getMutationObserver()) {
                    this.appendChild(child);
                } else {
                    var children;
                    if (child.nodeType === 11) {
                        children = makeArray(childNodes(child));
                    } else {
                        children = [child];
                    }
                    this.appendChild(child);
                    mutated(children, 'inserted');
                }
            },
            insertBefore: function (child, ref, document) {
                if (getMutationObserver()) {
                    this.insertBefore(child, ref);
                } else {
                    var children;
                    if (child.nodeType === 11) {
                        children = makeArray(childNodes(child));
                    } else {
                        children = [child];
                    }
                    this.insertBefore(child, ref);
                    mutated(children, 'inserted');
                }
            },
            removeChild: function (child) {
                if (getMutationObserver()) {
                    this.removeChild(child);
                } else {
                    mutated([child], 'removed');
                    this.removeChild(child);
                }
            },
            replaceChild: function (newChild, oldChild) {
                if (getMutationObserver()) {
                    this.replaceChild(newChild, oldChild);
                } else {
                    var children;
                    if (newChild.nodeType === 11) {
                        children = makeArray(childNodes(newChild));
                    } else {
                        children = [newChild];
                    }
                    mutated([oldChild], 'removed');
                    this.replaceChild(newChild, oldChild);
                    mutated(children, 'inserted');
                }
            },
            inserted: function (elements) {
                mutated(elements, 'inserted');
            },
            removed: function (elements) {
                mutated(elements, 'removed');
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-nodelist@3.1.1#can-view-nodelist*/
define('can-view-nodelist@3.1.1#can-view-nodelist', [
    'require',
    'exports',
    'module',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-namespace',
    'can-util/dom/mutate/mutate',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var namespace = require('can-namespace');
    var domMutate = require('can-util/dom/mutate/mutate');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var nodeMap = new CIDMap(), splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements) {
            var map = new CIDMap();
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map.set(node, replacements[i]);
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap) {
            rMap.forEach(function (replacement) {
                list.newDeepChildren.push(replacement);
            });
        };
    var nodeLists = {
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, rMap = replacementMap(list.replacements), rCount = list.replacements.length;
            while (index < list.length && rCount) {
                var node = list[index], replacement = rMap.get(node);
                if (replacement) {
                    rMap['delete'](node);
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap.get(node);
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap.set(node, list);
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        nodeMap['delete'](node);
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        },
        nodeMap: nodeMap
    };
    module.exports = namespace.nodeLists = nodeLists;
});
/*can-util@3.14.0#dom/fragment/fragment*/
define('can-util@3.14.0#dom/fragment/fragment', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    '../child-nodes/child-nodes',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var childNodes = require('../child-nodes/child-nodes');
        var namespace = require('can-namespace');
        var fragmentRE = /^\s*<(\w+)[^>]*>/, toString = {}.toString, fragment = function (html, name, doc) {
                if (name === undefined) {
                    name = fragmentRE.test(html) && RegExp.$1;
                }
                if (html && toString.call(html.replace) === '[object Function]') {
                    html = html.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, '<$1></$2>');
                }
                var container = doc.createElement('div'), temp = doc.createElement('div');
                if (name === 'tbody' || name === 'tfoot' || name === 'thead' || name === 'colgroup') {
                    temp.innerHTML = '<table>' + html + '</table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
                } else if (name === 'col') {
                    temp.innerHTML = '<table><colgroup>' + html + '</colgroup></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
                } else if (name === 'tr') {
                    temp.innerHTML = '<table><tbody>' + html + '</tbody></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild;
                } else if (name === 'td' || name === 'th') {
                    temp.innerHTML = '<table><tbody><tr>' + html + '</tr></tbody></table>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild.firstChild.firstChild;
                } else if (name === 'option') {
                    temp.innerHTML = '<select>' + html + '</select>';
                    container = temp.firstChild.nodeType === 3 ? temp.lastChild : temp.firstChild;
                } else {
                    container.innerHTML = '' + html;
                }
                var tmp = {}, children = childNodes(container);
                tmp.length = children.length;
                for (var i = 0; i < children.length; i++) {
                    tmp[i] = children[i];
                }
                return [].slice.call(tmp);
            };
        var buildFragment = function (html, doc) {
            if (html && html.nodeType === 11) {
                return html;
            }
            if (!doc) {
                doc = getDocument();
            } else if (doc.length) {
                doc = doc[0];
            }
            var parts = fragment(html, undefined, doc), frag = (doc || document).createDocumentFragment();
            for (var i = 0, length = parts.length; i < length; i++) {
                frag.appendChild(parts[i]);
            }
            return frag;
        };
        module.exports = namespace.fragment = buildFragment;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/frag/frag*/
define('can-util@3.14.0#dom/frag/frag', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    '../fragment/fragment',
    '../../js/each/each',
    '../child-nodes/child-nodes',
    'can-namespace',
    'can-symbol'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var fragment = require('../fragment/fragment');
        var each = require('../../js/each/each');
        var childNodes = require('../child-nodes/child-nodes');
        var namespace = require('can-namespace');
        var canSymbol = require('can-symbol');
        var toDOMSymbol = canSymbol.for('can.toDOM');
        var makeFrag = function (item, doc) {
            var document = doc || getDocument();
            var frag;
            if (!item || typeof item === 'string') {
                frag = fragment(item == null ? '' : '' + item, document);
                if (!frag.firstChild) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            } else if (typeof item[toDOMSymbol] === 'function') {
                return makeFrag(item[toDOMSymbol]());
            } else if (item.nodeType === 11) {
                return item;
            } else if (typeof item.nodeType === 'number') {
                frag = document.createDocumentFragment();
                frag.appendChild(item);
                return frag;
            } else if (typeof item.length === 'number') {
                frag = document.createDocumentFragment();
                each(item, function (item) {
                    frag.appendChild(makeFrag(item));
                });
                if (!childNodes(frag).length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            } else {
                frag = fragment('' + item, document);
                if (!childNodes(frag).length) {
                    frag.appendChild(document.createTextNode(''));
                }
                return frag;
            }
        };
        module.exports = namespace.frag = makeFrag;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/is-of-global-document/is-of-global-document*/
define('can-util@3.14.0#dom/is-of-global-document/is-of-global-document', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getDocument = require('can-globals/document/document');
        var namespace = require('can-namespace');
        module.exports = namespace.isOfGlobalDocument = function (el) {
            return (el.ownerDocument || el) === getDocument();
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/events/make-mutation-event/make-mutation-event*/
define('can-util@3.14.0#dom/events/make-mutation-event/make-mutation-event', [
    'require',
    'exports',
    'module',
    '../events',
    '../../data/data',
    'can-globals/mutation-observer/mutation-observer',
    '../../dispatch/dispatch',
    '../../mutation-observer/document/document',
    'can-globals/document/document',
    'can-cid/map/map',
    '../../../js/string/string',
    '../../is-of-global-document/is-of-global-document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var events = require('../events');
        var domData = require('../../data/data');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var domDispatch = require('../../dispatch/dispatch');
        var mutationDocument = require('../../mutation-observer/document/document');
        var getDocument = require('can-globals/document/document');
        var CIDMap = require('can-cid/map/map');
        var string = require('../../../js/string/string');
        require('../../is-of-global-document/is-of-global-document');
        module.exports = function (specialEventName, mutationNodesProperty) {
            var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
            events.addEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (!specialEventData) {
                        specialEventData = {
                            handler: function (mutatedNode) {
                                if (specialEventData.nodeIdsRespondingToInsert.has(mutatedNode)) {
                                    domDispatch.call(mutatedNode, specialEventName, [], false);
                                    specialEventData.nodeIdsRespondingToInsert.delete(mutatedNode);
                                }
                            },
                            nodeIdsRespondingToInsert: new CIDMap()
                        };
                        mutationDocument['on' + string.capitalize(mutationNodesProperty)](specialEventData.handler);
                        domData.set.call(documentElement, specialEventName + 'Data', specialEventData);
                    }
                    if (this.nodeType !== 11) {
                        var count = specialEventData.nodeIdsRespondingToInsert.get(this) || 0;
                        specialEventData.nodeIdsRespondingToInsert.set(this, count + 1);
                    }
                }
                return originalAdd.apply(this, arguments);
            };
            events.removeEventListener = function (eventName) {
                if (eventName === specialEventName && getMutationObserver()) {
                    var documentElement = getDocument().documentElement;
                    var specialEventData = domData.get.call(documentElement, specialEventName + 'Data');
                    if (specialEventData) {
                        var newCount = specialEventData.nodeIdsRespondingToInsert.get(this) - 1;
                        if (newCount) {
                            specialEventData.nodeIdsRespondingToInsert.set(this, newCount);
                        } else {
                            specialEventData.nodeIdsRespondingToInsert.delete(this);
                        }
                        if (!specialEventData.nodeIdsRespondingToInsert.size) {
                            mutationDocument['off' + string.capitalize(mutationNodesProperty)](specialEventData.handler);
                            domData.clean.call(documentElement, specialEventName + 'Data');
                        }
                    }
                }
                return originalRemove.apply(this, arguments);
            };
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/events/removed/removed*/
define('can-util@3.14.0#dom/events/removed/removed', [
    'require',
    'exports',
    'module',
    '../make-mutation-event/make-mutation-event'
], function (require, exports, module) {
    'use strict';
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('removed', 'removedNodes');
});
/*can-view-live@3.2.6#lib/core*/
define('can-view-live@3.2.6#lib/core', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-util/dom/events/events',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/dom/child-nodes/child-nodes',
    'can-reflect',
    'can-util/dom/events/removed/removed'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var domEvents = require('can-util/dom/events/events');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    require('can-util/dom/events/removed/removed');
    var childMutationCallbacks = {};
    var live = {
        setup: function (el, bind, unbind) {
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvents.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                }, data = {
                    teardownCheck: function (parent) {
                        return parent ? false : teardown();
                    }
                };
            domEvents.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        },
        listen: function (el, compute, change) {
            return live.setup(el, function () {
                canReflect.onValue(compute, change);
            }, function (data) {
                canReflect.offValue(compute, change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        },
        getAttributeParts: function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        },
        isNode: function (obj) {
            return obj && obj.nodeType;
        },
        addTextNodeIfNoChildren: function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        },
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = makeFrag(val);
            nodeLists.register(nodes, teardown);
            nodeLists.update(nodes, childNodes(frag));
            nodeLists.replace(oldNodes, frag);
            return nodes;
        },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        makeString: function (txt) {
            return txt == null ? '' : '' + txt;
        }
    };
    module.exports = live;
});
/*can-util@3.14.0#js/diff/diff*/
define('can-util@3.14.0#js/diff/diff', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var slice = [].slice;
    var defaultIdentity = function (a, b) {
        return a === b;
    };
    function reverseDiff(oldDiffStopIndex, newDiffStopIndex, oldList, newList, identity) {
        var oldIndex = oldList.length - 1, newIndex = newList.length - 1;
        while (oldIndex > oldDiffStopIndex && newIndex > newDiffStopIndex) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex--;
                newIndex--;
                continue;
            } else {
                return [{
                        index: newDiffStopIndex,
                        deleteCount: oldIndex - oldDiffStopIndex + 1,
                        insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
                    }];
            }
        }
        return [{
                index: newDiffStopIndex,
                deleteCount: oldIndex - oldDiffStopIndex + 1,
                insert: slice.call(newList, newDiffStopIndex, newIndex + 1)
            }];
    }
    module.exports = namespace.diff = function (oldList, newList, identity) {
        identity = identity || defaultIdentity;
        var oldIndex = 0, newIndex = 0, oldLength = oldList.length, newLength = newList.length, patches = [];
        while (oldIndex < oldLength && newIndex < newLength) {
            var oldItem = oldList[oldIndex], newItem = newList[newIndex];
            if (identity(oldItem, newItem)) {
                oldIndex++;
                newIndex++;
                continue;
            }
            if (newIndex + 1 < newLength && identity(oldItem, newList[newIndex + 1])) {
                patches.push({
                    index: newIndex,
                    deleteCount: 0,
                    insert: [newList[newIndex]]
                });
                oldIndex++;
                newIndex += 2;
                continue;
            } else if (oldIndex + 1 < oldLength && identity(oldList[oldIndex + 1], newItem)) {
                patches.push({
                    index: newIndex,
                    deleteCount: 1,
                    insert: []
                });
                oldIndex += 2;
                newIndex++;
                continue;
            } else {
                patches.push.apply(patches, reverseDiff(oldIndex, newIndex, oldList, newList, identity));
                return patches;
            }
        }
        if (newIndex === newLength && oldIndex === oldLength) {
            return patches;
        }
        patches.push({
            index: newIndex,
            deleteCount: oldLength - oldIndex,
            insert: slice.call(newList, newIndex)
        });
        return patches;
    };
});
/*can-util@3.14.0#dom/events/attributes/attributes*/
define('can-util@3.14.0#dom/events/attributes/attributes', [
    'require',
    'exports',
    'module',
    '../events',
    '../../is-of-global-document/is-of-global-document',
    '../../data/data',
    'can-globals/mutation-observer/mutation-observer',
    'can-assign',
    '../../dispatch/dispatch'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var events = require('../events');
        var isOfGlobalDocument = require('../../is-of-global-document/is-of-global-document');
        var domData = require('../../data/data');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var assign = require('can-assign');
        var domDispatch = require('../../dispatch/dispatch');
        var originalAdd = events.addEventListener, originalRemove = events.removeEventListener;
        events.addEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                if (isOfGlobalDocument(this) && MutationObserver) {
                    var existingObserver = domData.get.call(this, 'canAttributesObserver');
                    if (!existingObserver) {
                        var self = this;
                        var observer = new MutationObserver(function (mutations) {
                            mutations.forEach(function (mutation) {
                                var copy = assign({}, mutation);
                                domDispatch.call(self, copy, [], false);
                            });
                        });
                        observer.observe(this, {
                            attributes: true,
                            attributeOldValue: true
                        });
                        domData.set.call(this, 'canAttributesObserver', observer);
                    }
                } else {
                    domData.set.call(this, 'canHasAttributesBindings', true);
                }
            }
            return originalAdd.apply(this, arguments);
        };
        events.removeEventListener = function (eventName) {
            if (eventName === 'attributes') {
                var MutationObserver = getMutationObserver();
                var observer;
                if (isOfGlobalDocument(this) && MutationObserver) {
                    observer = domData.get.call(this, 'canAttributesObserver');
                    if (observer && observer.disconnect) {
                        observer.disconnect();
                        domData.clean.call(this, 'canAttributesObserver');
                    }
                } else {
                    domData.clean.call(this, 'canHasAttributesBindings');
                }
            }
            return originalRemove.apply(this, arguments);
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/events/inserted/inserted*/
define('can-util@3.14.0#dom/events/inserted/inserted', [
    'require',
    'exports',
    'module',
    '../make-mutation-event/make-mutation-event'
], function (require, exports, module) {
    'use strict';
    var makeMutationEvent = require('../make-mutation-event/make-mutation-event');
    makeMutationEvent('inserted', 'addedNodes');
});
/*can-util@3.14.0#dom/attr/attr*/
define('can-util@3.14.0#dom/attr/attr', [
    'require',
    'exports',
    'module',
    'can-namespace',
    '../../js/set-immediate/set-immediate',
    'can-globals/document/document',
    'can-globals/global/global',
    '../is-of-global-document/is-of-global-document',
    '../data/data',
    '../contains/contains',
    '../events/events',
    '../dispatch/dispatch',
    'can-globals/mutation-observer/mutation-observer',
    '../../js/each/each',
    'can-types',
    '../../js/diff/diff',
    '../events/attributes/attributes',
    '../events/inserted/inserted'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var setImmediate = require('../../js/set-immediate/set-immediate');
        var getDocument = require('can-globals/document/document');
        var global = require('can-globals/global/global')();
        var isOfGlobalDocument = require('../is-of-global-document/is-of-global-document');
        var setData = require('../data/data');
        var domContains = require('../contains/contains');
        var domEvents = require('../events/events');
        var domDispatch = require('../dispatch/dispatch');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var each = require('../../js/each/each');
        var types = require('can-types');
        var diff = require('../../js/diff/diff');
        require('../events/attributes/attributes');
        require('../events/inserted/inserted');
        var namespaces = { 'xlink': 'http://www.w3.org/1999/xlink' };
        var formElements = {
                'INPUT': true,
                'TEXTAREA': true,
                'SELECT': true
            }, toString = function (value) {
                if (value == null) {
                    return '';
                } else {
                    return '' + value;
                }
            }, isSVG = function (el) {
                return el.namespaceURI === 'http://www.w3.org/2000/svg';
            }, truthy = function () {
                return true;
            }, getSpecialTest = function (special) {
                return special && special.test || truthy;
            }, propProp = function (prop, obj) {
                obj = obj || {};
                obj.get = function () {
                    return this[prop];
                };
                obj.set = function (value) {
                    if (this[prop] !== value) {
                        this[prop] = value;
                    }
                    return value;
                };
                return obj;
            }, booleanProp = function (prop) {
                return {
                    isBoolean: true,
                    set: function (value) {
                        if (prop in this) {
                            this[prop] = value !== false;
                        } else {
                            this.setAttribute(prop, '');
                        }
                    },
                    remove: function () {
                        this[prop] = false;
                    }
                };
            }, setupMO = function (el, callback) {
                var attrMO = setData.get.call(el, 'attrMO');
                if (!attrMO) {
                    var onMutation = function () {
                        callback.call(el);
                    };
                    var MO = getMutationObserver();
                    if (MO) {
                        var observer = new MO(onMutation);
                        observer.observe(el, {
                            childList: true,
                            subtree: true
                        });
                        setData.set.call(el, 'attrMO', observer);
                    } else {
                        setData.set.call(el, 'attrMO', true);
                        setData.set.call(el, 'canBindingCallback', { onMutation: onMutation });
                    }
                }
            }, _findOptionToSelect = function (parent, value) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION' && value === child.value) {
                        return child;
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        var groupChild = _findOptionToSelect(child, value);
                        if (groupChild) {
                            return groupChild;
                        }
                    }
                    child = child.nextSibling;
                }
            }, setChildOptions = function (el, value) {
                var option;
                if (value != null) {
                    option = _findOptionToSelect(el, value);
                }
                if (option) {
                    option.selected = true;
                } else {
                    el.selectedIndex = -1;
                }
            }, forEachOption = function (parent, fn) {
                var child = parent.firstChild;
                while (child) {
                    if (child.nodeName === 'OPTION') {
                        fn(child);
                    }
                    if (child.nodeName === 'OPTGROUP') {
                        forEachOption(child, fn);
                    }
                    child = child.nextSibling;
                }
            }, collectSelectedOptions = function (parent) {
                var selectedValues = [];
                forEachOption(parent, function (option) {
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                });
                return selectedValues;
            }, markSelectedOptions = function (parent, values) {
                forEachOption(parent, function (option) {
                    option.selected = values.indexOf(option.value) !== -1;
                });
            }, setChildOptionsOnChange = function (select, aEL) {
                var handler = setData.get.call(select, 'attrSetChildOptions');
                if (handler) {
                    return Function.prototype;
                }
                handler = function () {
                    setChildOptions(select, select.value);
                };
                setData.set.call(select, 'attrSetChildOptions', handler);
                aEL.call(select, 'change', handler);
                return function (rEL) {
                    setData.clean.call(select, 'attrSetChildOptions');
                    rEL.call(select, 'change', handler);
                };
            }, attr = {
                special: {
                    checked: {
                        get: function () {
                            return this.checked;
                        },
                        set: function (val) {
                            var notFalse = !!val || val === '' || arguments.length === 0;
                            this.checked = notFalse;
                            if (notFalse && this.type === 'radio') {
                                this.defaultChecked = true;
                            }
                            return val;
                        },
                        remove: function () {
                            this.checked = false;
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'class': {
                        get: function () {
                            if (isSVG(this)) {
                                return this.getAttribute('class');
                            }
                            return this.className;
                        },
                        set: function (val) {
                            val = val || '';
                            if (isSVG(this)) {
                                this.setAttribute('class', '' + val);
                            } else {
                                this.className = val;
                            }
                            return val;
                        }
                    },
                    disabled: booleanProp('disabled'),
                    focused: {
                        get: function () {
                            return this === document.activeElement;
                        },
                        set: function (val) {
                            var cur = attr.get(this, 'focused');
                            var docEl = this.ownerDocument.documentElement;
                            var element = this;
                            function focusTask() {
                                if (val) {
                                    element.focus();
                                } else {
                                    element.blur();
                                }
                            }
                            if (cur !== val) {
                                if (!domContains.call(docEl, element)) {
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(element, 'inserted', initialSetHandler);
                                        focusTask();
                                    };
                                    domEvents.addEventListener.call(element, 'inserted', initialSetHandler);
                                } else {
                                    types.queueTask([
                                        focusTask,
                                        this,
                                        []
                                    ]);
                                }
                            }
                            return !!val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            aEL.call(this, 'focus', handler);
                            aEL.call(this, 'blur', handler);
                            return function (rEL) {
                                rEL.call(this, 'focus', handler);
                                rEL.call(this, 'blur', handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'INPUT';
                        }
                    },
                    'for': propProp('htmlFor'),
                    innertext: propProp('innerText'),
                    innerhtml: propProp('innerHTML'),
                    innerHTML: propProp('innerHTML', {
                        addEventListener: function (eventName, handler, aEL) {
                            var handlers = [];
                            var el = this;
                            each([
                                'change',
                                'blur'
                            ], function (eventName) {
                                var localHandler = function () {
                                    handler.apply(this, arguments);
                                };
                                domEvents.addEventListener.call(el, eventName, localHandler);
                                handlers.push([
                                    eventName,
                                    localHandler
                                ]);
                            });
                            return function (rEL) {
                                each(handlers, function (info) {
                                    rEL.call(el, info[0], info[1]);
                                });
                            };
                        }
                    }),
                    required: booleanProp('required'),
                    readonly: booleanProp('readOnly'),
                    selected: {
                        get: function () {
                            return this.selected;
                        },
                        set: function (val) {
                            val = !!val;
                            setData.set.call(this, 'lastSetValue', val);
                            return this.selected = val;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var option = this;
                            var select = this.parentNode;
                            var lastVal = option.selected;
                            var localHandler = function (changeEvent) {
                                var curVal = option.selected;
                                lastVal = setData.get.call(option, 'lastSetValue') || lastVal;
                                if (curVal !== lastVal) {
                                    lastVal = curVal;
                                    domDispatch.call(option, eventName);
                                }
                            };
                            var removeChangeHandler = setChildOptionsOnChange(select, aEL);
                            domEvents.addEventListener.call(select, 'change', localHandler);
                            aEL.call(option, eventName, handler);
                            return function (rEL) {
                                removeChangeHandler(rEL);
                                domEvents.removeEventListener.call(select, 'change', localHandler);
                                rEL.call(option, eventName, handler);
                            };
                        },
                        test: function () {
                            return this.nodeName === 'OPTION' && this.parentNode && this.parentNode.nodeName === 'SELECT';
                        }
                    },
                    src: {
                        set: function (val) {
                            if (val == null || val === '') {
                                this.removeAttribute('src');
                                return null;
                            } else {
                                this.setAttribute('src', val);
                                return val;
                            }
                        }
                    },
                    style: {
                        set: function () {
                            var el = global.document && getDocument().createElement('div');
                            if (el && el.style && 'cssText' in el.style) {
                                return function (val) {
                                    return this.style.cssText = val || '';
                                };
                            } else {
                                return function (val) {
                                    return this.setAttribute('style', val);
                                };
                            }
                        }()
                    },
                    textcontent: propProp('textContent'),
                    value: {
                        get: function () {
                            var value = this.value;
                            if (this.nodeName === 'SELECT') {
                                if ('selectedIndex' in this && this.selectedIndex === -1) {
                                    value = undefined;
                                }
                            }
                            return value;
                        },
                        set: function (value) {
                            var nodeName = this.nodeName.toLowerCase();
                            if (nodeName === 'input' || nodeName === 'textarea') {
                                value = toString(value);
                            }
                            if (this.value !== value || nodeName === 'option') {
                                this.value = value;
                            }
                            if (attr.defaultValue[nodeName]) {
                                this.defaultValue = value;
                            }
                            if (nodeName === 'select') {
                                setData.set.call(this, 'attrValueLastVal', value);
                                setChildOptions(this, value === null ? value : this.value);
                                var docEl = this.ownerDocument.documentElement;
                                if (!domContains.call(docEl, this)) {
                                    var select = this;
                                    var initialSetHandler = function () {
                                        domEvents.removeEventListener.call(select, 'inserted', initialSetHandler);
                                        setChildOptions(select, value === null ? value : select.value);
                                    };
                                    domEvents.addEventListener.call(this, 'inserted', initialSetHandler);
                                }
                                setupMO(this, function () {
                                    var value = setData.get.call(this, 'attrValueLastVal');
                                    attr.set(this, 'value', value);
                                    domDispatch.call(this, 'change');
                                });
                            }
                            return value;
                        },
                        test: function () {
                            return formElements[this.nodeName];
                        }
                    },
                    values: {
                        get: function () {
                            return collectSelectedOptions(this);
                        },
                        set: function (values) {
                            values = values || [];
                            markSelectedOptions(this, values);
                            setData.set.call(this, 'stickyValues', attr.get(this, 'values'));
                            setupMO(this, function () {
                                var previousValues = setData.get.call(this, 'stickyValues');
                                attr.set(this, 'values', previousValues);
                                var currentValues = setData.get.call(this, 'stickyValues');
                                var changes = diff(previousValues.slice().sort(), currentValues.slice().sort());
                                if (changes.length) {
                                    domDispatch.call(this, 'values');
                                }
                            });
                            return values;
                        },
                        addEventListener: function (eventName, handler, aEL) {
                            var localHandler = function () {
                                domDispatch.call(this, 'values');
                            };
                            domEvents.addEventListener.call(this, 'change', localHandler);
                            aEL.call(this, eventName, handler);
                            return function (rEL) {
                                domEvents.removeEventListener.call(this, 'change', localHandler);
                                rEL.call(this, eventName, handler);
                            };
                        }
                    }
                },
                defaultValue: {
                    input: true,
                    textarea: true
                },
                setAttrOrProp: function (el, attrName, val) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    if (special && special.isBoolean && !val) {
                        this.remove(el, attrName);
                    } else {
                        this.set(el, attrName, val);
                    }
                },
                set: function (el, attrName, val) {
                    var usingMutationObserver = isOfGlobalDocument(el) && getMutationObserver();
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!usingMutationObserver) {
                        oldValue = attr.get(el, attrName);
                    }
                    var newValue;
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var test = getSpecialTest(special);
                    if (typeof setter === 'function' && test.call(el)) {
                        if (arguments.length === 2) {
                            newValue = setter.call(el);
                        } else {
                            newValue = setter.call(el, val);
                        }
                    } else {
                        attr.setAttribute(el, attrName, val);
                    }
                    if (!usingMutationObserver && newValue !== oldValue) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                setSelectValue: function (el, value) {
                    attr.set(el, 'value', value);
                },
                setAttribute: function () {
                    var doc = getDocument();
                    if (doc && document.createAttribute) {
                        try {
                            doc.createAttribute('{}');
                        } catch (e) {
                            var invalidNodes = {}, attributeDummy = document.createElement('div');
                            return function (el, attrName, val) {
                                var first = attrName.charAt(0), cachedNode, node, attr;
                                if ((first === '{' || first === '(' || first === '*') && el.setAttributeNode) {
                                    cachedNode = invalidNodes[attrName];
                                    if (!cachedNode) {
                                        attributeDummy.innerHTML = '<div ' + attrName + '=""></div>';
                                        cachedNode = invalidNodes[attrName] = attributeDummy.childNodes[0].attributes[0];
                                    }
                                    node = cachedNode.cloneNode();
                                    node.value = val;
                                    el.setAttributeNode(node);
                                } else {
                                    attr = attrName.split(':');
                                    if (attr.length !== 1 && namespaces[attr[0]]) {
                                        el.setAttributeNS(namespaces[attr[0]], attrName, val);
                                    } else {
                                        el.setAttribute(attrName, val);
                                    }
                                }
                            };
                        }
                    }
                    return function (el, attrName, val) {
                        el.setAttribute(attrName, val);
                    };
                }(),
                trigger: function (el, attrName, oldValue) {
                    if (setData.get.call(el, 'canHasAttributesBindings')) {
                        attrName = attrName.toLowerCase();
                        return setImmediate(function () {
                            domDispatch.call(el, {
                                type: 'attributes',
                                attributeName: attrName,
                                target: el,
                                oldValue: oldValue,
                                bubbles: false
                            }, []);
                        });
                    }
                },
                get: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var special = attr.special[attrName];
                    var getter = special && special.get;
                    var test = getSpecialTest(special);
                    if (typeof getter === 'function' && test.call(el)) {
                        return getter.call(el);
                    } else {
                        return el.getAttribute(attrName);
                    }
                },
                remove: function (el, attrName) {
                    attrName = attrName.toLowerCase();
                    var oldValue;
                    if (!getMutationObserver()) {
                        oldValue = attr.get(el, attrName);
                    }
                    var special = attr.special[attrName];
                    var setter = special && special.set;
                    var remover = special && special.remove;
                    var test = getSpecialTest(special);
                    if (typeof remover === 'function' && test.call(el)) {
                        remover.call(el);
                    } else if (typeof setter === 'function' && test.call(el)) {
                        setter.call(el, undefined);
                    } else {
                        el.removeAttribute(attrName);
                    }
                    if (!getMutationObserver() && oldValue != null) {
                        attr.trigger(el, attrName, oldValue);
                    }
                },
                has: function () {
                    var el = getDocument() && document.createElement('div');
                    if (el && el.hasAttribute) {
                        return function (el, name) {
                            return el.hasAttribute(name);
                        };
                    } else {
                        return function (el, name) {
                            return el.getAttribute(name) !== null;
                        };
                    }
                }()
            };
        var oldAddEventListener = domEvents.addEventListener;
        domEvents.addEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardown = special.addEventListener.call(this, eventName, handler, oldAddEventListener);
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (!teardowns) {
                    setData.set.call(this, 'attrTeardowns', teardowns = {});
                }
                if (!teardowns[eventName]) {
                    teardowns[eventName] = [];
                }
                teardowns[eventName].push({
                    teardown: teardown,
                    handler: handler
                });
                return;
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        domEvents.removeEventListener = function (eventName, handler) {
            var special = attr.special[eventName];
            if (special && special.addEventListener) {
                var teardowns = setData.get.call(this, 'attrTeardowns');
                if (teardowns && teardowns[eventName]) {
                    var eventTeardowns = teardowns[eventName];
                    for (var i = 0, len = eventTeardowns.length; i < len; i++) {
                        if (eventTeardowns[i].handler === handler) {
                            eventTeardowns[i].teardown.call(this, oldRemoveEventListener);
                            eventTeardowns.splice(i, 1);
                            break;
                        }
                    }
                    if (eventTeardowns.length === 0) {
                        delete teardowns[eventName];
                    }
                }
                return;
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        module.exports = namespace.attr = attr;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-live@3.2.6#lib/attr*/
define('can-view-live@3.2.6#lib/attr', [
    'require',
    'exports',
    'module',
    'can-util/dom/attr/attr',
    './core',
    'can-reflect'
], function (require, exports, module) {
    var attr = require('can-util/dom/attr/attr');
    var live = require('./core');
    var canReflect = require('can-reflect');
    live.attr = function (el, attributeName, compute) {
        live.listen(el, compute, function (newVal) {
            attr.set(el, attributeName, newVal);
        });
        attr.set(el, attributeName, canReflect.getValue(compute));
    };
});
/*can-util@3.14.0#js/global/global*/
define('can-util@3.14.0#js/global/global', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        module.exports = namespace.global = require('can-globals/global/global');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-callbacks@3.2.5#can-view-callbacks*/
define('can-view-callbacks@3.2.5#can-view-callbacks', [
    'require',
    'exports',
    'module',
    'can-observation',
    'can-util/js/dev/dev',
    'can-util/js/global/global',
    'can-util/dom/mutate/mutate',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Observation = require('can-observation');
        var dev = require('can-util/js/dev/dev');
        var getGlobal = require('can-util/js/global/global');
        var domMutate = require('can-util/dom/mutate/mutate');
        var namespace = require('can-namespace');
        var attr = function (attributeName, attrHandler) {
            if (attrHandler) {
                if (typeof attributeName === 'string') {
                    attributes[attributeName] = attrHandler;
                } else {
                    regExpAttributes.push({
                        match: attributeName,
                        handler: attrHandler
                    });
                }
            } else {
                var cb = attributes[attributeName];
                if (!cb) {
                    for (var i = 0, len = regExpAttributes.length; i < len; i++) {
                        var attrMatcher = regExpAttributes[i];
                        if (attrMatcher.match.test(attributeName)) {
                            return attrMatcher.handler;
                        }
                    }
                }
                return cb;
            }
        };
        var attributes = {}, regExpAttributes = [], automaticCustomElementCharacters = /[-\:]/;
        var defaultCallback = function () {
        };
        var tag = function (tagName, tagHandler) {
            if (tagHandler) {
                var GLOBAL = getGlobal();
                if (GLOBAL.html5) {
                    GLOBAL.html5.elements += ' ' + tagName;
                    GLOBAL.html5.shivDocument();
                }
                tags[tagName.toLowerCase()] = tagHandler;
            } else {
                var cb;
                if (tagHandler === null) {
                    delete tags[tagName.toLowerCase()];
                } else {
                    cb = tags[tagName.toLowerCase()];
                }
                if (!cb && automaticCustomElementCharacters.test(tagName)) {
                    cb = defaultCallback;
                }
                return cb;
            }
        };
        var tags = {};
        var callbacks = {
            _tags: tags,
            _attributes: attributes,
            _regExpAttributes: regExpAttributes,
            defaultCallback: defaultCallback,
            tag: tag,
            attr: attr,
            tagHandler: function (el, tagName, tagData) {
                var helperTagCallback = tagData.options.get('tags.' + tagName, { proxyMethods: false }), tagCallback = helperTagCallback || tags[tagName];
                var scope = tagData.scope, res;
                if (tagCallback) {
                    res = Observation.ignore(tagCallback)(el, tagData);
                } else {
                    res = scope;
                }
                if (res && tagData.subtemplate) {
                    if (scope !== res) {
                        scope = scope.add(res);
                    }
                    var result = tagData.subtemplate(scope, tagData.options);
                    var frag = typeof result === 'string' ? can.view.frag(result) : result;
                    domMutate.appendChild.call(el, frag);
                }
            }
        };
        namespace.view = namespace.view || {};
        if (namespace.view.callbacks) {
            throw new Error('You can\'t have two versions of can-view-callbacks, check your dependencies');
        } else {
            module.exports = namespace.view.callbacks = callbacks;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-live@3.2.6#lib/attrs*/
define('can-view-live@3.2.6#lib/attrs', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-callbacks',
    'can-util/dom/attr/attr',
    'can-util/dom/events/events',
    'can-types',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var viewCallbacks = require('can-view-callbacks');
    var attr = require('can-util/dom/attr/attr');
    var domEvents = require('can-util/dom/events/events');
    var types = require('can-types');
    var canReflect = require('can-reflect');
    live.attrs = function (el, compute, scope, options) {
        if (!canReflect.isObservableLike(compute)) {
            var attrs = live.getAttributeParts(compute);
            for (var name in attrs) {
                attr.set(el, name, attrs[name]);
            }
            return;
        }
        var oldAttrs = {};
        var setAttrs = function (newVal) {
            var newAttrs = live.getAttributeParts(newVal), name;
            for (name in newAttrs) {
                var newValue = newAttrs[name], oldValue = oldAttrs[name];
                if (newValue !== oldValue) {
                    attr.set(el, name, newValue);
                    var callback = viewCallbacks.attr(name);
                    if (callback) {
                        callback(el, {
                            attributeName: name,
                            scope: scope,
                            options: options
                        });
                    }
                }
                delete oldAttrs[name];
            }
            for (name in oldAttrs) {
                attr.remove(el, name);
            }
            oldAttrs = newAttrs;
        };
        var handler = function (newVal) {
            setAttrs(newVal);
        };
        canReflect.onValue(compute, handler);
        var teardownHandler = function () {
            canReflect.offValue(compute, handler);
            domEvents.removeEventListener.call(el, 'removed', teardownHandler);
        };
        domEvents.addEventListener.call(el, 'removed', teardownHandler);
        setAttrs(canReflect.getValue(compute));
    };
});
/*can-view-live@3.2.6#lib/html*/
define('can-view-live@3.2.6#lib/html', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-util/dom/frag/frag',
    'can-util/js/make-array/make-array',
    'can-util/dom/child-nodes/child-nodes',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var makeFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var canReflect = require('can-reflect');
    live.html = function (el, compute, parentNode, nodeList) {
        var data, makeAndPut, nodes;
        parentNode = live.getParentNode(el, parentNode);
        data = live.listen(parentNode, compute, function (newVal) {
            var attached = nodeLists.first(nodes).parentNode;
            if (attached) {
                makeAndPut(newVal);
            }
            var pn = nodeLists.first(nodes).parentNode;
            data.teardownCheck(pn);
            live.callChildMutationCallback(pn);
        });
        nodes = nodeList || [el];
        makeAndPut = function (val) {
            var isFunction = typeof val === 'function', frag = makeFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
            live.addTextNodeIfNoChildren(frag);
            oldNodes = nodeLists.update(nodes, childNodes(frag));
            if (isFunction) {
                val(frag.firstChild);
            }
            nodeLists.replace(oldNodes, frag);
        };
        data.nodeList = nodes;
        if (!nodeList) {
            nodeLists.register(nodes, data.teardownCheck);
        } else {
            nodeList.unregistered = data.teardownCheck;
        }
        makeAndPut(canReflect.getValue(compute));
    };
});
/*can-view-live@3.2.6#lib/util/queueFns*/
define('can-view-live@3.2.6#lib/util/queueFns', [
    'require',
    'exports',
    'module',
    'can-observation'
], function (require, exports, module) {
    var Observation = require('can-observation');
    module.exports = function queueFns(fns, primaryDepth) {
        var updateQueue = [], queuedFns = {};
        var updateQueueObservation = {
            needsUpdate: false,
            update: function () {
                for (var i = 0; i < updateQueue.length; i++) {
                    var obj = updateQueue[i];
                    obj.fn.apply(obj.context, obj.args);
                }
                updateQueue = [];
            },
            getPrimaryDepth: function () {
                return primaryDepth || 0;
            }
        };
        var wrapFn = function (fn) {
            return function () {
                updateQueue.push({
                    fn: fn,
                    context: this,
                    args: arguments
                });
                updateQueueObservation.needsUpdate = false;
                Observation.registerUpdate(updateQueueObservation);
            };
        };
        for (var key in fns) {
            queuedFns[key] = wrapFn(fns[key]);
        }
        queuedFns.clear = function () {
            updateQueue = [];
        };
        return queuedFns;
    };
});
/*can-view-live@3.2.6#lib/list*/
define('can-view-live@3.2.6#lib/list', [
    'require',
    'exports',
    'module',
    './core',
    './util/queueFns',
    'can-view-nodelist',
    'can-compute',
    'can-event/batch/batch',
    'can-util/dom/frag/frag',
    'can-util/dom/mutate/mutate',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-util/js/is-function/is-function',
    'can-util/js/diff/diff',
    'can-compute/proto-compute',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var queueFns = require('./util/queueFns');
    var nodeLists = require('can-view-nodelist');
    var makeCompute = require('can-compute');
    var canBatch = require('can-event/batch/batch');
    var frag = require('can-util/dom/frag/frag');
    var domMutate = require('can-util/dom/mutate/mutate');
    var childNodes = require('can-util/dom/child-nodes/child-nodes');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var diff = require('can-util/js/diff/diff');
    var splice = [].splice;
    var Compute = require('can-compute/proto-compute');
    var canReflect = require('can-reflect');
    var renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, true, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = frag(itemHTML);
            var children = makeArray(childNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, children);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(children));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                nodeLists.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        };
    live.list = function (el, compute, render, context, parentNode, nodeList, falseyRender) {
        var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = function add(ev, items, index) {
                if (!afterPreviousEvents) {
                    return;
                }
                var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                each(items, function (item, key) {
                    var itemIndex = new Compute(key + index), itemCompute = new Compute(function (newVal) {
                            if (arguments.length) {
                                if ('set' in list) {
                                    list.set(itemIndex.get(), newVal);
                                } else {
                                    list.attr(itemIndex.get(), newVal);
                                }
                            } else {
                                return item;
                            }
                        }), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                            itemCompute,
                            itemIndex
                        ]);
                    frag.appendChild(itemFrag);
                    newIndicies.push(itemIndex);
                });
                var masterListIndex = index + 1;
                if (!indexMap.length) {
                    var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                    nodeLists.remove(falseyItemsToRemove);
                }
                if (!masterNodeList[masterListIndex]) {
                    nodeLists.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                } else {
                    var el = nodeLists.first(masterNodeList[masterListIndex]);
                    domMutate.insertBefore.call(el.parentNode, frag, el);
                }
                splice.apply(masterNodeList, [
                    masterListIndex,
                    0
                ].concat(newNodeLists));
                splice.apply(indexMap, [
                    index,
                    0
                ].concat(newIndicies));
                for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                    indexMap[i].set(i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            }, set = function set(ev, newVal, index) {
                remove({}, { length: 1 }, index, true);
                add({}, [newVal], index);
            }, remove = function remove(ev, items, index, duringTeardown, fullTeardown) {
                if (!afterPreviousEvents) {
                    return;
                }
                if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                    return;
                }
                if (index < 0) {
                    index = indexMap.length + index;
                }
                var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                indexMap.splice(index, items.length);
                for (var i = index, len = indexMap.length; i < len; i++) {
                    indexMap[i].set(i);
                }
                if (!fullTeardown) {
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    nodeLists.remove(itemsToRemove);
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                } else {
                    nodeLists.unregister(masterNodeList);
                }
            }, move = function move(ev, item, newIndex, currentIndex) {
                if (!afterPreviousEvents) {
                    return;
                }
                newIndex = newIndex + 1;
                currentIndex = currentIndex + 1;
                var referenceNodeList = masterNodeList[newIndex];
                var movedElements = frag(nodeLists.flatten(masterNodeList[currentIndex]));
                var referenceElement;
                if (currentIndex < newIndex) {
                    referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                } else {
                    referenceElement = nodeLists.first(referenceNodeList);
                }
                var parentNode = masterNodeList[0].parentNode;
                parentNode.insertBefore(movedElements, referenceElement);
                var temp = masterNodeList[currentIndex];
                [].splice.apply(masterNodeList, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(masterNodeList, [
                    newIndex,
                    0,
                    temp
                ]);
                newIndex = newIndex - 1;
                currentIndex = currentIndex - 1;
                var indexCompute = indexMap[currentIndex];
                [].splice.apply(indexMap, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(indexMap, [
                    newIndex,
                    0,
                    indexCompute
                ]);
                var i = Math.min(currentIndex, newIndex);
                var len = indexMap.length;
                for (i, len; i < len; i++) {
                    indexMap[i].set(i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            }, queuedFns = queueFns({
                add: add,
                set: set,
                remove: remove,
                move: move
            }, nodeList && nodeList.nesting), text = el.ownerDocument.createTextNode(''), list, teardownList = function (fullTeardown) {
                if (list && list.removeEventListener) {
                    list.removeEventListener('add', queuedFns.add);
                    list.removeEventListener('set', queuedFns.set);
                    list.removeEventListener('remove', queuedFns.remove);
                    list.removeEventListener('move', queuedFns.move);
                }
                remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
                queuedFns.clear();
            }, oldList, updateList = function (newList) {
                if (isTornDown) {
                    return;
                }
                afterPreviousEvents = true;
                if (newList && oldList) {
                    list = newList || [];
                    var patches = diff(oldList, newList);
                    if (oldList.removeEventListener) {
                        oldList.removeEventListener('add', queuedFns.add);
                        oldList.removeEventListener('set', queuedFns.set);
                        oldList.removeEventListener('remove', queuedFns.remove);
                        oldList.removeEventListener('move', queuedFns.move);
                    }
                    oldList = newList;
                    for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                        var patch = patches[i];
                        if (patch.deleteCount) {
                            remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                        }
                        if (patch.insert.length) {
                            add({ callChildMutationCallback: false }, patch.insert, patch.index);
                        }
                    }
                } else {
                    if (oldList) {
                        teardownList();
                    }
                    list = newList || [];
                    oldList = list;
                    add({ callChildMutationCallback: false }, list, 0);
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                }
                live.callChildMutationCallback(text.parentNode);
                afterPreviousEvents = false;
                if (list.addEventListener) {
                    list.addEventListener('add', queuedFns.add);
                    list.addEventListener('set', queuedFns.set);
                    list.addEventListener('remove', queuedFns.remove);
                    list.addEventListener('move', queuedFns.move);
                }
                canBatch.afterPreviousEvents(function () {
                    afterPreviousEvents = true;
                });
            };
        var isValueLike = canReflect.isValueLike(compute), isObservableLike = canReflect.isObservableLike(compute);
        parentNode = live.getParentNode(el, parentNode);
        var data = live.setup(parentNode, function () {
            if (isValueLike && isObservableLike) {
                canReflect.onValue(compute, updateList);
            }
        }, function () {
            if (isValueLike && isObservableLike) {
                canReflect.offValue(compute, updateList);
            }
            teardownList(true);
        });
        if (!nodeList) {
            live.replace(masterNodeList, text, data.teardownCheck);
        } else {
            nodeLists.replace(masterNodeList, text);
            nodeLists.update(masterNodeList, [text]);
            nodeList.unregistered = function () {
                data.teardownCheck();
                isTornDown = true;
            };
        }
        updateList(isValueLike ? canReflect.getValue(compute) : compute);
    };
});
/*can-view-live@3.2.6#lib/text*/
define('can-view-live@3.2.6#lib/text', [
    'require',
    'exports',
    'module',
    './core',
    'can-view-nodelist',
    'can-reflect'
], function (require, exports, module) {
    var live = require('./core');
    var nodeLists = require('can-view-nodelist');
    var canReflect = require('can-reflect');
    live.text = function (el, compute, parentNode, nodeList) {
        var parent = live.getParentNode(el, parentNode);
        var data = live.listen(parent, compute, function (newVal) {
            if (typeof node.nodeValue !== 'unknown') {
                node.nodeValue = live.makeString(newVal);
            }
        });
        var node = el.ownerDocument.createTextNode(live.makeString(canReflect.getValue(compute)));
        if (nodeList) {
            nodeList.unregistered = data.teardownCheck;
            data.nodeList = nodeList;
            nodeLists.update(nodeList, [node]);
            nodeLists.replace([el], node);
        } else {
            data.nodeList = live.replace([el], node, data.teardownCheck);
        }
    };
});
/*can-view-live@3.2.6#can-view-live*/
define('can-view-live@3.2.6#can-view-live', [
    'require',
    'exports',
    'module',
    './lib/core',
    './lib/attr',
    './lib/attrs',
    './lib/html',
    './lib/list',
    './lib/text'
], function (require, exports, module) {
    var live = require('./lib/core');
    require('./lib/attr');
    require('./lib/attrs');
    require('./lib/html');
    require('./lib/list');
    require('./lib/text');
    module.exports = live;
});
/*can-stache@3.15.0#src/utils*/
define('can-stache@3.15.0#src/utils', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-observation',
    'can-stache-key',
    'can-compute',
    'can-reflect',
    'can-log/dev/dev',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/each/each',
    'can-util/js/is-array-like/is-array-like'
], function (require, exports, module) {
    var Scope = require('can-view-scope');
    var Observation = require('can-observation');
    var observationReader = require('can-stache-key');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var dev = require('can-log/dev/dev');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var each = require('can-util/js/each/each');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var Options = Scope.Options;
    var noop = function () {
    };
    module.exports = {
        isArrayLike: isArrayLike,
        emptyHandler: function () {
        },
        jsonParse: function (str) {
            if (str[0] === '\'') {
                return str.substr(1, str.length - 2);
            } else if (str === 'undefined') {
                return undefined;
            } else {
                return JSON.parse(str);
            }
        },
        mixins: {
            last: function () {
                return this.stack[this.stack.length - 1];
            },
            add: function (chars) {
                this.last().add(chars);
            },
            subSectionDepth: function () {
                return this.stack.length - 1;
            }
        },
        convertToScopes: function (helperOptions, scope, options, nodeList, truthyRenderer, falseyRenderer, isStringOnly) {
            helperOptions.fn = truthyRenderer ? this.makeRendererConvertScopes(truthyRenderer, scope, options, nodeList, isStringOnly) : noop;
            helperOptions.inverse = falseyRenderer ? this.makeRendererConvertScopes(falseyRenderer, scope, options, nodeList, isStringOnly) : noop;
            helperOptions.isSection = !!(truthyRenderer || falseyRenderer);
        },
        makeRendererConvertScopes: function (renderer, parentScope, parentOptions, nodeList, observeObservables) {
            var rendererWithScope = function (ctx, opts, parentNodeList) {
                return renderer(ctx || parentScope, opts, parentNodeList);
            };
            var convertedRenderer = function (newScope, newOptions, parentNodeList) {
                if (newScope !== undefined && !(newScope instanceof Scope)) {
                    if (parentScope) {
                        newScope = parentScope.add(newScope);
                    } else {
                        newScope = Scope.refsScope().add(newScope || {});
                    }
                }
                if (newOptions !== undefined && !(newOptions instanceof Options)) {
                    newOptions = parentOptions.add(newOptions);
                }
                var result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);
                return result;
            };
            return observeObservables ? convertedRenderer : Observation.ignore(convertedRenderer);
        },
        getItemsStringContent: function (items, isObserveList, helperOptions, options) {
            var txt = '', len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items);
            for (var i = 0; i < len; i++) {
                var item = isObservable ? compute(items, '' + i) : items[i];
                txt += helperOptions.fn(item, options);
            }
            return txt;
        },
        getItemsFragContent: function (items, helperOptions, scope, asVariable) {
            var result = [], len = observationReader.get(items, 'length'), isObservable = canReflect.isObservableLike(items), hashExprs = helperOptions.exprData && helperOptions.exprData.hashExprs, hashOptions;
            if (!isEmptyObject(hashExprs)) {
                hashOptions = {};
                each(hashExprs, function (exprs, key) {
                    hashOptions[exprs.key] = key;
                });
            }
            for (var i = 0; i < len; i++) {
                var aliases = {
                    '%index': i,
                    '@index': i
                };
                var item = isObservable ? compute(items, '' + i) : items[i];
                if (asVariable) {
                    aliases[asVariable] = item;
                }
                if (!isEmptyObject(hashOptions)) {
                    if (hashOptions.value) {
                        aliases[hashOptions.value] = item;
                    }
                    if (hashOptions.index) {
                        aliases[hashOptions.index] = i;
                    }
                }
                result.push(helperOptions.fn(scope.add(aliases, { notContext: true }).add({ index: i }, { special: true }).add(item)));
            }
            return result;
        },
        Options: Options
    };
});
/*can-globals@1.2.0#base-url/base-url*/
define('can-globals@1.2.0#base-url/base-url', [
    'require',
    'exports',
    'module',
    '../can-globals-instance',
    '../global/global',
    '../document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('../can-globals-instance');
        require('../global/global');
        require('../document/document');
        globals.define('base-url', function () {
            var global = globals.getKeyValue('global');
            var domDocument = globals.getKeyValue('document');
            if (domDocument && 'baseURI' in domDocument) {
                return domDocument.baseURI;
            } else if (global.location) {
                var href = global.location.href;
                var lastSlash = href.lastIndexOf('/');
                return lastSlash !== -1 ? href.substr(0, lastSlash) : href;
            } else if (typeof process !== 'undefined') {
                return process.cwd();
            }
        });
        module.exports = globals.makeExport('base-url');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/base-url/base-url*/
define('can-util@3.14.0#js/base-url/base-url', [
    'require',
    'exports',
    'module',
    'can-globals/base-url/base-url'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        module.exports = require('can-globals/base-url/base-url');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-parse-uri@1.2.0#can-parse-uri*/
define('can-parse-uri@1.2.0#can-parse-uri', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.parseURI = function (url) {
        var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || '',
            protocol: m[1] || '',
            authority: m[2] || '',
            host: m[3] || '',
            hostname: m[4] || '',
            port: m[5] || '',
            pathname: m[6] || '',
            search: m[7] || '',
            hash: m[8] || ''
        } : null;
    };
});
/*can-util@3.14.0#js/join-uris/join-uris*/
define('can-util@3.14.0#js/join-uris/join-uris', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-parse-uri'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var parseURI = require('can-parse-uri');
    module.exports = namespace.joinURIs = function (base, href) {
        function removeDotSegments(input) {
            var output = [];
            input.replace(/^(\.\.?(\/|$))+/, '').replace(/\/(\.(\/|$))+/g, '/').replace(/\/\.\.$/, '/../').replace(/\/?[^\/]*/g, function (p) {
                if (p === '/..') {
                    output.pop();
                } else {
                    output.push(p);
                }
            });
            return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
        }
        href = parseURI(href || '');
        base = parseURI(base || '');
        return !href || !base ? null : (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : href.pathname ? (base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash;
    };
});
/*can-stache@3.15.0#helpers/-debugger*/
define('can-stache@3.15.0#helpers/-debugger', [
    'require',
    'exports',
    'module',
    'can-log'
], function (require, exports, module) {
    var canLog = require('can-log');
    function noop() {
    }
    ;
    var resolveValue = noop;
    var evaluateArgs = noop;
    var __testing = {};
    function debuggerHelper(left, right) {
        canLog.warn('Forgotten {{debugger}} helper');
    }
    module.exports = {
        helper: debuggerHelper,
        evaluateArgs: evaluateArgs,
        resolveValue: resolveValue,
        __testing: __testing
    };
});
/*can-stache@3.15.0#helpers/core*/
define('can-stache@3.15.0#helpers/core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    'can-compute',
    '../src/utils',
    'can-util/js/is-function/is-function',
    'can-util/js/base-url/base-url',
    'can-util/js/join-uris/join-uris',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-iterable/is-iterable',
    'can-log/dev/dev',
    'can-symbol',
    'can-reflect',
    'can-util/js/is-empty-object/is-empty-object',
    '../expressions/hashes',
    './-debugger',
    'can-observation',
    'can-util/dom/data/data'
], function (require, exports, module) {
    var live = require('can-view-live');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var utils = require('../src/utils');
    var isFunction = require('can-util/js/is-function/is-function');
    var getBaseURL = require('can-util/js/base-url/base-url');
    var joinURIs = require('can-util/js/join-uris/join-uris');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isIterable = require('can-util/js/is-iterable/is-iterable');
    var dev = require('can-log/dev/dev');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var Hashes = require('../expressions/hashes');
    var debuggerHelper = require('./-debugger').helper;
    var Observation = require('can-observation');
    var domData = require('can-util/dom/data/data');
    var looksLikeOptions = function (options) {
        return options && typeof options.fn === 'function' && typeof options.inverse === 'function';
    };
    var resolve = function (value) {
        if (value && canReflect.isValueLike(value)) {
            return canReflect.getValue(value);
        } else {
            return value;
        }
    };
    var resolveHash = function (hash) {
        var params = {};
        for (var prop in hash) {
            params[prop] = resolve(hash[prop]);
        }
        return params;
    };
    var peek = Observation.ignore(resolve);
    var helpers = {
        'each': {
            metadata: { isLiveBound: true },
            fn: function (items) {
                var args = [].slice.call(arguments), options = args.pop(), argsLen = args.length, argExprs = options.exprData.argExprs, hashExprs = options.exprData.hashExprs, resolved = peek(items), asVariable, hashOptions, aliases, key;
                if (argsLen === 2 && !(argExprs[1].expr instanceof Hashes) || argsLen === 3 && argExprs[1].key === 'as') {
                    asVariable = args[argsLen - 1];
                    if (typeof asVariable !== 'string') {
                        asVariable = argExprs[argsLen - 1].key;
                    }
                }
                if (!isEmptyObject(hashExprs)) {
                    hashOptions = {};
                    each(hashExprs, function (exprs, key) {
                        hashOptions[exprs.key] = key;
                    });
                }
                if ((canReflect.isObservableLike(resolved) && canReflect.isListLike(resolved) || utils.isArrayLike(resolved) && canReflect.isValueLike(items)) && !options.stringOnly) {
                    return function (el) {
                        var nodeList = [el];
                        nodeList.expression = 'live.list';
                        nodeLists.register(nodeList, null, options.nodeList, true);
                        nodeLists.update(options.nodeList, [el]);
                        var cb = function (item, index, parentNodeList) {
                            var aliases = {
                                '%index': index,
                                '@index': index
                            };
                            if (asVariable) {
                                aliases[asVariable] = item;
                            }
                            if (!isEmptyObject(hashOptions)) {
                                if (hashOptions.value) {
                                    aliases[hashOptions.value] = item;
                                }
                                if (hashOptions.index) {
                                    aliases[hashOptions.index] = index;
                                }
                            }
                            return options.fn(options.scope.add(aliases, { notContext: true }).add({ index: index }, { special: true }).add(item), options.options, parentNodeList);
                        };
                        live.list(el, items, cb, options.context, el.parentNode, nodeList, function (list, parentNodeList) {
                            return options.inverse(options.scope.add(list), options.options, parentNodeList);
                        });
                    };
                }
                var expr = resolve(items), result;
                if (!!expr && utils.isArrayLike(expr)) {
                    result = utils.getItemsFragContent(expr, options, options.scope, asVariable);
                    return options.stringOnly ? result.join('') : result;
                } else if (canReflect.isObservableLike(expr) && canReflect.isMapLike(expr) || expr instanceof Object) {
                    result = [];
                    canReflect.each(expr, function (val, key) {
                        var value = compute(expr, key);
                        aliases = {
                            '%key': key,
                            '@key': key
                        };
                        if (asVariable) {
                            aliases[asVariable] = value;
                        }
                        if (!isEmptyObject(hashOptions)) {
                            if (hashOptions.value) {
                                aliases[hashOptions.value] = value;
                            }
                            if (hashOptions.key) {
                                aliases[hashOptions.key] = key;
                            }
                        }
                        result.push(options.fn(options.scope.add(aliases, { notContext: true }).add({ key: key }, { special: true }).add(value)));
                    });
                    return options.stringOnly ? result.join('') : result;
                }
            }
        },
        '@index': {
            fn: function (offset, options) {
                if (!options) {
                    options = offset;
                    offset = 0;
                }
                var index = options.scope.peek('@index');
                return '' + ((isFunction(index) ? index() : index) + offset);
            }
        },
        'if': {
            fn: function (expr, options) {
                var value;
                if (expr && expr.isComputed) {
                    value = compute.truthy(expr)();
                } else {
                    value = !!resolve(expr);
                }
                if (value) {
                    return options.fn(options.scope || this);
                } else {
                    return options.inverse(options.scope || this);
                }
            }
        },
        'is': {
            fn: function () {
                var lastValue, curValue, options = arguments[arguments.length - 1];
                if (arguments.length - 2 <= 0) {
                    return options.inverse();
                }
                var args = arguments;
                var callFn = compute(function () {
                    for (var i = 0; i < args.length - 1; i++) {
                        curValue = resolve(args[i]);
                        curValue = isFunction(curValue) ? curValue() : curValue;
                        if (i > 0) {
                            if (curValue !== lastValue) {
                                return false;
                            }
                        }
                        lastValue = curValue;
                    }
                    return true;
                });
                return callFn() ? options.fn() : options.inverse();
            }
        },
        'eq': {
            fn: function () {
                return helpers.is.fn.apply(this, arguments);
            }
        },
        'unless': {
            fn: function (expr, options) {
                return helpers['if'].fn.apply(this, [
                    expr,
                    assign(assign({}, options), {
                        fn: options.inverse,
                        inverse: options.fn
                    })
                ]);
            }
        },
        'with': {
            fn: function (expr, options) {
                var ctx = expr;
                if (!options) {
                    options = expr;
                    expr = true;
                    ctx = options.hash;
                } else {
                    expr = resolve(expr);
                    if (options.hash && !isEmptyObject(options.hash)) {
                        ctx = options.scope.add(options.hash).add(ctx);
                    }
                }
                return options.fn(ctx || {});
            }
        },
        'log': {
            fn: function (options) {
                var logs = [];
                each(arguments, function (val) {
                    if (!looksLikeOptions(val)) {
                        logs.push(val);
                    }
                });
                if (typeof console !== 'undefined' && console.log) {
                    if (!logs.length) {
                        console.log(options.context);
                    } else {
                        console.log.apply(console, logs);
                    }
                }
            }
        },
        'data': {
            fn: function (attr) {
                var data = arguments.length === 2 ? this : arguments[1];
                return function (el) {
                    domData.set.call(el, attr, data || this.context);
                };
            }
        },
        'switch': {
            fn: function (expression, options) {
                resolve(expression);
                var found = false;
                var newOptions = options.helpers.add({
                    'case': function (value, options) {
                        if (!found && resolve(expression) === resolve(value)) {
                            found = true;
                            return options.fn(options.scope || this);
                        }
                    },
                    'default': function (options) {
                        if (!found) {
                            return options.fn(options.scope || this);
                        }
                    }
                });
                return options.fn(options.scope, newOptions);
            }
        },
        'joinBase': {
            fn: function (firstExpr) {
                var args = [].slice.call(arguments);
                var options = args.pop();
                var moduleReference = args.map(function (expr) {
                    var value = resolve(expr);
                    return isFunction(value) ? value() : value;
                }).join('');
                var templateModule = options.helpers.peek('helpers.module');
                var parentAddress = templateModule ? templateModule.uri : undefined;
                var isRelative = moduleReference[0] === '.';
                if (isRelative && parentAddress) {
                    return joinURIs(parentAddress, moduleReference);
                } else {
                    var baseURL = typeof System !== 'undefined' && (System.renderingBaseURL || System.baseURL) || getBaseURL();
                    if (moduleReference[0] !== '/' && baseURL[baseURL.length - 1] !== '/') {
                        baseURL += '/';
                    }
                    return joinURIs(baseURL, moduleReference);
                }
            }
        }
    };
    helpers.eachOf = helpers.each;
    helpers.debugger = { fn: debuggerHelper };
    var registerHelper = function (name, callback, metadata) {
        helpers[name] = {
            metadata: assign({ isHelper: true }, metadata),
            fn: callback
        };
    };
    var makeSimpleHelper = function (fn) {
        return function () {
            var realArgs = [];
            each(arguments, function (val) {
                while (val && val.isComputed) {
                    val = val();
                }
                realArgs.push(val);
            });
            return fn.apply(this, realArgs);
        };
    };
    var registerSimpleHelper = function (name, callback) {
        registerHelper(name, makeSimpleHelper(callback));
    };
    module.exports = {
        registerHelper: registerHelper,
        registerSimpleHelper: function () {
            registerSimpleHelper.apply(this, arguments);
        },
        addHelper: registerSimpleHelper,
        addLiveHelper: function (name, callback) {
            return registerHelper(name, callback, { isLiveBound: true });
        },
        getHelper: function (name, options) {
            var helper = options && options.get && options.get('helpers.' + name, { proxyMethods: false });
            if (helper) {
                helper = { fn: helper };
            } else {
                helper = helpers[name];
            }
            if (helper) {
                helper.metadata = assign(helper.metadata || {}, { isHelper: true });
                return helper;
            }
        },
        resolve: resolve,
        resolveHash: resolveHash,
        looksLikeOptions: looksLikeOptions,
        helpers: assign({}, helpers)
    };
});
/*can-stache@3.15.0#src/lookup-value-or-helper*/
define('can-stache@3.15.0#src/lookup-value-or-helper', [
    'require',
    'exports',
    'module',
    './expression-helpers',
    '../helpers/core'
], function (require, exports, module) {
    var expressionHelpers = require('./expression-helpers');
    var mustacheHelpers = require('../helpers/core');
    function lookupValueOrHelper(key, scope, helperOptions, readOptions) {
        var scopeKeyData = expressionHelpers.getObservableValue_fromKey(key, scope, readOptions);
        var result = { value: scopeKeyData };
        if (key.charAt(0) === '@' && key !== '@index') {
            key = key.substr(1);
        }
        if (scopeKeyData.initialValue === undefined || mustacheHelpers.helpers[key]) {
            var helper = mustacheHelpers.getHelper(key, helperOptions);
            result.helper = helper;
        }
        return result;
    }
    module.exports = lookupValueOrHelper;
});
/*can-stache@3.15.0#expressions/lookup*/
define('can-stache@3.15.0#expressions/lookup', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers',
    '../src/lookup-value-or-helper',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var expressionHelpers = require('../src/expression-helpers');
    var lookupValueOrHelper = require('../src/lookup-value-or-helper');
    var assign = require('can-util/js/assign/assign');
    var Lookup = function (key, root) {
        this.key = key;
        this.rootExpr = root;
    };
    Lookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope, helperOptions), scope, {}, {});
        } else {
            var result = lookupValueOrHelper(this.key, scope, helperOptions);
            assign(this, result.metadata);
            return result.helper || result.value;
        }
    };
    module.exports = Lookup;
});
/*can-stache@3.15.0#expressions/scope-lookup*/
define('can-stache@3.15.0#expressions/scope-lookup', [
    'require',
    'exports',
    'module',
    '../src/expression-helpers',
    './lookup'
], function (require, exports, module) {
    var expressionHelpers = require('../src/expression-helpers');
    var Lookup = require('./lookup');
    var ScopeLookup = function (key, root) {
        Lookup.apply(this, arguments);
    };
    ScopeLookup.prototype.value = function (scope, helperOptions) {
        if (this.rootExpr) {
            return expressionHelpers.getObservableValue_fromDynamicKey_fromObservable(this.key, this.rootExpr.value(scope, helperOptions), scope, {}, {});
        }
        return expressionHelpers.getObservableValue_fromKey(this.key, scope, helperOptions);
    };
    module.exports = ScopeLookup;
});
/*can-stache@3.15.0#expressions/helper*/
define('can-stache@3.15.0#expressions/helper', [
    'require',
    'exports',
    'module',
    './literal',
    'can-compute',
    'can-util/js/assign/assign',
    'can-util/js/dev/dev',
    'can-util/js/is-empty-object/is-empty-object',
    '../src/expression-helpers',
    '../src/utils',
    '../helpers/core'
], function (require, exports, module) {
    var Literal = require('./literal');
    var compute = require('can-compute');
    var assign = require('can-util/js/assign/assign');
    var dev = require('can-util/js/dev/dev');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var expressionHelpers = require('../src/expression-helpers');
    var utils = require('../src/utils');
    var mustacheHelpers = require('../helpers/core');
    var Helper = function (methodExpression, argExpressions, hashExpressions) {
        this.methodExpr = methodExpression;
        this.argExprs = argExpressions;
        this.hashExprs = hashExpressions;
        this.mode = null;
    };
    Helper.prototype.args = function (scope, helperOptions) {
        var args = [];
        for (var i = 0, len = this.argExprs.length; i < len; i++) {
            var arg = this.argExprs[i];
            args.push(expressionHelpers.toComputeOrValue(arg.value.apply(arg, arguments)));
        }
        return args;
    };
    Helper.prototype.hash = function (scope, helperOptions) {
        var hash = {};
        for (var prop in this.hashExprs) {
            var val = this.hashExprs[prop];
            hash[prop] = expressionHelpers.toComputeOrValue(val.value.apply(val, arguments));
        }
        return hash;
    };
    Helper.prototype.helperAndValue = function (scope, helperOptions) {
        var looksLikeAHelper = this.argExprs.length || !isEmptyObject(this.hashExprs), helper, computeData, methodKey = this.methodExpr instanceof Literal ? '' + this.methodExpr._value : this.methodExpr.key, initialValue, args;
        if (looksLikeAHelper) {
            helper = mustacheHelpers.getHelper(methodKey, helperOptions);
        }
        if (!helper) {
            computeData = expressionHelpers.getObservableValue_fromKey(methodKey, scope, { isArgument: true });
            if (typeof computeData.initialValue === 'function') {
                args = this.args(scope, helperOptions).map(expressionHelpers.toComputeOrValue);
                var functionResult = compute(function () {
                    return computeData.initialValue.apply(null, args);
                });
                compute.temporarilyBind(functionResult);
                return { value: functionResult };
            } else if (typeof computeData.initialValue !== 'undefined') {
                return { value: computeData };
            }
            if (!looksLikeAHelper && initialValue === undefined) {
                helper = mustacheHelpers.getHelper(methodKey, helperOptions);
            }
        }
        return {
            value: computeData,
            args: args,
            helper: helper && helper.fn
        };
    };
    Helper.prototype.evaluator = function (helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperOptionArg = { stringOnly: stringOnly }, context = scope.peek('.'), args = this.args(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly), hash = this.hash(scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        assign(helperOptionArg, {
            context: context,
            scope: scope,
            contexts: scope,
            hash: hash,
            nodeList: nodeList,
            exprData: this,
            helperOptions: helperOptions,
            helpers: helperOptions
        });
        args.push(helperOptionArg);
        return function () {
            return helper.apply(context, args);
        };
    };
    Helper.prototype.value = function (scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly) {
        var helperAndValue = this.helperAndValue(scope, helperOptions);
        var helper = helperAndValue.helper;
        if (!helper) {
            return helperAndValue.value;
        }
        var fn = this.evaluator(helper, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
        var computeValue = compute(fn);
        compute.temporarilyBind(computeValue);
        if (!expressionHelpers.computeHasDependencies(computeValue)) {
            return computeValue();
        } else {
            return computeValue;
        }
    };
    Helper.prototype.closingTag = function () {
        return this.methodExpr.key;
    };
    module.exports = Helper;
});
/*can-stache@3.15.0#expressions/helper-lookup*/
define('can-stache@3.15.0#expressions/helper-lookup', [
    'require',
    'exports',
    'module',
    './lookup',
    '../src/lookup-value-or-helper'
], function (require, exports, module) {
    var Lookup = require('./lookup');
    var lookupValueOrHelper = require('../src/lookup-value-or-helper');
    var HelperLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperLookup.prototype.value = function (scope, helperOptions) {
        var result = lookupValueOrHelper(this.key, scope, helperOptions, {
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
        return result.helper || result.value;
    };
    module.exports = HelperLookup;
});
/*can-stache@3.15.0#expressions/helper-scope-lookup*/
define('can-stache@3.15.0#expressions/helper-scope-lookup', [
    'require',
    'exports',
    'module',
    './lookup',
    '../src/expression-helpers'
], function (require, exports, module) {
    var Lookup = require('./lookup');
    var expressionHelpers = require('../src/expression-helpers');
    var HelperScopeLookup = function () {
        Lookup.apply(this, arguments);
    };
    HelperScopeLookup.prototype.value = function (scope, helperOptions) {
        return expressionHelpers.getObservableValue_fromKey(this.key, scope, {
            callMethodsOnObservables: true,
            isArgument: true,
            args: [
                scope.peek('.'),
                scope
            ]
        });
    };
    module.exports = HelperScopeLookup;
});
/*can-stache@3.15.0#src/expression*/
define('can-stache@3.15.0#src/expression', [
    'require',
    'exports',
    'module',
    '../expressions/arg',
    '../expressions/literal',
    '../expressions/hashes',
    '../expressions/bracket',
    '../expressions/call',
    '../expressions/scope-lookup',
    '../expressions/helper',
    '../expressions/lookup',
    '../expressions/helper-lookup',
    '../expressions/helper-scope-lookup',
    './set-identifier',
    '../src/expression-helpers',
    './utils',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/last/last',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var Arg = require('../expressions/arg');
    var Literal = require('../expressions/literal');
    var Hashes = require('../expressions/hashes');
    var Bracket = require('../expressions/bracket');
    var Call = require('../expressions/call');
    var ScopeLookup = require('../expressions/scope-lookup');
    var Helper = require('../expressions/helper');
    var Lookup = require('../expressions/lookup');
    var HelperLookup = require('../expressions/helper-lookup');
    var HelperScopeLookup = require('../expressions/helper-scope-lookup');
    var SetIdentifier = require('./set-identifier');
    var expressionHelpers = require('../src/expression-helpers');
    var utils = require('./utils');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var last = require('can-util/js/last/last');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var Hash = function () {
    };
    var keyRegExp = /[\w\.\\\-_@\/\&%]+/, tokensRegExp = /('.*?'|".*?"|=|[\w\.\\\-_@\/*%\$]+|[\(\)]|,|\~|\[|\]\s*|\s*(?=\[))/g, bracketSpaceRegExp = /\]\s+/, literalRegExp = /^('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false|null|undefined)$/;
    var isTokenKey = function (token) {
        return keyRegExp.test(token);
    };
    var testDot = /^[\.@]\w/;
    var isAddingToExpression = function (token) {
        return isTokenKey(token) && testDot.test(token);
    };
    var ensureChildren = function (type) {
        if (!type.children) {
            type.children = [];
        }
        return type;
    };
    var Stack = function () {
        this.root = {
            children: [],
            type: 'Root'
        };
        this.current = this.root;
        this.stack = [this.root];
    };
    assign(Stack.prototype, {
        top: function () {
            return last(this.stack);
        },
        isRootTop: function () {
            return this.top() === this.root;
        },
        popTo: function (types) {
            this.popUntil(types);
            this.pop();
        },
        pop: function () {
            if (!this.isRootTop()) {
                this.stack.pop();
            }
        },
        first: function (types) {
            var curIndex = this.stack.length - 1;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        firstParent: function (types) {
            var curIndex = this.stack.length - 2;
            while (curIndex > 0 && types.indexOf(this.stack[curIndex].type) === -1) {
                curIndex--;
            }
            return this.stack[curIndex];
        },
        popUntil: function (types) {
            while (types.indexOf(this.top().type) === -1 && !this.isRootTop()) {
                this.stack.pop();
            }
            return this.top();
        },
        addTo: function (types, type) {
            var cur = this.popUntil(types);
            ensureChildren(cur).children.push(type);
        },
        addToAndPush: function (types, type) {
            this.addTo(types, type);
            this.stack.push(type);
        },
        push: function (type) {
            this.stack.push(type);
        },
        topLastChild: function () {
            return last(this.top().children);
        },
        replaceTopLastChild: function (type) {
            var children = ensureChildren(this.top()).children;
            children.pop();
            children.push(type);
            return type;
        },
        replaceTopLastChildAndPush: function (type) {
            this.replaceTopLastChild(type);
            this.stack.push(type);
        },
        replaceTopAndPush: function (type) {
            var children;
            if (this.top() === this.root) {
                children = ensureChildren(this.top()).children;
            } else {
                this.stack.pop();
                children = ensureChildren(this.top()).children;
            }
            children.pop();
            children.push(type);
            this.stack.push(type);
            return type;
        }
    });
    var convertKeyToLookup = function (key) {
        var lastPath = key.lastIndexOf('./');
        var lastDot = key.lastIndexOf('.');
        if (lastDot > lastPath) {
            return key.substr(0, lastDot) + '@' + key.substr(lastDot + 1);
        }
        var firstNonPathCharIndex = lastPath === -1 ? 0 : lastPath + 2;
        var firstNonPathChar = key.charAt(firstNonPathCharIndex);
        if (firstNonPathChar === '.' || firstNonPathChar === '@') {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex + 1);
        } else {
            return key.substr(0, firstNonPathCharIndex) + '@' + key.substr(firstNonPathCharIndex);
        }
    };
    var convertToAtLookup = function (ast) {
        if (ast.type === 'Lookup') {
            ast.key = convertKeyToLookup(ast.key);
        }
        return ast;
    };
    var convertToHelperIfTopIsLookup = function (stack) {
        var top = stack.top();
        if (top && top.type === 'Lookup') {
            var base = stack.stack[stack.stack.length - 2];
            if (base.type !== 'Helper' && base) {
                stack.replaceTopAndPush({
                    type: 'Helper',
                    method: top
                });
            }
        }
    };
    var expression = {
        toComputeOrValue: expressionHelpers.toComputeOrValue,
        convertKeyToLookup: convertKeyToLookup,
        Literal: Literal,
        Lookup: Lookup,
        ScopeLookup: ScopeLookup,
        Arg: Arg,
        Hash: Hash,
        Hashes: Hashes,
        Call: Call,
        Helper: Helper,
        HelperLookup: HelperLookup,
        HelperScopeLookup: HelperScopeLookup,
        Bracket: Bracket,
        SetIdentifier: SetIdentifier,
        tokenize: function (expression) {
            var tokens = [];
            (expression.trim() + ' ').replace(tokensRegExp, function (whole, arg) {
                if (bracketSpaceRegExp.test(arg)) {
                    tokens.push(arg[0]);
                    tokens.push(arg.slice(1));
                } else {
                    tokens.push(arg);
                }
            });
            return tokens;
        },
        lookupRules: {
            'default': function (ast, methodType, isArg) {
                var name = (methodType === 'Helper' && !ast.root ? 'Helper' : '') + (isArg ? 'Scope' : '') + 'Lookup';
                return expression[name];
            },
            'method': function (ast, methodType, isArg) {
                return ScopeLookup;
            }
        },
        methodRules: {
            'default': function (ast) {
                return ast.type === 'Call' ? Call : Helper;
            },
            'call': function (ast) {
                return Call;
            }
        },
        parse: function (expressionString, options) {
            options = options || {};
            var ast = this.ast(expressionString);
            if (!options.lookupRule) {
                options.lookupRule = 'default';
            }
            if (typeof options.lookupRule === 'string') {
                options.lookupRule = expression.lookupRules[options.lookupRule];
            }
            if (!options.methodRule) {
                options.methodRule = 'default';
            }
            if (typeof options.methodRule === 'string') {
                options.methodRule = expression.methodRules[options.methodRule];
            }
            var expr = this.hydrateAst(ast, options, options.baseMethodType || 'Helper');
            return expr;
        },
        hydrateAst: function (ast, options, methodType, isArg) {
            var hashes;
            if (ast.type === 'Lookup') {
                var lookup = new (options.lookupRule(ast, methodType, isArg))(ast.key, ast.root && this.hydrateAst(ast.root, options, methodType));
                return lookup;
            } else if (ast.type === 'Literal') {
                return new Literal(ast.value);
            } else if (ast.type === 'Arg') {
                return new Arg(this.hydrateAst(ast.children[0], options, methodType, isArg), { compute: true });
            } else if (ast.type === 'Hash') {
                throw new Error('');
            } else if (ast.type === 'Hashes') {
                hashes = {};
                each(ast.children, function (hash) {
                    hashes[hash.prop] = this.hydrateAst(hash.children[0], options, methodType, true);
                }, this);
                return new Hashes(hashes);
            } else if (ast.type === 'Call' || ast.type === 'Helper') {
                hashes = {};
                var args = [], children = ast.children, ExpressionType = options.methodRule(ast);
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.type === 'Hashes' && ast.type === 'Helper' && ExpressionType !== Call) {
                            each(child.children, function (hash) {
                                hashes[hash.prop] = this.hydrateAst(hash.children[0], options, ast.type, true);
                            }, this);
                        } else {
                            args.push(this.hydrateAst(child, options, ast.type, true));
                        }
                    }
                }
                return new ExpressionType(this.hydrateAst(ast.method, options, ast.type), args, hashes);
            } else if (ast.type === 'Bracket') {
                var originalKey;
                return new Bracket(this.hydrateAst(ast.children[0], options), ast.root ? this.hydrateAst(ast.root, options) : undefined, originalKey);
            }
        },
        ast: function (expression) {
            var tokens = this.tokenize(expression);
            return this.parseAst(tokens, { index: 0 });
        },
        parseAst: function (tokens, cursor) {
            var stack = new Stack(), top, firstParent, lastToken;
            while (cursor.index < tokens.length) {
                var token = tokens[cursor.index], nextToken = tokens[cursor.index + 1];
                cursor.index++;
                if (nextToken === '=') {
                    top = stack.top();
                    if (top && top.type === 'Lookup') {
                        firstParent = stack.firstParent([
                            'Call',
                            'Helper',
                            'Hash'
                        ]);
                        if (firstParent.type === 'Call' || firstParent.type === 'Root') {
                            stack.popUntil(['Call']);
                            top = stack.top();
                            stack.replaceTopAndPush({
                                type: 'Helper',
                                method: top.type === 'Root' ? last(top.children) : top
                            });
                        }
                    }
                    firstParent = stack.firstParent([
                        'Call',
                        'Helper',
                        'Hashes'
                    ]);
                    var hash = {
                        type: 'Hash',
                        prop: token
                    };
                    if (firstParent.type === 'Hashes') {
                        stack.addToAndPush(['Hashes'], hash);
                    } else {
                        stack.addToAndPush([
                            'Helper',
                            'Call'
                        ], {
                            type: 'Hashes',
                            children: [hash]
                        });
                        stack.push(hash);
                    }
                    cursor.index++;
                } else if (literalRegExp.test(token)) {
                    convertToHelperIfTopIsLookup(stack);
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (firstParent.type === 'Hash' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else if (firstParent.type === 'Bracket' && (firstParent.children && firstParent.children.length > 0)) {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    } else {
                        stack.addTo([
                            'Helper',
                            'Call',
                            'Hash',
                            'Bracket'
                        ], {
                            type: 'Literal',
                            value: utils.jsonParse(token)
                        });
                    }
                } else if (keyRegExp.test(token)) {
                    lastToken = stack.topLastChild();
                    firstParent = stack.first([
                        'Helper',
                        'Call',
                        'Hash',
                        'Bracket'
                    ]);
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket') && isAddingToExpression(token)) {
                        stack.replaceTopLastChildAndPush({
                            type: 'Lookup',
                            root: lastToken,
                            key: token.slice(1)
                        });
                    } else if (firstParent.type === 'Bracket') {
                        if (!(firstParent.children && firstParent.children.length > 0)) {
                            stack.addToAndPush(['Bracket'], {
                                type: 'Lookup',
                                key: token
                            });
                        } else {
                            if (stack.first([
                                    'Helper',
                                    'Call',
                                    'Hash',
                                    'Arg'
                                ]).type === 'Helper' && token[0] !== '.') {
                                stack.addToAndPush(['Helper'], {
                                    type: 'Lookup',
                                    key: token
                                });
                            } else {
                                stack.replaceTopAndPush({
                                    type: 'Lookup',
                                    key: token.slice(1),
                                    root: firstParent
                                });
                            }
                        }
                    } else {
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash',
                            'Arg',
                            'Bracket'
                        ], {
                            type: 'Lookup',
                            key: token
                        });
                    }
                } else if (token === '~') {
                    convertToHelperIfTopIsLookup(stack);
                    stack.addToAndPush([
                        'Helper',
                        'Call',
                        'Hash'
                    ], {
                        type: 'Arg',
                        key: token
                    });
                } else if (token === '(') {
                    top = stack.top();
                    if (top.type === 'Lookup') {
                        stack.replaceTopAndPush({
                            type: 'Call',
                            method: convertToAtLookup(top)
                        });
                    } else {
                        throw new Error('Unable to understand expression ' + tokens.join(''));
                    }
                } else if (token === ')') {
                    stack.popTo(['Call']);
                } else if (token === ',') {
                    stack.popUntil(['Call']);
                } else if (token === '[') {
                    top = stack.top();
                    lastToken = stack.topLastChild();
                    if (lastToken && (lastToken.type === 'Call' || lastToken.type === 'Bracket')) {
                        stack.replaceTopAndPush({
                            type: 'Bracket',
                            root: lastToken
                        });
                    } else if (top.type === 'Lookup' || top.type === 'Bracket') {
                        var bracket = {
                            type: 'Bracket',
                            root: top
                        };
                        stack.replaceTopAndPush(bracket);
                    } else if (top.type === 'Call') {
                        stack.addToAndPush(['Call'], { type: 'Bracket' });
                    } else if (top === ' ') {
                        stack.popUntil([
                            'Lookup',
                            'Call'
                        ]);
                        convertToHelperIfTopIsLookup(stack);
                        stack.addToAndPush([
                            'Helper',
                            'Call',
                            'Hash'
                        ], { type: 'Bracket' });
                    } else {
                        stack.replaceTopAndPush({ type: 'Bracket' });
                    }
                } else if (token === ']') {
                    stack.pop();
                } else if (token === ' ') {
                    stack.push(token);
                }
            }
            return stack.root.children[0];
        }
    };
    module.exports = expression;
});
/*can-view-model@3.5.2#can-view-model*/
define('can-view-model@3.5.2#can-view-model', [
    'require',
    'exports',
    'module',
    'can-util/dom/data/data',
    'can-simple-map',
    'can-types',
    'can-namespace',
    'can-globals/document/document',
    'can-util/js/is-array-like/is-array-like',
    'can-reflect'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var domData = require('can-util/dom/data/data');
        var SimpleMap = require('can-simple-map');
        var types = require('can-types');
        var ns = require('can-namespace');
        var getDocument = require('can-globals/document/document');
        var isArrayLike = require('can-util/js/is-array-like/is-array-like');
        var canReflect = require('can-reflect');
        module.exports = ns.viewModel = function (el, attr, val) {
            var scope;
            if (typeof el === 'string') {
                el = getDocument().querySelector(el);
            } else if (isArrayLike(el) && !el.nodeType) {
                el = el[0];
            }
            if (canReflect.isObservableLike(attr) && canReflect.isMapLike(attr)) {
                return domData.set.call(el, 'viewModel', attr);
            }
            scope = domData.get.call(el, 'viewModel');
            if (!scope) {
                scope = types.DefaultMap ? new types.DefaultMap() : new SimpleMap();
                domData.set.call(el, 'viewModel', scope);
            }
            switch (arguments.length) {
            case 0:
            case 1:
                return scope;
            case 2:
                return 'attr' in scope ? scope.attr(attr) : scope[attr];
            default:
                if ('attr' in scope) {
                    scope.attr(attr, val);
                } else {
                    scope[attr] = val;
                }
                return el;
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-observable@1.0.2#can-simple-observable*/
define('can-simple-observable@1.0.2#can-simple-observable', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-event/batch/batch',
    'can-observation',
    'can-cid',
    'can-namespace'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var ns = require('can-namespace');
    module.exports = ns.simpleObservable = function simpleObservable(initialValue) {
        var value = initialValue;
        var handlers = [];
        var fn = function (newValue) {
            if (arguments.length) {
                value = newValue;
                handlers.forEach(function (handler) {
                    canBatch.queue([
                        handler,
                        fn,
                        [newValue]
                    ]);
                }, this);
            } else {
                Observation.add(fn);
                return value;
            }
        };
        CID(fn);
        canReflect.assignSymbols(fn, {
            'can.onValue': function (handler) {
                handlers.push(handler);
            },
            'can.offValue': function (handler) {
                var index = handlers.indexOf(handler);
                handlers.splice(index, 1);
            },
            'can.setValue': function (newValue) {
                return fn(newValue);
            },
            'can.getValue': function () {
                return fn();
            }
        });
        return fn;
    };
});
/*can-dom-events@1.3.0#helpers/util*/
define('can-dom-events@1.3.0#helpers/util', [
    'require',
    'exports',
    'module',
    'can-globals/document/document',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getCurrentDocument = require('can-globals/document/document');
        var isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
        function getTargetDocument(target) {
            return target.ownerDocument || getCurrentDocument();
        }
        function createEvent(target, eventData, bubbles, cancelable) {
            var doc = getTargetDocument(target);
            var event = doc.createEvent('HTMLEvents');
            var eventType;
            if (typeof eventData === 'string') {
                eventType = eventData;
            } else {
                eventType = eventData.type;
                for (var prop in eventData) {
                    if (event[prop] === undefined) {
                        event[prop] = eventData[prop];
                    }
                }
            }
            if (bubbles === undefined) {
                bubbles = true;
            }
            event.initEvent(eventType, bubbles, cancelable);
            return event;
        }
        function isDomEventTarget(obj) {
            if (!(obj && obj.nodeName)) {
                return obj === window;
            }
            var nodeType = obj.nodeType;
            return nodeType === 1 || nodeType === 9 || nodeType === 11;
        }
        function addDomContext(context, args) {
            if (isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                args.unshift(context);
            }
            return args;
        }
        function removeDomContext(context, args) {
            if (!isDomEventTarget(context)) {
                args = Array.prototype.slice.call(args, 0);
                context = args.shift();
            }
            return {
                context: context,
                args: args
            };
        }
        var fixSyntheticEventsOnDisabled = false;
        (function () {
            if (!isBrowserWindow()) {
                return;
            }
            var testEventName = 'fix_synthetic_events_on_disabled_test';
            var input = document.createElement('input');
            input.disabled = true;
            var timer = setTimeout(function () {
                fixSyntheticEventsOnDisabled = true;
            }, 50);
            var onTest = function onTest() {
                clearTimeout(timer);
                input.removeEventListener(testEventName, onTest);
            };
            input.addEventListener(testEventName, onTest);
            try {
                var event = document.create('HTMLEvents');
                event.initEvent(testEventName, false);
                input.dispatchEvent(event);
            } catch (e) {
                onTest();
                fixSyntheticEventsOnDisabled = true;
            }
        }());
        function isDispatchingOnDisabled(element, event) {
            var eventType = event.type;
            var isInsertedOrRemoved = eventType === 'inserted' || eventType === 'removed';
            var isDisabled = !!element.disabled;
            return isInsertedOrRemoved && isDisabled;
        }
        function forceEnabledForDispatch(element, event) {
            return fixSyntheticEventsOnDisabled && isDispatchingOnDisabled(element, event);
        }
        module.exports = {
            createEvent: createEvent,
            addDomContext: addDomContext,
            removeDomContext: removeDomContext,
            isDomEventTarget: isDomEventTarget,
            getTargetDocument: getTargetDocument,
            forceEnabledForDispatch: forceEnabledForDispatch
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.3.0#helpers/add-event-compat*/
define('can-dom-events@1.3.0#helpers/add-event-compat', [
    'require',
    'exports',
    'module',
    './util'
], function (require, exports, module) {
    'use strict';
    var util = require('./util');
    var addDomContext = util.addDomContext;
    var removeDomContext = util.removeDomContext;
    function isDomEvents(obj) {
        return !!(obj && obj.addEventListener && obj.removeEventListener && obj.dispatch);
    }
    function isNewEvents(obj) {
        return typeof obj.addEvent === 'function';
    }
    module.exports = function addEventCompat(domEvents, customEvent, customEventType) {
        if (!isDomEvents(domEvents)) {
            throw new Error('addEventCompat() must be passed can-dom-events or can-util/dom/events/events');
        }
        customEventType = customEventType || customEvent.defaultEventType;
        if (isNewEvents(domEvents)) {
            return domEvents.addEvent(customEvent, customEventType);
        }
        var registry = domEvents._compatRegistry;
        if (!registry) {
            registry = domEvents._compatRegistry = {};
        }
        if (registry[customEventType]) {
            return function noopRemoveOverride() {
            };
        }
        registry[customEventType] = customEvent;
        var newEvents = {
            addEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.addEventListener.apply(data.context, data.args);
            },
            removeEventListener: function () {
                var data = removeDomContext(this, arguments);
                return domEvents.removeEventListener.apply(data.context, data.args);
            },
            dispatch: function () {
                var data = removeDomContext(this, arguments);
                var eventData = data.args[0];
                var eventArgs = typeof eventData === 'object' ? eventData.args : [];
                data.args.splice(1, 0, eventArgs);
                return domEvents.dispatch.apply(data.context, data.args);
            }
        };
        var isOverriding = true;
        var oldAddEventListener = domEvents.addEventListener;
        var addEventListener = domEvents.addEventListener = function addEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.addEventListener.apply(newEvents, args);
            }
            return oldAddEventListener.apply(this, arguments);
        };
        var oldRemoveEventListener = domEvents.removeEventListener;
        var removeEventListener = domEvents.removeEventListener = function removeEventListener(eventName) {
            if (isOverriding && eventName === customEventType) {
                var args = addDomContext(this, arguments);
                customEvent.removeEventListener.apply(newEvents, args);
            }
            return oldRemoveEventListener.apply(this, arguments);
        };
        return function removeOverride() {
            isOverriding = false;
            registry[customEventType] = null;
            if (domEvents.addEventListener === addEventListener) {
                domEvents.addEventListener = oldAddEventListener;
            }
            if (domEvents.removeEventListener === removeEventListener) {
                domEvents.removeEventListener = oldRemoveEventListener;
            }
        };
    };
});
/*can-event-dom-enter@1.0.4#can-event-dom-enter*/
define('can-event-dom-enter@1.0.4#can-event-dom-enter', [
    'require',
    'exports',
    'module',
    'can-dom-data-state',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var domData = require('can-dom-data-state');
    var canCid = require('can-cid');
    var baseEventType = 'keyup';
    function isEnterEvent(event) {
        var hasEnterKey = event.key === 'Enter';
        var hasEnterCode = event.keyCode === 13;
        return hasEnterKey || hasEnterCode;
    }
    function getHandlerKey(eventType, handler) {
        return eventType + ':' + canCid(handler);
    }
    function associateHandler(target, eventType, handler, otherHandler) {
        var key = getHandlerKey(eventType, handler);
        domData.set.call(target, key, otherHandler);
    }
    function disassociateHandler(target, eventType, handler) {
        var key = getHandlerKey(eventType, handler);
        var otherHandler = domData.get.call(target, key);
        if (otherHandler) {
            domData.clean.call(target, key);
        }
        return otherHandler;
    }
    module.exports = {
        defaultEventType: 'enter',
        addEventListener: function (target, eventType, handler) {
            var keyHandler = function (event) {
                if (isEnterEvent(event)) {
                    return handler.apply(this, arguments);
                }
            };
            associateHandler(target, eventType, handler, keyHandler);
            this.addEventListener(target, baseEventType, keyHandler);
        },
        removeEventListener: function (target, eventType, handler) {
            var keyHandler = disassociateHandler(target, eventType, handler);
            if (keyHandler) {
                this.removeEventListener(target, baseEventType, keyHandler);
            }
        }
    };
});
/*can-event-dom-enter@1.0.4#compat*/
define('can-event-dom-enter@1.0.4#compat', [
    'require',
    'exports',
    'module',
    'can-dom-events/helpers/add-event-compat',
    './can-event-dom-enter'
], function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-enter');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-dom-events@1.3.0#helpers/make-event-registry*/
define('can-dom-events@1.3.0#helpers/make-event-registry', function (require, exports, module) {
    'use strict';
    function EventRegistry() {
        this._registry = {};
    }
    module.exports = function makeEventRegistry() {
        return new EventRegistry();
    };
    EventRegistry.prototype.has = function (eventType) {
        return !!this._registry[eventType];
    };
    EventRegistry.prototype.get = function (eventType) {
        return this._registry[eventType];
    };
    EventRegistry.prototype.add = function (event, eventType) {
        if (!event) {
            throw new Error('An EventDefinition must be provided');
        }
        if (typeof event.addEventListener !== 'function') {
            throw new TypeError('EventDefinition addEventListener must be a function');
        }
        if (typeof event.removeEventListener !== 'function') {
            throw new TypeError('EventDefinition removeEventListener must be a function');
        }
        eventType = eventType || event.defaultEventType;
        if (typeof eventType !== 'string') {
            throw new TypeError('Event type must be a string, not ' + eventType);
        }
        if (this.has(eventType)) {
            throw new Error('Event "' + eventType + '" is already registered');
        }
        this._registry[eventType] = event;
        var self = this;
        return function remove() {
            self._registry[eventType] = undefined;
        };
    };
});
/*can-key-tree@1.2.0#can-key-tree*/
define('can-key-tree@1.2.0#can-key-tree', [
    'require',
    'exports',
    'module',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var reflect = require('can-reflect');
    function isBuiltInPrototype(obj) {
        if (obj === Object.prototype) {
            return true;
        }
        var protoString = Object.prototype.toString.call(obj);
        var isNotObjObj = protoString !== '[object Object]';
        var isObjSomething = protoString.indexOf('[object ') !== -1;
        return isNotObjObj && isObjSomething;
    }
    function getDeepSize(root, level) {
        if (level === 0) {
            return reflect.size(root);
        } else if (reflect.size(root) === 0) {
            return 0;
        } else {
            var count = 0;
            reflect.each(root, function (value) {
                count += getDeepSize(value, level - 1);
            });
            return count;
        }
    }
    function getDeep(node, items, depth, maxDepth) {
        if (!node) {
            return;
        }
        if (maxDepth === depth) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                reflect.addValues(items, reflect.toArray(node));
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value) {
                getDeep(value, items, depth + 1, maxDepth);
            });
        }
    }
    function clearDeep(node, keys, maxDepth, deleteHandler) {
        if (maxDepth === keys.length) {
            if (reflect.isMoreListLikeThanMapLike(node)) {
                var valuesToRemove = reflect.toArray(node);
                if (deleteHandler) {
                    valuesToRemove.forEach(function (value) {
                        deleteHandler.apply(null, keys.concat(value));
                    });
                }
                reflect.removeValues(node, valuesToRemove);
            } else {
                throw new Error('can-key-tree: Map-type leaf containers are not supported yet.');
            }
        } else {
            reflect.each(node, function (value, key) {
                clearDeep(value, keys.concat(key), maxDepth, deleteHandler);
                reflect.deleteKeyValue(node, key);
            });
        }
    }
    var KeyTree = function (treeStructure, callbacks) {
        var FirstConstructor = treeStructure[0];
        if (reflect.isConstructorLike(FirstConstructor)) {
            this.root = new FirstConstructor();
        } else {
            this.root = FirstConstructor;
        }
        this.callbacks = callbacks || {};
        this.treeStructure = treeStructure;
        this.empty = true;
    };
    reflect.assign(KeyTree.prototype, {
        add: function (keys) {
            if (keys.length > this.treeStructure.length) {
                throw new Error('can-key-tree: Can not add path deeper than tree.');
            }
            var place = this.root;
            var rootWasEmpty = this.empty === true;
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(place, key);
                if (!childNode) {
                    var Constructor = this.treeStructure[i + 1];
                    if (isBuiltInPrototype(Constructor.prototype)) {
                        childNode = new Constructor();
                    } else {
                        childNode = new Constructor(key);
                    }
                    reflect.setKeyValue(place, key, childNode);
                }
                place = childNode;
            }
            if (reflect.isMoreListLikeThanMapLike(place)) {
                reflect.addValues(place, [keys[keys.length - 1]]);
            } else {
                throw new Error('can-key-tree: Map types are not supported yet.');
            }
            if (rootWasEmpty) {
                this.empty = false;
                if (this.callbacks.onFirst) {
                    this.callbacks.onFirst.call(this);
                }
            }
            return this;
        },
        getNode: function (keys) {
            var node = this.root;
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                node = reflect.getKeyValue(node, key);
                if (!node) {
                    return;
                }
            }
            return node;
        },
        get: function (keys) {
            var node = this.getNode(keys);
            if (this.treeStructure.length === keys.length) {
                return node;
            } else {
                var Type = this.treeStructure[this.treeStructure.length - 1];
                var items = new Type();
                getDeep(node, items, keys.length, this.treeStructure.length - 1);
                return items;
            }
        },
        delete: function (keys, deleteHandler) {
            var parentNode = this.root, path = [this.root], lastKey = keys[keys.length - 1];
            for (var i = 0; i < keys.length - 1; i++) {
                var key = keys[i];
                var childNode = reflect.getKeyValue(parentNode, key);
                if (childNode === undefined) {
                    return false;
                } else {
                    path.push(childNode);
                }
                parentNode = childNode;
            }
            if (!keys.length) {
                clearDeep(parentNode, [], this.treeStructure.length - 1, deleteHandler);
            } else if (keys.length === this.treeStructure.length) {
                if (reflect.isMoreListLikeThanMapLike(parentNode)) {
                    if (deleteHandler) {
                        deleteHandler.apply(null, keys.concat(lastKey));
                    }
                    reflect.removeValues(parentNode, [lastKey]);
                } else {
                    throw new Error('can-key-tree: Map types are not supported yet.');
                }
            } else {
                var nodeToRemove = reflect.getKeyValue(parentNode, lastKey);
                if (nodeToRemove !== undefined) {
                    clearDeep(nodeToRemove, keys, this.treeStructure.length - 1, deleteHandler);
                    reflect.deleteKeyValue(parentNode, lastKey);
                } else {
                    return false;
                }
            }
            for (i = path.length - 2; i >= 0; i--) {
                if (reflect.size(parentNode) === 0) {
                    parentNode = path[i];
                    reflect.deleteKeyValue(parentNode, keys[i]);
                } else {
                    break;
                }
            }
            if (reflect.size(this.root) === 0) {
                this.empty = true;
                if (this.callbacks.onEmpty) {
                    this.callbacks.onEmpty.call(this);
                }
            }
            return true;
        },
        size: function () {
            return getDeepSize(this.root, this.treeStructure.length - 1);
        },
        isEmpty: function () {
            return this.empty;
        }
    });
    module.exports = KeyTree;
});
/*can-dom-events@1.3.0#helpers/-make-delegate-event-tree*/
define('can-dom-events@1.3.0#helpers/-make-delegate-event-tree', [
    'require',
    'exports',
    'module',
    'can-key-tree',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var KeyTree = require('can-key-tree');
    var canReflect = require('can-reflect');
    var useCapture = function (eventType) {
        return eventType === 'focus' || eventType === 'blur';
    };
    function makeDelegator(domEvents) {
        var Delegator = function Delegator(parentKey) {
            this.element = parentKey;
            this.events = {};
            this.delegated = {};
        };
        canReflect.assignSymbols(Delegator.prototype, {
            'can.setKeyValue': function (eventType, handlersBySelector) {
                var handler = this.delegated[eventType] = function (ev) {
                    canReflect.each(handlersBySelector, function (handlers, selector) {
                        var cur = ev.target;
                        do {
                            var el = cur === document ? document.documentElement : cur;
                            var matches = el.matches || el.msMatchesSelector;
                            if (matches.call(el, selector)) {
                                handlers.forEach(function (handler) {
                                    handler.call(el, ev);
                                });
                            }
                            cur = cur.parentNode;
                        } while (cur && cur !== ev.currentTarget);
                    });
                };
                this.events[eventType] = handlersBySelector;
                domEvents.addEventListener(this.element, eventType, handler, useCapture(eventType));
            },
            'can.getKeyValue': function (eventType) {
                return this.events[eventType];
            },
            'can.deleteKeyValue': function (eventType) {
                domEvents.removeEventListener(this.element, eventType, this.delegated[eventType], useCapture(eventType));
                delete this.delegated[eventType];
                delete this.events[eventType];
            },
            'can.getOwnEnumerableKeys': function () {
                return Object.keys(this.events);
            }
        });
        return Delegator;
    }
    module.exports = function makeDelegateEventTree(domEvents) {
        var Delegator = makeDelegator(domEvents);
        return new KeyTree([
            Map,
            Delegator,
            Object,
            Array
        ]);
    };
});
/*can-dom-events@1.3.0#can-dom-events*/
define('can-dom-events@1.3.0#can-dom-events', [
    'require',
    'exports',
    'module',
    'can-namespace',
    './helpers/util',
    './helpers/make-event-registry',
    './helpers/-make-delegate-event-tree'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        var util = require('./helpers/util');
        var makeEventRegistry = require('./helpers/make-event-registry');
        var makeDelegateEventTree = require('./helpers/-make-delegate-event-tree');
        var domEvents = {
            _eventRegistry: makeEventRegistry(),
            addEvent: function (event, eventType) {
                return this._eventRegistry.add(event, eventType);
            },
            addEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.addEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.addEventListener.apply(target, eventArgs);
            },
            removeEventListener: function (target, eventType) {
                var hasCustomEvent = domEvents._eventRegistry.has(eventType);
                if (hasCustomEvent) {
                    var event = domEvents._eventRegistry.get(eventType);
                    return event.removeEventListener.apply(domEvents, arguments);
                }
                var eventArgs = Array.prototype.slice.call(arguments, 1);
                return target.removeEventListener.apply(target, eventArgs);
            },
            addDelegateListener: function (root, eventType, selector, handler) {
                domEvents._eventTree.add([
                    root,
                    eventType,
                    selector,
                    handler
                ]);
            },
            removeDelegateListener: function (target, eventType, selector, handler) {
                domEvents._eventTree.delete([
                    target,
                    eventType,
                    selector,
                    handler
                ]);
            },
            dispatch: function (target, eventData, bubbles, cancelable) {
                var event = util.createEvent(target, eventData, bubbles, cancelable);
                var enableForDispatch = util.forceEnabledForDispatch(target, event);
                if (enableForDispatch) {
                    target.disabled = false;
                }
                var ret = target.dispatchEvent(event);
                if (enableForDispatch) {
                    target.disabled = true;
                }
                return ret;
            }
        };
        domEvents._eventTree = makeDelegateEventTree(domEvents);
        module.exports = namespace.domEvents = domEvents;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event-dom-radiochange@1.0.5#can-event-dom-radiochange*/
define('can-event-dom-radiochange@1.0.5#can-event-dom-radiochange', [
    'require',
    'exports',
    'module',
    'can-dom-data-state',
    'can-globals/document/document',
    'can-dom-events',
    'can-cid/map/map'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var domData = require('can-dom-data-state');
        var getDocument = require('can-globals/document/document');
        var domEvents = require('can-dom-events');
        var CIDMap = require('can-cid/map/map');
        function getRoot(el) {
            return el.ownerDocument || getDocument().documentElement;
        }
        function getRegistryName(eventName) {
            return 'can-event-radiochange:' + eventName + ':registry';
        }
        function getListenerName(eventName) {
            return 'can-event-radiochange:' + eventName + ':listener';
        }
        function getRegistry(root, eventName) {
            var name = getRegistryName(eventName);
            var registry = domData.get.call(root, name);
            if (!registry) {
                registry = new CIDMap();
                domData.set.call(root, name, registry);
            }
            return registry;
        }
        function findParentForm(el) {
            while (el) {
                if (el.nodeName === 'FORM') {
                    break;
                }
                el = el.parentNode;
            }
            return el;
        }
        function shouldReceiveEventFromRadio(source, dest) {
            var name = source.getAttribute('name');
            return name && name === dest.getAttribute('name') && findParentForm(source) === findParentForm(dest);
        }
        function isRadioInput(el) {
            return el.nodeName === 'INPUT' && el.type === 'radio';
        }
        function dispatch(eventName, target) {
            var root = getRoot(target);
            var registry = getRegistry(root, eventName);
            registry.forEach(function (el) {
                if (shouldReceiveEventFromRadio(target, el)) {
                    domEvents.dispatch(el, eventName);
                }
            });
        }
        function attachRootListener(root, eventName, events) {
            var listenerName = getListenerName(eventName);
            var listener = domData.get.call(root, listenerName);
            if (listener) {
                return;
            }
            var newListener = function (event) {
                var target = event.target;
                if (isRadioInput(target)) {
                    dispatch(eventName, target);
                }
            };
            events.addEventListener(root, 'change', newListener);
            domData.set.call(root, listenerName, newListener);
        }
        function detachRootListener(root, eventName, events) {
            var listenerName = getListenerName(eventName);
            var listener = domData.get.call(root, listenerName);
            if (!listener) {
                return;
            }
            var registry = getRegistry(root, eventName);
            if (registry.size > 0) {
                return;
            }
            events.removeEventListener(root, 'change', listener);
            domData.clean.call(root, listenerName);
        }
        function addListener(eventName, el, events) {
            if (!isRadioInput(el)) {
                throw new Error('Listeners for ' + eventName + ' must be radio inputs');
            }
            var root = getRoot(el);
            getRegistry(root, eventName).set(el, el);
            attachRootListener(root, eventName, events);
        }
        function removeListener(eventName, el, events) {
            var root = getRoot(el);
            getRegistry(root, eventName).delete(el);
            detachRootListener(root, eventName, events);
        }
        module.exports = {
            defaultEventType: 'radiochange',
            addEventListener: function (target, eventName, handler) {
                addListener(eventName, target, this);
                target.addEventListener(eventName, handler);
            },
            removeEventListener: function (target, eventName, handler) {
                removeListener(eventName, target, this);
                target.removeEventListener(eventName, handler);
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-event-dom-radiochange@1.0.5#compat*/
define('can-event-dom-radiochange@1.0.5#compat', [
    'require',
    'exports',
    'module',
    'can-dom-events/helpers/add-event-compat',
    './can-event-dom-radiochange'
], function (require, exports, module) {
    var addEventCompat = require('can-dom-events/helpers/add-event-compat');
    var radioChange = require('./can-event-dom-radiochange');
    module.exports = function (domEvents, eventType) {
        return addEventCompat(domEvents, radioChange, eventType);
    };
});
/*can-stache-bindings@3.11.12#can-stache-bindings*/
define('can-stache-bindings@3.11.12#can-stache-bindings', [
    'require',
    'exports',
    'module',
    'can-stache/src/expression',
    'can-view-callbacks',
    'can-view-live',
    'can-view-scope',
    'can-view-model',
    'can-event',
    'can-compute',
    'can-stache-key',
    'can-observation',
    'can-simple-observable',
    'can-util/js/assign/assign',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-util/js/string/string',
    'can-log/dev/dev',
    'can-types',
    'can-util/js/last/last',
    'can-globals/mutation-observer/mutation-observer',
    'can-util/dom/events/events',
    'can-util/dom/events/removed/removed',
    'can-util/dom/data/data',
    'can-util/dom/attr/attr',
    'can-log',
    'can-stache/helpers/core',
    'can-symbol',
    'can-reflect',
    'can-util/js/single-reference/single-reference',
    'can-attribute-encoder',
    'can-event-dom-enter/compat',
    'can-event-dom-radiochange/compat'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var expression = require('can-stache/src/expression');
        var viewCallbacks = require('can-view-callbacks');
        var live = require('can-view-live');
        var Scope = require('can-view-scope');
        var canViewModel = require('can-view-model');
        var canEvent = require('can-event');
        var compute = require('can-compute');
        var observeReader = require('can-stache-key');
        var Observation = require('can-observation');
        var observable = require('can-simple-observable');
        var assign = require('can-util/js/assign/assign');
        var makeArray = require('can-util/js/make-array/make-array');
        var each = require('can-util/js/each/each');
        var string = require('can-util/js/string/string');
        var dev = require('can-log/dev/dev');
        var types = require('can-types');
        var last = require('can-util/js/last/last');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var domEvents = require('can-util/dom/events/events');
        require('can-util/dom/events/removed/removed');
        var domData = require('can-util/dom/data/data');
        var attr = require('can-util/dom/attr/attr');
        var canLog = require('can-log');
        var stacheHelperCore = require('can-stache/helpers/core');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var singleReference = require('can-util/js/single-reference/single-reference');
        var encoder = require('can-attribute-encoder');
        var addEnterEvent = require('can-event-dom-enter/compat');
        addEnterEvent(domEvents);
        var addRadioChange = require('can-event-dom-radiochange/compat');
        addRadioChange(domEvents);
        var noop = function () {
        };
        var onMatchStr = 'on:', vmMatchStr = 'vm:', elMatchStr = 'el:', byMatchStr = ':by:', toMatchStr = ':to', fromMatchStr = ':from', bindMatchStr = ':bind', attributesEventStr = 'attributes', removedStr = 'removed', viewModelBindingStr = 'viewModel', attributeBindingStr = 'attribute', scopeBindingStr = 'scope', viewModelOrAttributeBindingStr = 'viewModelOrAttribute', getValueSymbol = 'can.getValue', setValueSymbol = 'can.setValue', onValueSymbol = 'can.onValue', offValueSymbol = 'can.offValue';
        function isBindingsAttribute(attributeName) {
            return attributeName.indexOf(toMatchStr) !== -1 || attributeName.indexOf(fromMatchStr) !== -1 || attributeName.indexOf(bindMatchStr) !== -1;
        }
        function setPriority(observable, priority) {
            if (observable instanceof Observation) {
                observable.compute._primaryDepth = priority;
            } else if (observable.computeInstance) {
                observable.computeInstance.setPrimaryDepth(priority);
            } else if (observable.observation) {
                observable.observation.compute._primaryDepth = priority;
            }
        }
        var throwOnlyOneTypeOfBindingError = function () {
            throw new Error('can-stache-bindings - you can not have contextual bindings ( this:from=\'value\' ) and key bindings ( prop:from=\'value\' ) on one element.');
        };
        var checkBindingState = function (bindingState, dataBinding) {
            var isSettingOnViewModel = dataBinding.bindingInfo.parentToChild && dataBinding.bindingInfo.child === viewModelBindingStr;
            if (isSettingOnViewModel) {
                var bindingName = dataBinding.bindingInfo.childName;
                var isSettingViewModel = isSettingOnViewModel && (bindingName === 'this' || bindingName === '.');
                if (isSettingViewModel) {
                    if (bindingState.isSettingViewModel || bindingState.isSettingOnViewModel) {
                        throwOnlyOneTypeOfBindingError();
                    } else {
                        return {
                            isSettingViewModel: true,
                            initialViewModelData: undefined
                        };
                    }
                } else {
                    if (bindingState.isSettingViewModel) {
                        throwOnlyOneTypeOfBindingError();
                    } else {
                        return {
                            isSettingOnViewModel: true,
                            initialViewModelData: bindingState.initialViewModelData
                        };
                    }
                }
            } else {
                return bindingState;
            }
        };
        var behaviors = {
            viewModel: function (el, tagData, makeViewModel, initialViewModelData, staticDataBindingsOnly) {
                var bindingsSemaphore = {}, viewModel, onCompleteBindings = [], onTeardowns = {}, bindingInfos = {}, attributeViewModelBindings = assign({}, initialViewModelData), bindingsState = {
                        isSettingOnViewModel: false,
                        isSettingViewModel: false,
                        initialViewModelData: initialViewModelData || {}
                    }, hasDataBinding = false;
                each(makeArray(el.attributes), function (node) {
                    var dataBinding = makeDataBinding(node, el, {
                        templateType: tagData.templateType,
                        scope: tagData.scope,
                        semaphore: bindingsSemaphore,
                        getViewModel: function () {
                            return viewModel;
                        },
                        attributeViewModelBindings: attributeViewModelBindings,
                        alreadyUpdatedChild: true,
                        nodeList: tagData.parentNodeList,
                        favorViewModel: true
                    });
                    if (dataBinding) {
                        bindingsState = checkBindingState(bindingsState, dataBinding);
                        hasDataBinding = true;
                        if (dataBinding.onCompleteBinding) {
                            if (dataBinding.bindingInfo.parentToChild && dataBinding.value !== undefined) {
                                if (bindingsState.isSettingViewModel) {
                                    bindingsState.initialViewModelData = dataBinding.value;
                                } else {
                                    bindingsState.initialViewModelData[cleanVMName(dataBinding.bindingInfo.childName)] = dataBinding.value;
                                }
                            }
                            onCompleteBindings.push(dataBinding.onCompleteBinding);
                        }
                        onTeardowns[node.name] = dataBinding.onTeardown;
                    }
                });
                if (staticDataBindingsOnly && !hasDataBinding) {
                    return;
                }
                viewModel = makeViewModel(bindingsState.initialViewModelData, hasDataBinding);
                for (var i = 0, len = onCompleteBindings.length; i < len; i++) {
                    onCompleteBindings[i]();
                }
                var attributeListener;
                if (!bindingsState.isSettingViewModel) {
                    attributeListener = function (ev) {
                        var attrName = ev.attributeName, value = el.getAttribute(attrName);
                        if (onTeardowns[attrName]) {
                            onTeardowns[attrName]();
                        }
                        var parentBindingWasAttribute = bindingInfos[attrName] && bindingInfos[attrName].parent === attributeBindingStr;
                        if (value !== null || parentBindingWasAttribute) {
                            var dataBinding = makeDataBinding({
                                name: attrName,
                                value: value
                            }, el, {
                                templateType: tagData.templateType,
                                scope: tagData.scope,
                                semaphore: {},
                                getViewModel: function () {
                                    return viewModel;
                                },
                                attributeViewModelBindings: attributeViewModelBindings,
                                initializeValues: true,
                                nodeList: tagData.parentNodeList
                            });
                            if (dataBinding) {
                                if (dataBinding.onCompleteBinding) {
                                    dataBinding.onCompleteBinding();
                                }
                                bindingInfos[attrName] = dataBinding.bindingInfo;
                                onTeardowns[attrName] = dataBinding.onTeardown;
                            }
                        }
                    };
                    domEvents.addEventListener.call(el, attributesEventStr, attributeListener);
                }
                return function () {
                    domEvents.removeEventListener.call(el, attributesEventStr, attributeListener);
                    for (var attrName in onTeardowns) {
                        onTeardowns[attrName]();
                    }
                };
            },
            data: function (el, attrData) {
                if (domData.get.call(el, 'preventDataBindings')) {
                    return;
                }
                var viewModel, getViewModel = function () {
                        return viewModel || (viewModel = canViewModel(el));
                    }, semaphore = {}, teardown;
                var legacyBindings = bindingsRegExp.exec(attrData.attributeName);
                var twoWay = legacyBindings && legacyBindings[1];
                var dataBinding = makeDataBinding({
                    name: attrData.attributeName,
                    value: el.getAttribute(attrData.attributeName),
                    nodeList: attrData.nodeList
                }, el, {
                    templateType: attrData.templateType,
                    scope: attrData.scope,
                    semaphore: semaphore,
                    getViewModel: getViewModel,
                    syncChildWithParent: twoWay
                });
                if (dataBinding.onCompleteBinding) {
                    dataBinding.onCompleteBinding();
                }
                var attributeListener = function (ev) {
                    var attrName = ev.attributeName, value = el.getAttribute(attrName);
                    if (attrName === attrData.attributeName) {
                        if (teardown) {
                            teardown();
                        }
                        if (value !== null) {
                            var dataBinding = makeDataBinding({
                                name: attrName,
                                value: value
                            }, el, {
                                templateType: attrData.templateType,
                                scope: attrData.scope,
                                semaphore: semaphore,
                                getViewModel: getViewModel,
                                initializeValues: true,
                                nodeList: attrData.nodeList,
                                syncChildWithParent: twoWay
                            });
                            if (dataBinding) {
                                if (dataBinding.onCompleteBinding) {
                                    dataBinding.onCompleteBinding();
                                }
                                teardown = dataBinding.onTeardown;
                            }
                        }
                    }
                };
                domEvents.addEventListener.call(el, attributesEventStr, attributeListener);
                teardown = dataBinding.onTeardown;
                canEvent.one.call(el, removedStr, function () {
                    teardown();
                    domEvents.removeEventListener.call(el, attributesEventStr, attributeListener);
                });
            },
            reference: function (el, attrData) {
                if (el.getAttribute(attrData.attributeName)) {
                    canLog.warn('*reference attributes can only export the view model.');
                }
                var name = string.camelize(attrData.attributeName.substr(1).toLowerCase());
                var viewModel = canViewModel(el);
                attrData.scope.set('scope.vars.' + name, viewModel);
            },
            event: function (el, data) {
                var attributeName = encoder.decode(data.attributeName), event, bindingContext;
                if (attributeName.indexOf(toMatchStr + ':') !== -1 || attributeName.indexOf(fromMatchStr + ':') !== -1 || attributeName.indexOf(bindMatchStr + ':') !== -1) {
                    return this.data(el, data);
                }
                if (startsWith.call(attributeName, 'can-')) {
                    event = attributeName.substr('can-'.length);
                    bindingContext = el;
                } else if (startsWith.call(attributeName, onMatchStr)) {
                    event = attributeName.substr(onMatchStr.length);
                    var viewModel = domData.get.call(el, viewModelBindingStr);
                    var byParent = data.scope;
                    if (startsWith.call(event, elMatchStr)) {
                        event = event.substr(elMatchStr.length);
                        bindingContext = el;
                    } else {
                        if (startsWith.call(event, vmMatchStr)) {
                            event = event.substr(vmMatchStr.length);
                            bindingContext = viewModel;
                            byParent = viewModel;
                        } else {
                            bindingContext = viewModel || el;
                        }
                        var byIndex = event.indexOf(byMatchStr);
                        if (byIndex >= 0) {
                            bindingContext = byParent.get(decodeAttrName(event.substr(byIndex + byMatchStr.length)));
                            event = event.substr(0, byIndex);
                        }
                    }
                } else {
                    event = removeBrackets(attributeName, '(', ')');
                    dev.warn('can-stache-bindings: the event binding format (' + event + ') is deprecated. Use on:' + string.camelize(event[0] === '$' ? event.slice(1) : event.split(' ').reverse().filter(function (s) {
                        return s;
                    }).join(':by:')) + ' instead');
                    if (event.charAt(0) === '$') {
                        event = event.substr(1);
                        bindingContext = el;
                    } else {
                        if (event.indexOf(' ') >= 0) {
                            var eventSplit = event.split(' ');
                            bindingContext = data.scope.get(decodeAttrName(eventSplit[0]));
                            event = eventSplit[1];
                        } else {
                            bindingContext = canViewModel(el);
                        }
                    }
                }
                event = decodeAttrName(event);
                var handler = function (ev) {
                    var attrVal = el.getAttribute(encoder.encode(attributeName));
                    if (!attrVal) {
                        return;
                    }
                    var viewModel = canViewModel(el);
                    var expr = expression.parse(removeBrackets(attrVal), {
                        lookupRule: function () {
                            return expression.Lookup;
                        },
                        methodRule: 'call'
                    });
                    if (!(expr instanceof expression.Call) && !(expr instanceof expression.Helper)) {
                        var defaultArgs = [
                            data.scope._context,
                            el
                        ].concat(makeArray(arguments)).map(function (data) {
                            return new expression.Arg(new expression.Literal(data));
                        });
                        expr = new expression.Call(expr, defaultArgs, {});
                    }
                    var specialValues = {
                        element: el,
                        event: ev,
                        viewModel: viewModel,
                        arguments: arguments
                    };
                    var legacySpecialValues = {
                        '@element': el,
                        '@event': ev,
                        '@viewModel': viewModel,
                        '@scope': data.scope,
                        '@context': data.scope._context,
                        '%element': this,
                        '$element': types.wrapElement(el),
                        '%event': ev,
                        '%viewModel': viewModel,
                        '%scope': data.scope,
                        '%context': data.scope._context,
                        '%arguments': arguments
                    };
                    var localScope = data.scope.add(legacySpecialValues, { notContext: true }).add(specialValues, { special: true });
                    var scopeData = localScope.read(expr.methodExpr.key, { isArgument: true }), args, stacheHelper, stacheHelperResult;
                    if (!scopeData.value) {
                        var name = observeReader.reads(expr.methodExpr.key).map(function (part) {
                            return part.key;
                        }).join('.');
                        stacheHelper = stacheHelperCore.getHelper(name);
                        if (stacheHelper) {
                            args = expr.args(localScope, null)();
                            stacheHelperResult = stacheHelper.fn.apply(localScope.peek('.'), args);
                            if (typeof stacheHelperResult === 'function') {
                                stacheHelperResult(el);
                            }
                            return stacheHelperResult;
                        }
                        return null;
                    }
                    args = expr.args(localScope, null)();
                    return scopeData.value.apply(scopeData.parent, args);
                };
                var attributesHandler = function (ev) {
                    var isEventAttribute = ev.attributeName === attributeName;
                    var isRemoved = !this.getAttribute(attributeName);
                    var isEventAttributeRemoved = isEventAttribute && isRemoved;
                    if (isEventAttributeRemoved) {
                        unbindEvent();
                    }
                };
                var removedHandler = function (ev) {
                    unbindEvent();
                };
                var unbindEvent = function () {
                    canEvent.off.call(bindingContext, event, handler);
                    canEvent.off.call(el, attributesEventStr, attributesHandler);
                    canEvent.off.call(el, removedStr, removedHandler);
                };
                canEvent.on.call(bindingContext, event, handler);
                canEvent.on.call(el, attributesEventStr, attributesHandler);
                canEvent.on.call(el, removedStr, removedHandler);
            },
            value: function (el, data) {
                var propName = '$value', attrValue = removeBrackets(el.getAttribute('can-value')).trim(), nodeName = el.nodeName.toLowerCase(), elType = nodeName === 'input' && (el.type || el.getAttribute('type')), getterSetter;
                if (nodeName === 'input' && (elType === 'checkbox' || elType === 'radio')) {
                    var property = getObservableFrom.scope(el, data.scope, attrValue, {}, true);
                    if (el.type === 'checkbox') {
                        var trueValue = attr.has(el, 'can-true-value') ? el.getAttribute('can-true-value') : true, falseValue = attr.has(el, 'can-false-value') ? el.getAttribute('can-false-value') : false;
                        getterSetter = compute(function (newValue) {
                            var isSet = arguments.length !== 0;
                            if (property && property[canSymbol.for(getValueSymbol)]) {
                                if (isSet) {
                                    canReflect.setValue(property, newValue ? trueValue : falseValue);
                                } else {
                                    return canReflect.getValue(property) == trueValue;
                                }
                            } else {
                                if (isSet) {
                                } else {
                                    return property == trueValue;
                                }
                            }
                        });
                    } else if (elType === 'radio') {
                        getterSetter = compute(function (newValue) {
                            var isSet = arguments.length !== 0 && newValue;
                            if (property && property[canSymbol.for(getValueSymbol)]) {
                                if (isSet) {
                                    canReflect.setValue(property, el.value);
                                } else {
                                    return canReflect.getValue(property) == el.value;
                                }
                            } else {
                                if (isSet) {
                                } else {
                                    return property == el.value;
                                }
                            }
                        });
                    }
                    propName = '$checked';
                    attrValue = 'getterSetter';
                    data.scope = new Scope({ getterSetter: getterSetter });
                } else if (isContentEditable(el)) {
                    propName = '$innerHTML';
                }
                var dataBinding = makeDataBinding({
                    name: '{(' + propName + ')}',
                    value: attrValue
                }, el, {
                    templateType: data.templateType,
                    scope: data.scope,
                    semaphore: {},
                    initializeValues: true,
                    legacyBindings: true
                });
                canEvent.one.call(el, removedStr, function () {
                    dataBinding.onTeardown();
                });
            }
        };
        viewCallbacks.attr(/^(:lb:)[(:c:)\w-]+(:rb:)$/, behaviors.data);
        viewCallbacks.attr(/[\w\.:]+:to$/, behaviors.data);
        viewCallbacks.attr(/[\w\.:]+:from$/, behaviors.data);
        viewCallbacks.attr(/[\w\.:]+:bind$/, behaviors.data);
        viewCallbacks.attr(/[\w\.:]+:to:on:[\w\.:]+/, behaviors.data);
        viewCallbacks.attr(/[\w\.:]+:from:on:[\w\.:]+/, behaviors.data);
        viewCallbacks.attr(/[\w\.:]+:bind:on:[\w\.:]+/, behaviors.data);
        viewCallbacks.attr(/\*[\w\.\-_]+/, behaviors.reference);
        viewCallbacks.attr(/on:[\w\.:]+/, behaviors.event);
        viewCallbacks.attr(/^(:lp:)[(:d:)?\w\.\\]+(:rp:)$/, behaviors.event);
        viewCallbacks.attr(/can-[\w\.]+/, behaviors.event);
        viewCallbacks.attr('can-value', behaviors.value);
        var getObservableFrom = {
            viewModelOrAttribute: function (el, scope, vmNameOrProp, bindingData, mustBeSettable, stickyCompute, event) {
                var viewModel = domData.get.call(el, viewModelBindingStr);
                if (viewModel) {
                    return this.viewModel.apply(this, arguments);
                } else {
                    return this.attribute.apply(this, arguments);
                }
            },
            scope: function (el, scope, scopeProp, bindingData, mustBeSettable, stickyCompute) {
                if (!scopeProp) {
                    return observable();
                } else {
                    if (mustBeSettable) {
                        var parentExpression = expression.parse(scopeProp, { baseMethodType: 'Call' });
                        return parentExpression.value(scope, new Scope.Options({}));
                    } else {
                        var observation = new Observation(function () {
                        });
                        observation[canSymbol.for(getValueSymbol)] = function getValue(newVal) {
                            return scope.get(cleanVMName(scopeProp));
                        };
                        observation[canSymbol.for(setValueSymbol)] = function setValue(newVal) {
                            scope.set(cleanVMName(scopeProp), newVal);
                        };
                        return observation;
                    }
                }
            },
            viewModel: function (el, scope, vmName, bindingData, mustBeSettable, stickyCompute) {
                var setName = cleanVMName(vmName);
                var isBoundToContext = vmName === '.' || vmName === 'this';
                var keysToRead = isBoundToContext ? [] : observeReader.reads(vmName);
                var observation = new Observation(function () {
                    var viewModel = bindingData.getViewModel();
                    return observeReader.read(viewModel, keysToRead, {}).value;
                });
                observation[canSymbol.for(setValueSymbol)] = function (newVal) {
                    var viewModel = bindingData.getViewModel();
                    if (arguments.length) {
                        if (stickyCompute) {
                            var oldValue = canReflect.getKeyValue(viewModel, setName);
                            if (canReflect.isObservableLike(oldValue)) {
                                canReflect.setValue(oldValue, newVal);
                            } else {
                                canReflect.setKeyValue(viewModel, setName, observable(canReflect.getValue(stickyCompute)));
                            }
                        } else {
                            if (isBoundToContext) {
                                canReflect.setValue(viewModel, newVal);
                            } else {
                                canReflect.setKeyValue(viewModel, setName, newVal);
                            }
                        }
                    }
                };
                return observation;
            },
            attribute: function (el, scope, prop, bindingData, mustBeSettable, stickyCompute, event) {
                if (!event) {
                    event = 'change';
                    var isRadioInput = el.nodeName === 'INPUT' && el.type === 'radio';
                    var isValidProp = prop === 'checked' && !bindingData.legacyBindings;
                    if (isRadioInput && isValidProp) {
                        event = 'radiochange';
                    }
                    var isSpecialProp = attr.special[prop] && attr.special[prop].addEventListener;
                    if (isSpecialProp) {
                        event = prop;
                    }
                }
                var hasChildren = el.nodeName.toLowerCase() === 'select', isMultiselectValue = prop === 'value' && hasChildren && el.multiple, set = function (newVal) {
                        if (bindingData.legacyBindings && hasChildren && 'selectedIndex' in el && prop === 'value') {
                            attr.setAttrOrProp(el, prop, newVal == null ? '' : newVal);
                        } else {
                            attr.setAttrOrProp(el, prop, newVal);
                        }
                        return newVal;
                    }, get = function () {
                        return attr.get(el, prop);
                    };
                if (isMultiselectValue) {
                    prop = 'values';
                }
                var observation = new Observation(get);
                observation[canSymbol.for(setValueSymbol)] = set;
                observation[canSymbol.for(getValueSymbol)] = get;
                observation[canSymbol.for(onValueSymbol)] = function (updater) {
                    var translationHandler = function () {
                        updater(get());
                    };
                    singleReference.set(updater, this, translationHandler);
                    if (event === 'radiochange') {
                        canEvent.on.call(el, 'change', translationHandler);
                    }
                    canEvent.on.call(el, event, translationHandler);
                };
                observation[canSymbol.for(offValueSymbol)] = function (updater) {
                    var translationHandler = singleReference.getAndDelete(updater, this);
                    if (event === 'radiochange') {
                        canEvent.off.call(el, 'change', translationHandler);
                    }
                    canEvent.off.call(el, event, translationHandler);
                };
                return observation;
            }
        };
        var bind = {
            childToParent: function (el, parentObservable, childObservable, bindingsSemaphore, attrName, syncChild) {
                var updateParent = function (newVal) {
                    if (!bindingsSemaphore[attrName]) {
                        if (parentObservable && parentObservable[canSymbol.for(getValueSymbol)]) {
                            if (canReflect.getValue(parentObservable) !== newVal) {
                                canReflect.setValue(parentObservable, newVal);
                            }
                            if (syncChild) {
                                if (canReflect.getValue(parentObservable) !== canReflect.getValue(childObservable)) {
                                    bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                                    canReflect.setValue(childObservable, canReflect.getValue(parentObservable));
                                    Observation.afterUpdateAndNotify(function () {
                                        --bindingsSemaphore[attrName];
                                    });
                                }
                            }
                        } else if (canReflect.isMapLike(parentObservable)) {
                            var attrValue = el.getAttribute(attrName);
                            dev.warn('can-stache-bindings: Merging ' + attrName + ' into ' + attrValue + ' because its parent is non-observable');
                            canReflect.eachKey(parentObservable, function (prop) {
                                canReflect.deleteKeyValue(parentObservable, prop);
                            });
                            canReflect.setValue(parentObservable, newVal && newVal.serialize ? newVal.serialize() : newVal, true);
                        }
                    }
                };
                if (childObservable && childObservable[canSymbol.for(getValueSymbol)]) {
                    canReflect.onValue(childObservable, updateParent);
                }
                return updateParent;
            },
            parentToChild: function (el, parentObservable, childUpdate, bindingsSemaphore, attrName) {
                var updateChild = function (newValue) {
                    bindingsSemaphore[attrName] = (bindingsSemaphore[attrName] || 0) + 1;
                    canReflect.setValue(childUpdate, newValue);
                    Observation.afterUpdateAndNotify(function () {
                        --bindingsSemaphore[attrName];
                    });
                };
                if (parentObservable && parentObservable[canSymbol.for(getValueSymbol)]) {
                    canReflect.onValue(parentObservable, updateChild);
                }
                return updateChild;
            }
        };
        var startsWith = String.prototype.startsWith || function (text) {
            return this.indexOf(text) === 0;
        };
        function getEventName(result) {
            if (result.special.on !== undefined) {
                return result.tokens[result.special.on + 1];
            }
        }
        var bindingRules = {
            to: {
                childToParent: true,
                parentToChild: false,
                syncChildWithParent: false
            },
            from: {
                childToParent: false,
                parentToChild: true,
                syncChildWithParent: false
            },
            bind: {
                childToParent: true,
                parentToChild: true,
                syncChildWithParent: true
            }
        };
        var bindingNames = [];
        var special = {
            vm: true,
            on: true
        };
        each(bindingRules, function (value, key) {
            bindingNames.push(key);
            special[key] = true;
        });
        function tokenize(source) {
            var splitByColon = source.split(':');
            var result = {
                tokens: [],
                special: {}
            };
            splitByColon.forEach(function (token) {
                if (special[token]) {
                    result.special[token] = result.tokens.push(token) - 1;
                } else {
                    result.tokens.push(token);
                }
            });
            return result;
        }
        var bindingsRegExp = /\{(\()?(\^)?([^\}\)]+)\)?\}/, ignoreAttributesRegExp = /^(data-view-id|class|name|id|\[[\w\.-]+\]|#[\w\.-])$/i, DOUBLE_CURLY_BRACE_REGEX = /\{\{/g, encodedSpacesRegExp = /\\s/g, encodedForwardSlashRegExp = /\\f/g;
        var getChildBindingStr = function (tokens, favorViewModel) {
            if (tokens.indexOf('vm') >= 0) {
                return viewModelBindingStr;
            } else if (tokens.indexOf('el') >= 0) {
                return attributeBindingStr;
            } else {
                return favorViewModel ? viewModelBindingStr : viewModelOrAttributeBindingStr;
            }
        };
        var getBindingInfo = function (node, attributeViewModelBindings, templateType, tagName, favorViewModel) {
            var bindingInfo, attributeName = encoder.decode(node.name), attributeValue = node.value || '', childName;
            var result = tokenize(attributeName), dataBindingName, specialIndex;
            bindingNames.forEach(function (name) {
                if (result.special[name] !== undefined && result.special[name] > 0) {
                    dataBindingName = name;
                    specialIndex = result.special[name];
                    return false;
                }
            });
            if (dataBindingName) {
                var childEventName = getEventName(result);
                var initializeValues = childEventName ? false : true;
                return assign({
                    parent: scopeBindingStr,
                    child: getChildBindingStr(result.tokens, favorViewModel),
                    childName: result.tokens[specialIndex - 1],
                    childEvent: childEventName,
                    bindingAttributeName: attributeName,
                    parentName: attributeValue,
                    initializeValues: initializeValues
                }, bindingRules[dataBindingName]);
            }
            var matches = attributeName.match(bindingsRegExp);
            if (!matches) {
                var ignoreAttribute = ignoreAttributesRegExp.test(attributeName);
                var vmName = string.camelize(attributeName);
                if (ignoreAttribute || viewCallbacks.attr(encoder.encode(attributeName))) {
                    return;
                }
                var syntaxRight = attributeValue[0] === '{' && last(attributeValue) === '}';
                var isAttributeToChild = templateType === 'legacy' ? attributeViewModelBindings[vmName] : !syntaxRight;
                var scopeName = syntaxRight ? attributeValue.substr(1, attributeValue.length - 2) : attributeValue;
                if (isAttributeToChild) {
                    return {
                        bindingAttributeName: attributeName,
                        parent: attributeBindingStr,
                        parentName: attributeName,
                        child: viewModelBindingStr,
                        childName: vmName,
                        parentToChild: true,
                        childToParent: true,
                        syncChildWithParent: true
                    };
                } else {
                    return {
                        bindingAttributeName: attributeName,
                        parent: scopeBindingStr,
                        parentName: scopeName,
                        child: viewModelBindingStr,
                        childName: vmName,
                        parentToChild: true,
                        childToParent: true,
                        syncChildWithParent: true
                    };
                }
            }
            var twoWay = !!matches[1], childToParent = twoWay || !!matches[2], parentToChild = twoWay || !childToParent;
            childName = matches[3];
            var newLookup = {
                '^': ':to',
                '(': ':bind'
            };
            dev.warn('can-stache-bindings: the data binding format ' + attributeName + ' is deprecated. Use ' + string.camelize(matches[3][0] === '$' ? matches[3].slice(1) : matches[3]) + (newLookup[attributeName.charAt(1)] || ':from') + ' instead');
            var isDOM = childName.charAt(0) === '$';
            if (isDOM) {
                bindingInfo = {
                    parent: scopeBindingStr,
                    child: attributeBindingStr,
                    childToParent: childToParent,
                    parentToChild: parentToChild,
                    bindingAttributeName: attributeName,
                    childName: childName.substr(1),
                    parentName: attributeValue,
                    initializeValues: true,
                    syncChildWithParent: twoWay
                };
                if (tagName === 'select') {
                    bindingInfo.stickyParentToChild = true;
                }
                return bindingInfo;
            } else {
                bindingInfo = {
                    parent: scopeBindingStr,
                    child: viewModelBindingStr,
                    childToParent: childToParent,
                    parentToChild: parentToChild,
                    bindingAttributeName: attributeName,
                    childName: decodeAttrName(string.camelize(childName)),
                    parentName: attributeValue,
                    initializeValues: true,
                    syncChildWithParent: twoWay
                };
                if (attributeValue.trim().charAt(0) === '~') {
                    bindingInfo.stickyParentToChild = true;
                }
                return bindingInfo;
            }
        };
        var decodeAttrName = function (name) {
            return name.replace(encodedSpacesRegExp, ' ').replace(encodedForwardSlashRegExp, '/');
        };
        var makeDataBinding = function (node, el, bindingData) {
            var bindingInfo = getBindingInfo(node, bindingData.attributeViewModelBindings, bindingData.templateType, el.nodeName.toLowerCase(), bindingData.favorViewModel);
            if (!bindingInfo) {
                return;
            }
            bindingInfo.alreadyUpdatedChild = bindingData.alreadyUpdatedChild;
            if (bindingData.initializeValues) {
                bindingInfo.initializeValues = true;
            }
            var parentObservable = getObservableFrom[bindingInfo.parent](el, bindingData.scope, bindingInfo.parentName, bindingData, bindingInfo.parentToChild), childObservable = getObservableFrom[bindingInfo.child](el, bindingData.scope, bindingInfo.childName, bindingData, bindingInfo.childToParent, bindingInfo.stickyParentToChild && parentObservable, bindingInfo.childEvent), updateParent, updateChild;
            if (bindingData.nodeList) {
                if (parentObservable) {
                    setPriority(parentObservable, bindingData.nodeList.nesting + 1);
                }
                if (childObservable) {
                    setPriority(childObservable, bindingData.nodeList.nesting + 1);
                }
            }
            if (bindingInfo.parentToChild) {
                updateChild = bind.parentToChild(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName);
            }
            var completeBinding = function () {
                if (bindingInfo.childToParent) {
                    updateParent = bind.childToParent(el, parentObservable, childObservable, bindingData.semaphore, bindingInfo.bindingAttributeName, bindingInfo.syncChildWithParent);
                } else if (bindingInfo.stickyParentToChild && childObservable[canSymbol.for(onValueSymbol)]) {
                    canReflect.onValue(childObservable, noop);
                }
                if (bindingInfo.initializeValues) {
                    initializeValues(bindingInfo, childObservable, parentObservable, updateChild, updateParent);
                }
            };
            var onTeardown = function () {
                unbindUpdate(parentObservable, updateChild);
                unbindUpdate(childObservable, updateParent);
                unbindUpdate(childObservable, noop);
            };
            if (bindingInfo.child === viewModelBindingStr) {
                return {
                    value: bindingInfo.stickyParentToChild ? observable(getValue(parentObservable)) : getValue(parentObservable),
                    onCompleteBinding: completeBinding,
                    bindingInfo: bindingInfo,
                    onTeardown: onTeardown
                };
            } else {
                completeBinding();
                return {
                    bindingInfo: bindingInfo,
                    onTeardown: onTeardown
                };
            }
        };
        var initializeValues = function (bindingInfo, childObservable, parentObservable, updateChild, updateParent) {
            var doUpdateParent = false;
            if (bindingInfo.parentToChild && !bindingInfo.childToParent) {
            } else if (!bindingInfo.parentToChild && bindingInfo.childToParent) {
                doUpdateParent = true;
            } else if (getValue(childObservable) === undefined) {
            } else if (getValue(parentObservable) === undefined) {
                doUpdateParent = true;
            }
            if (doUpdateParent) {
                updateParent(getValue(childObservable));
            } else {
                if (!bindingInfo.alreadyUpdatedChild) {
                    updateChild(getValue(parentObservable));
                }
            }
        };
        if (!getMutationObserver()) {
            var updateSelectValue = function (el) {
                var bindingCallback = domData.get.call(el, 'canBindingCallback');
                if (bindingCallback) {
                    bindingCallback.onMutation(el);
                }
            };
            live.registerChildMutationCallback('select', updateSelectValue);
            live.registerChildMutationCallback('optgroup', function (el) {
                updateSelectValue(el.parentNode);
            });
        }
        var isContentEditable = function () {
                var values = {
                    '': true,
                    'true': true,
                    'false': false
                };
                var editable = function (el) {
                    if (!el || !el.getAttribute) {
                        return;
                    }
                    var attr = el.getAttribute('contenteditable');
                    return values[attr];
                };
                return function (el) {
                    var val = editable(el);
                    if (typeof val === 'boolean') {
                        return val;
                    } else {
                        return !!editable(el.parentNode);
                    }
                };
            }(), removeBrackets = function (value, open, close) {
                open = open || '{';
                close = close || '}';
                if (value[0] === open && value[value.length - 1] === close) {
                    return value.substr(1, value.length - 2);
                }
                return value;
            }, getValue = function (value) {
                return value && value[canSymbol.for(getValueSymbol)] ? canReflect.getValue(value) : value;
            }, unbindUpdate = function (observable, updater) {
                if (observable && observable[canSymbol.for(getValueSymbol)] && typeof updater === 'function') {
                    canReflect.offValue(observable, updater);
                }
            }, cleanVMName = function (name) {
                return name.replace(/@/g, '');
            };
        module.exports = {
            behaviors: behaviors,
            getBindingInfo: getBindingInfo
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-component@3.3.10#can-component*/
define('can-component@3.3.10#can-component', [
    'require',
    'exports',
    'module',
    './control/control',
    'can-namespace',
    'can-construct',
    'can-stache-bindings',
    'can-view-scope',
    'can-view-callbacks',
    'can-view-nodelist',
    'can-compute',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/dom/dispatch/dispatch',
    'can-types',
    'can-util/js/string/string',
    'can-reflect',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-function/is-function',
    'can-util/js/log/log',
    'can-util/js/dev/dev',
    'can-util/js/make-array/make-array',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/dom/events/inserted/inserted',
    'can-util/dom/events/removed/removed',
    'can-view-model'
], function (require, exports, module) {
    var ComponentControl = require('./control/control');
    var namespace = require('can-namespace');
    var Construct = require('can-construct');
    var stacheBindings = require('can-stache-bindings');
    var Scope = require('can-view-scope');
    var viewCallbacks = require('can-view-callbacks');
    var nodeLists = require('can-view-nodelist');
    var compute = require('can-compute');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var types = require('can-types');
    var string = require('can-util/js/string/string');
    var canReflect = require('can-reflect');
    var canEach = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var canLog = require('can-util/js/log/log');
    var canDev = require('can-util/js/dev/dev');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    require('can-util/dom/events/inserted/inserted');
    require('can-util/dom/events/removed/removed');
    require('can-view-model');
    function addContext(el, tagData, insertionElementTagData) {
        var vm;
        domData.set.call(el, 'preventDataBindings', true);
        var teardown = stacheBindings.behaviors.viewModel(el, insertionElementTagData, function (initialData) {
            return vm = compute(initialData);
        }, undefined, true);
        if (!teardown) {
            return tagData;
        } else {
            return assign(assign({}, tagData), {
                teardown: teardown,
                scope: tagData.scope.add(vm)
            });
        }
    }
    function makeInsertionTagCallback(tagName, componentTagData, shadowTagData, leakScope, getPrimaryTemplate) {
        var options = shadowTagData.options._context;
        return function hookupFunction(el, insertionElementTagData) {
            var template = getPrimaryTemplate(el) || insertionElementTagData.subtemplate, renderingLightContent = template !== insertionElementTagData.subtemplate;
            if (template) {
                delete options.tags[tagName];
                var tagData;
                if (renderingLightContent) {
                    if (leakScope.toLightContent) {
                        tagData = addContext(el, {
                            scope: insertionElementTagData.scope.cloneFromRef(),
                            options: insertionElementTagData.options
                        }, insertionElementTagData);
                    } else {
                        tagData = addContext(el, componentTagData, insertionElementTagData);
                    }
                } else {
                    tagData = addContext(el, insertionElementTagData, insertionElementTagData);
                }
                var nodeList = nodeLists.register([el], function () {
                    if (tagData.teardown) {
                        tagData.teardown();
                    }
                }, insertionElementTagData.parentNodeList || true, false);
                nodeList.expression = '<can-slot name=\'' + el.getAttribute('name') + '\'/>';
                var frag = template(tagData.scope, tagData.options, nodeList);
                var newNodes = makeArray(getChildNodes(frag));
                nodeLists.replace(nodeList, frag);
                nodeLists.update(nodeList, newNodes);
                options.tags[tagName] = hookupFunction;
            }
        };
    }
    var Component = Construct.extend({
        setup: function () {
            Construct.setup.apply(this, arguments);
            if (Component) {
                var self = this;
                if (!isEmptyObject(this.prototype.events)) {
                    this.Control = ComponentControl.extend(this.prototype.events);
                }
                var protoViewModel = this.prototype.viewModel || this.prototype.scope;
                if (protoViewModel && this.prototype.ViewModel) {
                    throw new Error('Cannot provide both a ViewModel and a viewModel property');
                }
                var vmName = string.capitalize(string.camelize(this.prototype.tag)) + 'VM';
                if (this.prototype.ViewModel) {
                    if (typeof this.prototype.ViewModel === 'function') {
                        this.ViewModel = this.prototype.ViewModel;
                    } else {
                        this.ViewModel = types.DefaultMap.extend(vmName, this.prototype.ViewModel);
                    }
                } else {
                    if (protoViewModel) {
                        if (typeof protoViewModel === 'function') {
                            if (canReflect.isObservableLike(protoViewModel.prototype) && canReflect.isMapLike(protoViewModel.prototype)) {
                                this.ViewModel = protoViewModel;
                            } else {
                                this.viewModelHandler = protoViewModel;
                            }
                        } else {
                            if (canReflect.isObservableLike(protoViewModel) && canReflect.isMapLike(protoViewModel)) {
                                this.viewModelInstance = protoViewModel;
                            } else {
                                this.ViewModel = types.DefaultMap.extend(vmName, protoViewModel);
                            }
                        }
                    } else {
                        this.ViewModel = types.DefaultMap.extend(vmName, {});
                    }
                }
                if (this.prototype.template) {
                    this.renderer = this.prototype.template;
                }
                if (this.prototype.view) {
                    this.renderer = this.prototype.view;
                }
                viewCallbacks.tag(this.prototype.tag, function (el, options) {
                    new self(el, options);
                });
            }
        }
    }, {
        setup: function (el, componentTagData) {
            var component = this;
            var teardownFunctions = [];
            var initialViewModelData = {};
            var callTeardownFunctions = function () {
                for (var i = 0, len = teardownFunctions.length; i < len; i++) {
                    teardownFunctions[i]();
                }
            };
            var setupBindings = !domData.get.call(el, 'preventDataBindings');
            var viewModel, frag;
            var teardownBindings;
            if (setupBindings) {
                var setupFn = componentTagData.setupBindings || function (el, callback, data) {
                    return stacheBindings.behaviors.viewModel(el, componentTagData, callback, data);
                };
                teardownBindings = setupFn(el, function (initialViewModelData) {
                    var ViewModel = component.constructor.ViewModel, viewModelHandler = component.constructor.viewModelHandler, viewModelInstance = component.constructor.viewModelInstance;
                    if (viewModelHandler) {
                        var scopeResult = viewModelHandler.call(component, initialViewModelData, componentTagData.scope, el);
                        if (canReflect.isObservableLike(scopeResult) && canReflect.isMapLike(scopeResult)) {
                            viewModelInstance = scopeResult;
                        } else if (canReflect.isObservableLike(scopeResult.prototype) && canReflect.isMapLike(scopeResult.prototype)) {
                            ViewModel = scopeResult;
                        } else {
                            ViewModel = types.DefaultMap.extend(scopeResult);
                        }
                    }
                    if (ViewModel) {
                        viewModelInstance = new component.constructor.ViewModel(initialViewModelData);
                    }
                    viewModel = viewModelInstance;
                    return viewModelInstance;
                }, initialViewModelData);
            }
            this.viewModel = viewModel;
            domData.set.call(el, 'viewModel', viewModel);
            domData.set.call(el, 'preventDataBindings', true);
            var options = {
                helpers: {},
                tags: {}
            };
            canEach(this.helpers || {}, function (val, prop) {
                if (isFunction(val)) {
                    options.helpers[prop] = val.bind(viewModel);
                }
            });
            if (this.constructor.Control) {
                this._control = new this.constructor.Control(el, {
                    scope: this.viewModel,
                    viewModel: this.viewModel,
                    destroy: callTeardownFunctions
                });
            }
            var leakScope = {
                toLightContent: this.leakScope === true,
                intoShadowContent: this.leakScope === true
            };
            var hasShadowTemplate = !!this.constructor.renderer;
            var betweenTagsRenderer;
            var betweenTagsTagData;
            if (hasShadowTemplate) {
                var shadowTagData;
                if (leakScope.intoShadowContent) {
                    shadowTagData = {
                        scope: componentTagData.scope.add(new Scope.Refs()).add(this.viewModel, { viewModel: true }),
                        options: componentTagData.options.add(options)
                    };
                } else {
                    shadowTagData = {
                        scope: Scope.refsScope().add(this.viewModel, { viewModel: true }),
                        options: new Scope.Options(options)
                    };
                }
                options.tags['can-slot'] = makeInsertionTagCallback('can-slot', componentTagData, shadowTagData, leakScope, function (el) {
                    var templates = componentTagData.templates;
                    if (templates) {
                        return templates[el.getAttribute('name')];
                    }
                });
                options.tags.content = makeInsertionTagCallback('content', componentTagData, shadowTagData, leakScope, function () {
                    return componentTagData.subtemplate;
                });
                betweenTagsRenderer = this.constructor.renderer;
                betweenTagsTagData = shadowTagData;
            } else {
                var lightTemplateTagData = {
                    scope: componentTagData.scope.add(this.viewModel, { viewModel: true }),
                    options: componentTagData.options.add(options)
                };
                betweenTagsTagData = lightTemplateTagData;
                betweenTagsRenderer = componentTagData.subtemplate || el.ownerDocument.createDocumentFragment.bind(el.ownerDocument);
            }
            var nodeList = nodeLists.register([], function () {
                domDispatch.call(el, 'beforeremove', [], false);
                if (teardownBindings) {
                    teardownBindings();
                }
            }, componentTagData.parentNodeList || true, false);
            nodeList.expression = '<' + this.tag + '>';
            teardownFunctions.push(function () {
                nodeLists.unregister(nodeList);
            });
            frag = betweenTagsRenderer(betweenTagsTagData.scope, betweenTagsTagData.options, nodeList);
            domMutate.appendChild.call(el, frag);
            nodeLists.update(nodeList, getChildNodes(el));
        }
    });
    module.exports = namespace.Component = Component;
});
/*can-view-target@3.1.6#can-view-target*/
define('can-view-target@3.1.6#can-view-target', [
    'require',
    'exports',
    'module',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/dom/attr/attr',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-globals/document/document',
    'can-util/dom/mutate/mutate',
    'can-namespace',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var childNodes = require('can-util/dom/child-nodes/child-nodes');
        var domAttr = require('can-util/dom/attr/attr');
        var each = require('can-util/js/each/each');
        var makeArray = require('can-util/js/make-array/make-array');
        var getDocument = require('can-globals/document/document');
        var domMutate = require('can-util/dom/mutate/mutate');
        var namespace = require('can-namespace');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        var processNodes = function (nodes, paths, location, document) {
                var frag = document.createDocumentFragment();
                for (var i = 0, len = nodes.length; i < len; i++) {
                    var node = nodes[i];
                    frag.appendChild(processNode(node, paths, location.concat(i), document));
                }
                return frag;
            }, keepsTextNodes = typeof document !== 'undefined' && function () {
                var testFrag = document.createDocumentFragment();
                var div = document.createElement('div');
                div.appendChild(document.createTextNode(''));
                div.appendChild(document.createTextNode(''));
                testFrag.appendChild(div);
                var cloned = testFrag.cloneNode(true);
                return childNodes(cloned.firstChild).length === 2;
            }(), clonesWork = typeof document !== 'undefined' && function () {
                var el = document.createElement('a');
                el.innerHTML = '<xyz></xyz>';
                var clone = el.cloneNode(true);
                var works = clone.innerHTML === '<xyz></xyz>';
                var MO, observer;
                if (works) {
                    el = document.createDocumentFragment();
                    el.appendChild(document.createTextNode('foo-bar'));
                    MO = MUTATION_OBSERVER();
                    if (MO) {
                        observer = new MO(function () {
                        });
                        observer.observe(document.documentElement, {
                            childList: true,
                            subtree: true
                        });
                        clone = el.cloneNode(true);
                        observer.disconnect();
                    } else {
                        clone = el.cloneNode(true);
                    }
                    return clone.childNodes.length === 1;
                }
                return works;
            }(), namespacesWork = typeof document !== 'undefined' && !!document.createElementNS;
        var cloneNode = clonesWork ? function (el) {
            return el.cloneNode(true);
        } : function (node) {
            var document = node.ownerDocument;
            var copy;
            if (node.nodeType === 1) {
                if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml' && namespacesWork && document.createElementNS) {
                    copy = document.createElementNS(node.namespaceURI, node.nodeName);
                } else {
                    copy = document.createElement(node.nodeName);
                }
            } else if (node.nodeType === 3) {
                copy = document.createTextNode(node.nodeValue);
            } else if (node.nodeType === 8) {
                copy = document.createComment(node.nodeValue);
            } else if (node.nodeType === 11) {
                copy = document.createDocumentFragment();
            }
            if (node.attributes) {
                var attributes = makeArray(node.attributes);
                each(attributes, function (node) {
                    if (node && node.specified) {
                        domAttr.setAttribute(copy, node.nodeName || node.name, node.nodeValue || node.value);
                    }
                });
            }
            if (node && node.firstChild) {
                var child = node.firstChild;
                while (child) {
                    copy.appendChild(cloneNode(child));
                    child = child.nextSibling;
                }
            }
            return copy;
        };
        function processNode(node, paths, location, document) {
            var callback, loc = location, nodeType = typeof node, el, p, i, len;
            var getCallback = function () {
                if (!callback) {
                    callback = {
                        path: location,
                        callbacks: []
                    };
                    paths.push(callback);
                    loc = [];
                }
                return callback;
            };
            if (nodeType === 'object') {
                if (node.tag) {
                    if (namespacesWork && node.namespace) {
                        el = document.createElementNS(node.namespace, node.tag);
                    } else {
                        el = document.createElement(node.tag);
                    }
                    if (node.attrs) {
                        for (var attrName in node.attrs) {
                            var value = node.attrs[attrName];
                            if (typeof value === 'function') {
                                getCallback().callbacks.push({ callback: value });
                            } else {
                                domAttr.setAttribute(el, attrName, value);
                            }
                        }
                    }
                    if (node.attributes) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.attributes[i] });
                        }
                    }
                    if (node.children && node.children.length) {
                        if (callback) {
                            p = callback.paths = [];
                        } else {
                            p = paths;
                        }
                        el.appendChild(processNodes(node.children, p, loc, document));
                    }
                } else if (node.comment) {
                    el = document.createComment(node.comment);
                    if (node.callbacks) {
                        for (i = 0, len = node.attributes.length; i < len; i++) {
                            getCallback().callbacks.push({ callback: node.callbacks[i] });
                        }
                    }
                }
            } else if (nodeType === 'string') {
                el = document.createTextNode(node);
            } else if (nodeType === 'function') {
                if (keepsTextNodes) {
                    el = document.createTextNode('');
                    getCallback().callbacks.push({ callback: node });
                } else {
                    el = document.createComment('~');
                    getCallback().callbacks.push({
                        callback: function () {
                            var el = document.createTextNode('');
                            domMutate.replaceChild.call(this.parentNode, el, this);
                            return node.apply(el, arguments);
                        }
                    });
                }
            }
            return el;
        }
        function getCallbacks(el, pathData, elementCallbacks) {
            var path = pathData.path, callbacks = pathData.callbacks, paths = pathData.paths, child = el, pathLength = path ? path.length : 0, pathsLength = paths ? paths.length : 0;
            for (var i = 0; i < pathLength; i++) {
                child = child.childNodes.item(path[i]);
            }
            for (i = 0; i < pathsLength; i++) {
                getCallbacks(child, paths[i], elementCallbacks);
            }
            elementCallbacks.push({
                element: child,
                callbacks: callbacks
            });
        }
        function hydrateCallbacks(callbacks, args) {
            var len = callbacks.length, callbacksLength, callbackElement, callbackData;
            for (var i = 0; i < len; i++) {
                callbackData = callbacks[i];
                callbacksLength = callbackData.callbacks.length;
                callbackElement = callbackData.element;
                for (var c = 0; c < callbacksLength; c++) {
                    callbackData.callbacks[c].callback.apply(callbackElement, args);
                }
            }
        }
        function makeTarget(nodes, doc) {
            var paths = [];
            var frag = processNodes(nodes, paths, [], doc || getDocument());
            return {
                paths: paths,
                clone: frag,
                hydrate: function () {
                    var cloned = cloneNode(this.clone);
                    var args = makeArray(arguments);
                    var callbacks = [];
                    for (var i = 0; i < paths.length; i++) {
                        getCallbacks(cloned, paths[i], callbacks);
                    }
                    hydrateCallbacks(callbacks, args);
                    return cloned;
                }
            };
        }
        makeTarget.keepsTextNodes = keepsTextNodes;
        makeTarget.cloneNode = cloneNode;
        namespace.view = namespace.view || {};
        module.exports = namespace.view.target = makeTarget;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@3.15.0#src/mustache_core*/
define('can-stache@3.15.0#src/mustache_core', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-view-nodelist',
    'can-compute',
    'can-observation',
    './utils',
    './expression',
    'can-util/dom/frag/frag',
    'can-util/dom/attr/attr',
    'can-symbol',
    'can-reflect',
    'can-log/dev/dev',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var live = require('can-view-live');
        var nodeLists = require('can-view-nodelist');
        var compute = require('can-compute');
        var Observation = require('can-observation');
        var utils = require('./utils');
        var expression = require('./expression');
        var frag = require('can-util/dom/frag/frag');
        var attr = require('can-util/dom/attr/attr');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var dev = require('can-log/dev/dev');
        var getDocument = require('can-globals/document/document');
        var mustacheLineBreakRegExp = /(?:(^|\r?\n)(\s*)(\{\{([\s\S]*)\}\}\}?)([^\S\n\r]*)($|\r?\n))|(\{\{([\s\S]*)\}\}\}?)/g, mustacheWhitespaceRegExp = /(\s*)(\{\{\{?)(-?)([\s\S]*?)(-?)(\}\}\}?)(\s*)/g, k = function () {
            };
        var core = {
            expression: expression,
            makeEvaluator: function (scope, helperOptions, nodeList, mode, exprData, truthyRenderer, falseyRenderer, stringOnly) {
                if (mode === '^') {
                    var temp = truthyRenderer;
                    truthyRenderer = falseyRenderer;
                    falseyRenderer = temp;
                }
                var value, helperOptionArg;
                if (exprData instanceof expression.Call) {
                    helperOptionArg = {
                        context: scope.peek('.'),
                        scope: scope,
                        nodeList: nodeList,
                        exprData: exprData,
                        helpers: helperOptions
                    };
                    utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                    value = exprData.value(scope, helperOptions, helperOptionArg);
                    if (exprData.isHelper) {
                        return value;
                    }
                } else if (exprData instanceof expression.Bracket) {
                    value = exprData.value(scope);
                    if (exprData.isHelper) {
                        return value;
                    }
                } else if (exprData instanceof expression.Lookup) {
                    value = exprData.value(scope);
                    if (exprData.isHelper) {
                        return value;
                    }
                } else if (exprData instanceof expression.Helper && exprData.methodExpr instanceof expression.Bracket) {
                    value = exprData.methodExpr.value(scope);
                    if (exprData.isHelper) {
                        return value;
                    }
                } else {
                    var readOptions = {
                        isArgument: true,
                        args: [
                            scope.peek('.'),
                            scope
                        ],
                        asCompute: true
                    };
                    var helperAndValue = exprData.helperAndValue(scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                    var helper = helperAndValue.helper;
                    value = helperAndValue.value;
                    if (helper) {
                        return exprData.evaluator(helper, scope, helperOptions, readOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                    }
                }
                if (!mode) {
                    return value;
                } else if (mode === '#' || mode === '^') {
                    helperOptionArg = {};
                    utils.convertToScopes(helperOptionArg, scope, helperOptions, nodeList, truthyRenderer, falseyRenderer, stringOnly);
                    return function () {
                        var finalValue = canReflect.getValue(value);
                        if (typeof finalValue === 'function') {
                            return finalValue;
                        } else if (typeof finalValue !== 'string' && utils.isArrayLike(finalValue)) {
                            var isObserveList = canReflect.isObservableLike(finalValue) && canReflect.isListLike(finalValue);
                            if (canReflect.getKeyValue(finalValue, 'length')) {
                                if (stringOnly) {
                                    return utils.getItemsStringContent(finalValue, isObserveList, helperOptionArg, helperOptions);
                                } else {
                                    return frag(utils.getItemsFragContent(finalValue, helperOptionArg, scope));
                                }
                            } else {
                                return helperOptionArg.inverse(scope, helperOptions);
                            }
                        } else {
                            return finalValue ? helperOptionArg.fn(finalValue || scope, helperOptions) : helperOptionArg.inverse(scope, helperOptions);
                        }
                    };
                } else {
                }
            },
            makeLiveBindingPartialRenderer: function (expressionString, state) {
                expressionString = expressionString.trim();
                var exprData, partialName = expressionString.split(/\s+/).shift();
                if (partialName !== expressionString) {
                    exprData = core.expression.parse(expressionString);
                }
                return function (scope, options, parentSectionNodeList) {
                    var nodeList = [this];
                    nodeList.expression = '>' + partialName;
                    nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                    var partialFrag = compute(function () {
                        var localPartialName = partialName;
                        if (exprData && exprData.argExprs.length === 1) {
                            var newContext = canReflect.getValue(exprData.argExprs[0].value(scope, options));
                            if (typeof newContext === 'undefined') {
                            } else {
                                scope = scope.add(newContext);
                            }
                        }
                        var partial = options.peek('partials.' + localPartialName);
                        var parent = options;
                        while (!partial && parent) {
                            partial = parent.inlinePartials && parent.inlinePartials[localPartialName];
                            parent = parent._parent;
                        }
                        var renderer;
                        if (partial) {
                            renderer = function () {
                                return partial.render ? partial.render(scope, options, nodeList) : partial(scope, options);
                            };
                        } else {
                            var scopePartialName = scope.read(localPartialName, { isArgument: true }).value;
                            if (scopePartialName === null || !scopePartialName && localPartialName[0] === '*') {
                                return frag('');
                            }
                            if (scopePartialName) {
                                localPartialName = scopePartialName;
                            }
                            renderer = function () {
                                if (typeof localPartialName === 'function') {
                                    return localPartialName(scope, options, nodeList);
                                } else {
                                    var domRenderer = core.getTemplateById(localPartialName);
                                    return domRenderer ? domRenderer(scope, options, nodeList) : getDocument().createDocumentFragment();
                                }
                            };
                        }
                        var res = Observation.ignore(renderer)();
                        return frag(res);
                    });
                    partialFrag.computeInstance.setPrimaryDepth(nodeList.nesting);
                    live.html(this, partialFrag, this.parentNode, nodeList);
                };
            },
            makeStringBranchRenderer: function (mode, expressionString, state) {
                var exprData = core.expression.parse(expressionString), fullExpression = mode + expressionString;
                if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call)) {
                    exprData = new expression.Helper(exprData, [], {});
                }
                var branchRenderer = function branchRenderer(scope, options, truthyRenderer, falseyRenderer) {
                    var evaluator = scope.__cache[fullExpression];
                    if (mode || !evaluator) {
                        evaluator = makeEvaluator(scope, options, null, mode, exprData, truthyRenderer, falseyRenderer, true);
                        if (!mode) {
                            scope.__cache[fullExpression] = evaluator;
                        }
                    }
                    var gotObservableValue = evaluator[canSymbol.for('can.onValue')], res;
                    if (gotObservableValue) {
                        res = canReflect.getValue(evaluator);
                    } else {
                        res = evaluator();
                    }
                    return res == null ? '' : '' + res;
                };
                branchRenderer.exprData = exprData;
                return branchRenderer;
            },
            makeLiveBindingBranchRenderer: function (mode, expressionString, state) {
                var exprData = core.expression.parse(expressionString);
                if (!(exprData instanceof expression.Helper) && !(exprData instanceof expression.Call) && !(exprData instanceof expression.Bracket) && !(exprData instanceof expression.Lookup)) {
                    exprData = new expression.Helper(exprData, [], {});
                }
                var branchRenderer = function branchRenderer(scope, options, parentSectionNodeList, truthyRenderer, falseyRenderer) {
                    var nodeList = [this];
                    nodeList.expression = expressionString;
                    nodeLists.register(nodeList, null, parentSectionNodeList || true, state.directlyNested);
                    var evaluator = makeEvaluator(scope, options, nodeList, mode, exprData, truthyRenderer, falseyRenderer, state.tag);
                    var gotObservableValue = evaluator[canSymbol.for('can.onValue')];
                    var observable;
                    if (gotObservableValue) {
                        observable = evaluator;
                    } else {
                        observable = new Observation(evaluator, null, { isObservable: false });
                    }
                    if (observable instanceof Observation) {
                        observable.compute._primaryDepth = nodeList.nesting;
                    } else if (observable.computeInstance) {
                        observable.computeInstance.setPrimaryDepth(nodeList.nesting);
                    } else if (observable.observation) {
                        observable.observation.compute._primaryDepth = nodeList.nesting;
                    }
                    canReflect.onValue(observable, k);
                    var value = canReflect.getValue(observable);
                    if (typeof value === 'function') {
                        Observation.ignore(value)(this);
                    } else if (canReflect.valueHasDependencies(observable)) {
                        if (state.attr) {
                            live.attr(this, state.attr, observable);
                        } else if (state.tag) {
                            live.attrs(this, observable);
                        } else if (state.text && typeof value !== 'object') {
                            live.text(this, observable, this.parentNode, nodeList);
                        } else {
                            live.html(this, observable, this.parentNode, nodeList);
                        }
                    } else {
                        if (state.attr) {
                            attr.set(this, state.attr, value);
                        } else if (state.tag) {
                            live.attrs(this, value);
                        } else if (state.text && typeof value === 'string') {
                            this.nodeValue = value;
                        } else if (value != null) {
                            nodeLists.replace([this], frag(value, this.ownerDocument));
                        }
                    }
                    canReflect.offValue(observable, k);
                };
                branchRenderer.exprData = exprData;
                return branchRenderer;
            },
            splitModeFromExpression: function (expression, state) {
                expression = expression.trim();
                var mode = expression.charAt(0);
                if ('#/{&^>!<'.indexOf(mode) >= 0) {
                    expression = expression.substr(1).trim();
                } else {
                    mode = null;
                }
                if (mode === '{' && state.node) {
                    mode = null;
                }
                return {
                    mode: mode,
                    expression: expression
                };
            },
            cleanLineEndings: function (template) {
                return template.replace(mustacheLineBreakRegExp, function (whole, returnBefore, spaceBefore, special, expression, spaceAfter, returnAfter, spaceLessSpecial, spaceLessExpression, matchIndex) {
                    spaceAfter = spaceAfter || '';
                    returnBefore = returnBefore || '';
                    spaceBefore = spaceBefore || '';
                    var modeAndExpression = splitModeFromExpression(expression || spaceLessExpression, {});
                    if (spaceLessSpecial || '>{'.indexOf(modeAndExpression.mode) >= 0) {
                        return whole;
                    } else if ('^#!/'.indexOf(modeAndExpression.mode) >= 0) {
                        spaceBefore = returnBefore + spaceBefore && ' ';
                        return spaceBefore + special + (matchIndex !== 0 && returnAfter.length ? returnBefore + '\n' : '');
                    } else {
                        return spaceBefore + special + spaceAfter + (spaceBefore.length || matchIndex !== 0 ? returnBefore + '\n' : '');
                    }
                });
            },
            cleanWhitespaceControl: function (template) {
                return template.replace(mustacheWhitespaceRegExp, function (whole, spaceBefore, bracketBefore, controlBefore, expression, controlAfter, bracketAfter, spaceAfter, matchIndex) {
                    if (controlBefore === '-') {
                        spaceBefore = '';
                    }
                    if (controlAfter === '-') {
                        spaceAfter = '';
                    }
                    return spaceBefore + bracketBefore + expression + bracketAfter + spaceAfter;
                });
            },
            Options: utils.Options,
            getTemplateById: function () {
            }
        };
        var makeEvaluator = core.makeEvaluator, splitModeFromExpression = core.splitModeFromExpression;
        module.exports = core;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@3.15.0#src/html_section*/
define('can-stache@3.15.0#src/html_section', [
    'require',
    'exports',
    'module',
    'can-view-target',
    'can-view-scope',
    'can-observation',
    './utils',
    './mustache_core',
    'can-globals/document/document',
    'can-util/js/assign/assign',
    'can-util/js/last/last'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var target = require('can-view-target');
        var Scope = require('can-view-scope');
        var Observation = require('can-observation');
        var utils = require('./utils');
        var mustacheCore = require('./mustache_core');
        var getDocument = require('can-globals/document/document');
        var assign = require('can-util/js/assign/assign');
        var last = require('can-util/js/last/last');
        var decodeHTML = typeof document !== 'undefined' && function () {
            var el = getDocument().createElement('div');
            return function (html) {
                if (html.indexOf('&') === -1) {
                    return html.replace(/\r\n/g, '\n');
                }
                el.innerHTML = html;
                return el.childNodes.length === 0 ? '' : el.childNodes.item(0).nodeValue;
            };
        }();
        var HTMLSectionBuilder = function (filename) {
            if (filename) {
                this.filename = filename;
            }
            this.stack = [new HTMLSection()];
        };
        HTMLSectionBuilder.scopify = function (renderer) {
            return Observation.ignore(function (scope, options, nodeList) {
                if (!(scope instanceof Scope)) {
                    scope = Scope.refsScope().add(scope || {});
                }
                if (!(options instanceof mustacheCore.Options)) {
                    options = new mustacheCore.Options(options || {});
                }
                return renderer(scope, options, nodeList);
            });
        };
        assign(HTMLSectionBuilder.prototype, utils.mixins);
        assign(HTMLSectionBuilder.prototype, {
            startSubSection: function (process) {
                var newSection = new HTMLSection(process);
                this.stack.push(newSection);
                return newSection;
            },
            endSubSectionAndReturnRenderer: function () {
                if (this.last().isEmpty()) {
                    this.stack.pop();
                    return null;
                } else {
                    var htmlSection = this.endSection();
                    return htmlSection.compiled.hydrate.bind(htmlSection.compiled);
                }
            },
            startSection: function (process) {
                var newSection = new HTMLSection(process);
                this.last().add(newSection.targetCallback);
                this.stack.push(newSection);
            },
            endSection: function () {
                this.last().compile();
                return this.stack.pop();
            },
            inverse: function () {
                this.last().inverse();
            },
            compile: function () {
                var compiled = this.stack.pop().compile();
                return Observation.ignore(function (scope, options, nodeList) {
                    if (!(scope instanceof Scope)) {
                        scope = Scope.refsScope().add(scope || {});
                    }
                    if (!(options instanceof mustacheCore.Options)) {
                        options = new mustacheCore.Options(options || {});
                    }
                    return compiled.hydrate(scope, options, nodeList);
                });
            },
            push: function (chars) {
                this.last().push(chars);
            },
            pop: function () {
                return this.last().pop();
            },
            removeCurrentNode: function () {
                this.last().removeCurrentNode();
            }
        });
        var HTMLSection = function (process) {
            this.data = 'targetData';
            this.targetData = [];
            this.targetStack = [];
            var self = this;
            this.targetCallback = function (scope, options, sectionNode) {
                process.call(this, scope, options, sectionNode, self.compiled.hydrate.bind(self.compiled), self.inverseCompiled && self.inverseCompiled.hydrate.bind(self.inverseCompiled));
            };
        };
        assign(HTMLSection.prototype, {
            inverse: function () {
                this.inverseData = [];
                this.data = 'inverseData';
            },
            push: function (data) {
                this.add(data);
                this.targetStack.push(data);
            },
            pop: function () {
                return this.targetStack.pop();
            },
            add: function (data) {
                if (typeof data === 'string') {
                    data = decodeHTML(data);
                }
                if (this.targetStack.length) {
                    last(this.targetStack).children.push(data);
                } else {
                    this[this.data].push(data);
                }
            },
            compile: function () {
                this.compiled = target(this.targetData, getDocument());
                if (this.inverseData) {
                    this.inverseCompiled = target(this.inverseData, getDocument());
                    delete this.inverseData;
                }
                this.targetStack = this.targetData = null;
                return this.compiled;
            },
            removeCurrentNode: function () {
                var children = this.children();
                return children.pop();
            },
            children: function () {
                if (this.targetStack.length) {
                    return last(this.targetStack).children;
                } else {
                    return this[this.data];
                }
            },
            isEmpty: function () {
                return !this.targetData.length;
            }
        });
        HTMLSectionBuilder.HTMLSection = HTMLSection;
        module.exports = HTMLSectionBuilder;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@3.15.0#src/text_section*/
define('can-stache@3.15.0#src/text_section', [
    'require',
    'exports',
    'module',
    'can-compute',
    'can-view-live',
    './utils',
    'can-util/dom/attr/attr',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-observation'
], function (require, exports, module) {
    var compute = require('can-compute');
    var live = require('can-view-live');
    var utils = require('./utils');
    var attr = require('can-util/dom/attr/attr');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var noop = function () {
    };
    var TextSectionBuilder = function () {
        this.stack = [new TextSection()];
    };
    assign(TextSectionBuilder.prototype, utils.mixins);
    assign(TextSectionBuilder.prototype, {
        startSection: function (process) {
            var subSection = new TextSection();
            this.last().add({
                process: process,
                truthy: subSection
            });
            this.stack.push(subSection);
        },
        endSection: function () {
            this.stack.pop();
        },
        inverse: function () {
            this.stack.pop();
            var falseySection = new TextSection();
            this.last().last().falsey = falseySection;
            this.stack.push(falseySection);
        },
        compile: function (state) {
            var renderer = this.stack[0].compile();
            return function (scope, options) {
                var observation = new Observation(function () {
                    return renderer(scope, options);
                }, null, { isObservable: false });
                canReflect.onValue(observation, noop);
                var value = canReflect.getValue(observation);
                if (canReflect.valueHasDependencies(observation)) {
                    if (state.textContentOnly) {
                        live.text(this, observation);
                    } else if (state.attr) {
                        live.attr(this, state.attr, observation);
                    } else {
                        live.attrs(this, observation, scope, options);
                    }
                    canReflect.offValue(observation, noop);
                } else {
                    if (state.textContentOnly) {
                        this.nodeValue = value;
                    } else if (state.attr) {
                        attr.set(this, state.attr, value);
                    } else {
                        live.attrs(this, value);
                    }
                }
            };
        }
    });
    var passTruthyFalsey = function (process, truthy, falsey) {
        return function (scope, options) {
            return process.call(this, scope, options, truthy, falsey);
        };
    };
    var TextSection = function () {
        this.values = [];
    };
    assign(TextSection.prototype, {
        add: function (data) {
            this.values.push(data);
        },
        last: function () {
            return this.values[this.values.length - 1];
        },
        compile: function () {
            var values = this.values, len = values.length;
            for (var i = 0; i < len; i++) {
                var value = this.values[i];
                if (typeof value === 'object') {
                    values[i] = passTruthyFalsey(value.process, value.truthy && value.truthy.compile(), value.falsey && value.falsey.compile());
                }
            }
            return function (scope, options) {
                var txt = '', value;
                for (var i = 0; i < len; i++) {
                    value = values[i];
                    txt += typeof value === 'string' ? value : value.call(this, scope, options);
                }
                return txt;
            };
        }
    });
    module.exports = TextSectionBuilder;
});
/*can-stache@3.15.0#helpers/converter*/
define('can-stache@3.15.0#helpers/converter', [
    'require',
    'exports',
    'module',
    './core',
    '../src/expression',
    'can-util/js/make-array/make-array'
], function (require, exports, module) {
    var helpers = require('./core');
    var expression = require('../src/expression');
    var makeArray = require('can-util/js/make-array/make-array');
    helpers.registerConverter = function (name, getterSetter) {
        getterSetter = getterSetter || {};
        helpers.registerHelper(name, function (newVal, source) {
            var args = makeArray(arguments);
            if (newVal instanceof expression.SetIdentifier) {
                return typeof getterSetter.set === 'function' ? getterSetter.set.apply(this, [newVal.value].concat(args.slice(1))) : source(newVal.value);
            } else {
                return typeof getterSetter.get === 'function' ? getterSetter.get.apply(this, args) : args[0];
            }
        });
    };
    module.exports = helpers;
});
/*can-stache@3.15.0#src/intermediate_and_imports*/
define('can-stache@3.15.0#src/intermediate_and_imports', [
    'require',
    'exports',
    'module',
    './mustache_core',
    'can-view-parser'
], function (require, exports, module) {
    var mustacheCore = require('./mustache_core');
    var parser = require('can-view-parser');
    module.exports = function (filename, source) {
        if (arguments.length === 1) {
            source = arguments[0];
            filename = undefined;
        }
        var template = source;
        template = mustacheCore.cleanWhitespaceControl(template);
        template = mustacheCore.cleanLineEndings(template);
        var imports = [], dynamicImports = [], ases = {}, inImport = false, inFrom = false, inAs = false, isUnary = false, importIsDynamic = false, currentAs = '', currentFrom = '';
        function processImport() {
            if (currentAs) {
                ases[currentAs] = currentFrom;
                currentAs = '';
            }
            if (importIsDynamic) {
                dynamicImports.push(currentFrom);
            } else {
                imports.push(currentFrom);
            }
        }
        var intermediate = parser(template, {
            filename: filename,
            start: function (tagName, unary) {
                if (tagName === 'can-import') {
                    isUnary = unary;
                    importIsDynamic = false;
                    inImport = true;
                } else if (tagName === 'can-dynamic-import') {
                    isUnary = unary;
                    importIsDynamic = true;
                    inImport = true;
                } else if (inImport) {
                    importIsDynamic = true;
                    inImport = false;
                }
            },
            attrStart: function (attrName) {
                if (attrName === 'from') {
                    inFrom = true;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = true;
                }
            },
            attrEnd: function (attrName) {
                if (attrName === 'from') {
                    inFrom = false;
                } else if (attrName === 'as' || attrName === 'export-as') {
                    inAs = false;
                }
            },
            attrValue: function (value) {
                if (inFrom && inImport) {
                    currentFrom = value;
                } else if (inAs && inImport) {
                    currentAs = value;
                }
            },
            end: function (tagName) {
                if ((tagName === 'can-import' || tagName === 'can-dymamic-import') && isUnary) {
                    processImport();
                }
            },
            close: function (tagName) {
                if (tagName === 'can-import' || tagName === 'can-dymamic-import') {
                    processImport();
                }
            },
            chars: function (text) {
                if (text.trim().length > 0) {
                    importIsDynamic = true;
                }
            },
            special: function (text) {
                importIsDynamic = true;
            }
        }, true);
        return {
            intermediate: intermediate,
            imports: imports,
            dynamicImports: dynamicImports,
            ases: ases,
            exports: ases
        };
    };
});
/*can-util@3.14.0#js/import/import*/
define('can-util@3.14.0#js/import/import', [
    'require',
    'exports',
    'module',
    '../is-function/is-function',
    'can-globals/global/global',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var isFunction = require('../is-function/is-function');
        var global = require('can-globals/global/global')();
        var namespace = require('can-namespace');
        module.exports = namespace.import = function (moduleName, parentName) {
            return new Promise(function (resolve, reject) {
                try {
                    if (typeof global.System === 'object' && isFunction(global.System['import'])) {
                        global.System['import'](moduleName, { name: parentName }).then(resolve, reject);
                    } else if (global.define && global.define.amd) {
                        global.require([moduleName], function (value) {
                            resolve(value);
                        });
                    } else if (global.require) {
                        resolve(global.require(moduleName));
                    } else {
                        if (typeof stealRequire !== 'undefined') {
                            steal.import(moduleName, { name: parentName }).then(resolve, reject);
                        } else {
                            resolve();
                        }
                    }
                } catch (err) {
                    reject(err);
                }
            });
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache@3.15.0#can-stache*/
define('can-stache@3.15.0#can-stache', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-view-callbacks',
    './src/html_section',
    './src/text_section',
    './src/mustache_core',
    './helpers/core',
    './helpers/converter',
    './src/intermediate_and_imports',
    './src/utils',
    'can-attribute-encoder',
    'can-log/dev/dev',
    'can-namespace',
    'can-globals/document/document',
    'can-util/js/assign/assign',
    'can-util/js/last/last',
    'can-util/js/import/import',
    'can-view-target',
    'can-view-nodelist'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var parser = require('can-view-parser');
        var viewCallbacks = require('can-view-callbacks');
        var HTMLSectionBuilder = require('./src/html_section');
        var TextSectionBuilder = require('./src/text_section');
        var mustacheCore = require('./src/mustache_core');
        var mustacheHelpers = require('./helpers/core');
        require('./helpers/converter');
        var getIntermediateAndImports = require('./src/intermediate_and_imports');
        var makeRendererConvertScopes = require('./src/utils').makeRendererConvertScopes;
        var attributeEncoder = require('can-attribute-encoder');
        var dev = require('can-log/dev/dev');
        var namespace = require('can-namespace');
        var DOCUMENT = require('can-globals/document/document');
        var assign = require('can-util/js/assign/assign');
        var last = require('can-util/js/last/last');
        var importer = require('can-util/js/import/import');
        require('can-view-target');
        require('can-view-nodelist');
        if (!viewCallbacks.tag('content')) {
            viewCallbacks.tag('content', function (el, tagData) {
                return tagData.scope;
            });
        }
        var wrappedAttrPattern = /[{(].*[)}]/;
        var colonWrappedAttrPattern = /^on:|(:to|:from|:bind)$|.*:to:on:.*/;
        var svgNamespace = 'http://www.w3.org/2000/svg';
        var namespaces = {
                'svg': svgNamespace,
                'g': svgNamespace
            }, textContentOnlyTag = {
                style: true,
                script: true
            };
        function stache(filename, template) {
            if (arguments.length === 1) {
                template = arguments[0];
                filename = undefined;
            }
            var inlinePartials = {};
            if (typeof template === 'string') {
                template = mustacheCore.cleanWhitespaceControl(template);
                template = mustacheCore.cleanLineEndings(template);
            }
            var section = new HTMLSectionBuilder(filename), state = {
                    node: null,
                    attr: null,
                    sectionElementStack: [],
                    text: false,
                    namespaceStack: [],
                    textContentOnly: null
                }, makeRendererAndUpdateSection = function (section, mode, stache, lineNo) {
                    if (mode === '>') {
                        section.add(mustacheCore.makeLiveBindingPartialRenderer(stache, copyState({ lineNo: lineNo })));
                    } else if (mode === '/') {
                        var createdSection = section.last();
                        if (createdSection.startedWith === '<') {
                            inlinePartials[stache] = section.endSubSectionAndReturnRenderer();
                            section.removeCurrentNode();
                        } else {
                            section.endSection();
                        }
                        if (section instanceof HTMLSectionBuilder) {
                            state.sectionElementStack.pop();
                        }
                    } else if (mode === 'else') {
                        section.inverse();
                    } else {
                        var makeRenderer = section instanceof HTMLSectionBuilder ? mustacheCore.makeLiveBindingBranchRenderer : mustacheCore.makeStringBranchRenderer;
                        if (mode === '{' || mode === '&') {
                            section.add(makeRenderer(null, stache, copyState({ lineNo: lineNo })));
                        } else if (mode === '#' || mode === '^' || mode === '<') {
                            var renderer = makeRenderer(mode, stache, copyState({ lineNo: lineNo }));
                            section.startSection(renderer);
                            section.last().startedWith = mode;
                            if (section instanceof HTMLSectionBuilder) {
                                state.sectionElementStack.push({ type: 'section' });
                            }
                        } else {
                            section.add(makeRenderer(null, stache, copyState({
                                text: true,
                                lineNo: lineNo
                            })));
                        }
                    }
                }, copyState = function (overwrites) {
                    var lastElement = state.sectionElementStack[state.sectionElementStack.length - 1];
                    var cur = {
                        tag: state.node && state.node.tag,
                        attr: state.attr && state.attr.name,
                        directlyNested: state.sectionElementStack.length ? lastElement.type === 'section' || lastElement.type === 'custom' : true,
                        textContentOnly: !!state.textContentOnly
                    };
                    return overwrites ? assign(cur, overwrites) : cur;
                }, addAttributesCallback = function (node, callback) {
                    if (!node.attributes) {
                        node.attributes = [];
                    }
                    node.attributes.unshift(callback);
                };
            parser(template, {
                filename: filename,
                start: function (tagName, unary, lineNo) {
                    var matchedNamespace = namespaces[tagName];
                    if (matchedNamespace && !unary) {
                        state.namespaceStack.push(matchedNamespace);
                    }
                    state.node = {
                        tag: tagName,
                        children: [],
                        namespace: matchedNamespace || last(state.namespaceStack)
                    };
                },
                end: function (tagName, unary, lineNo) {
                    var isCustomTag = viewCallbacks.tag(tagName);
                    if (unary) {
                        section.add(state.node);
                        if (isCustomTag) {
                            addAttributesCallback(state.node, function (scope, options, parentNodeList) {
                                viewCallbacks.tagHandler(this, tagName, {
                                    scope: scope,
                                    options: options,
                                    subtemplate: null,
                                    templateType: 'stache',
                                    parentNodeList: parentNodeList
                                });
                            });
                        }
                    } else {
                        section.push(state.node);
                        state.sectionElementStack.push({
                            type: isCustomTag ? 'custom' : null,
                            tag: isCustomTag ? null : tagName,
                            templates: {}
                        });
                        if (isCustomTag) {
                            section.startSubSection();
                        } else if (textContentOnlyTag[tagName]) {
                            state.textContentOnly = new TextSectionBuilder();
                        }
                    }
                    state.node = null;
                },
                close: function (tagName, lineNo) {
                    var matchedNamespace = namespaces[tagName];
                    if (matchedNamespace) {
                        state.namespaceStack.pop();
                    }
                    var isCustomTag = viewCallbacks.tag(tagName), renderer;
                    if (isCustomTag) {
                        renderer = section.endSubSectionAndReturnRenderer();
                    }
                    if (textContentOnlyTag[tagName]) {
                        section.last().add(state.textContentOnly.compile(copyState()));
                        state.textContentOnly = null;
                    }
                    var oldNode = section.pop();
                    if (isCustomTag) {
                        if (tagName === 'can-template') {
                            var parent = state.sectionElementStack[state.sectionElementStack.length - 2];
                            if (renderer) {
                                parent.templates[oldNode.attrs.name] = makeRendererConvertScopes(renderer);
                            }
                            section.removeCurrentNode();
                        } else {
                            var current = state.sectionElementStack[state.sectionElementStack.length - 1];
                            addAttributesCallback(oldNode, function (scope, options, parentNodeList) {
                                viewCallbacks.tagHandler(this, tagName, {
                                    scope: scope,
                                    options: options,
                                    subtemplate: renderer ? makeRendererConvertScopes(renderer) : renderer,
                                    templateType: 'stache',
                                    parentNodeList: parentNodeList,
                                    templates: current.templates
                                });
                            });
                        }
                    }
                    state.sectionElementStack.pop();
                },
                attrStart: function (attrName, lineNo) {
                    if (state.node.section) {
                        state.node.section.add(attrName + '="');
                    } else {
                        state.attr = {
                            name: attrName,
                            value: ''
                        };
                    }
                },
                attrEnd: function (attrName, lineNo) {
                    if (state.node.section) {
                        state.node.section.add('" ');
                    } else {
                        if (!state.node.attrs) {
                            state.node.attrs = {};
                        }
                        state.node.attrs[state.attr.name] = state.attr.section ? state.attr.section.compile(copyState()) : state.attr.value;
                        var attrCallback = viewCallbacks.attr(attrName);
                        if (attrCallback) {
                            if (!state.node.attributes) {
                                state.node.attributes = [];
                            }
                            state.node.attributes.push(function (scope, options, nodeList) {
                                attrCallback(this, {
                                    attributeName: attrName,
                                    scope: scope,
                                    options: options,
                                    nodeList: nodeList
                                });
                            });
                        }
                        state.attr = null;
                    }
                },
                attrValue: function (value, lineNo) {
                    var section = state.node.section || state.attr.section;
                    if (section) {
                        section.add(value);
                    } else {
                        state.attr.value += value;
                    }
                },
                chars: function (text, lineNo) {
                    (state.textContentOnly || section).add(text);
                },
                special: function (text, lineNo) {
                    var firstAndText = mustacheCore.splitModeFromExpression(text, state), mode = firstAndText.mode, expression = firstAndText.expression;
                    if (expression === 'else') {
                        var inverseSection;
                        if (state.attr && state.attr.section) {
                            inverseSection = state.attr.section;
                        } else if (state.node && state.node.section) {
                            inverseSection = state.node.section;
                        } else {
                            inverseSection = state.textContentOnly || section;
                        }
                        inverseSection.inverse();
                        return;
                    }
                    if (mode === '!') {
                        return;
                    }
                    if (state.node && state.node.section) {
                        makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
                        if (state.node.section.subSectionDepth() === 0) {
                            state.node.attributes.push(state.node.section.compile(copyState()));
                            delete state.node.section;
                        }
                    } else if (state.attr) {
                        if (!state.attr.section) {
                            state.attr.section = new TextSectionBuilder();
                            if (state.attr.value) {
                                state.attr.section.add(state.attr.value);
                            }
                        }
                        makeRendererAndUpdateSection(state.attr.section, mode, expression, lineNo);
                    } else if (state.node) {
                        if (!state.node.attributes) {
                            state.node.attributes = [];
                        }
                        if (!mode) {
                            state.node.attributes.push(mustacheCore.makeLiveBindingBranchRenderer(null, expression, copyState({ lineNo: lineNo })));
                        } else if (mode === '#' || mode === '^') {
                            if (!state.node.section) {
                                state.node.section = new TextSectionBuilder();
                            }
                            makeRendererAndUpdateSection(state.node.section, mode, expression, lineNo);
                        } else {
                            throw new Error(mode + ' is currently not supported within a tag.');
                        }
                    } else {
                        makeRendererAndUpdateSection(state.textContentOnly || section, mode, expression, lineNo);
                    }
                },
                comment: function (text) {
                    section.add({ comment: text });
                },
                done: function (lineNo) {
                }
            });
            var renderer = section.compile();
            var scopifiedRenderer = HTMLSectionBuilder.scopify(function (scope, optionsScope, nodeList) {
                if (Object.keys(inlinePartials).length) {
                    optionsScope.inlinePartials = optionsScope.inlinePartials || {};
                    assign(optionsScope.inlinePartials, inlinePartials);
                }
                scope.set('scope.view', scopifiedRenderer);
                scope.set('scope.root', scope._context);
                return renderer.apply(this, arguments);
            });
            return scopifiedRenderer;
        }
        assign(stache, mustacheHelpers);
        stache.safeString = function (text) {
            return {
                toString: function () {
                    return text;
                }
            };
        };
        stache.async = function (source) {
            var iAi = getIntermediateAndImports(source);
            var importPromises = iAi.imports.map(function (moduleName) {
                return importer(moduleName);
            });
            return Promise.all(importPromises).then(function () {
                return stache(iAi.intermediate);
            });
        };
        var templates = {};
        stache.from = mustacheCore.getTemplateById = function (id) {
            if (!templates[id]) {
                var el = DOCUMENT().getElementById(id);
                if (el) {
                    templates[id] = stache('#' + id, el.innerHTML);
                }
            }
            return templates[id];
        };
        stache.registerPartial = function (id, partial) {
            templates[id] = typeof partial === 'string' ? stache(partial) : partial;
        };
        module.exports = namespace.stache = stache;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-qunit@1.0.2#add-dom*/
define('steal-qunit@1.0.2#add-dom', function (require, exports, module) {
    'format cjs';
    if (!document.getElementById('qunit')) {
        var qunit = document.createElement('div');
        qunit.id = 'qunit';
        (document.body || document.documentElement).appendChild(qunit);
    }
});
/*qunitjs@1.23.1#qunit/qunit*/
define('qunitjs@1.23.1#qunit/qunit', [
    'module',
    '@loader',
    'require',
    'steal-qunit/add-dom'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: ['steal-qunit/add-dom'],
        exports: 'QUnit'
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/*!\n * QUnit 1.23.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-12T17:29Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = "qunit-test-string";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || "" ).replace( /(:\\d+)+\\)?/, "" ).replace( /.+\\//, "" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( "array", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid "Member not found" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== "constructor" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== "undefined" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === "undefined" ) {\n\t\treturn "undefined";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn "null";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase "Number":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn "nan";\n\t\t\t}\n\t\t\treturn "number";\n\t\tcase "String":\n\t\tcase "Boolean":\n\t\tcase "Array":\n\t\tcase "Set":\n\t\tcase "Map":\n\t\tcase "Date":\n\t\tcase "RegExp":\n\t\tcase "Function":\n\t\tcase "Symbol":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === "object" ) {\n\t\treturn "object";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn\'t support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( "\\n" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( "\\n" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// Exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For actual exceptions, this is useful\n\t\treturn e.sourceURL + ":" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with "Hide passed tests" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: "",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ "begin", "done", "log", "testStart", "testDone",\n\t\t\t"moduleStart", "moduleDone" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== "function" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t"QUnit logging methods require a callback function as their first parameters."\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === "undefined" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t"QUnit." + loggingCallback + " was replaced with a new value.\\n" +\n\t\t\t\t\t"Please, check out the documentation on how to apply logging callbacks.\\n" +\n\t\t\t\t\t"Reference: https://api.qunitjs.com/category/callbacks/"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( "global failure", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + ":" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we\'re running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== "file:" );\n\n// Expose the current QUnit version\nQUnit.version = "1.23.1";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === "function" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, "beforeEach" ),\n\t\t\tafterEach: setHook( module, "afterEach" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === "function" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( " > " ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName )\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context while already started" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context too many times" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( "Called start() outside of a test context when " +\n\t\t\t\t\t"QUnit.config.autostart was true" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn\'t completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() with a non-numeric decrement.",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don\'t start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t"Called start() while already started (test\'s semaphore was 0 already)",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn\'t a test running, don\'t allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( "Called stop() outside of a test context" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: ""\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn\'t officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run\'s beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === "" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules\' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( "begin", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( "Test timed out", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( "Test timed out" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( "done", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\nvar priorityCount = 0;\nvar unitSampler;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += " ";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we\'re switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn\'t\n\t\t\t\t// yet exist it means this is the first test in a suite that isn\'t wrapped in a\n\t\t\t\t// module, in which case we\'ll just emit a moduleStart event for \'undefined\'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, "previousModule" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, "previousModule" ) ) {\n\t\t\t\trunLoggingCallbacks( "moduleDone", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( "moduleStart", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( "testStart", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( "Died on test #" + ( this.assertions.length + 1 ) + " " +\n\t\t\t\tthis.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they\'re blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + " failed on " + test.testName + ": " +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === "function" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( "Expected number of assertions to be defined, but expect() was " +\n\t\t\t\t"not called.", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected " + this.expected + " assertions, but " +\n\t\t\t\tthis.assertions.length + " were run", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( "Expected at least one assertion, but none were run - call " +\n\t\t\t\t"expect(0) to accept zero assertions.", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "testDone", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t} );\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It\'s still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "beforeEach" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( "afterEach" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( "qunit-test-" + this.module.name + "-" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( "pushFailure() assertion outside test context, was " +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || "error",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( "log", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === "function" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = "Promise rejected " +\n\t\t\t\t\t\t\t( !phase ? "during" : phase.replace( /Each$/, "" ) ) +\n\t\t\t\t\t\t\t" " + test.testName + ": " + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + ": " + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== "!";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( "qunit-fixture" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( "pushFailure() assertion outside test context, in " +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java\'s String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + "\\x1C" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn\'t\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = "0000000" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === "array" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join( ", " ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join( ", " ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don\'t slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test\'s semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === "undefined" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( "Too many calls to the `assert.async` callback",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it\'s use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( "assertion outside test context, in " + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( "Assertion after the final `assert.async` was resolved",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? "okay" : "failed, expected argument to be truthy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? "okay" : "failed, expected argument to be falsy, was: " +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t"throws": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// \'expected\' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === "string" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don\'t want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === "regexp" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a string\n\t\t\t} else if ( expectedType === "string" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === "function" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === "object" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === "function" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ "throws" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === "[object" ) {\n\t\tname = error.name ? error.name.toString() : "Error";\n\t\tmessage = error.message ? error.message.toString() : "";\n\t\tif ( name && message ) {\n\t\t\treturn name + ": " + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn "Error";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS \'new\' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === "object" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === "object" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn "flags" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t"string": useStrictEquality,\n\t\t"boolean": useStrictEquality,\n\t\t"number": useStrictEquality,\n\t\t"null": useStrictEquality,\n\t\t"undefined": useStrictEquality,\n\t\t"symbol": useStrictEquality,\n\t\t"date": useStrictEquality,\n\n\t\t"nan": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t"regexp": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t"function": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== "undefined";\n\t\t},\n\n\t\t"array": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t"set": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"map": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t"object": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don\'t ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b\'s properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We\'re done when there\'s nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn "\\"" + str.toString().replace( /\\\\/g, "\\\\\\\\" ).replace( /"/g, "\\\\\\"" ) + "\\"";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + "";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( "," + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn "[object Array]";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( "[", ret, "]" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn "recursion(" + ( inStack - stack.length ) + ")";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === "function" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === "string" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = "null";\n\t\t\t\t} else if ( typeof obj === "undefined" ) {\n\t\t\t\t\ttype = "undefined";\n\t\t\t\t} else if ( QUnit.is( "regexp", obj ) ) {\n\t\t\t\t\ttype = "regexp";\n\t\t\t\t} else if ( QUnit.is( "date", obj ) ) {\n\t\t\t\t\ttype = "date";\n\t\t\t\t} else if ( QUnit.is( "function", obj ) ) {\n\t\t\t\t\ttype = "function";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = "window";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = "document";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = "node";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === "[object Array]" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === "number" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = "array";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = "error";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? "<br />" : "\\n" : this.HTML ? "&#160;" : " ";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn "";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, "   " ).replace( / /g, "&#160;" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: "[Window]",\n\t\t\t\tdocument: "[Document]",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn "Error(\\"" + error.message + "\\")";\n\t\t\t\t},\n\t\t\t\tunknown: "[Unknown]",\n\t\t\t\t"null": "null",\n\t\t\t\t"undefined": "undefined",\n\t\t\t\t"function": function( fn ) {\n\t\t\t\t\tvar ret = "function",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = "name" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += " " + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += "(";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, "functionArgs" ), "){" ].join( "" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, "functionCode" ), "}" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t"arguments": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn "[object Object]";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ "message", "name" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, "key" ) + ": " +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( "{", ret, "}" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? "&lt;" : "<",\n\t\t\t\t\t\tclose = dump.HTML ? "&gt;" : ">",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, "" or\n\t\t\t\t\t\t\t// "inherit".\n\t\t\t\t\t\t\tif ( val && val !== "inherit" ) {\n\t\t\t\t\t\t\t\tret += " " + attrs[ i ].nodeName + "=" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, "attribute" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + "/" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it\'s the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn "";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is \'a\'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn " " + args.join( ", " ) + " ";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it\'s the content of the function\n\t\t\t\tfunctionCode: "[code]",\n\n\t\t\t\t// Node calls it internally, it\'s a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t"boolean": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: "  ",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\n// Deprecated\n// Extend assert methods to QUnit for Backwards compatibility\n( function() {\n\tvar i,\n\t\tassertions = Assert.prototype;\n\n\tfunction applyCurrent( current ) {\n\t\treturn function() {\n\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\tcurrent.apply( assert, arguments );\n\t\t};\n\t}\n\n\tfor ( i in assertions ) {\n\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t}\n}() );\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t( function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t"test",\n\t\t\t\t"module",\n\t\t\t\t"expect",\n\t\t\t\t"asyncTest",\n\t\t\t\t"start",\n\t\t\t\t"stop",\n\t\t\t\t"ok",\n\t\t\t\t"notOk",\n\t\t\t\t"equal",\n\t\t\t\t"notEqual",\n\t\t\t\t"propEqual",\n\t\t\t\t"notPropEqual",\n\t\t\t\t"deepEqual",\n\t\t\t\t"notDeepEqual",\n\t\t\t\t"strictEqual",\n\t\t\t\t"notStrictEqual",\n\t\t\t\t"throws",\n\t\t\t\t"raises"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t}() );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== "undefined" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments\' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== "undefined" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === "function" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== "undefined" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against "moduleName: testName"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: "hidepassed",\n\t\tlabel: "Hide passed tests",\n\t\ttooltip: "Only show tests and assertions that fail. Stored as query-strings."\n\t},\n\t{\n\t\tid: "noglobals",\n\t\tlabel: "Check for Globals",\n\t\ttooltip: "Enabling this will test if any test introduces new properties on the " +\n\t\t\t"global object (`window` in Browsers). Stored as query-strings."\n\t},\n\t{\n\t\tid: "notrycatch",\n\t\tlabel: "No try-catch",\n\t\ttooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " +\n\t\t\t"exceptions in IE reasonable. Stored as query-strings."\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== "string" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( "&" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( "=" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( "=" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don\'t load the HTML Reporter on non-browser environments\nif ( typeof window === "undefined" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar config = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = "";\n\tconfig.queue = [];\n\n\tappendInterface();\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = "qunit-test-string";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn "";\n\t}\n\ts = s + "";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /[\'"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase "\'":\n\t\t\treturn "&#039;";\n\t\tcase "\\"":\n\t\t\treturn "&quot;";\n\t\tcase "<":\n\t\t\treturn "&lt;";\n\t\tcase ">":\n\t\t\treturn "&gt;";\n\t\tcase "&":\n\t\t\treturn "&amp;";\n\t\t}\n\t} );\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// Support: IE <9\n\t\telem.attachEvent( "on" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t} );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( " " + elem.className + " " ).indexOf( " " + name + " " ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? " " : "" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === "undefined" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = " " + elem.className + " ";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( " " + name + " " ) >= 0 ) {\n\t\tset = set.replace( " " + name + " ", " " );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === "function" ? set.trim() : set.replace( /^\\s+|\\s+$/g, "" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = "";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty "id" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === "string" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === "string" ) {\n\t\t\turlConfigHtml += "<input id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' type=\'checkbox\'" +\n\t\t\t\t( val.value ? " value=\'" + escapeText( val.value ) + "\'" : "" ) +\n\t\t\t\t( config[ val.id ] ? " checked=\'checked\'" : "" ) +\n\t\t\t\t" title=\'" + escapedTooltip + "\' /><label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label + "</label>";\n\t\t} else {\n\t\t\turlConfigHtml += "<label for=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' title=\'" + escapedTooltip + "\'>" + val.label +\n\t\t\t\t": </label><select id=\'qunit-urlconfig-" + escaped +\n\t\t\t\t"\' name=\'" + escaped + "\' title=\'" + escapedTooltip + "\'><option></option>";\n\n\t\t\tif ( QUnit.is( "array", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += "<option value=\'" + escaped + "\'" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t">" + escaped + "</option>";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += "<option value=\'" + escapeText( j ) + "\'" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && " selected=\'selected\'" : "" ) +\n\t\t\t\t\t\t\t">" + escapeText( val.value[ j ] ) + "</option>";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += "<option value=\'" + escaped +\n\t\t\t\t\t"\' selected=\'selected\' disabled=\'disabled\'>" + escaped + "</option>";\n\t\t\t}\n\t\t\turlConfigHtml += "</select>";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle "click" events on toolbar checkboxes and "change" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( "selectedIndex" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( "hidepassed" === field.name && "replaceState" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( "qunit-tests" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, "hidepass", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, "", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = "?",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += "=" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += "&";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + "//" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( "qunit-modulefilter" ),\n\t\tfilter = id( "qunit-filter-input" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl( {\n\t\tmodule: ( selectedModule === "" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === "" ) ? undefined : filter,\n\n\t\t// Remove moduleId and testId filters\n\t\tmoduleId: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( "span" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, "qunit-url-config" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use "click" instead of "change" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( "input" ), "click", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( "select" ), "change", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( "form" ),\n\t\tlabel = document.createElement( "label" ),\n\t\tinput = document.createElement( "input" ),\n\t\tbutton = document.createElement( "button" );\n\n\taddClass( filter, "qunit-filter" );\n\n\tlabel.innerHTML = "Filter: ";\n\n\tinput.type = "text";\n\tinput.value = config.filter || "";\n\tinput.name = "filter";\n\tinput.id = "qunit-filter-input";\n\n\tbutton.innerHTML = "Go";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, "submit", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = "";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += "<label for=\'qunit-modulefilter\'>Module: </label>" +\n\t\t"<select id=\'qunit-modulefilter\' name=\'modulefilter\'><option value=\'\' " +\n\t\t( QUnit.urlParams.module === undefined ? "selected=\'selected\'" : "" ) +\n\t\t">< All Modules ></option>";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += "<option value=\'" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + "\' " +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? "selected=\'selected\'" : "" ) +\n\t\t\t">" + escapeText( modulesList[ i ] ) + "</option>";\n\t}\n\tmoduleFilterHtml += "</select>";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" ),\n\t\tmoduleFilter = document.createElement( "span" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( "id", "qunit-modulefilter-container" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, "change", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( "qunit-testrunner-toolbar" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( "qunit-header" );\n\n\tif ( header ) {\n\t\theader.innerHTML = "<a href=\'" + escapeText( unfilteredUrl ) + "\'>" + header.innerHTML +\n\t\t\t"</a> ";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( "qunit-banner" );\n\n\tif ( banner ) {\n\t\tbanner.className = "";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( "qunit-tests" ),\n\t\tresult = id( "qunit-testresult" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = "";\n\t\tresult = document.createElement( "p" );\n\t\tresult.id = "qunit-testresult";\n\t\tresult.className = "result";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = "Running...<br />&#160;";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( "qunit-fixture" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn "";\n\t}\n\treturn "<div id=\'qunit-filteredTest\'>Rerunning selected tests: " +\n\t\tescapeText( testId.join( ", " ) ) +\n\t\t" <a id=\'qunit-clearFilter\' href=\'" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t"\'>Run all tests</a></div>";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( "qunit-userAgent" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = "";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t"QUnit " + QUnit.version + "; " + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( "qunit" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t"<h1 id=\'qunit-header\'>" + escapeText( document.title ) + "</h1>" +\n\t\t\t"<h2 id=\'qunit-banner\'></h2>" +\n\t\t\t"<div id=\'qunit-testrunner-toolbar\'></div>" +\n\t\t\tappendFilteredTest() +\n\t\t\t"<h2 id=\'qunit-userAgent\'></h2>" +\n\t\t\t"<ol id=\'qunit-tests\'></ol>";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( "strong" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( "a" );\n\trerunTrigger.innerHTML = "Rerun";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( "li" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = "qunit-test-output-" + testId;\n\n\tassertList = document.createElement( "ol" );\n\tassertList.className = "qunit-assert-list";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( "qunit-tests" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, "hidepass" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( "qunit-banner" ),\n\t\ttests = id( "qunit-tests" ),\n\t\thtml = [\n\t\t\t"Tests completed in ",\n\t\t\tdetails.runtime,\n\t\t\t" milliseconds.<br />",\n\t\t\t"<span class=\'passed\'>",\n\t\t\tdetails.passed,\n\t\t\t"</span> assertions of <span class=\'total\'>",\n\t\t\tdetails.total,\n\t\t\t"</span> passed, <span class=\'failed\'>",\n\t\t\tdetails.failed,\n\t\t\t"</span> failed."\n\t\t].join( "" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? "qunit-fail" : "qunit-pass";\n\t}\n\n\tif ( tests ) {\n\t\tid( "qunit-testresult" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show \u2716 for good, \u2714 for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? "\\u2716" : "\\u2714" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, "" )\n\t\t].join( " " );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( "qunit-test-" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = "";\n\n\tif ( module ) {\n\t\tnameHtml = "<span class=\'module-name\'>" + escapeText( module ) + "</span>: ";\n\t}\n\n\tnameHtml += "<span class=\'test-name\'>" + escapeText( name ) + "</span>";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( "qunit-test-output-" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = "running";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( "qunit-testresult" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( "qunit-test-" + details.module + "-" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t"Rerunning previously failed test: <br />" :\n\t\t\t"Running: <br />" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, "" ).replace( /\\&quot;/g, "" ).replace( /\\s+/g, "" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? "okay" : "failed" );\n\tmessage = "<span class=\'test-message\'>" + message + "</span>";\n\tmessage += "<span class=\'runtime\'>@ " + details.runtime + " ms</span>";\n\n\t// The pushFailure doesn\'t provide details.expected\n\t// when it calls, it\'s implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, "expected" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = "NOT " + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += "<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>" +\n\t\t\tescapeText( expected ) +\n\t\t\t"</pre></td></tr>";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += "<tr class=\'test-actual\'><th>Result: </th><td><pre>" +\n\t\t\t\tescapeText( actual ) + "</pre></td></tr>";\n\n\t\t\t// Don\'t show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don\'t show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += "<tr class=\'test-diff\'><th>Diff: </th><td><pre>" +\n\t\t\t\t\tdiff + "</pre></td></tr>";\n\t\t\t}\n\t\t} else if ( expected.indexOf( "[object Array]" ) !== -1 ||\n\t\t\t\texpected.indexOf( "[object Object]" ) !== -1 ) {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the depth of object is more than current max depth (" +\n\t\t\t\tQUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " +\n\t\t\t\t" run with a higher max depth or <a href=\'" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + "\'>" +\n\t\t\t\t"Rerun</a> without max depth.</p></td></tr>";\n\t\t} else {\n\t\t\tmessage += "<tr class=\'test-message\'><th>Message: </th><td>" +\n\t\t\t\t"Diff suppressed as the expected and actual results have an equivalent" +\n\t\t\t\t" serialization</td></tr>";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += "<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\t\tescapeText( details.source ) + "</pre></td></tr>";\n\t\t}\n\n\t\tmessage += "</table>";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += "<table>" +\n\t\t\t"<tr class=\'test-source\'><th>Source: </th><td><pre>" +\n\t\t\tescapeText( details.source ) + "</pre></td></tr>" +\n\t\t\t"</table>";\n\t}\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tassertLi = document.createElement( "li" );\n\tassertLi.className = details.result ? "pass" : "fail";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( "qunit-tests" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( "qunit-test-output-" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( "ol" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( "qunit-test-" + details.module + "-" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( "qunit-test-" + details.module + "-" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, "qunit-collapsed" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t"<b class=\'failed\'>" + bad + "</b>, " + "<b class=\'passed\'>" + good + "</b>, " :\n\t\t"";\n\n\ttestTitle.innerHTML += " <b class=\'counts\'>(" + testCounts +\n\t\tdetails.assertions.length + ")</b>";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = "skipped";\n\t\tskipped = document.createElement( "em" );\n\t\tskipped.className = "qunit-skipped-label";\n\t\tskipped.innerHTML = "skipped";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( assertList, "qunit-collapsed" );\n\t\t} );\n\n\t\ttestItem.className = bad ? "fail" : "pass";\n\n\t\ttime = document.createElement( "span" );\n\t\ttime.className = "runtime";\n\t\ttime.innerHTML = details.runtime + " ms";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( "p" );\n\t\tsourceName.innerHTML = "<strong>Source: </strong>" + details.source;\n\t\taddClass( sourceName, "qunit-source" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, "qunit-collapsed" );\n\t\t}\n\t\taddEvent( testTitle, "click", function() {\n\t\t\ttoggleClass( sourceName, "qunit-collapsed" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === "complete" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, "load", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch\'s JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, \'Hello\'], [DIFF_INSERT, \'Goodbye\'], [DIFF_EQUAL, \' world.\']]\n\t * which means: delete \'Hello\', add \'Goodbye\' and keep \' world.\'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don\'t run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( "Null input. (DiffMain)" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === "undefined" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = "<ins>" + escapeText( data ) + "</ins>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = "<del>" + escapeText( data ) + "</del>";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = "<span>" + escapeText( data ) + "</span>";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( "" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don\'t run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can\'t be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // \'this\' becomes \'window\' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = "";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the \'middle snake\' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the \'middle snake\', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === \'Hello\\n\'\n\t\tlineHash = {};  // E.g. lineHash[\'Hello\\n\'] === 4\n\n\t\t// \'\\x00\' is a valid character, but various debuggers don\'t like it.\n\t\t// So we\'ll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = "";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = "";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split(\'\\n\') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( "\\n", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( "" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn\'t cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, "" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = "";\n\t\ttextInsert = "";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = "";\n\t\t\t\ttextInsert = "";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === "" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don\'t need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, 'QUnit');
});
/*steal-css@1.3.2#css*/
define('steal-css@1.3.2#css', [
    'require',
    'exports',
    'module',
    '@loader',
    '@steal'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var loader = require('@loader');
        var steal = require('@steal');
        var isNode = typeof process === 'object' && {}.toString.call(process) === '[object process]';
        var importRegEx = /@import [^uU]['"]?([^'"\)]*)['"]?/g;
        var resourceRegEx = /url\(['"]?([^'"\)]*)['"]?\)/g;
        var waitSeconds = loader.cssOptions && loader.cssOptions.timeout ? parseInt(loader.cssOptions.timeout, 10) : 60;
        var onloadCss = function (link, cb) {
            var styleSheets = getDocument().styleSheets, i = styleSheets.length;
            while (i--) {
                if (styleSheets[i].href === link.href) {
                    return cb();
                }
            }
            setTimeout(function () {
                onloadCss(link, cb);
            });
        };
        function isIE9() {
            var doc = getDocument();
            return doc && !!Function('/*@cc_on return (/^9/.test(@_jscript_version) && /MSIE 9.0(?!.*IEMobile)/i.test(navigator.userAgent)); @*/')();
        }
        function getDocument() {
            if (typeof doneSsr !== 'undefined' && doneSsr.globalDocument) {
                return doneSsr.globalDocument;
            }
            if (typeof document !== 'undefined') {
                return document;
            }
            throw new Error('Unable to load CSS in an environment without a document.');
        }
        function getHead() {
            var doc = getDocument();
            var head = doc.head || doc.getElementsByTagName('head')[0];
            if (!head) {
                var docEl = doc.documentElement || doc;
                head = doc.createElement('head');
                docEl.insertBefore(head, docEl.firstChild);
            }
            return head;
        }
        function CSSModule(load, loader) {
            if (typeof load === 'object') {
                this.load = load;
                this.loader = loader;
                this.address = this.load.address;
                this.source = this.load.source;
            } else {
                this.address = load;
                this.source = loader;
            }
        }
        CSSModule.cssCount = 0;
        CSSModule.ie9MaxStyleSheets = 31;
        CSSModule.currentStyleSheet = null;
        CSSModule.prototype = {
            injectLink: function () {
                if (this._loaded) {
                    return this._loaded;
                }
                if (this.linkExists()) {
                    this._loaded = Promise.resolve('');
                    return this._loaded;
                }
                var doc = getDocument();
                var link = this.link = doc.createElement('link');
                link.type = 'text/css';
                link.rel = 'stylesheet';
                link.href = this.address;
                this._loaded = new Promise(function (resolve, reject) {
                    var timeout = setTimeout(function () {
                        reject('Unable to load CSS');
                    }, waitSeconds * 1000);
                    var loadCB = function (event) {
                        clearTimeout(timeout);
                        link.removeEventListener('load', loadCB);
                        link.removeEventListener('error', loadCB);
                        if (event && event.type === 'error') {
                            reject('Unable to load CSS');
                        } else {
                            resolve('');
                        }
                    };
                    if ('isApplicationInstalled' in navigator || !link.addEventListener) {
                        onloadCss(link, loadCB);
                    } else if (navigator.noUI) {
                        loadCB();
                    } else {
                        link.addEventListener('load', loadCB);
                        link.addEventListener('error', loadCB);
                    }
                    getHead().appendChild(link);
                });
                return this._loaded;
            },
            injectStyle: function () {
                var doc = getDocument();
                var head = getHead();
                var style = this.style = doc.createElement('style');
                style.type = 'text/css';
                if (style.sheet) {
                    style.sheet.cssText = this.source;
                } else if (style.styleSheet) {
                    style.styleSheet.cssText = this.source;
                } else {
                    style.appendChild(doc.createTextNode(this.source));
                }
                head.appendChild(style);
            },
            ie9StyleSheetLimitHack: function () {
                var doc = getDocument();
                if (!CSSModule.cssCount) {
                    CSSModule.currentStyleSheet = doc.createStyleSheet();
                }
                CSSModule.cssCount += 1;
                CSSModule.currentStyleSheet.cssText += this.source;
                if (CSSModule.cssCount === CSSModule.ie9MaxStyleSheets) {
                    CSSModule.cssCount = 0;
                }
            },
            updateURLs: function () {
                var rawSource = this.source, address = this.address;
                this.source = rawSource.replace(importRegEx, function (whole, part) {
                    if (isNode) {
                        return '@import url(' + part + ')';
                    } else {
                        return '@import url(' + steal.joinURIs(address, part) + ')';
                    }
                });
                if (!loader.isEnv('build')) {
                    this.source = this.source + '/*# sourceURL=' + address + ' */';
                    this.source = this.source.replace(resourceRegEx, function (whole, part) {
                        return 'url(' + steal.joinURIs(address, part) + ')';
                    });
                }
                return this.source;
            },
            getExistingNode: function () {
                var doc = getDocument();
                var selector = '[href=\'' + this.address + '\']';
                return doc.querySelector && doc.querySelector(selector);
            },
            linkExists: function () {
                var styleSheets = getDocument().styleSheets;
                for (var i = 0; i < styleSheets.length; ++i) {
                    if (this.address === styleSheets[i].href) {
                        return true;
                    }
                }
                return false;
            },
            setupLiveReload: function (loader, name) {
                var head = getHead();
                var css = this;
                if (loader.liveReloadInstalled) {
                    var cssReload = loader['import']('live-reload', { name: module.id });
                    Promise.resolve(cssReload).then(function (reload) {
                        loader['import'](name).then(function () {
                            reload.once('!dispose/' + name, function () {
                                css.style.__isDirty = true;
                                reload.once('!cycleComplete', function () {
                                    head.removeChild(css.style);
                                });
                            });
                        });
                    });
                }
            }
        };
        if (loader.isEnv('production')) {
            exports.fetch = function (load) {
                var css = new CSSModule(load.address);
                return css.injectLink();
            };
        } else {
            exports.instantiate = function (load) {
                var loader = this;
                var css = new CSSModule(load.address, load.source);
                load.source = css.updateURLs();
                load.metadata.deps = [];
                load.metadata.format = 'css';
                load.metadata.execute = function () {
                    if (getDocument()) {
                        if (isIE9()) {
                            css.ie9StyleSheetLimitHack();
                        } else {
                            css.injectStyle();
                        }
                        css.setupLiveReload(loader, load.name);
                    }
                    return loader.newModule({ source: css.source });
                };
            };
        }
        exports.CSSModule = CSSModule;
        exports.getDocument = getDocument;
        exports.getHead = getHead;
        exports.locateScheme = true;
        exports.buildType = 'css';
        exports.includeInBuild = true;
        exports.pluginBuilder = 'steal-css/slim';
    }(function () {
        return this;
    }(), require, exports, module));
});
/*steal-qunit@1.0.2#steal-qunit*/
'format amd';
define('steal-qunit@1.0.2#steal-qunit', [
    '@loader',
    'qunitjs/qunit/qunit',
    'qunitjs/qunit/qunit.css'
], function (loader, QUnit) {
    if (loader.has('live-reload')) {
        setupLiveReload();
    }
    setupSauceLabsReporting();
    function setupLiveReload() {
        QUnit.done(updateResults);
        function findModule(name) {
            var mods = QUnit.config.modules;
            return mods.filter(function (mod) {
                return mod.name === name;
            }).pop();
        }
        function findTestResult(mod, id) {
            var tests = mod.tests || [];
            return tests.filter(function (test) {
                return test.testId === id;
            })[0];
        }
        function updateResults() {
            var tests = document.getElementById('qunit-tests').children;
            var node, id, test, moduleName, mod;
            passed = true, removedNodes = [];
            for (var i = 0, len = tests.length; i < len; i++) {
                node = tests.item(i);
                id = node.id.split('-').pop();
                moduleName = node.querySelector('.module-name').textContent;
                mod = findModule(moduleName);
                test = findTestResult(mod, id);
                if (test) {
                    removeAllButLast(node, 'runtime');
                    if (node.hasAttribute && node.hasAttribute('class') && node.className !== 'pass') {
                        passed = false;
                        break;
                    }
                } else {
                    removedNodes.push(node);
                }
            }
            removedNodes.forEach(function (node) {
                node.parentNode.removeChild(node);
            });
            document.getElementById('qunit-banner').className = passed ? 'qunit-pass' : 'qunit-fail';
        }
        function removeAllButLast(parent, className) {
            var node, nodes = [];
            var children = parent.children;
            for (var i = 0, len = children.length; i < len; i++) {
                node = children.item(i);
                if (node.className === className)
                    nodes.push(node);
            }
            while (nodes.length > 1) {
                node = nodes.shift();
                parent.removeChild(node);
            }
        }
    }
    function setupSauceLabsReporting() {
        var log = [];
        QUnit.done(function (test_results) {
            var tests = [];
            for (var i = 0, len = log.length; i < len; i++) {
                var details = log[i];
                tests.push({
                    name: details.name,
                    result: details.result,
                    expected: details.expected,
                    actual: details.actual,
                    source: details.source
                });
            }
            test_results.tests = tests;
            window.global_test_results = test_results;
        });
        QUnit.testStart(function (testDetails) {
            QUnit.log(function (details) {
                if (!details.result) {
                    details.name = testDetails.name;
                    log.push(details);
                }
            });
        });
    }
    QUnit.config.autorun = false;
    steal.done().then(function () {
        if (window.Testee && window.Testee.init) {
            Testee.init();
        }
        QUnit.load();
    });
    return QUnit;
});
/*can-util@3.14.0#js/defaults/defaults*/
define('can-util@3.14.0#js/defaults/defaults', function (require, exports, module) {
    'use strict';
    module.exports = function (target) {
        var length = arguments.length;
        for (var i = 1; i < length; i++) {
            for (var prop in arguments[i]) {
                if (target[prop] === undefined) {
                    target[prop] = arguments[i][prop];
                }
            }
        }
        return target;
    };
});
/*can-util@3.14.0#js/string-to-any/string-to-any*/
define('can-util@3.14.0#js/string-to-any/string-to-any', function (require, exports, module) {
    'use strict';
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-define@1.5.7#can-define*/
define('can-define@1.5.7#can-define', [
    'require',
    'exports',
    'module',
    'can-event/lifecycle/lifecycle',
    'can-event/batch/batch',
    'can-event',
    'can-compute',
    'can-observation',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/assign/assign',
    'can-log/dev/dev',
    'can-cid',
    'can-util/js/is-plain-object/is-plain-object',
    'can-types',
    'can-util/js/each/each',
    'can-util/js/defaults/defaults',
    'can-util/js/string-to-any/string-to-any',
    'can-namespace',
    'can-symbol',
    'can-reflect',
    'can-util/js/single-reference/single-reference',
    'can-simple-observable',
    'can-define-lazy-value'
], function (require, exports, module) {
    'use strict';
    'format cjs';
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var Observation = require('can-observation');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var assign = require('can-util/js/assign/assign');
    var canLogDev = require('can-log/dev/dev');
    var CID = require('can-cid');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var defaults = require('can-util/js/defaults/defaults');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var ns = require('can-namespace');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var simpleObervable = require('can-simple-observable');
    var defineLazyValue = require('can-define-lazy-value');
    var eventsProto, define, make, makeDefinition, getDefinitionsAndMethods, isDefineType, getDefinitionOrMethod;
    var defineConfigurableAndNotEnumerable = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
    var eachPropertyDescriptor = function (map, cb) {
        for (var prop in map) {
            if (map.hasOwnProperty(prop)) {
                cb.call(map, prop, Object.getOwnPropertyDescriptor(map, prop));
            }
        }
    };
    function trapSets(observableValue) {
        return {
            observable: observableValue,
            lastSetValue: simpleObervable(),
            setValue: function (value) {
                canReflect.setValue(this.lastSetValue, value);
                if (this.observable) {
                    if (canSymbol.for('can.setValue') in this.observable) {
                        canReflect.setValue(this.observable, value);
                    } else {
                        this.observable.update();
                    }
                }
            }
        };
    }
    module.exports = define = ns.define = function (objPrototype, defines, baseDefine) {
        var prop, dataInitializers = Object.create(baseDefine ? baseDefine.dataInitializers : null), computedInitializers = Object.create(baseDefine ? baseDefine.computedInitializers : null);
        var result = getDefinitionsAndMethods(defines, baseDefine);
        result.dataInitializers = dataInitializers;
        result.computedInitializers = computedInitializers;
        each(result.definitions, function (definition, property) {
            define.property(objPrototype, property, definition, dataInitializers, computedInitializers);
        });
        if (objPrototype.hasOwnProperty('_data')) {
            for (prop in dataInitializers) {
                defineLazyValue(objPrototype._data, prop, dataInitializers[prop].bind(objPrototype), true);
            }
        } else {
            defineLazyValue(objPrototype, '_data', function () {
                var map = this;
                var data = {};
                for (var prop in dataInitializers) {
                    defineLazyValue(data, prop, dataInitializers[prop].bind(map), true);
                }
                return data;
            });
        }
        if (objPrototype.hasOwnProperty('_computed')) {
            for (prop in computedInitializers) {
                defineLazyValue(objPrototype._computed, prop, computedInitializers[prop].bind(objPrototype));
            }
        } else {
            defineLazyValue(objPrototype, '_computed', function () {
                var map = this;
                var data = Object.create(null);
                for (var prop in computedInitializers) {
                    defineLazyValue(data, prop, computedInitializers[prop].bind(map));
                }
                return data;
            });
        }
        if (!objPrototype.hasOwnProperty('_cid')) {
            defineLazyValue(objPrototype, '_cid', function () {
                return CID({});
            });
        }
        for (prop in eventsProto) {
            Object.defineProperty(objPrototype, prop, {
                enumerable: false,
                value: eventsProto[prop],
                configurable: true,
                writable: true
            });
        }
        Object.defineProperty(objPrototype, '_define', {
            enumerable: false,
            value: result,
            configurable: true,
            writable: true
        });
        var iteratorSymbol = canSymbol.iterator || canSymbol.for('iterator');
        if (!objPrototype[iteratorSymbol]) {
            defineConfigurableAndNotEnumerable(objPrototype, iteratorSymbol, function () {
                return new define.Iterator(this);
            });
        }
        return result;
    };
    define.extensions = function () {
    };
    var onlyType = function (obj) {
        for (var prop in obj) {
            if (prop !== 'type') {
                return false;
            }
        }
        return true;
    };
    define.property = function (objPrototype, prop, definition, dataInitializers, computedInitializers) {
        var propertyDefinition = define.extensions.apply(this, arguments);
        if (propertyDefinition) {
            definition = propertyDefinition;
        }
        var type = definition.type;
        if (type && onlyType(definition) && type === define.types['*']) {
            Object.defineProperty(objPrototype, prop, {
                get: make.get.data(prop),
                set: make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop)),
                enumerable: true,
                configurable: true
            });
            return;
        }
        definition.type = type;
        var dataProperty = definition.get ? 'computed' : 'data', reader = make.read[dataProperty](prop), getter = make.get[dataProperty](prop), setter = make.set[dataProperty](prop), getInitialValue;
        var typeConvert = function (val) {
            return val;
        };
        if (definition.Type) {
            typeConvert = make.set.Type(prop, definition.Type, typeConvert);
        }
        if (type) {
            typeConvert = make.set.type(prop, type, typeConvert);
        }
        var eventsSetter = make.set.events(prop, reader, setter, make.eventType[dataProperty](prop));
        if (definition.value !== undefined || definition.Value !== undefined) {
            getInitialValue = Observation.ignore(make.get.defaultValue(prop, definition, typeConvert, eventsSetter));
        }
        if (definition.get) {
            computedInitializers[prop] = make.compute(prop, definition.get, getInitialValue);
        } else if (getInitialValue) {
            dataInitializers[prop] = getInitialValue;
        }
        if (definition.get && definition.set) {
            setter = make.set.setter(prop, definition.set, make.read.lastSet(prop), setter, true);
        } else if (definition.set) {
            setter = make.set.setter(prop, definition.set, reader, eventsSetter, false);
        } else if (!definition.get) {
            setter = eventsSetter;
        }
        if (type) {
            setter = make.set.type(prop, type, setter);
        }
        if (definition.Type) {
            setter = make.set.Type(prop, definition.Type, setter);
        }
        Object.defineProperty(objPrototype, prop, {
            get: getter,
            set: setter,
            enumerable: 'serialize' in definition ? !!definition.serialize : !definition.get,
            configurable: true
        });
    };
    define.Constructor = function (defines) {
        var constructor = function (props) {
            define.setup.call(this, props);
        };
        define(constructor.prototype, defines);
        return constructor;
    };
    make = {
        compute: function (prop, get, defaultValueFn) {
            return function () {
                var map = this, defaultValue = defaultValueFn && defaultValueFn.call(this), computeFn, valueTrap, computeObj;
                var boundGet = function () {
                    return get.call(map, canReflect.getValue(computeObj.valueTrap.lastSetValue));
                };
                if (get.length < 2) {
                    if (defaultValue && defaultValue.isComputed) {
                        computeFn = defaultValue;
                        valueTrap = trapSets(computeFn);
                    } else {
                        computeFn = new Observation(boundGet, map);
                        valueTrap = trapSets(computeFn);
                        canReflect.setValue(valueTrap.lastSetValue, defaultValue);
                    }
                } else {
                    if (defaultValue) {
                        computeFn = defaultValue.isComputed ? defaultValue : compute.async(defaultValue, get, map);
                    } else {
                        computeFn = compute.async(defaultValue, get, map);
                    }
                    valueTrap = trapSets(computeFn);
                }
                computeObj = {
                    oldValue: undefined,
                    compute: computeFn,
                    count: 0,
                    handler: function (newVal) {
                        var oldValue = computeObj.oldValue;
                        computeObj.oldValue = newVal;
                        canEvent.dispatch.call(map, {
                            type: prop,
                            target: map,
                            batchNum: canBatch.batchNum
                        }, [
                            newVal,
                            oldValue
                        ]);
                    },
                    valueTrap: valueTrap
                };
                return computeObj;
            };
        },
        set: {
            data: function (prop) {
                return function (newVal) {
                    this._data[prop] = newVal;
                };
            },
            computed: function (prop) {
                return function (val) {
                    this._computed[prop].valueTrap.setValue(val);
                };
            },
            events: function (prop, getCurrent, setData, eventType) {
                return function (newVal) {
                    if (this.__inSetup) {
                        setData.call(this, newVal);
                    } else {
                        var current = getCurrent.call(this);
                        if (newVal !== current) {
                            setData.call(this, newVal);
                            canEvent.dispatch.call(this, {
                                type: prop,
                                target: this
                            }, [
                                newVal,
                                current
                            ]);
                        }
                    }
                };
            },
            setter: function (prop, setter, getCurrent, setEvents, hasGetter) {
                return function (value) {
                    var self = this;
                    canBatch.start();
                    var setterCalled = false, current = getCurrent.call(this), setValue = setter.call(this, value, function (value) {
                            setEvents.call(self, value);
                            setterCalled = true;
                        }, current);
                    if (setterCalled) {
                        canBatch.stop();
                    } else {
                        if (hasGetter) {
                            if (setValue !== undefined) {
                                if (current !== setValue) {
                                    setEvents.call(this, setValue);
                                }
                                canBatch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                canBatch.stop();
                                return;
                            } else if (setter.length === 1) {
                                canBatch.stop();
                            } else {
                                canBatch.stop();
                                return;
                            }
                        } else {
                            if (setValue !== undefined) {
                                setEvents.call(this, setValue);
                                canBatch.stop();
                            } else if (setter.length === 0) {
                                setEvents.call(this, value);
                                canBatch.stop();
                                return;
                            } else if (setter.length === 1) {
                                setEvents.call(this, undefined);
                                canBatch.stop();
                            } else {
                                canBatch.stop();
                                return;
                            }
                        }
                    }
                };
            },
            type: function (prop, type, set) {
                if (typeof type === 'object') {
                    return make.set.Type(prop, type, set);
                } else {
                    return function (newValue) {
                        return set.call(this, type.call(this, newValue, prop));
                    };
                }
            },
            Type: function (prop, Type, set) {
                if (Array.isArray(Type) && types.DefineList) {
                    Type = types.DefineList.extend({ '#': Type[0] });
                } else if (typeof Type === 'object') {
                    if (types.DefineMap) {
                        Type = types.DefineMap.extend(Type);
                    } else {
                        Type = define.constructor(Type);
                    }
                }
                return function (newValue) {
                    if (newValue instanceof Type || newValue == null) {
                        return set.call(this, newValue);
                    } else {
                        return set.call(this, new Type(newValue));
                    }
                };
            }
        },
        eventType: {
            data: function (prop) {
                return function (newVal, oldVal) {
                    return oldVal !== undefined || this._data.hasOwnProperty(prop) ? 'set' : 'add';
                };
            },
            computed: function () {
                return function () {
                    return 'set';
                };
            }
        },
        read: {
            data: function (prop) {
                return function () {
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            },
            lastSet: function (prop) {
                return function () {
                    var lastSetValue = this._computed[prop].valueTrap.lastSetValue;
                    return canReflect.getValue(lastSetValue);
                };
            }
        },
        get: {
            defaultValue: function (prop, definition, typeConvert, callSetter) {
                return function () {
                    var value = definition.value;
                    if (value !== undefined) {
                        if (typeof value === 'function') {
                            value = value.call(this);
                        }
                        value = typeConvert(value);
                    } else {
                        var Value = definition.Value;
                        if (Value) {
                            value = typeConvert(new Value());
                        }
                    }
                    if (definition.set) {
                        var VALUE;
                        var sync = true;
                        var setter = make.set.setter(prop, definition.set, function () {
                        }, function (value) {
                            if (sync) {
                                VALUE = value;
                            } else {
                                callSetter.call(this, value);
                            }
                        }, definition.get);
                        setter.call(this, value);
                        sync = false;
                        return VALUE;
                    }
                    return value;
                };
            },
            data: function (prop) {
                return function () {
                    if (!this.__inSetup) {
                        Observation.add(this, prop);
                    }
                    return this._data[prop];
                };
            },
            computed: function (prop) {
                return function () {
                    return canReflect.getValue(this._computed[prop].compute);
                };
            }
        }
    };
    define.behaviors = [
        'get',
        'set',
        'value',
        'Value',
        'type',
        'Type',
        'serialize'
    ];
    var addDefinition = function (definition, behavior, value) {
        if (behavior === 'type') {
            var behaviorDef = value;
            if (typeof behaviorDef === 'string') {
                behaviorDef = define.types[behaviorDef];
                if (typeof behaviorDef === 'object') {
                    assign(definition, behaviorDef);
                    behaviorDef = behaviorDef[behavior];
                }
            }
            if (typeof behaviorDef !== 'undefined') {
                definition[behavior] = behaviorDef;
            }
        } else {
            definition[behavior] = value;
        }
    };
    makeDefinition = function (prop, def, defaultDefinition) {
        var definition = {};
        each(def, function (value, behavior) {
            addDefinition(definition, behavior, value);
        });
        each(defaultDefinition, function (value, prop) {
            if (definition[prop] === undefined) {
                if (prop !== 'type' && prop !== 'Type') {
                    definition[prop] = value;
                }
            }
        });
        if (typeof def.type !== 'string') {
            if (!definition.type && !definition.Type) {
                defaults(definition, defaultDefinition);
            }
            if (isEmptyObject(definition)) {
                definition.type = define.types['*'];
            }
        }
        return definition;
    };
    getDefinitionOrMethod = function (prop, value, defaultDefinition) {
        var definition;
        if (typeof value === 'string') {
            definition = { type: value };
        } else if (typeof value === 'function') {
            if (canReflect.isConstructorLike(value)) {
                definition = { Type: value };
            } else if (isDefineType(value)) {
                definition = { type: value };
            }
        } else if (Array.isArray(value)) {
            definition = { Type: value };
        } else if (isPlainObject(value)) {
            definition = value;
        }
        if (definition) {
            return makeDefinition(prop, definition, defaultDefinition);
        } else {
            return value;
        }
    };
    getDefinitionsAndMethods = function (defines, baseDefines) {
        var definitions = Object.create(baseDefines ? baseDefines.definitions : null);
        var methods = {};
        var defaults = defines['*'], defaultDefinition;
        if (defaults) {
            delete defines['*'];
            defaultDefinition = getDefinitionOrMethod('*', defaults, {});
        } else {
            defaultDefinition = Object.create(null);
        }
        eachPropertyDescriptor(defines, function (prop, propertyDescriptor) {
            var value;
            if (propertyDescriptor.get || propertyDescriptor.set) {
                value = {
                    get: propertyDescriptor.get,
                    set: propertyDescriptor.set
                };
            } else {
                value = propertyDescriptor.value;
            }
            if (prop === 'constructor') {
                methods[prop] = value;
                return;
            } else {
                var result = getDefinitionOrMethod(prop, value, defaultDefinition);
                if (result && typeof result === 'object' && !isEmptyObject(result)) {
                    definitions[prop] = result;
                } else {
                    if (typeof result === 'function') {
                        methods[prop] = result;
                    }
                }
            }
        });
        if (defaults) {
            defines['*'] = defaults;
        }
        return {
            definitions: definitions,
            methods: methods,
            defaultDefinition: defaultDefinition
        };
    };
    eventsProto = assign({}, canEvent);
    assign(eventsProto, {
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        addEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    canReflect.onValue(computedBinding.compute, computedBinding.handler);
                    computedBinding.oldValue = canReflect.getValue(computedBinding.compute);
                } else {
                    computedBinding.count++;
                }
            }
            return eventLifecycle.addAndSetup.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computed && this._computed[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    canReflect.offValue(computedBinding.compute, computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            return eventLifecycle.removeAndTeardown.apply(this, arguments);
        }
    });
    eventsProto.on = eventsProto.bind = eventsProto.addEventListener;
    eventsProto.off = eventsProto.unbind = eventsProto.removeEventListener;
    canReflect.set(eventsProto, canSymbol.for('can.onKeyValue'), function (key, handler) {
        var translationHandler = function (ev, newValue, oldValue) {
            handler(newValue, oldValue);
        };
        singleReference.set(handler, this, translationHandler, key);
        this.addEventListener(key, translationHandler);
    });
    canReflect.set(eventsProto, canSymbol.for('can.offKeyValue'), function (key, handler) {
        this.removeEventListener(key, singleReference.getAndDelete(handler, this, key));
    });
    delete eventsProto.one;
    define.setup = function (props, sealed) {
        CID(this);
        Object.defineProperty(this, '_cid', {
            value: this._cid,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, 'constructor', {
            value: this.constructor,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(this, '__bindEvents', {
            value: Object.create(null),
            enumerable: false,
            writable: false
        });
        var definitions = this._define.definitions;
        var instanceDefinitions = Object.create(null);
        var map = this;
        canReflect.eachKey(props, function (value, prop) {
            if (definitions[prop] !== undefined) {
                map[prop] = value;
            } else {
                var def = define.makeSimpleGetterSetter(prop);
                instanceDefinitions[prop] = {};
                Object.defineProperty(map, prop, def);
                map[prop] = define.types.observable(value);
            }
        });
        if (!isEmptyObject(instanceDefinitions)) {
            defineConfigurableAndNotEnumerable(this, '_instanceDefinitions', instanceDefinitions);
        }
    };
    define.replaceWith = defineLazyValue;
    define.eventsProto = eventsProto;
    define.defineConfigurableAndNotEnumerable = defineConfigurableAndNotEnumerable;
    define.make = make;
    define.getDefinitionOrMethod = getDefinitionOrMethod;
    var simpleGetterSetters = {};
    define.makeSimpleGetterSetter = function (prop) {
        if (!simpleGetterSetters[prop]) {
            var setter = make.set.events(prop, make.get.data(prop), make.set.data(prop), make.eventType.data(prop));
            simpleGetterSetters[prop] = {
                get: make.get.data(prop),
                set: function (newVal) {
                    return setter.call(this, define.types.observable(newVal));
                },
                enumerable: true
            };
        }
        return simpleGetterSetters[prop];
    };
    define.Iterator = function (obj) {
        this.obj = obj;
        this.definitions = Object.keys(obj._define.definitions);
        this.instanceDefinitions = obj._instanceDefinitions ? Object.keys(obj._instanceDefinitions) : Object.keys(obj);
        this.hasGet = typeof obj.get === 'function';
    };
    define.Iterator.prototype.next = function () {
        var key;
        if (this.definitions.length) {
            key = this.definitions.shift();
            var def = this.obj._define.definitions[key];
            if (def.get) {
                return this.next();
            }
        } else if (this.instanceDefinitions.length) {
            key = this.instanceDefinitions.shift();
        } else {
            return {
                value: undefined,
                done: true
            };
        }
        return {
            value: [
                key,
                this.hasGet ? this.obj.get(key) : this.obj[key]
            ],
            done: false
        };
    };
    isDefineType = function (func) {
        return func && func.canDefineType === true;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'observable': function (newVal) {
            if (Array.isArray(newVal) && types.DefineList) {
                newVal = new types.DefineList(newVal);
            } else if (isPlainObject(newVal) && types.DefineMap) {
                newVal = new types.DefineMap(newVal);
            }
            return newVal;
        },
        'stringOrObservable': function (newVal) {
            if (Array.isArray(newVal)) {
                return new types.DefaultList(newVal);
            } else if (isPlainObject(newVal)) {
                return new types.DefaultMap(newVal);
            } else {
                return define.types.string(newVal);
            }
        },
        'htmlbool': function (val) {
            if (val === '') {
                return true;
            }
            return !!stringToAny(val);
        },
        '*': function (val) {
            return val;
        },
        'any': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue && newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
});
/*can-define@1.5.7#define-helpers/define-helpers*/
define('can-define@1.5.7#define-helpers/define-helpers', [
    'require',
    'exports',
    'module',
    'can-define',
    'can-event/batch/batch',
    'can-event',
    'can-reflect'
], function (require, exports, module) {
    var define = require('can-define');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var canReflect = require('can-reflect');
    var defineHelpers = {
        defineExpando: function (map, prop, value) {
            var constructorDefines = map._define.definitions;
            if (constructorDefines && constructorDefines[prop]) {
                return;
            }
            var instanceDefines = map._instanceDefinitions;
            if (!instanceDefines) {
                Object.defineProperty(map, '_instanceDefinitions', {
                    configurable: true,
                    enumerable: false,
                    value: {}
                });
                instanceDefines = map._instanceDefinitions;
            }
            if (!instanceDefines[prop]) {
                var defaultDefinition = map._define.defaultDefinition || { type: define.types.observable };
                define.property(map, prop, defaultDefinition, {}, {});
                map._data[prop] = defaultDefinition.type ? defaultDefinition.type(value) : define.types.observable(value);
                instanceDefines[prop] = defaultDefinition;
                canBatch.start();
                canEvent.dispatch.call(map, {
                    type: '__keys',
                    target: map
                });
                if (map._data[prop] !== undefined) {
                    canEvent.dispatch.call(map, {
                        type: prop,
                        target: map
                    }, [
                        map._data[prop],
                        undefined
                    ]);
                }
                canBatch.stop();
                return true;
            }
        },
        reflectSerialize: function (unwrapped) {
            var constructorDefinitions = this._define.definitions;
            var defaultDefinition = this._define.defaultDefinition;
            this.each(function (val, name) {
                var propDef = constructorDefinitions[name];
                if (propDef && typeof propDef.serialize === 'function') {
                    val = propDef.serialize.call(this, val, name);
                } else if (defaultDefinition && typeof defaultDefinition.serialize === 'function') {
                    val = defaultDefinition.serialize.call(this, val, name);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.forEach(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        }
    };
    module.exports = defineHelpers;
});
/*can-define@1.5.7#map/map*/
define('can-define@1.5.7#map/map', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    '../define-helpers/define-helpers',
    'can-observation',
    'can-types',
    'can-event/batch/batch',
    'can-namespace',
    'can-log',
    'can-log/dev/dev',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var defineHelpers = require('../define-helpers/define-helpers');
    var Observation = require('can-observation');
    var types = require('can-types');
    var canBatch = require('can-event/batch/batch');
    var ns = require('can-namespace');
    var canLog = require('can-log');
    var canLogDev = require('can-log/dev/dev');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var keysForDefinition = function (definitions) {
        var keys = [];
        for (var prop in definitions) {
            var definition = definitions[prop];
            if (typeof definition !== 'object' || ('serialize' in definition ? !!definition.serialize : !definition.get)) {
                keys.push(prop);
            }
        }
        return keys;
    };
    function assign(source) {
        canBatch.start();
        canReflect.assignMap(this, source || {});
        canBatch.stop();
    }
    function update(source) {
        canBatch.start();
        canReflect.updateMap(this, source || {});
        canBatch.stop();
    }
    function assignDeep(source) {
        canBatch.start();
        canReflect.assignDeepMap(this, source || {});
        canBatch.stop();
    }
    function updateDeep(source) {
        canBatch.start();
        canReflect.updateDeepMap(this, source || {});
        canBatch.stop();
    }
    function setKeyValue(key, value) {
        var defined = defineHelpers.defineExpando(this, key, value);
        if (!defined) {
            this[key] = value;
        }
    }
    function getKeyValue(key) {
        var value = this[key];
        if (value !== undefined || key in this || Object.isSealed(this)) {
            return value;
        } else {
            Observation.add(this, key);
            return this[key];
        }
    }
    var DefineMap = Construct.extend('DefineMap', {
        setup: function (base) {
            var key, prototype = this.prototype;
            if (DefineMap) {
                define(prototype, prototype, base.prototype._define);
                for (key in DefineMap.prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
                this.prototype.setup = function (props) {
                    define.setup.call(this, props || {}, this.constructor.seal);
                };
            } else {
                for (key in prototype) {
                    define.defineConfigurableAndNotEnumerable(prototype, key, prototype[key]);
                }
            }
            define.defineConfigurableAndNotEnumerable(prototype, 'constructor', this);
        }
    }, {
        setup: function (props, sealed) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: { definitions: {} }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, props || {}, sealed === true);
        },
        get: function (prop) {
            if (prop) {
                return getKeyValue.call(this, prop);
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        set: function (prop, value) {
            if (typeof prop === 'object') {
                if (value === true) {
                    updateDeep.call(this, prop);
                } else {
                    assignDeep.call(this, prop);
                }
            } else {
                setKeyValue.call(this, prop, value);
            }
            return this;
        },
        assignDeep: function (prop) {
            assignDeep.call(this, prop);
            return this;
        },
        updateDeep: function (prop) {
            updateDeep.call(this, prop);
            return this;
        },
        assign: function (prop) {
            assign.call(this, prop);
            return this;
        },
        update: function (prop) {
            update.call(this, prop);
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        forEach: function () {
            var forEach = function (list, cb, thisarg) {
                    return canReflect.eachKey(list, cb, thisarg);
                }, noObserve = Observation.ignore(forEach);
            return function (cb, thisarg, observe) {
                return observe === false ? noObserve(this, cb, thisarg) : forEach(this, cb, thisarg);
            };
        }(),
        '*': { type: define.types.observable }
    });
    canReflect.assignSymbols(DefineMap.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': getKeyValue,
        'can.setKeyValue': setKeyValue,
        'can.deleteKeyValue': function (prop) {
            this.set(prop, undefined);
            return this;
        },
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return keysForDefinition(this._define.definitions).concat(keysForDefinition(this._instanceDefinitions));
        },
        'can.assignDeep': assignDeep,
        'can.updateDeep': updateDeep,
        'can.unwrap': defineHelpers.reflectUnwrap,
        'can.serialize': defineHelpers.reflectSerialize,
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        }
    });
    canReflect.setKeyValue(DefineMap.prototype, canSymbol.iterator, function () {
        return new define.Iterator(this);
    });
    for (var prop in define.eventsProto) {
        DefineMap[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineMap.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    var eventsProtoSymbols = 'getOwnPropertySymbols' in Object ? Object.getOwnPropertySymbols(define.eventsProto) : [
        canSymbol.for('can.onKeyValue'),
        canSymbol.for('can.offKeyValue')
    ];
    eventsProtoSymbols.forEach(function (sym) {
        Object.defineProperty(DefineMap.prototype, sym, {
            enumerable: false,
            value: define.eventsProto[sym],
            writable: true
        });
    });
    types.DefineMap = DefineMap;
    types.DefaultMap = DefineMap;
    Object.defineProperty(DefineMap.prototype, 'toObject', {
        enumerable: false,
        writable: true,
        value: function () {
            canLog.warn('Use DefineMap::get instead of DefineMap::toObject');
            return this.get();
        }
    });
    Object.defineProperty(DefineMap.prototype, 'each', {
        enumerable: false,
        writable: true,
        value: DefineMap.prototype.forEach
    });
    module.exports = ns.DefineMap = DefineMap;
});
/*can-component@3.3.10#test/component-define-test*/
define('can-component@3.3.10#test/component-define-test', [
    'require',
    'exports',
    'module',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-define',
    'can-define/map/map',
    'can-view-model',
    'can-types',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var define = require('can-define');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    var types = require('can-types');
    var canDev = require('can-util/js/dev/dev');
    QUnit.module('can-component with can-define');
    QUnit.test('Works with can-define', function () {
        var VM = define.Constructor({
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            fullName: {
                get: function () {
                    return [
                        this.firstName,
                        this.lastName
                    ].join(' ');
                }
            }
        });
        Component.extend({
            tag: 'can-define-component',
            ViewModel: VM,
            view: stache('Name: {{fullName}}')
        });
        var frag = stache('<can-define-component firstName:from="firstName" lastName:from="lastName" />')({
            firstName: 'Chris',
            lastName: 'Gomez'
        });
        var vm = viewModel(frag.firstChild);
        QUnit.ok(vm instanceof VM, 'Constructor was called');
        QUnit.equal(vm.firstName, 'Chris', 'ViewModel was set from scope');
        QUnit.equal(vm.lastName, 'Gomez', 'ViewModel was set from scope');
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Chris Gomez', 'Rendered fullName');
        vm.firstName = 'Justin';
        vm.lastName = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Name: Justin Meyer', 'Rendered fullName after change');
    });
    QUnit.test('scope method works', function () {
        Component.extend({
            tag: 'my-element',
            viewModel: function (properties, scope, element) {
                QUnit.deepEqual(properties, {
                    first: 'Justin',
                    last: 'Meyer'
                });
                return new types.DefaultMap(properties);
            }
        });
        stache('<my-element {first}=\'firstName\' last=\'Meyer\'/>')({
            firstName: 'Justin',
            middleName: 'Barry'
        });
    });
    QUnit.test('33 - works when instantiated with an object for ViewModel', function () {
        Component.extend({
            tag: 'test-element',
            view: stache('{{someMethod}}'),
            ViewModel: {
                someMethod: function () {
                    ok(true, 'Function got called');
                    return true;
                }
            }
        });
        var renderer = stache('<test-element>');
        renderer();
    });
    QUnit.test('helpers do not leak when leakscope is false (#77)', function () {
        var called = 0;
        var inner = Component.extend({
            tag: 'inner-el',
            view: stache('inner{{test}}'),
            leakScope: false
        });
        var outer = Component.extend({
            tag: 'outer-el',
            view: stache('outer:<inner-el>'),
            helpers: {
                test: function () {
                    called++;
                    return 'heyo';
                }
            }
        });
        var renderer = stache('<outer-el>');
        renderer();
        QUnit.equal(called, 0, 'Outer helper not called');
    });
    QUnit.test('helpers do leak when leakscope is true (#77)', function () {
        var called = 0;
        var inner = Component.extend({
            tag: 'inner-el',
            view: stache('inner{{test}}'),
            leakScope: true
        });
        var outer = Component.extend({
            tag: 'outer-el',
            view: stache('outer:<inner-el>'),
            helpers: {
                test: function () {
                    called++;
                    return 'heyo';
                }
            }
        });
        var renderer = stache('<outer-el>');
        renderer();
        QUnit.equal(called, 1, 'Outer helper called once');
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('warn if viewModel is assigned a DefineMap (#14)', function () {
            QUnit.expect(1);
            var oldwarn = canDev.warn;
            canDev.warn = function (mesg) {
                QUnit.equal(mesg, 'can-component: Assigning a DefineMap or constructor type to the viewModel property may not be what you intended. Did you mean ViewModel instead? More info: https://canjs.com/doc/can-component.prototype.ViewModel.html', 'Warning is expected message');
            };
            var VM = DefineMap.extend({});
            Component.extend({
                tag: 'can-vm1-test-component',
                viewModel: VM
            });
            Component.extend({
                tag: 'can-vm2-test-component',
                viewModel: function () {
                }
            });
            canDev.warn = oldwarn;
        });
    }
});
/*can-map@3.6.1#bubble*/
define('can-map@3.6.1#bubble', [
    'require',
    'exports',
    'module',
    'can-event',
    'can-util/js/make-array/make-array',
    'can-reflect',
    'can-util/js/is-empty-object/is-empty-object'
], function (require, exports, module) {
    var canEvent = require('can-event');
    var makeArray = require('can-util/js/make-array/make-array');
    var canReflect = require('can-reflect');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var bubble = {
        bind: function (parent, eventName) {
            if (!parent.__inSetup) {
                var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
                if (!parent._bubbleBindings) {
                    parent._bubbleBindings = {};
                }
                for (var i = 0; i < len; i++) {
                    bubbleEvent = bubbleEvents[i];
                    if (!parent._bubbleBindings[bubbleEvent]) {
                        parent._bubbleBindings[bubbleEvent] = 1;
                        bubble.childrenOf(parent, bubbleEvent);
                    } else {
                        parent._bubbleBindings[bubbleEvent]++;
                    }
                }
            }
        },
        unbind: function (parent, eventName) {
            var bubbleEvents = bubble.events(parent, eventName), len = bubbleEvents.length, bubbleEvent;
            for (var i = 0; i < len; i++) {
                bubbleEvent = bubbleEvents[i];
                if (parent._bubbleBindings) {
                    parent._bubbleBindings[bubbleEvent]--;
                }
                if (parent._bubbleBindings && !parent._bubbleBindings[bubbleEvent]) {
                    delete parent._bubbleBindings[bubbleEvent];
                    bubble.teardownChildrenFrom(parent, bubbleEvent);
                    if (isEmptyObject(parent._bubbleBindings)) {
                        delete parent._bubbleBindings;
                    }
                }
            }
        },
        add: function (parent, child, prop) {
            if (canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                        bubble.toParent(child, parent, prop, eventName);
                    }
                }
            }
        },
        addMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.add(parent, children[i], i);
            }
        },
        remove: function (parent, child) {
            if (canReflect.isObservableLike(child) && canReflect.isMapLike(child) && parent._bubbleBindings) {
                for (var eventName in parent._bubbleBindings) {
                    if (parent._bubbleBindings[eventName]) {
                        bubble.teardownFromParent(parent, child, eventName);
                    }
                }
            }
        },
        removeMany: function (parent, children) {
            for (var i = 0, len = children.length; i < len; i++) {
                bubble.remove(parent, children[i]);
            }
        },
        set: function (parent, prop, value, current) {
            if (canReflect.isObservableLike(value) && canReflect.isMapLike(value)) {
                bubble.add(parent, value, prop);
            }
            if (canReflect.isObservableLike(current) && canReflect.isMapLike(current)) {
                bubble.remove(parent, current);
            }
            return value;
        },
        events: function (map, boundEventName) {
            return map.constructor._bubbleRule(boundEventName, map);
        },
        toParent: function (child, parent, prop, eventName) {
            canEvent.listenTo.call(parent, child, eventName, function () {
                var args = makeArray(arguments), ev = args.shift();
                args[0] = (canReflect.isObservableLike(parent) && canReflect.isListLike(parent) ? parent.indexOf(child) : prop) + (args[0] ? '.' + args[0] : '');
                ev.triggeredNS = ev.triggeredNS || {};
                if (ev.triggeredNS[parent._cid]) {
                    return;
                }
                ev.triggeredNS[parent._cid] = true;
                canEvent.dispatch.call(parent, ev, args);
                if (eventName === 'change') {
                    canEvent.dispatch.call(parent, args[0], [
                        args[2],
                        args[3]
                    ]);
                }
            });
        },
        childrenOf: function (parent, eventName) {
            parent._each(function (child, prop) {
                if (child && child.bind) {
                    bubble.toParent(child, parent, prop, eventName);
                }
            });
        },
        teardownFromParent: function (parent, child, eventName) {
            if (child && child.unbind) {
                canEvent.stopListening.call(parent, child, eventName);
            }
        },
        teardownChildrenFrom: function (parent, eventName) {
            parent._each(function (child) {
                bubble.teardownFromParent(parent, child, eventName);
            });
        },
        isBubbling: function (parent, eventName) {
            return parent._bubbleBindings && parent._bubbleBindings[eventName];
        }
    };
    module.exports = bubble;
});
/*can-util@3.14.0#js/is-promise/is-promise*/
define('can-util@3.14.0#js/is-promise/is-promise', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var canReflect = require('can-reflect');
    var namespace = require('can-namespace');
    module.exports = namespace.isPromise = function (obj) {
        return canReflect.isPromise(obj);
    };
});
/*can-map@3.6.1#map-helpers*/
define('can-map@3.6.1#map-helpers', [
    'require',
    'exports',
    'module',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/is-promise/is-promise',
    'can-cid',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var CID = require('can-cid');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var madeMap = null;
    var teardownMap = function () {
        for (var cid in madeMap) {
            if (madeMap[cid].added) {
                delete madeMap[cid].obj._cid;
            }
        }
        madeMap = null;
    };
    var mapHelpers = {
        attrParts: function (attr, keepKey) {
            if (keepKey) {
                return [attr];
            }
            return typeof attr === 'object' ? attr : ('' + attr).split('.');
        },
        canMakeObserve: function (obj) {
            return obj && !isPromise(obj) && (Array.isArray(obj) || isPlainObject(obj));
        },
        reflectSerialize: function (unwrapped) {
            this.each(function (val, name) {
                if (this.___serialize) {
                    val = this.___serialize(name, val);
                } else {
                    val = canReflect.serialize(val);
                }
                if (val !== undefined) {
                    unwrapped[name] = val;
                }
            }, this);
            return unwrapped;
        },
        reflectUnwrap: function (unwrapped) {
            this.each(function (value, key) {
                if (value !== undefined) {
                    unwrapped[key] = canReflect.unwrap(value);
                }
            });
            return unwrapped;
        },
        removeSpecialKeys: function (map) {
            if (map) {
                [
                    '_data',
                    'constructor',
                    '_cid',
                    '__bindEvents'
                ].forEach(function (key) {
                    delete map[key];
                });
            }
            return map;
        },
        serialize: function () {
            var serializeMap = null;
            return function (map, how, where) {
                var cid = CID(map), firstSerialize = false;
                if (!serializeMap) {
                    firstSerialize = true;
                    serializeMap = {
                        attr: {},
                        serialize: {}
                    };
                }
                serializeMap[how][cid] = where;
                map.each(function (val, name) {
                    var result, isObservable = canReflect.isObservableLike(val), serialized = isObservable && serializeMap[how][CID(val)];
                    if (serialized) {
                        result = serialized;
                    } else {
                        if (map['___' + how]) {
                            result = map['___' + how](name, val);
                        } else {
                            result = mapHelpers.getValue(map, name, val, how);
                        }
                    }
                    if (result !== undefined) {
                        where[name] = result;
                    }
                });
                if (firstSerialize) {
                    serializeMap = null;
                }
                return where;
            };
        }(),
        getValue: function (map, name, val, how) {
            if (how === 'attr') {
                how = canSymbol.for('can.getValue');
            }
            if (canReflect.isObservableLike(val) && val[how]) {
                return val[how]();
            } else {
                return val;
            }
        },
        define: null,
        addComputedAttr: function (map, attrName, compute) {
            map._computedAttrs[attrName] = {
                compute: compute,
                count: 0,
                handler: function (newVal, oldVal) {
                    map._triggerChange(attrName, 'set', newVal, oldVal);
                }
            };
        },
        addToMap: function addToMap(obj, instance) {
            var teardown;
            if (!madeMap) {
                teardown = teardownMap;
                madeMap = {};
            }
            var hasCid = obj._cid;
            var cid = CID(obj);
            if (!madeMap[cid]) {
                madeMap[cid] = {
                    obj: obj,
                    instance: instance,
                    added: !hasCid
                };
            }
            return teardown;
        },
        getMapFromObject: function (obj) {
            return madeMap && madeMap[obj._cid] && madeMap[obj._cid].instance;
        },
        twoLevelDeepExtend: function (destination, source) {
            for (var prop in source) {
                destination[prop] = destination[prop] || {};
                assign(destination[prop], source[prop]);
            }
        }
    };
    module.exports = exports = mapHelpers;
});
/*can-util@3.14.0#js/deep-assign/deep-assign*/
define('can-util@3.14.0#js/deep-assign/deep-assign', [
    'require',
    'exports',
    'module',
    '../is-function/is-function',
    '../is-plain-object/is-plain-object',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var isFunction = require('../is-function/is-function');
    var isPlainObject = require('../is-plain-object/is-plain-object');
    var namespace = require('can-namespace');
    function deepAssign() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length;
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (length === i) {
            target = this;
            --i;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && Array.isArray(src) ? src : [];
                        } else {
                            clone = src && isPlainObject(src) ? src : {};
                        }
                        target[name] = deepAssign(clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    }
    module.exports = namespace.deepAssign = deepAssign;
});
/*can-map@3.6.1#can-map*/
define('can-map@3.6.1#can-map', [
    'require',
    'exports',
    'module',
    './bubble',
    './map-helpers',
    'can-event',
    'can-event/batch/batch',
    'can-event/lifecycle/lifecycle',
    'can-construct',
    'can-observation',
    'can-stache-key',
    'can-compute',
    'can-util/js/single-reference/single-reference',
    'can-namespace',
    'can-util/js/dev/dev',
    'can-cid',
    'can-util/js/deep-assign/deep-assign',
    'can-util/js/is-function/is-function',
    'can-util/js/assign/assign',
    'can-types',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    var bubble = require('./bubble');
    var mapHelpers = require('./map-helpers');
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var eventLifecycle = require('can-event/lifecycle/lifecycle');
    var Construct = require('can-construct');
    var Observation = require('can-observation');
    var ObserveReader = require('can-stache-key');
    var canCompute = require('can-compute');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var namespace = require('can-namespace');
    var dev = require('can-util/js/dev/dev');
    var CID = require('can-cid');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var isFunction = require('can-util/js/is-function/is-function');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var unobservable = { 'constructor': true };
    var hasOwnProperty = {}.hasOwnProperty;
    var Map = Construct.extend({
        setup: function (baseMap) {
            Construct.setup.apply(this, arguments);
            this._computedPropertyNames = [];
            if (Map) {
                if (!this.defaults) {
                    this.defaults = {};
                }
                for (var prop in this.prototype) {
                    if (prop !== 'define' && prop !== 'constructor' && (typeof this.prototype[prop] !== 'function' || this.prototype[prop].prototype instanceof Construct)) {
                        this.defaults[prop] = this.prototype[prop];
                    } else if (this.prototype[prop].isComputed) {
                        this._computedPropertyNames.push(prop);
                    }
                }
                if (mapHelpers.define) {
                    mapHelpers.define(this, baseMap.prototype.define);
                }
            }
        },
        shortName: 'Map',
        _bubbleRule: function (eventName) {
            return eventName === 'change' || eventName.indexOf('.') >= 0 ? ['change'] : [];
        },
        addEventListener: eventLifecycle.addAndSetup,
        removeEventListener: eventLifecycle.removeAndTeardown,
        keys: function (map) {
            Observation.add(map, '__keys');
            return canReflect.getOwnEnumerableKeys(map._data);
        }
    }, {
        setup: function (obj) {
            if (canReflect.isObservableLike(obj) && typeof obj.serialize === 'function') {
                obj = obj.serialize();
            }
            this._data = Object.create(null);
            CID(this, '.map');
            this._setupComputedProperties();
            var teardownMapping = obj && mapHelpers.addToMap(obj, this);
            var defaultValues = this._setupDefaults(obj);
            var data = assign(deepAssign(true, {}, defaultValues), obj);
            this.attr(data);
            if (teardownMapping) {
                teardownMapping();
            }
        },
        _setupComputedProperties: function () {
            this._computedAttrs = Object.create(null);
            var computes = this.constructor._computedPropertyNames;
            for (var i = 0, len = computes.length; i < len; i++) {
                var attrName = computes[i];
                mapHelpers.addComputedAttr(this, attrName, this[attrName].clone(this));
            }
        },
        _setupDefaults: function () {
            return this.constructor.defaults || {};
        },
        attr: function (attr, val) {
            var type = typeof attr;
            if (attr === undefined) {
                return this._getAttrs();
            } else if (type !== 'string' && type !== 'number') {
                return this._setAttrs(attr, val);
            } else if (arguments.length === 1) {
                return this._get(attr + '');
            } else {
                this._set(attr + '', val);
                return this;
            }
        },
        _get: function (attr) {
            var dotIndex = attr.indexOf('.');
            if (dotIndex >= 0) {
                var value = this.___get(attr);
                if (value !== undefined) {
                    Observation.add(this, attr);
                    return value;
                }
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                var current = this.__get(first);
                return current && canReflect.getKeyValue(current, second);
            } else {
                return this.__get(attr);
            }
        },
        __get: function (attr) {
            if (!unobservable[attr] && !this._computedAttrs[attr]) {
                Observation.add(this, attr);
            }
            return this.___get(attr);
        },
        ___get: function (attr) {
            if (attr !== undefined) {
                var computedAttr = this._computedAttrs[attr];
                if (computedAttr && computedAttr.compute) {
                    return computedAttr.compute();
                } else {
                    return hasOwnProperty.call(this._data, attr) ? this._data[attr] : undefined;
                }
            } else {
                return this._data;
            }
        },
        _set: function (attr, value, keepKey) {
            var dotIndex = attr.indexOf('.'), current;
            if (dotIndex >= 0 && !keepKey) {
                var first = attr.substr(0, dotIndex), second = attr.substr(dotIndex + 1);
                current = this.__inSetup ? undefined : this.___get(first);
                if (canReflect.isMapLike(current)) {
                    canReflect.setKeyValue(current, second, value);
                } else {
                    current = this.__inSetup ? undefined : this.___get(attr);
                    if (this.__convert) {
                        value = this.__convert(attr, value);
                    }
                    this.__set(attr, this.__type(value, attr), current);
                }
            } else {
                current = this.__inSetup ? undefined : this.___get(attr);
                if (this.__convert) {
                    value = this.__convert(attr, value);
                }
                this.__set(attr, this.__type(value, attr), current);
            }
        },
        __type: function (value, prop) {
            if (typeof value === 'object' && !canReflect.isObservableLike(value) && mapHelpers.canMakeObserve(value) && !canReflect.isListLike(value)) {
                var cached = mapHelpers.getMapFromObject(value);
                if (cached) {
                    return cached;
                }
                var MapConstructor = this.constructor.Map || Map;
                return new MapConstructor(value);
            }
            return value;
        },
        __set: function (prop, value, current) {
            if (value !== current) {
                var computedAttr = this._computedAttrs[prop];
                var changeType = computedAttr || current !== undefined || hasOwnProperty.call(this.___get(), prop) ? 'set' : 'add';
                this.___set(prop, typeof value === 'object' ? bubble.set(this, prop, value, current) : value);
                if (!computedAttr || !computedAttr.count) {
                    this._triggerChange(prop, changeType, value, current);
                }
                if (typeof current === 'object') {
                    bubble.teardownFromParent(this, current);
                }
            }
        },
        ___set: function (prop, val) {
            var computedAttr = this._computedAttrs[prop];
            if (computedAttr) {
                computedAttr.compute(val);
            } else {
                this._data[prop] = val;
            }
            if (typeof this.constructor.prototype[prop] !== 'function' && !computedAttr) {
                this[prop] = val;
            }
        },
        removeAttr: function (attr) {
            return this._remove(attr);
        },
        _remove: function (attr) {
            var parts = mapHelpers.attrParts(attr), prop = parts.shift(), current = this.___get(prop);
            if (parts.length && current) {
                return canReflect.deleteKeyValue(current, parts.join('.'));
            } else {
                if (typeof attr === 'string' && !!~attr.indexOf('.')) {
                    prop = attr;
                }
                this.__remove(prop, current);
                return current;
            }
        },
        __remove: function (prop, current) {
            if (prop in this._data) {
                this.___remove(prop);
                this._triggerChange(prop, 'remove', undefined, current);
            }
        },
        ___remove: function (prop) {
            delete this._data[prop];
            if (!(prop in this.constructor.prototype)) {
                delete this[prop];
            }
        },
        ___serialize: function (name, val) {
            if (this._legacyAttrBehavior) {
                return mapHelpers.getValue(this, name, val, 'serialize');
            } else {
                return canReflect.serialize(val, CIDMap);
            }
        },
        _getAttrs: function () {
            if (this._legacyAttrBehavior) {
                return mapHelpers.serialize(this, 'attr', {});
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        _setAttrs: function (props, remove) {
            if (this._legacyAttrBehavior) {
                return this.__setAttrs(props, remove);
            }
            if (remove === true) {
                this[canSymbol.for('can.updateDeep')](props);
            } else {
                this[canSymbol.for('can.assignDeep')](props);
            }
            return this;
        },
        __setAttrs: function (props, remove) {
            props = assign({}, props);
            var prop, self = this, newVal;
            canBatch.start();
            this._each(function (curVal, prop) {
                if (prop === '_cid') {
                    return;
                }
                newVal = props[prop];
                if (newVal === undefined) {
                    if (remove) {
                        self.removeAttr(prop);
                    }
                    return;
                }
                if (self.__convert) {
                    newVal = self.__convert(prop, newVal);
                }
                if (types.isMapLike(curVal) && mapHelpers.canMakeObserve(newVal)) {
                    if (remove === true) {
                        canReflect.updateDeep(curVal, newVal);
                    } else {
                        canReflect.assignDeep(curVal, newVal);
                    }
                } else if (curVal !== newVal) {
                    self.__set(prop, self.__type(newVal, prop), curVal);
                }
                delete props[prop];
            });
            for (prop in props) {
                if (prop !== '_cid') {
                    newVal = props[prop];
                    this._set(prop, newVal, true);
                }
            }
            canBatch.stop();
            return this;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        },
        _triggerChange: function (attr, how, newVal, oldVal, batchNum) {
            if (bubble.isBubbling(this, 'change')) {
                canEvent.dispatch.call(this, {
                    type: 'change',
                    target: this,
                    batchNum: batchNum
                }, [
                    attr,
                    how,
                    newVal,
                    oldVal
                ]);
            }
            canEvent.dispatch.call(this, {
                type: attr,
                target: this,
                batchNum: batchNum
            }, [
                newVal,
                oldVal
            ]);
            if (how === 'remove' || how === 'add') {
                canEvent.dispatch.call(this, {
                    type: '__keys',
                    target: this,
                    batchNum: batchNum
                });
            }
        },
        _eventSetup: function () {
        },
        _eventTeardown: function () {
        },
        one: canEvent.one,
        addEventListener: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding && computedBinding.compute) {
                if (!computedBinding.count) {
                    computedBinding.count = 1;
                    computedBinding.compute.addEventListener('change', function (ev, newVal, oldVal) {
                        computedBinding.handler(newVal, oldVal);
                    });
                } else {
                    computedBinding.count++;
                }
            }
            bubble.bind(this, eventName);
            return eventLifecycle.addAndSetup.apply(this, arguments);
        },
        removeEventListener: function (eventName, handler) {
            var computedBinding = this._computedAttrs && this._computedAttrs[eventName];
            if (computedBinding) {
                if (computedBinding.count === 1) {
                    computedBinding.count = 0;
                    canReflect.offValue(computedBinding.compute, computedBinding.handler);
                } else {
                    computedBinding.count--;
                }
            }
            bubble.unbind(this, eventName);
            return eventLifecycle.removeAndTeardown.apply(this, arguments);
        },
        compute: function (prop) {
            if (isFunction(this.constructor.prototype[prop])) {
                return canCompute(this[prop], this);
            } else {
                var reads = ObserveReader.reads(prop);
                var last = reads.length - 1;
                return canCompute(function (newVal) {
                    if (arguments.length) {
                        ObserveReader.write(this, reads[last].key, newVal, {});
                    } else {
                        return ObserveReader.get(this, prop);
                    }
                }, this);
            }
        },
        each: function (callback, context) {
            var key, item;
            var keys = Map.keys(this);
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                item = this.attr(key);
                if (callback.call(context || item, item, key, this) === false) {
                    break;
                }
            }
            return this;
        },
        _each: function (callback) {
            var data = this.___get();
            for (var prop in data) {
                if (hasOwnProperty.call(data, prop)) {
                    callback(data[prop], prop);
                }
            }
        },
        dispatch: canEvent.dispatch
    });
    Map.prototype.on = Map.prototype.bind = Map.prototype.addEventListener;
    Map.prototype.off = Map.prototype.unbind = Map.prototype.removeEventListener;
    Map.on = Map.bind = Map.addEventListener;
    Map.off = Map.unbind = Map.removeEventListener;
    canReflect.assignSymbols(Map.prototype, {
        'can.isMapLike': true,
        'can.isListLike': false,
        'can.isValueLike': false,
        'can.getKeyValue': Map.prototype._get,
        'can.setKeyValue': Map.prototype._set,
        'can.deleteKeyValue': Map.prototype._remove,
        'can.getOwnEnumerableKeys': function () {
            Observation.add(this, '__keys');
            return Object.keys(this._data);
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            canReflect.updateDeepMap(this, mapHelpers.removeSpecialKeys(canReflect.assignMap({}, source)));
            canBatch.stop();
        },
        'can.unwrap': mapHelpers.reflectUnwrap,
        'can.serialize': mapHelpers.reflectSerialize,
        'can.onKeyValue': function (key, handler) {
            var translationHandler = function (ev, newValue, oldValue) {
                handler.call(this, newValue, oldValue);
            };
            singleReference.set(handler, this, translationHandler, key);
            this.addEventListener(key, translationHandler);
        },
        'can.offKeyValue': function (key, handler) {
            this.removeEventListener(key, singleReference.getAndDelete(handler, this, key));
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computedAttrs && this._computedAttrs[key] && this._computedAttrs[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computedAttrs[key].compute);
            }
            return ret;
        }
    });
    if (!types.DefaultMap) {
        types.DefaultMap = Map;
    }
    module.exports = namespace.Map = Map;
});
/*can-list@3.2.2#can-list*/
define('can-list@3.2.2#can-list', [
    'require',
    'exports',
    'module',
    'can-event',
    'can-namespace',
    'can-map',
    'can-map/bubble',
    'can-map/map-helpers',
    'can-event/batch/batch',
    'can-event',
    'can-observation',
    'can-cid',
    'can-util/js/is-promise/is-promise',
    'can-util/js/make-array/make-array',
    'can-util/js/assign/assign',
    'can-types',
    'can-util/js/each/each',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-map/cid-map'
], function (require, exports, module) {
    require('can-event');
    var namespace = require('can-namespace');
    var Map = require('can-map');
    var bubble = require('can-map/bubble');
    var mapHelpers = require('can-map/map-helpers');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var isPromise = require('can-util/js/is-promise/is-promise');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var splice = [].splice, spliceRemovesProps = function () {
            var obj = {
                0: 'a',
                length: 1
            };
            splice.call(obj, 0, 1);
            return !obj[0];
        }();
    var serializeNonTypes = function (MapType, arg, args) {
        if (arg && arg.serialize && !(arg instanceof MapType)) {
            args.push(new MapType(arg.serialize()));
        } else {
            args.push(arg);
        }
    };
    var List = Map.extend({ Map: Map }, {
            setup: function (instances, options) {
                this.length = 0;
                CID(this, '.map');
                this._setupComputedProperties();
                instances = instances || [];
                var teardownMapping;
                if (isPromise(instances)) {
                    this.replace(instances);
                } else {
                    teardownMapping = instances.length && mapHelpers.addToMap(instances, this);
                    this.push.apply(this, makeArray(instances || []));
                }
                if (teardownMapping) {
                    teardownMapping();
                }
                assign(this, options);
            },
            _triggerChange: function (attr, how, newVal, oldVal) {
                Map.prototype._triggerChange.apply(this, arguments);
                var index = +attr;
                if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                    if (how === 'add') {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                    } else if (how === 'remove') {
                        canEvent.dispatch.call(this, how, [
                            oldVal,
                            index
                        ]);
                        canEvent.dispatch.call(this, 'length', [this.length]);
                    } else {
                        canEvent.dispatch.call(this, how, [
                            newVal,
                            index
                        ]);
                    }
                }
            },
            ___get: function (attr) {
                if (attr) {
                    var computedAttr = this._computedAttrs[attr];
                    if (computedAttr && computedAttr.compute) {
                        return canReflect.getValue(computedAttr.compute);
                    }
                    if (this[attr] && this[attr].isComputed && typeof this.constructor.prototype[attr] === 'function') {
                        return canReflect.getValue(this[attr]);
                    } else {
                        return this[attr];
                    }
                } else {
                    return this;
                }
            },
            __set: function (prop, value, current) {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (prop > this.length - 1) {
                        var newArr = new Array(prop + 1 - this.length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    } else {
                        this.splice(prop, 1, value);
                        return this;
                    }
                }
                return Map.prototype.__set.call(this, '' + prop, value, current);
            },
            ___set: function (attr, val) {
                this[attr] = val;
                if (+attr >= this.length) {
                    this.length = +attr + 1;
                }
            },
            __remove: function (prop, current) {
                if (isNaN(+prop)) {
                    delete this[prop];
                    this._triggerChange(prop, 'remove', undefined, current);
                } else {
                    this.splice(prop, 1);
                }
            },
            _each: function (callback) {
                var data = this.___get();
                for (var i = 0; i < data.length; i++) {
                    callback(data[i], i);
                }
            },
            serialize: function () {
                return canReflect.serialize(this, CIDMap);
            },
            splice: function (index, howMany) {
                var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
                index = index || 0;
                for (i = 0, len = args.length - 2; i < len; i++) {
                    listIndex = i + 2;
                    args[listIndex] = this.__type(args[listIndex], listIndex);
                    added.push(args[listIndex]);
                    if (this[i + index] !== args[listIndex]) {
                        allSame = false;
                    }
                }
                if (allSame && this.length <= added.length) {
                    return added;
                }
                if (howMany === undefined) {
                    howMany = args[1] = this.length - index;
                }
                var removed = splice.apply(this, args);
                if (!spliceRemovesProps) {
                    for (i = this.length; i < removed.length + this.length; i++) {
                        delete this[i];
                    }
                }
                canBatch.start();
                if (howMany > 0) {
                    bubble.removeMany(this, removed);
                    this._triggerChange('' + index, 'remove', undefined, removed);
                }
                if (args.length > 2) {
                    bubble.addMany(this, added);
                    this._triggerChange('' + index, 'add', added, removed);
                }
                canBatch.stop();
                return removed;
            }
        }), getArgs = function (args) {
            return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
        };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        List.prototype[name] = function () {
            var args = [], len = where ? this.length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = bubble.set(this, i, this.__type(val, i));
            }
            res = orig.apply(this, args);
            if (!this.comparator || args.length) {
                this._triggerChange('' + len, 'add', args, undefined);
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        List.prototype[name] = function () {
            if (!this.length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this.length ? this.length - 1 : 0;
            var res = [][name].apply(this, args);
            this._triggerChange('' + len, 'remove', undefined, [res]);
            if (res && res.removeEventListener) {
                bubble.remove(this, res);
            }
            return res;
        };
    });
    assign(List.prototype, {
        indexOf: function (item, fromIndex) {
            Observation.add(this, 'length');
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.attr(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(makeArray(this));
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [], MapType = this.constructor.Map;
            each(arguments, function (arg) {
                if (canReflect.isObservableLike(arg) && canReflect.isListLike(arg) || Array.isArray(arg)) {
                    var arr = canReflect.isObservableLike(arg) && canReflect.isListLike(arg) ? makeArray(arg) : arg;
                    each(arr, function (innerArg) {
                        serializeNonTypes(MapType, innerArg, args);
                    });
                } else {
                    serializeNonTypes(MapType, arg, args);
                }
            });
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.attr('length'); i < len; i++) {
                item = this.attr(i);
                if (item !== undefined && cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            if (isPromise(newList)) {
                if (this._promise) {
                    this._promise.__isCurrentPromise = false;
                }
                var promise = this._promise = newList;
                promise.__isCurrentPromise = true;
                var self = this;
                newList.then(function (newList) {
                    if (promise.__isCurrentPromise) {
                        self.replace(newList);
                    }
                });
            } else {
                this.splice.apply(this, [
                    0,
                    this.length
                ].concat(makeArray(newList || [])));
            }
            return this;
        },
        filter: function (callback, thisArg) {
            var filteredList = new this.constructor(), self = this, filtered;
            this.each(function (item, index, list) {
                filtered = callback.call(thisArg || self, item, index, self);
                if (filtered) {
                    filteredList.push(item);
                }
            });
            return filteredList;
        },
        map: function (callback, thisArg) {
            var filteredList = new List(), self = this;
            this.each(function (item, index, list) {
                var mapped = callback.call(thisArg || self, item, index, self);
                filteredList.push(mapped);
            });
            return filteredList;
        }
    });
    var oldType = Map.prototype.__type;
    Map.prototype.__type = function (value, prop) {
        if (typeof value === 'object' && Array.isArray(value)) {
            var cached = mapHelpers.getMapFromObject(value);
            if (cached) {
                return cached;
            }
            return new List(value);
        }
        return oldType.apply(this, arguments);
    };
    var oldSetup = Map.setup;
    Map.setup = function () {
        oldSetup.apply(this, arguments);
        if (!(this.prototype instanceof List)) {
            this.List = Map.List.extend({ Map: this }, {});
        }
    };
    if (!types.DefaultList) {
        types.DefaultList = List;
    }
    canReflect.assignSymbols(List.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isListLike': true,
        'can.getKeyValue': List.prototype._get,
        'can.setKeyValue': List.prototype._set,
        'can.deleteKeyValue': List.prototype._remove,
        'can.getOwnEnumerableKeys': function () {
            return Object.keys(this._data || {}).concat(this.map(function (val, index) {
                return index;
            }));
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignDeepList(this, source);
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            canReflect.updateDeepList(this, source);
            canBatch.stop();
        },
        'can.unwrap': mapHelpers.reflectUnwrap,
        'can.serialize': mapHelpers.reflectSerialize,
        'can.onKeysAdded': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('add', handler);
        },
        'can.onKeysRemoved': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('remove', handler);
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        }
    });
    List.prototype.each = List.prototype.forEach;
    Map.List = List;
    module.exports = namespace.List = List;
});
/*can-globals@1.2.0#location/location*/
define('can-globals@1.2.0#location/location', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('location', function () {
            return globals.getKeyValue('global').location;
        });
        module.exports = globals.makeExport('location');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#custom-elements/custom-elements*/
define('can-globals@1.2.0#custom-elements/custom-elements', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-globals/can-globals-instance'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('can-globals/global/global');
        var globals = require('can-globals/can-globals-instance');
        globals.define('customElements', function () {
            var GLOBAL = globals.getKeyValue('global');
            return GLOBAL.customElements;
        });
        module.exports = globals.makeExport('customElements');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-globals@1.2.0#can-globals*/
define('can-globals@1.2.0#can-globals', [
    'require',
    'exports',
    'module',
    'can-globals/can-globals-instance',
    './global/global',
    './document/document',
    './location/location',
    './mutation-observer/mutation-observer',
    './is-browser-window/is-browser-window',
    './is-node/is-node',
    './custom-elements/custom-elements'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals/can-globals-instance');
        require('./global/global');
        require('./document/document');
        require('./location/location');
        require('./mutation-observer/mutation-observer');
        require('./is-browser-window/is-browser-window');
        require('./is-node/is-node');
        require('./custom-elements/custom-elements');
        module.exports = globals;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.4.2#lib/document/node*/
define('can-simple-dom@1.4.2#lib/document/node', function (require, exports, module) {
    function Node(nodeType, nodeName, nodeValue, ownerDocument) {
        this.nodeType = nodeType;
        this.nodeName = nodeName;
        this.nodeValue = nodeValue;
        this.ownerDocument = ownerDocument;
        this.childNodes = new ChildNodes(this);
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
    }
    Node.prototype._cloneNode = function () {
        return new Node(this.nodeType, this.nodeName, this.nodeValue, this.ownerDocument);
    };
    Node.prototype.cloneNode = function (deep) {
        var node = this._cloneNode();
        if (deep) {
            var child = this.firstChild, nextChild = child;
            while (nextChild) {
                nextChild = child.nextSibling;
                nodeAppendChild.call(node, child.cloneNode(true));
                child = nextChild;
            }
        }
        return node;
    };
    var nodeAppendChild = Node.prototype.appendChild = function (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, this.lastChild, null);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var refNode = this.lastChild;
        if (refNode === null) {
            this.firstChild = node;
            this.lastChild = node;
        } else {
            node.previousSibling = refNode;
            refNode.nextSibling = node;
            this.lastChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    function insertFragment(fragment, newParent, before, after) {
        if (!fragment.firstChild) {
            return;
        }
        var firstChild = fragment.firstChild;
        var lastChild = firstChild;
        var node = firstChild;
        firstChild.previousSibling = before;
        if (before) {
            before.nextSibling = firstChild;
        } else {
            newParent.firstChild = firstChild;
        }
        while (node) {
            node.parentNode = newParent;
            ensureOwnerDocument(newParent, node);
            lastChild = node;
            node = node.nextSibling;
        }
        lastChild.nextSibling = after;
        if (after) {
            after.previousSibling = lastChild;
        } else {
            newParent.lastChild = lastChild;
        }
        fragment.firstChild = null;
        fragment.lastChild = null;
    }
    function ensureOwnerDocument(parent, child) {
        var ownerDocument = parent.nodeType === 9 ? parent : parent.ownerDocument;
        if (parent.ownerDocument !== child.ownerDocument) {
            var node = child;
            while (node) {
                node.ownerDocument = ownerDocument;
                if (node.firstChild) {
                    ensureOwnerDocument(node, node.firstChild);
                }
                node = node.nextSibling;
            }
        }
    }
    var nodeInsertBefore = Node.prototype.insertBefore = function (node, refNode) {
        if (refNode == null) {
            return nodeAppendChild.call(this, node);
        }
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            insertFragment(node, this, refNode ? refNode.previousSibling : null, refNode);
            return node;
        }
        if (node.parentNode) {
            nodeRemoveChild.call(node.parentNode, node);
        }
        node.parentNode = this;
        var previousSibling = refNode.previousSibling;
        if (previousSibling) {
            previousSibling.nextSibling = node;
            node.previousSibling = previousSibling;
        }
        refNode.previousSibling = node;
        node.nextSibling = refNode;
        if (this.firstChild === refNode) {
            this.firstChild = node;
        }
        ensureOwnerDocument(this, node);
        return node;
    };
    var nodeRemoveChild = Node.prototype.removeChild = function (refNode) {
        if (this.firstChild === refNode) {
            this.firstChild = refNode.nextSibling;
        }
        if (this.lastChild === refNode) {
            this.lastChild = refNode.previousSibling;
        }
        if (refNode.previousSibling) {
            refNode.previousSibling.nextSibling = refNode.nextSibling;
        }
        if (refNode.nextSibling) {
            refNode.nextSibling.previousSibling = refNode.previousSibling;
        }
        refNode.parentNode = null;
        refNode.nextSibling = null;
        refNode.previousSibling = null;
        return refNode;
    };
    Node.prototype.replaceChild = function (newChild, oldChild) {
        nodeInsertBefore.call(this, newChild, oldChild);
        nodeRemoveChild.call(this, oldChild);
        return oldChild;
    };
    Node.prototype.contains = function (child) {
        child = child.parentNode;
        while (child) {
            if (child === this) {
                return true;
            }
            child = child.parentNode;
        }
        return false;
    };
    Node.prototype.addEventListener = function () {
    };
    Node.prototype.removeEventListener = function () {
    };
    Node.ELEMENT_NODE = 1;
    Node.ATTRIBUTE_NODE = 2;
    Node.TEXT_NODE = 3;
    Node.CDATA_SECTION_NODE = 4;
    Node.ENTITY_REFERENCE_NODE = 5;
    Node.ENTITY_NODE = 6;
    Node.PROCESSING_INSTRUCTION_NODE = 7;
    Node.COMMENT_NODE = 8;
    Node.DOCUMENT_NODE = 9;
    Node.DOCUMENT_TYPE_NODE = 10;
    Node.DOCUMENT_FRAGMENT_NODE = 11;
    Node.NOTATION_NODE = 12;
    function ChildNodes(node) {
        this.node = node;
    }
    ChildNodes.prototype.item = function (index) {
        var child = this.node.firstChild;
        for (var i = 0; child && index !== i; i++) {
            child = child.nextSibling;
        }
        return child;
    };
    exports.Node = Node;
    exports.nodeRemoveChild = nodeRemoveChild;
});
/*can-simple-dom@1.4.2#lib/document/style*/
define('can-simple-dom@1.4.2#lib/document/style', function (require, exports, module) {
    function CSSStyleDeclaration(node) {
        this.__node = node;
    }
    CSSStyleDeclaration.prototype.getPropertyValue = function () {
    };
    Object.defineProperty(CSSStyleDeclaration.prototype, 'cssText', {
        enumerable: true,
        configurable: true,
        get: function () {
            return this.__node.getAttribute('style') || '';
        },
        set: function (val) {
            this.__node._setAttribute('style', val);
        }
    });
    module.exports = CSSStyleDeclaration;
});
/*can-simple-dom@1.4.2#lib/document/element*/
define('can-simple-dom@1.4.2#lib/document/element', [
    'require',
    'exports',
    'module',
    './node',
    './style'
], function (require, exports, module) {
    var _node = require('./node');
    var nodeRemoveChild = _node.nodeRemoveChild;
    var Node = _node.Node;
    var CSSStyleDeclaration = require('./style');
    let attrSpecial = {
        'class': function (element, value) {
            element._className = value;
        }
    };
    function Element(tagName, ownerDocument) {
        tagName = tagName.toUpperCase();
        this.nodeConstructor(1, tagName, null, ownerDocument);
        this.style = new CSSStyleDeclaration(this);
        this.attributes = [];
        this.tagName = tagName;
    }
    Element.prototype = Object.create(Node.prototype);
    Element.prototype.constructor = Element;
    Element.prototype.nodeConstructor = Node;
    Element.prototype._cloneNode = function () {
        var node = this.ownerDocument.createElement(this.tagName);
        node.attributes = this.attributes.map(function (attr) {
            return {
                name: attr.name,
                value: attr.value,
                specified: attr.specified
            };
        });
        return node;
    };
    Element.prototype.getAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return attr.value;
            }
        }
        return null;
    };
    Element.prototype.setAttribute = function () {
        return this._setAttribute.apply(this, arguments);
    };
    Element.prototype._setAttribute = function (_name, value) {
        value += '';
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, l = attributes.length; i < l; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                attr.value = value;
                const special = attrSpecial[name];
                if (special) {
                    special(this, value);
                }
                return;
            }
        }
        attributes.push({
            name: name,
            value: value,
            specified: true
        });
        attributes[name] = value;
        const special = attrSpecial[name];
        if (special) {
            special(this, value);
        }
    };
    Element.prototype.hasAttribute = function (_name) {
        var attributes = this.attributes;
        var name = _name.toLowerCase();
        var attr;
        for (var i = 0, len = attributes.length; i < len; i++) {
            attr = attributes[i];
            if (attr.name === name) {
                return true;
            }
        }
        return false;
    };
    Element.prototype.removeAttribute = function (name) {
        var attributes = this.attributes;
        for (var i = 0, l = attributes.length; i < l; i++) {
            var attr = attributes[i];
            if (attr.name === name) {
                attributes.splice(i, 1);
                const special = attrSpecial[name];
                if (special) {
                    special(this, undefined);
                }
                delete attributes[name];
                return;
            }
        }
    };
    Element.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Element.prototype.getElementById = function (id) {
        var cur = this.firstChild, child;
        while (cur) {
            if (cur.attributes && cur.attributes.length) {
                var attr;
                for (var i = 0, len = cur.attributes.length; i < len; i++) {
                    attr = cur.attributes[i];
                    if (attr.name === 'id' && attr.value === id) {
                        return cur;
                    }
                }
            }
            if (cur.getElementById) {
                child = cur.getElementById(id);
                if (child) {
                    return child;
                }
            }
            cur = cur.nextSibling;
        }
    };
    function Style(node) {
        this.__node = node;
    }
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, 'className', {
            configurable: true,
            enumerable: true,
            get: function () {
                return this._className || '';
            },
            set: function (val) {
                this._setAttribute('class', val);
                this._className = val;
            }
        });
        Object.defineProperty(Element.prototype, 'innerHTML', {
            configurable: true,
            enumerable: true,
            get: function () {
                var html = '';
                var cur = this.firstChild;
                while (cur) {
                    html += this.ownerDocument.__serializer.serialize(cur);
                    cur = cur.nextSibling;
                }
                return html;
            },
            set: function (html) {
                this.lastChild = this.firstChild = null;
                var fragment;
                if (this.nodeName === 'SCRIPT' || this.nodeName === 'STYLE') {
                    fragment = this.ownerDocument.createTextNode(html);
                } else {
                    fragment = this.ownerDocument.__parser.parse(html);
                }
                this.appendChild(fragment);
            }
        });
        Object.defineProperty(Element.prototype, 'outerHTML', {
            get: function () {
                return this.ownerDocument.__serializer.serialize(this);
            },
            set: function (html) {
                this.parentNode.replaceChild(this.ownerDocument.__parser.parse(html), this);
            }
        });
        Object.defineProperty(Element.prototype, 'textContent', {
            get: function () {
                var fc = this.firstChild;
                return fc && fc.nodeValue || '';
            },
            set: function (val) {
                while (this.firstChild) {
                    nodeRemoveChild.call(this, this.firstChild);
                }
                var tn = this.ownerDocument.createTextNode(val);
                this.appendChild(tn);
            }
        });
    }
    module.exports = Element;
});
/*can-simple-dom@1.4.2#lib/document/text*/
define('can-simple-dom@1.4.2#lib/document/text', [
    'require',
    'exports',
    'module',
    './node'
], function (require, exports, module) {
    var Node = require('./node').Node;
    function Text(text, ownerDocument) {
        this.nodeConstructor(3, '#text', text, ownerDocument);
    }
    Text.prototype._cloneNode = function () {
        return this.ownerDocument.createTextNode(this.nodeValue);
    };
    Text.prototype = Object.create(Node.prototype);
    Text.prototype.constructor = Text;
    Text.prototype.nodeConstructor = Node;
    module.exports = Text;
});
/*can-simple-dom@1.4.2#lib/document/comment*/
define('can-simple-dom@1.4.2#lib/document/comment', [
    'require',
    'exports',
    'module',
    './node'
], function (require, exports, module) {
    var Node = require('./node').Node;
    function Comment(text, ownerDocument) {
        this.nodeConstructor(8, '#comment', text, ownerDocument);
    }
    Comment.prototype._cloneNode = function () {
        return this.ownerDocument.createComment(this.nodeValue);
    };
    Comment.prototype = Object.create(Node.prototype);
    Comment.prototype.constructor = Comment;
    Comment.prototype.nodeConstructor = Node;
    module.exports = Comment;
});
/*can-simple-dom@1.4.2#lib/document/document-fragment*/
define('can-simple-dom@1.4.2#lib/document/document-fragment', [
    'require',
    'exports',
    'module',
    './node'
], function (require, exports, module) {
    var Node = require('./node').Node;
    function DocumentFragment(ownerDocument) {
        this.nodeConstructor(11, '#document-fragment', null, ownerDocument);
    }
    DocumentFragment.prototype._cloneNode = function () {
        return this.ownerDocument.createDocumentFragment();
    };
    DocumentFragment.prototype = Object.create(Node.prototype);
    DocumentFragment.prototype.constructor = DocumentFragment;
    DocumentFragment.prototype.nodeConstructor = Node;
    module.exports = DocumentFragment;
});
/*micro-location@0.1.5#lib/micro-location*/
function Location() {
    this.init.apply(this, arguments);
}
Location.prototype = {
    init: function (protocol, host, hostname, port, pathname, search, hash) {
        this.protocol = protocol;
        this.host = host;
        this.hostname = hostname;
        this.port = port || '';
        this.pathname = pathname || '';
        this.search = search || '';
        this.hash = hash || '';
        if (protocol) {
            with (this)
                this.href = protocol + '//' + host + pathname + search + hash;
        } else if (host) {
            with (this)
                this.href = '//' + host + pathname + search + hash;
        } else {
            with (this)
                this.href = pathname + search + hash;
        }
    },
    params: function (name) {
        if (!this._params) {
            var params = {};
            var pairs = this.search.substring(1).split(/[;&]/);
            for (var i = 0, len = pairs.length; i < len; i++) {
                if (!pairs[i])
                    continue;
                var pair = pairs[i].split(/=/);
                var key = decodeURIComponent(pair[0].replace(/\+/g, '%20'));
                var val = decodeURIComponent(pair[1].replace(/\+/g, '%20'));
                if (!params[key])
                    params[key] = [];
                params[key].push(val);
            }
            this._params = params;
        }
        switch (typeof name) {
        case 'undefined':
            return this._params;
        case 'object':
            return this.build(name);
        }
        return this._params[name] ? this._params[name][0] : null;
    },
    build: function (params) {
        if (!params)
            params = this._params;
        var ret = new Location();
        var _search = this.search;
        if (params) {
            var search = [];
            for (var key in params)
                if (params.hasOwnProperty(key)) {
                    var val = params[key];
                    switch (typeof val) {
                    case 'object':
                        for (var i = 0, len = val.length; i < len; i++) {
                            search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val[i]));
                        }
                        break;
                    default:
                        search.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                    }
                }
            _search = '?' + search.join('&');
        }
        with (this)
            ret.init.apply(ret, [
                protocol,
                host,
                hostname,
                port,
                pathname,
                _search,
                hash
            ]);
        return ret;
    }
};
Location.regexp = new RegExp('^(?:(https?:)//(([^:/]+)(:[^/]+)?))?([^#?]*)(\\?[^#]*)?(#.*)?$');
Location.parse = function (string) {
    var matched = String(string).match(this.regexp);
    var ret = new Location();
    ret.init.apply(ret, matched.slice(1));
    return ret;
};
(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = { Location: factory() };
    } else if (typeof define === 'function' && define.amd) {
        define('micro-location@0.1.5#lib/micro-location', [], function () {
            return { Location: factory() };
        });
    } else {
        root.Location = factory();
    }
}(this, function () {
    return Location;
}));
/*can-simple-dom@1.4.2#lib/extend*/
define('can-simple-dom@1.4.2#lib/extend', function (require, exports, module) {
    module.exports = function (a, b) {
        for (var p in b) {
            a[p] = b[p];
        }
        return a;
    };
});
/*can-simple-dom@1.4.2#lib/document/anchor-element*/
define('can-simple-dom@1.4.2#lib/document/anchor-element', [
    'require',
    'exports',
    'module',
    './element',
    'micro-location',
    '../extend'
], function (require, exports, module) {
    var Element = require('./element');
    var microLocation = require('micro-location');
    var extend = require('../extend');
    const Location = microLocation.Location || microLocation;
    function AnchorElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        extend(this, Location.parse(''));
    }
    AnchorElement.prototype = Object.create(Element.prototype);
    AnchorElement.prototype.constructor = AnchorElement;
    AnchorElement.prototype.elementConstructor = Element;
    AnchorElement.prototype.setAttribute = function (_name, value) {
        Element.prototype.setAttribute.apply(this, arguments);
        if (_name.toLowerCase() === 'href') {
            extend(this, Location.parse(value));
        }
    };
    module.exports = AnchorElement;
});
/*can-simple-dom@1.4.2#lib/document/utils*/
define('can-simple-dom@1.4.2#lib/document/utils', function (require, exports, module) {
    exports.propToAttr = function (Element, name) {
        Object.defineProperty(Element.prototype, name, {
            configurable: true,
            enumerable: true,
            get: function () {
                return this.getAttribute(name);
            },
            set: function (val) {
                this.setAttribute(name, val);
            }
        });
    };
});
/*can-simple-dom@1.4.2#lib/document/input-element*/
define('can-simple-dom@1.4.2#lib/document/input-element', [
    'require',
    'exports',
    'module',
    './element',
    './utils'
], function (require, exports, module) {
    var Element = require('./element');
    var propToAttr = require('./utils').propToAttr;
    function InputElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    InputElement.prototype = Object.create(Element.prototype);
    InputElement.prototype.constructor = InputElement;
    InputElement.prototype.elementConstructor = Element;
    propToAttr(InputElement, 'type');
    propToAttr(InputElement, 'value');
    Object.defineProperty(InputElement.prototype, 'checked', {
        configurable: true,
        enumerable: true,
        get: function () {
            return this.hasAttribute('checked');
        },
        set: function (value) {
            if (value) {
                this.setAttribute('checked', '');
            } else {
                this.removeAttribute('checked');
            }
        }
    });
    module.exports = InputElement;
});
/*can-simple-dom@1.4.2#lib/document/option-element*/
define('can-simple-dom@1.4.2#lib/document/option-element', [
    'require',
    'exports',
    'module',
    './element',
    './utils'
], function (require, exports, module) {
    var Element = require('./element');
    var propToAttr = require('./utils').propToAttr;
    function OptionElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
    }
    OptionElement.prototype = Object.create(Element.prototype);
    OptionElement.prototype.constructor = OptionElement;
    OptionElement.prototype.elementConstructor = Element;
    propToAttr(OptionElement, 'value');
    Object.defineProperty(OptionElement.prototype, 'selected', {
        enumerable: true,
        configurable: true,
        get: function () {
            var val = this.value || '';
            var parent = this.parentNode;
            return parent && parent.value == val;
        },
        set: function (val) {
            if (val) {
                var parent = this.parentNode;
                if (parent) {
                    parent.value = this.value;
                }
            }
        }
    });
    module.exports = OptionElement;
});
/*can-simple-dom@1.4.2#lib/document/select-element*/
define('can-simple-dom@1.4.2#lib/document/select-element', [
    'require',
    'exports',
    'module',
    './element',
    './utils'
], function (require, exports, module) {
    var Element = require('./element');
    var propToAttr = require('./utils').propToAttr;
    function SelectElement(tagName, ownerDocument) {
        this.elementConstructor(tagName, ownerDocument);
        this.selectedIndex = 0;
    }
    SelectElement.prototype = Object.create(Element.prototype);
    SelectElement.prototype.constructor = SelectElement;
    SelectElement.prototype.elementConstructor = Element;
    propToAttr(SelectElement, 'value');
    module.exports = SelectElement;
});
/*can-simple-dom@1.4.2#lib/document*/
define('can-simple-dom@1.4.2#lib/document', [
    'require',
    'exports',
    'module',
    './document/node',
    './document/element',
    './document/text',
    './document/comment',
    './document/document-fragment',
    './document/anchor-element',
    './document/input-element',
    './document/option-element',
    './document/select-element'
], function (require, exports, module) {
    var Node = require('./document/node').Node;
    var Element = require('./document/element');
    var Text = require('./document/text');
    var Comment = require('./document/comment');
    var DocumentFragment = require('./document/document-fragment');
    var AnchorElement = require('./document/anchor-element');
    var InputElement = require('./document/input-element');
    var OptionElement = require('./document/option-element');
    var SelectElement = require('./document/select-element');
    var noop = Function.prototype;
    function Document() {
        this.nodeConstructor(9, '#document', null, this);
        var documentElement = new Element('html', this);
        var body = new Element('body', this);
        var head = new Element('head', this);
        documentElement.appendChild(head);
        documentElement.appendChild(body);
        this.appendChild(documentElement);
        var self = this;
        this.implementation = {
            createHTMLDocument: function (content) {
                var document = new Document();
                var frag = self.__parser.parse(content);
                var body = Element.prototype.getElementsByTagName.call(frag, 'body')[0];
                var head = Element.prototype.getElementsByTagName.call(frag, 'head')[0];
                if (!body && !head) {
                    document.body.appendChild(frag);
                } else {
                    if (body) {
                        document.documentElement.replaceChild(body, document.body);
                    }
                    if (head) {
                        document.documentElement.replaceChild(head, document.head);
                    }
                    document.documentElement.appendChild(frag);
                }
                document.__addSerializerAndParser(self.__serializer, self.__parser);
                return document;
            }
        };
    }
    Document.prototype = Object.create(Node.prototype);
    Document.prototype.constructor = Document;
    Document.prototype.nodeConstructor = Node;
    const specialElements = {
        'a': AnchorElement,
        'input': InputElement,
        'option': OptionElement,
        'select': SelectElement
    };
    Document.prototype.createElement = function (tagName) {
        var Special = specialElements[tagName.toLowerCase()];
        if (Special) {
            return new Special(tagName, this);
        }
        return new Element(tagName, this);
    };
    Document.prototype.createTextNode = function (text) {
        return new Text(text, this);
    };
    Document.prototype.createComment = function (text) {
        return new Comment(text, this);
    };
    Document.prototype.createDocumentFragment = function () {
        return new DocumentFragment(this);
    };
    Document.prototype.getElementsByTagName = function (name) {
        name = name.toUpperCase();
        var elements = [];
        var cur = this.firstChild;
        while (cur) {
            if (cur.nodeType === Node.ELEMENT_NODE) {
                if (cur.nodeName === name || name === '*') {
                    elements.push(cur);
                }
                elements.push.apply(elements, cur.getElementsByTagName(name));
            }
            cur = cur.nextSibling;
        }
        return elements;
    };
    Document.prototype.getElementById = function (id) {
        return Element.prototype.getElementById.apply(this.documentElement, arguments);
    };
    Document.prototype.__addSerializerAndParser = function (serializer, parser) {
        this.__parser = parser;
        this.__serializer = serializer;
    };
    if (Object.defineProperty) {
        Object.defineProperty(Document.prototype, 'currentScript', {
            get: function () {
                var scripts = this.getElementsByTagName('script');
                var first = scripts[scripts.length - 1];
                if (!first) {
                    first = this.createElement('script');
                }
                return first;
            }
        });
        Object.defineProperty(Document.prototype, 'documentElement', {
            get: function () {
                return this.firstChild;
            },
            set: noop
        });
        function firstOfKind(root, nodeName) {
            if (root == null)
                return null;
            var node = root.firstChild;
            while (node) {
                if (node.nodeName === nodeName) {
                    return node;
                }
                node = node.nextSibling;
            }
            return null;
        }
        [
            'head',
            'body'
        ].forEach(function (localName) {
            var nodeName = localName.toUpperCase();
            Object.defineProperty(Document.prototype, localName, {
                get: function () {
                    return firstOfKind(this.documentElement, nodeName);
                },
                set: noop
            });
        });
    }
    module.exports = Document;
});
/*can-simple-dom@1.4.2#lib/event*/
define('can-simple-dom@1.4.2#lib/event', [
    'require',
    'exports',
    'module',
    './document/node',
    './document'
], function (require, exports, module) {
    var Node = require('./document/node').Node;
    var Document = require('./document');
    var Event = function () {
    };
    Event.prototype.initEvent = function (type, bubbles, cancelable) {
        this.type = type;
        this.bubbles = !!bubbles;
        this.cancelable = !!cancelable;
    };
    Event.prototype.stopPropagation = function () {
        this.isPropagationStopped = true;
    };
    Event.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    Document.prototype.createEvent = function (type) {
        return new Event();
    };
    Node.prototype.addEventListener = function (event, handler, capture) {
        if (!this.__handlers) {
            Object.defineProperty(this, '__handlers', {
                value: {},
                enumerable: false
            });
        }
        var phase = capture ? 'capture' : 'bubble';
        var handlersByType = this.__handlers[event + ' ' + phase];
        if (!handlersByType) {
            handlersByType = this.__handlers[event + ' ' + phase] = [];
        }
        if (handlersByType.indexOf(handler) === -1) {
            handlersByType.push(handler);
        }
    };
    Node.prototype.removeEventListener = function (event, handler, capture) {
        if (this.__handlers) {
            var phase = capture ? 'capture' : 'bubble';
            var handlersByType = this.__handlers[event + ' ' + phase];
            if (handlersByType) {
                var index = 0;
                while (index < handlersByType.length) {
                    if (handlersByType[index] === handler) {
                        handlersByType.splice(index, 1);
                    } else {
                        index++;
                    }
                }
            }
        }
    };
    Node.prototype.dispatchEvent = function (event) {
        event.target = this;
        var cur = this;
        var dispatchHandlers = [];
        do {
            var handlers = cur.__handlers && cur.__handlers[event.type + ' bubble'];
            if (handlers) {
                dispatchHandlers.push({
                    node: cur,
                    handlers: handlers
                });
            }
            cur = cur.parentNode;
        } while (event.bubbles && cur);
        for (var i = 0; i < dispatchHandlers.length; i++) {
            var dispatches = dispatchHandlers[i];
            event.currentTarget = dispatches.node;
            for (var h = 0; h < dispatches.handlers.length; h++) {
                var handler = dispatches.handlers[h];
                var res = handler.call(this, event);
                if (res) {
                    event.stopPropagation();
                    event.preventDefault();
                }
                if (event.isImmediatePropagationStopped) {
                    return !event.isDefaultPrevented;
                }
            }
            if (event.isPropagationStopped) {
                return !event.isDefaultPrevented;
            }
        }
        return !event.isDefaultPrevented;
    };
    module.exports = Event;
});
/*he@1.1.1#he*/
;
(function (root) {
    var freeExports = typeof exports == 'object' && exports;
    var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
    var freeGlobal = typeof global == 'object' && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var regexAsciiWhitelist = /[\x01-\x7F]/g;
    var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
    var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
    var encodeMap = {
        '\xAD': 'shy',
        '‌': 'zwnj',
        '‍': 'zwj',
        '\u200E': 'lrm',
        '\u2063': 'ic',
        '\u2062': 'it',
        '\u2061': 'af',
        '\u200F': 'rlm',
        '\u200B': 'ZeroWidthSpace',
        '\u2060': 'NoBreak',
        '̑': 'DownBreve',
        '⃛': 'tdot',
        '⃜': 'DotDot',
        '\t': 'Tab',
        '\n': 'NewLine',
        '\u2008': 'puncsp',
        '\u205F': 'MediumSpace',
        '\u2009': 'thinsp',
        '\u200A': 'hairsp',
        '\u2004': 'emsp13',
        '\u2002': 'ensp',
        '\u2005': 'emsp14',
        '\u2003': 'emsp',
        '\u2007': 'numsp',
        '\xA0': 'nbsp',
        '\u205F\u200A': 'ThickSpace',
        '\u203E': 'oline',
        '_': 'lowbar',
        '\u2010': 'dash',
        '\u2013': 'ndash',
        '\u2014': 'mdash',
        '\u2015': 'horbar',
        ',': 'comma',
        ';': 'semi',
        '\u204F': 'bsemi',
        ':': 'colon',
        '\u2A74': 'Colone',
        '!': 'excl',
        '\xA1': 'iexcl',
        '?': 'quest',
        '\xBF': 'iquest',
        '.': 'period',
        '\u2025': 'nldr',
        '\u2026': 'mldr',
        '\xB7': 'middot',
        '\'': 'apos',
        '\u2018': 'lsquo',
        '\u2019': 'rsquo',
        '\u201A': 'sbquo',
        '\u2039': 'lsaquo',
        '\u203A': 'rsaquo',
        '"': 'quot',
        '\u201C': 'ldquo',
        '\u201D': 'rdquo',
        '\u201E': 'bdquo',
        '\xAB': 'laquo',
        '\xBB': 'raquo',
        '(': 'lpar',
        ')': 'rpar',
        '[': 'lsqb',
        ']': 'rsqb',
        '{': 'lcub',
        '}': 'rcub',
        '\u2308': 'lceil',
        '\u2309': 'rceil',
        '\u230A': 'lfloor',
        '\u230B': 'rfloor',
        '\u2985': 'lopar',
        '\u2986': 'ropar',
        '\u298B': 'lbrke',
        '\u298C': 'rbrke',
        '\u298D': 'lbrkslu',
        '\u298E': 'rbrksld',
        '\u298F': 'lbrksld',
        '\u2990': 'rbrkslu',
        '\u2991': 'langd',
        '\u2992': 'rangd',
        '\u2993': 'lparlt',
        '\u2994': 'rpargt',
        '\u2995': 'gtlPar',
        '\u2996': 'ltrPar',
        '\u27E6': 'lobrk',
        '\u27E7': 'robrk',
        '\u27E8': 'lang',
        '\u27E9': 'rang',
        '\u27EA': 'Lang',
        '\u27EB': 'Rang',
        '\u27EC': 'loang',
        '\u27ED': 'roang',
        '\u2772': 'lbbrk',
        '\u2773': 'rbbrk',
        '\u2016': 'Vert',
        '\xA7': 'sect',
        '\xB6': 'para',
        '@': 'commat',
        '*': 'ast',
        '/': 'sol',
        'undefined': null,
        '&': 'amp',
        '#': 'num',
        '%': 'percnt',
        '\u2030': 'permil',
        '\u2031': 'pertenk',
        '\u2020': 'dagger',
        '\u2021': 'Dagger',
        '\u2022': 'bull',
        '\u2043': 'hybull',
        '\u2032': 'prime',
        '\u2033': 'Prime',
        '\u2034': 'tprime',
        '\u2057': 'qprime',
        '\u2035': 'bprime',
        '\u2041': 'caret',
        '`': 'grave',
        '\xB4': 'acute',
        '\u02DC': 'tilde',
        '^': 'Hat',
        '\xAF': 'macr',
        '\u02D8': 'breve',
        '\u02D9': 'dot',
        '\xA8': 'die',
        '\u02DA': 'ring',
        '\u02DD': 'dblac',
        '\xB8': 'cedil',
        '\u02DB': 'ogon',
        'ˆ': 'circ',
        'ˇ': 'caron',
        '\xB0': 'deg',
        '\xA9': 'copy',
        '\xAE': 'reg',
        '\u2117': 'copysr',
        '\u2118': 'wp',
        '\u211E': 'rx',
        '\u2127': 'mho',
        '\u2129': 'iiota',
        '\u2190': 'larr',
        '\u219A': 'nlarr',
        '\u2192': 'rarr',
        '\u219B': 'nrarr',
        '\u2191': 'uarr',
        '\u2193': 'darr',
        '\u2194': 'harr',
        '\u21AE': 'nharr',
        '\u2195': 'varr',
        '\u2196': 'nwarr',
        '\u2197': 'nearr',
        '\u2198': 'searr',
        '\u2199': 'swarr',
        '\u219D': 'rarrw',
        '\u219D̸': 'nrarrw',
        '\u219E': 'Larr',
        '\u219F': 'Uarr',
        '\u21A0': 'Rarr',
        '\u21A1': 'Darr',
        '\u21A2': 'larrtl',
        '\u21A3': 'rarrtl',
        '\u21A4': 'mapstoleft',
        '\u21A5': 'mapstoup',
        '\u21A6': 'map',
        '\u21A7': 'mapstodown',
        '\u21A9': 'larrhk',
        '\u21AA': 'rarrhk',
        '\u21AB': 'larrlp',
        '\u21AC': 'rarrlp',
        '\u21AD': 'harrw',
        '\u21B0': 'lsh',
        '\u21B1': 'rsh',
        '\u21B2': 'ldsh',
        '\u21B3': 'rdsh',
        '\u21B5': 'crarr',
        '\u21B6': 'cularr',
        '\u21B7': 'curarr',
        '\u21BA': 'olarr',
        '\u21BB': 'orarr',
        '\u21BC': 'lharu',
        '\u21BD': 'lhard',
        '\u21BE': 'uharr',
        '\u21BF': 'uharl',
        '\u21C0': 'rharu',
        '\u21C1': 'rhard',
        '\u21C2': 'dharr',
        '\u21C3': 'dharl',
        '\u21C4': 'rlarr',
        '\u21C5': 'udarr',
        '\u21C6': 'lrarr',
        '\u21C7': 'llarr',
        '\u21C8': 'uuarr',
        '\u21C9': 'rrarr',
        '\u21CA': 'ddarr',
        '\u21CB': 'lrhar',
        '\u21CC': 'rlhar',
        '\u21D0': 'lArr',
        '\u21CD': 'nlArr',
        '\u21D1': 'uArr',
        '\u21D2': 'rArr',
        '\u21CF': 'nrArr',
        '\u21D3': 'dArr',
        '\u21D4': 'iff',
        '\u21CE': 'nhArr',
        '\u21D5': 'vArr',
        '\u21D6': 'nwArr',
        '\u21D7': 'neArr',
        '\u21D8': 'seArr',
        '\u21D9': 'swArr',
        '\u21DA': 'lAarr',
        '\u21DB': 'rAarr',
        '\u21DD': 'zigrarr',
        '\u21E4': 'larrb',
        '\u21E5': 'rarrb',
        '\u21F5': 'duarr',
        '\u21FD': 'loarr',
        '\u21FE': 'roarr',
        '\u21FF': 'hoarr',
        '\u2200': 'forall',
        '\u2201': 'comp',
        '\u2202': 'part',
        '\u2202̸': 'npart',
        '\u2203': 'exist',
        '\u2204': 'nexist',
        '\u2205': 'empty',
        '\u2207': 'Del',
        '\u2208': 'in',
        '\u2209': 'notin',
        '\u220B': 'ni',
        '\u220C': 'notni',
        '\u03F6': 'bepsi',
        '\u220F': 'prod',
        '\u2210': 'coprod',
        '\u2211': 'sum',
        '+': 'plus',
        '\xB1': 'pm',
        '\xF7': 'div',
        '\xD7': 'times',
        '<': 'lt',
        '\u226E': 'nlt',
        '<⃒': 'nvlt',
        '=': 'equals',
        '\u2260': 'ne',
        '=⃥': 'bne',
        '\u2A75': 'Equal',
        '>': 'gt',
        '\u226F': 'ngt',
        '>⃒': 'nvgt',
        '\xAC': 'not',
        '|': 'vert',
        '\xA6': 'brvbar',
        '\u2212': 'minus',
        '\u2213': 'mp',
        '\u2214': 'plusdo',
        '\u2044': 'frasl',
        '\u2216': 'setmn',
        '\u2217': 'lowast',
        '\u2218': 'compfn',
        '\u221A': 'Sqrt',
        '\u221D': 'prop',
        '\u221E': 'infin',
        '\u221F': 'angrt',
        '\u2220': 'ang',
        '\u2220⃒': 'nang',
        '\u2221': 'angmsd',
        '\u2222': 'angsph',
        '\u2223': 'mid',
        '\u2224': 'nmid',
        '\u2225': 'par',
        '\u2226': 'npar',
        '\u2227': 'and',
        '\u2228': 'or',
        '\u2229': 'cap',
        '\u2229︀': 'caps',
        '\u222A': 'cup',
        '\u222A︀': 'cups',
        '\u222B': 'int',
        '\u222C': 'Int',
        '\u222D': 'tint',
        '\u2A0C': 'qint',
        '\u222E': 'oint',
        '\u222F': 'Conint',
        '\u2230': 'Cconint',
        '\u2231': 'cwint',
        '\u2232': 'cwconint',
        '\u2233': 'awconint',
        '\u2234': 'there4',
        '\u2235': 'becaus',
        '\u2236': 'ratio',
        '\u2237': 'Colon',
        '\u2238': 'minusd',
        '\u223A': 'mDDot',
        '\u223B': 'homtht',
        '\u223C': 'sim',
        '\u2241': 'nsim',
        '\u223C⃒': 'nvsim',
        '\u223D': 'bsim',
        '\u223Ḏ': 'race',
        '\u223E': 'ac',
        '\u223E̳': 'acE',
        '\u223F': 'acd',
        '\u2240': 'wr',
        '\u2242': 'esim',
        '\u2242̸': 'nesim',
        '\u2243': 'sime',
        '\u2244': 'nsime',
        '\u2245': 'cong',
        '\u2247': 'ncong',
        '\u2246': 'simne',
        '\u2248': 'ap',
        '\u2249': 'nap',
        '\u224A': 'ape',
        '\u224B': 'apid',
        '\u224B̸': 'napid',
        '\u224C': 'bcong',
        '\u224D': 'CupCap',
        '\u226D': 'NotCupCap',
        '\u224D⃒': 'nvap',
        '\u224E': 'bump',
        '\u224E̸': 'nbump',
        '\u224F': 'bumpe',
        '\u224F̸': 'nbumpe',
        '\u2250': 'doteq',
        '\u2250̸': 'nedot',
        '\u2251': 'eDot',
        '\u2252': 'efDot',
        '\u2253': 'erDot',
        '\u2254': 'colone',
        '\u2255': 'ecolon',
        '\u2256': 'ecir',
        '\u2257': 'cire',
        '\u2259': 'wedgeq',
        '\u225A': 'veeeq',
        '\u225C': 'trie',
        '\u225F': 'equest',
        '\u2261': 'equiv',
        '\u2262': 'nequiv',
        '\u2261⃥': 'bnequiv',
        '\u2264': 'le',
        '\u2270': 'nle',
        '\u2264⃒': 'nvle',
        '\u2265': 'ge',
        '\u2271': 'nge',
        '\u2265⃒': 'nvge',
        '\u2266': 'lE',
        '\u2266̸': 'nlE',
        '\u2267': 'gE',
        '\u2267̸': 'ngE',
        '\u2268︀': 'lvnE',
        '\u2268': 'lnE',
        '\u2269': 'gnE',
        '\u2269︀': 'gvnE',
        '\u226A': 'll',
        '\u226A̸': 'nLtv',
        '\u226A⃒': 'nLt',
        '\u226B': 'gg',
        '\u226B̸': 'nGtv',
        '\u226B⃒': 'nGt',
        '\u226C': 'twixt',
        '\u2272': 'lsim',
        '\u2274': 'nlsim',
        '\u2273': 'gsim',
        '\u2275': 'ngsim',
        '\u2276': 'lg',
        '\u2278': 'ntlg',
        '\u2277': 'gl',
        '\u2279': 'ntgl',
        '\u227A': 'pr',
        '\u2280': 'npr',
        '\u227B': 'sc',
        '\u2281': 'nsc',
        '\u227C': 'prcue',
        '\u22E0': 'nprcue',
        '\u227D': 'sccue',
        '\u22E1': 'nsccue',
        '\u227E': 'prsim',
        '\u227F': 'scsim',
        '\u227F̸': 'NotSucceedsTilde',
        '\u2282': 'sub',
        '\u2284': 'nsub',
        '\u2282⃒': 'vnsub',
        '\u2283': 'sup',
        '\u2285': 'nsup',
        '\u2283⃒': 'vnsup',
        '\u2286': 'sube',
        '\u2288': 'nsube',
        '\u2287': 'supe',
        '\u2289': 'nsupe',
        '\u228A︀': 'vsubne',
        '\u228A': 'subne',
        '\u228B︀': 'vsupne',
        '\u228B': 'supne',
        '\u228D': 'cupdot',
        '\u228E': 'uplus',
        '\u228F': 'sqsub',
        '\u228F̸': 'NotSquareSubset',
        '\u2290': 'sqsup',
        '\u2290̸': 'NotSquareSuperset',
        '\u2291': 'sqsube',
        '\u22E2': 'nsqsube',
        '\u2292': 'sqsupe',
        '\u22E3': 'nsqsupe',
        '\u2293': 'sqcap',
        '\u2293︀': 'sqcaps',
        '\u2294': 'sqcup',
        '\u2294︀': 'sqcups',
        '\u2295': 'oplus',
        '\u2296': 'ominus',
        '\u2297': 'otimes',
        '\u2298': 'osol',
        '\u2299': 'odot',
        '\u229A': 'ocir',
        '\u229B': 'oast',
        '\u229D': 'odash',
        '\u229E': 'plusb',
        '\u229F': 'minusb',
        '\u22A0': 'timesb',
        '\u22A1': 'sdotb',
        '\u22A2': 'vdash',
        '\u22AC': 'nvdash',
        '\u22A3': 'dashv',
        '\u22A4': 'top',
        '\u22A5': 'bot',
        '\u22A7': 'models',
        '\u22A8': 'vDash',
        '\u22AD': 'nvDash',
        '\u22A9': 'Vdash',
        '\u22AE': 'nVdash',
        '\u22AA': 'Vvdash',
        '\u22AB': 'VDash',
        '\u22AF': 'nVDash',
        '\u22B0': 'prurel',
        '\u22B2': 'vltri',
        '\u22EA': 'nltri',
        '\u22B3': 'vrtri',
        '\u22EB': 'nrtri',
        '\u22B4': 'ltrie',
        '\u22EC': 'nltrie',
        '\u22B4⃒': 'nvltrie',
        '\u22B5': 'rtrie',
        '\u22ED': 'nrtrie',
        '\u22B5⃒': 'nvrtrie',
        '\u22B6': 'origof',
        '\u22B7': 'imof',
        '\u22B8': 'mumap',
        '\u22B9': 'hercon',
        '\u22BA': 'intcal',
        '\u22BB': 'veebar',
        '\u22BD': 'barvee',
        '\u22BE': 'angrtvb',
        '\u22BF': 'lrtri',
        '\u22C0': 'Wedge',
        '\u22C1': 'Vee',
        '\u22C2': 'xcap',
        '\u22C3': 'xcup',
        '\u22C4': 'diam',
        '\u22C5': 'sdot',
        '\u22C6': 'Star',
        '\u22C7': 'divonx',
        '\u22C8': 'bowtie',
        '\u22C9': 'ltimes',
        '\u22CA': 'rtimes',
        '\u22CB': 'lthree',
        '\u22CC': 'rthree',
        '\u22CD': 'bsime',
        '\u22CE': 'cuvee',
        '\u22CF': 'cuwed',
        '\u22D0': 'Sub',
        '\u22D1': 'Sup',
        '\u22D2': 'Cap',
        '\u22D3': 'Cup',
        '\u22D4': 'fork',
        '\u22D5': 'epar',
        '\u22D6': 'ltdot',
        '\u22D7': 'gtdot',
        '\u22D8': 'Ll',
        '\u22D8̸': 'nLl',
        '\u22D9': 'Gg',
        '\u22D9̸': 'nGg',
        '\u22DA︀': 'lesg',
        '\u22DA': 'leg',
        '\u22DB': 'gel',
        '\u22DB︀': 'gesl',
        '\u22DE': 'cuepr',
        '\u22DF': 'cuesc',
        '\u22E6': 'lnsim',
        '\u22E7': 'gnsim',
        '\u22E8': 'prnsim',
        '\u22E9': 'scnsim',
        '\u22EE': 'vellip',
        '\u22EF': 'ctdot',
        '\u22F0': 'utdot',
        '\u22F1': 'dtdot',
        '\u22F2': 'disin',
        '\u22F3': 'isinsv',
        '\u22F4': 'isins',
        '\u22F5': 'isindot',
        '\u22F5̸': 'notindot',
        '\u22F6': 'notinvc',
        '\u22F7': 'notinvb',
        '\u22F9': 'isinE',
        '\u22F9̸': 'notinE',
        '\u22FA': 'nisd',
        '\u22FB': 'xnis',
        '\u22FC': 'nis',
        '\u22FD': 'notnivc',
        '\u22FE': 'notnivb',
        '\u2305': 'barwed',
        '\u2306': 'Barwed',
        '\u230C': 'drcrop',
        '\u230D': 'dlcrop',
        '\u230E': 'urcrop',
        '\u230F': 'ulcrop',
        '\u2310': 'bnot',
        '\u2312': 'profline',
        '\u2313': 'profsurf',
        '\u2315': 'telrec',
        '\u2316': 'target',
        '\u231C': 'ulcorn',
        '\u231D': 'urcorn',
        '\u231E': 'dlcorn',
        '\u231F': 'drcorn',
        '\u2322': 'frown',
        '\u2323': 'smile',
        '\u232D': 'cylcty',
        '\u232E': 'profalar',
        '\u2336': 'topbot',
        '\u233D': 'ovbar',
        '\u233F': 'solbar',
        '\u237C': 'angzarr',
        '\u23B0': 'lmoust',
        '\u23B1': 'rmoust',
        '\u23B4': 'tbrk',
        '\u23B5': 'bbrk',
        '\u23B6': 'bbrktbrk',
        '\u23DC': 'OverParenthesis',
        '\u23DD': 'UnderParenthesis',
        '\u23DE': 'OverBrace',
        '\u23DF': 'UnderBrace',
        '\u23E2': 'trpezium',
        '\u23E7': 'elinters',
        '\u2423': 'blank',
        '\u2500': 'boxh',
        '\u2502': 'boxv',
        '\u250C': 'boxdr',
        '\u2510': 'boxdl',
        '\u2514': 'boxur',
        '\u2518': 'boxul',
        '\u251C': 'boxvr',
        '\u2524': 'boxvl',
        '\u252C': 'boxhd',
        '\u2534': 'boxhu',
        '\u253C': 'boxvh',
        '\u2550': 'boxH',
        '\u2551': 'boxV',
        '\u2552': 'boxdR',
        '\u2553': 'boxDr',
        '\u2554': 'boxDR',
        '\u2555': 'boxdL',
        '\u2556': 'boxDl',
        '\u2557': 'boxDL',
        '\u2558': 'boxuR',
        '\u2559': 'boxUr',
        '\u255A': 'boxUR',
        '\u255B': 'boxuL',
        '\u255C': 'boxUl',
        '\u255D': 'boxUL',
        '\u255E': 'boxvR',
        '\u255F': 'boxVr',
        '\u2560': 'boxVR',
        '\u2561': 'boxvL',
        '\u2562': 'boxVl',
        '\u2563': 'boxVL',
        '\u2564': 'boxHd',
        '\u2565': 'boxhD',
        '\u2566': 'boxHD',
        '\u2567': 'boxHu',
        '\u2568': 'boxhU',
        '\u2569': 'boxHU',
        '\u256A': 'boxvH',
        '\u256B': 'boxVh',
        '\u256C': 'boxVH',
        '\u2580': 'uhblk',
        '\u2584': 'lhblk',
        '\u2588': 'block',
        '\u2591': 'blk14',
        '\u2592': 'blk12',
        '\u2593': 'blk34',
        '\u25A1': 'squ',
        '\u25AA': 'squf',
        '\u25AB': 'EmptyVerySmallSquare',
        '\u25AD': 'rect',
        '\u25AE': 'marker',
        '\u25B1': 'fltns',
        '\u25B3': 'xutri',
        '\u25B4': 'utrif',
        '\u25B5': 'utri',
        '\u25B8': 'rtrif',
        '\u25B9': 'rtri',
        '\u25BD': 'xdtri',
        '\u25BE': 'dtrif',
        '\u25BF': 'dtri',
        '\u25C2': 'ltrif',
        '\u25C3': 'ltri',
        '\u25CA': 'loz',
        '\u25CB': 'cir',
        '\u25EC': 'tridot',
        '\u25EF': 'xcirc',
        '\u25F8': 'ultri',
        '\u25F9': 'urtri',
        '\u25FA': 'lltri',
        '\u25FB': 'EmptySmallSquare',
        '\u25FC': 'FilledSmallSquare',
        '\u2605': 'starf',
        '\u2606': 'star',
        '\u260E': 'phone',
        '\u2640': 'female',
        '\u2642': 'male',
        '\u2660': 'spades',
        '\u2663': 'clubs',
        '\u2665': 'hearts',
        '\u2666': 'diams',
        '\u266A': 'sung',
        '\u2713': 'check',
        '\u2717': 'cross',
        '\u2720': 'malt',
        '\u2736': 'sext',
        '\u2758': 'VerticalSeparator',
        '\u27C8': 'bsolhsub',
        '\u27C9': 'suphsol',
        '\u27F5': 'xlarr',
        '\u27F6': 'xrarr',
        '\u27F7': 'xharr',
        '\u27F8': 'xlArr',
        '\u27F9': 'xrArr',
        '\u27FA': 'xhArr',
        '\u27FC': 'xmap',
        '\u27FF': 'dzigrarr',
        '\u2902': 'nvlArr',
        '\u2903': 'nvrArr',
        '\u2904': 'nvHarr',
        '\u2905': 'Map',
        '\u290C': 'lbarr',
        '\u290D': 'rbarr',
        '\u290E': 'lBarr',
        '\u290F': 'rBarr',
        '\u2910': 'RBarr',
        '\u2911': 'DDotrahd',
        '\u2912': 'UpArrowBar',
        '\u2913': 'DownArrowBar',
        '\u2916': 'Rarrtl',
        '\u2919': 'latail',
        '\u291A': 'ratail',
        '\u291B': 'lAtail',
        '\u291C': 'rAtail',
        '\u291D': 'larrfs',
        '\u291E': 'rarrfs',
        '\u291F': 'larrbfs',
        '\u2920': 'rarrbfs',
        '\u2923': 'nwarhk',
        '\u2924': 'nearhk',
        '\u2925': 'searhk',
        '\u2926': 'swarhk',
        '\u2927': 'nwnear',
        '\u2928': 'toea',
        '\u2929': 'tosa',
        '\u292A': 'swnwar',
        '\u2933': 'rarrc',
        '\u2933̸': 'nrarrc',
        '\u2935': 'cudarrr',
        '\u2936': 'ldca',
        '\u2937': 'rdca',
        '\u2938': 'cudarrl',
        '\u2939': 'larrpl',
        '\u293C': 'curarrm',
        '\u293D': 'cularrp',
        '\u2945': 'rarrpl',
        '\u2948': 'harrcir',
        '\u2949': 'Uarrocir',
        '\u294A': 'lurdshar',
        '\u294B': 'ldrushar',
        '\u294E': 'LeftRightVector',
        '\u294F': 'RightUpDownVector',
        '\u2950': 'DownLeftRightVector',
        '\u2951': 'LeftUpDownVector',
        '\u2952': 'LeftVectorBar',
        '\u2953': 'RightVectorBar',
        '\u2954': 'RightUpVectorBar',
        '\u2955': 'RightDownVectorBar',
        '\u2956': 'DownLeftVectorBar',
        '\u2957': 'DownRightVectorBar',
        '\u2958': 'LeftUpVectorBar',
        '\u2959': 'LeftDownVectorBar',
        '\u295A': 'LeftTeeVector',
        '\u295B': 'RightTeeVector',
        '\u295C': 'RightUpTeeVector',
        '\u295D': 'RightDownTeeVector',
        '\u295E': 'DownLeftTeeVector',
        '\u295F': 'DownRightTeeVector',
        '\u2960': 'LeftUpTeeVector',
        '\u2961': 'LeftDownTeeVector',
        '\u2962': 'lHar',
        '\u2963': 'uHar',
        '\u2964': 'rHar',
        '\u2965': 'dHar',
        '\u2966': 'luruhar',
        '\u2967': 'ldrdhar',
        '\u2968': 'ruluhar',
        '\u2969': 'rdldhar',
        '\u296A': 'lharul',
        '\u296B': 'llhard',
        '\u296C': 'rharul',
        '\u296D': 'lrhard',
        '\u296E': 'udhar',
        '\u296F': 'duhar',
        '\u2970': 'RoundImplies',
        '\u2971': 'erarr',
        '\u2972': 'simrarr',
        '\u2973': 'larrsim',
        '\u2974': 'rarrsim',
        '\u2975': 'rarrap',
        '\u2976': 'ltlarr',
        '\u2978': 'gtrarr',
        '\u2979': 'subrarr',
        '\u297B': 'suplarr',
        '\u297C': 'lfisht',
        '\u297D': 'rfisht',
        '\u297E': 'ufisht',
        '\u297F': 'dfisht',
        '\u299A': 'vzigzag',
        '\u299C': 'vangrt',
        '\u299D': 'angrtvbd',
        '\u29A4': 'ange',
        '\u29A5': 'range',
        '\u29A6': 'dwangle',
        '\u29A7': 'uwangle',
        '\u29A8': 'angmsdaa',
        '\u29A9': 'angmsdab',
        '\u29AA': 'angmsdac',
        '\u29AB': 'angmsdad',
        '\u29AC': 'angmsdae',
        '\u29AD': 'angmsdaf',
        '\u29AE': 'angmsdag',
        '\u29AF': 'angmsdah',
        '\u29B0': 'bemptyv',
        '\u29B1': 'demptyv',
        '\u29B2': 'cemptyv',
        '\u29B3': 'raemptyv',
        '\u29B4': 'laemptyv',
        '\u29B5': 'ohbar',
        '\u29B6': 'omid',
        '\u29B7': 'opar',
        '\u29B9': 'operp',
        '\u29BB': 'olcross',
        '\u29BC': 'odsold',
        '\u29BE': 'olcir',
        '\u29BF': 'ofcir',
        '\u29C0': 'olt',
        '\u29C1': 'ogt',
        '\u29C2': 'cirscir',
        '\u29C3': 'cirE',
        '\u29C4': 'solb',
        '\u29C5': 'bsolb',
        '\u29C9': 'boxbox',
        '\u29CD': 'trisb',
        '\u29CE': 'rtriltri',
        '\u29CF': 'LeftTriangleBar',
        '\u29CF̸': 'NotLeftTriangleBar',
        '\u29D0': 'RightTriangleBar',
        '\u29D0̸': 'NotRightTriangleBar',
        '\u29DC': 'iinfin',
        '\u29DD': 'infintie',
        '\u29DE': 'nvinfin',
        '\u29E3': 'eparsl',
        '\u29E4': 'smeparsl',
        '\u29E5': 'eqvparsl',
        '\u29EB': 'lozf',
        '\u29F4': 'RuleDelayed',
        '\u29F6': 'dsol',
        '\u2A00': 'xodot',
        '\u2A01': 'xoplus',
        '\u2A02': 'xotime',
        '\u2A04': 'xuplus',
        '\u2A06': 'xsqcup',
        '\u2A0D': 'fpartint',
        '\u2A10': 'cirfnint',
        '\u2A11': 'awint',
        '\u2A12': 'rppolint',
        '\u2A13': 'scpolint',
        '\u2A14': 'npolint',
        '\u2A15': 'pointint',
        '\u2A16': 'quatint',
        '\u2A17': 'intlarhk',
        '\u2A22': 'pluscir',
        '\u2A23': 'plusacir',
        '\u2A24': 'simplus',
        '\u2A25': 'plusdu',
        '\u2A26': 'plussim',
        '\u2A27': 'plustwo',
        '\u2A29': 'mcomma',
        '\u2A2A': 'minusdu',
        '\u2A2D': 'loplus',
        '\u2A2E': 'roplus',
        '\u2A2F': 'Cross',
        '\u2A30': 'timesd',
        '\u2A31': 'timesbar',
        '\u2A33': 'smashp',
        '\u2A34': 'lotimes',
        '\u2A35': 'rotimes',
        '\u2A36': 'otimesas',
        '\u2A37': 'Otimes',
        '\u2A38': 'odiv',
        '\u2A39': 'triplus',
        '\u2A3A': 'triminus',
        '\u2A3B': 'tritime',
        '\u2A3C': 'iprod',
        '\u2A3F': 'amalg',
        '\u2A40': 'capdot',
        '\u2A42': 'ncup',
        '\u2A43': 'ncap',
        '\u2A44': 'capand',
        '\u2A45': 'cupor',
        '\u2A46': 'cupcap',
        '\u2A47': 'capcup',
        '\u2A48': 'cupbrcap',
        '\u2A49': 'capbrcup',
        '\u2A4A': 'cupcup',
        '\u2A4B': 'capcap',
        '\u2A4C': 'ccups',
        '\u2A4D': 'ccaps',
        '\u2A50': 'ccupssm',
        '\u2A53': 'And',
        '\u2A54': 'Or',
        '\u2A55': 'andand',
        '\u2A56': 'oror',
        '\u2A57': 'orslope',
        '\u2A58': 'andslope',
        '\u2A5A': 'andv',
        '\u2A5B': 'orv',
        '\u2A5C': 'andd',
        '\u2A5D': 'ord',
        '\u2A5F': 'wedbar',
        '\u2A66': 'sdote',
        '\u2A6A': 'simdot',
        '\u2A6D': 'congdot',
        '\u2A6D̸': 'ncongdot',
        '\u2A6E': 'easter',
        '\u2A6F': 'apacir',
        '\u2A70': 'apE',
        '\u2A70̸': 'napE',
        '\u2A71': 'eplus',
        '\u2A72': 'pluse',
        '\u2A73': 'Esim',
        '\u2A77': 'eDDot',
        '\u2A78': 'equivDD',
        '\u2A79': 'ltcir',
        '\u2A7A': 'gtcir',
        '\u2A7B': 'ltquest',
        '\u2A7C': 'gtquest',
        '\u2A7D': 'les',
        '\u2A7D̸': 'nles',
        '\u2A7E': 'ges',
        '\u2A7E̸': 'nges',
        '\u2A7F': 'lesdot',
        '\u2A80': 'gesdot',
        '\u2A81': 'lesdoto',
        '\u2A82': 'gesdoto',
        '\u2A83': 'lesdotor',
        '\u2A84': 'gesdotol',
        '\u2A85': 'lap',
        '\u2A86': 'gap',
        '\u2A87': 'lne',
        '\u2A88': 'gne',
        '\u2A89': 'lnap',
        '\u2A8A': 'gnap',
        '\u2A8B': 'lEg',
        '\u2A8C': 'gEl',
        '\u2A8D': 'lsime',
        '\u2A8E': 'gsime',
        '\u2A8F': 'lsimg',
        '\u2A90': 'gsiml',
        '\u2A91': 'lgE',
        '\u2A92': 'glE',
        '\u2A93': 'lesges',
        '\u2A94': 'gesles',
        '\u2A95': 'els',
        '\u2A96': 'egs',
        '\u2A97': 'elsdot',
        '\u2A98': 'egsdot',
        '\u2A99': 'el',
        '\u2A9A': 'eg',
        '\u2A9D': 'siml',
        '\u2A9E': 'simg',
        '\u2A9F': 'simlE',
        '\u2AA0': 'simgE',
        '\u2AA1': 'LessLess',
        '\u2AA1̸': 'NotNestedLessLess',
        '\u2AA2': 'GreaterGreater',
        '\u2AA2̸': 'NotNestedGreaterGreater',
        '\u2AA4': 'glj',
        '\u2AA5': 'gla',
        '\u2AA6': 'ltcc',
        '\u2AA7': 'gtcc',
        '\u2AA8': 'lescc',
        '\u2AA9': 'gescc',
        '\u2AAA': 'smt',
        '\u2AAB': 'lat',
        '\u2AAC': 'smte',
        '\u2AAC︀': 'smtes',
        '\u2AAD': 'late',
        '\u2AAD︀': 'lates',
        '\u2AAE': 'bumpE',
        '\u2AAF': 'pre',
        '\u2AAF̸': 'npre',
        '\u2AB0': 'sce',
        '\u2AB0̸': 'nsce',
        '\u2AB3': 'prE',
        '\u2AB4': 'scE',
        '\u2AB5': 'prnE',
        '\u2AB6': 'scnE',
        '\u2AB7': 'prap',
        '\u2AB8': 'scap',
        '\u2AB9': 'prnap',
        '\u2ABA': 'scnap',
        '\u2ABB': 'Pr',
        '\u2ABC': 'Sc',
        '\u2ABD': 'subdot',
        '\u2ABE': 'supdot',
        '\u2ABF': 'subplus',
        '\u2AC0': 'supplus',
        '\u2AC1': 'submult',
        '\u2AC2': 'supmult',
        '\u2AC3': 'subedot',
        '\u2AC4': 'supedot',
        '\u2AC5': 'subE',
        '\u2AC5̸': 'nsubE',
        '\u2AC6': 'supE',
        '\u2AC6̸': 'nsupE',
        '\u2AC7': 'subsim',
        '\u2AC8': 'supsim',
        '\u2ACB︀': 'vsubnE',
        '\u2ACB': 'subnE',
        '\u2ACC︀': 'vsupnE',
        '\u2ACC': 'supnE',
        '\u2ACF': 'csub',
        '\u2AD0': 'csup',
        '\u2AD1': 'csube',
        '\u2AD2': 'csupe',
        '\u2AD3': 'subsup',
        '\u2AD4': 'supsub',
        '\u2AD5': 'subsub',
        '\u2AD6': 'supsup',
        '\u2AD7': 'suphsub',
        '\u2AD8': 'supdsub',
        '\u2AD9': 'forkv',
        '\u2ADA': 'topfork',
        '\u2ADB': 'mlcp',
        '\u2AE4': 'Dashv',
        '\u2AE6': 'Vdashl',
        '\u2AE7': 'Barv',
        '\u2AE8': 'vBar',
        '\u2AE9': 'vBarv',
        '\u2AEB': 'Vbar',
        '\u2AEC': 'Not',
        '\u2AED': 'bNot',
        '\u2AEE': 'rnmid',
        '\u2AEF': 'cirmid',
        '\u2AF0': 'midcir',
        '\u2AF1': 'topcir',
        '\u2AF2': 'nhpar',
        '\u2AF3': 'parsim',
        '\u2AFD': 'parsl',
        '\u2AFD⃥': 'nparsl',
        '\u266D': 'flat',
        '\u266E': 'natur',
        '\u266F': 'sharp',
        '\xA4': 'curren',
        '\xA2': 'cent',
        '$': 'dollar',
        '\xA3': 'pound',
        '\xA5': 'yen',
        '\u20AC': 'euro',
        '\xB9': 'sup1',
        '\xBD': 'half',
        '\u2153': 'frac13',
        '\xBC': 'frac14',
        '\u2155': 'frac15',
        '\u2159': 'frac16',
        '\u215B': 'frac18',
        '\xB2': 'sup2',
        '\u2154': 'frac23',
        '\u2156': 'frac25',
        '\xB3': 'sup3',
        '\xBE': 'frac34',
        '\u2157': 'frac35',
        '\u215C': 'frac38',
        '\u2158': 'frac45',
        '\u215A': 'frac56',
        '\u215D': 'frac58',
        '\u215E': 'frac78',
        '\uD835\uDCB6': 'ascr',
        '\uD835\uDD52': 'aopf',
        '\uD835\uDD1E': 'afr',
        '\uD835\uDD38': 'Aopf',
        '\uD835\uDD04': 'Afr',
        '\uD835\uDC9C': 'Ascr',
        'ª': 'ordf',
        'á': 'aacute',
        'Á': 'Aacute',
        'à': 'agrave',
        'À': 'Agrave',
        'ă': 'abreve',
        'Ă': 'Abreve',
        'â': 'acirc',
        'Â': 'Acirc',
        'å': 'aring',
        'Å': 'angst',
        'ä': 'auml',
        'Ä': 'Auml',
        'ã': 'atilde',
        'Ã': 'Atilde',
        'ą': 'aogon',
        'Ą': 'Aogon',
        'ā': 'amacr',
        'Ā': 'Amacr',
        'æ': 'aelig',
        'Æ': 'AElig',
        '\uD835\uDCB7': 'bscr',
        '\uD835\uDD53': 'bopf',
        '\uD835\uDD1F': 'bfr',
        '\uD835\uDD39': 'Bopf',
        'ℬ': 'Bscr',
        '\uD835\uDD05': 'Bfr',
        '\uD835\uDD20': 'cfr',
        '\uD835\uDCB8': 'cscr',
        '\uD835\uDD54': 'copf',
        'ℭ': 'Cfr',
        '\uD835\uDC9E': 'Cscr',
        'ℂ': 'Copf',
        'ć': 'cacute',
        'Ć': 'Cacute',
        'ĉ': 'ccirc',
        'Ĉ': 'Ccirc',
        'č': 'ccaron',
        'Č': 'Ccaron',
        'ċ': 'cdot',
        'Ċ': 'Cdot',
        'ç': 'ccedil',
        'Ç': 'Ccedil',
        '\u2105': 'incare',
        '\uD835\uDD21': 'dfr',
        'ⅆ': 'dd',
        '\uD835\uDD55': 'dopf',
        '\uD835\uDCB9': 'dscr',
        '\uD835\uDC9F': 'Dscr',
        '\uD835\uDD07': 'Dfr',
        'ⅅ': 'DD',
        '\uD835\uDD3B': 'Dopf',
        'ď': 'dcaron',
        'Ď': 'Dcaron',
        'đ': 'dstrok',
        'Đ': 'Dstrok',
        'ð': 'eth',
        'Ð': 'ETH',
        'ⅇ': 'ee',
        'ℯ': 'escr',
        '\uD835\uDD22': 'efr',
        '\uD835\uDD56': 'eopf',
        'ℰ': 'Escr',
        '\uD835\uDD08': 'Efr',
        '\uD835\uDD3C': 'Eopf',
        'é': 'eacute',
        'É': 'Eacute',
        'è': 'egrave',
        'È': 'Egrave',
        'ê': 'ecirc',
        'Ê': 'Ecirc',
        'ě': 'ecaron',
        'Ě': 'Ecaron',
        'ë': 'euml',
        'Ë': 'Euml',
        'ė': 'edot',
        'Ė': 'Edot',
        'ę': 'eogon',
        'Ę': 'Eogon',
        'ē': 'emacr',
        'Ē': 'Emacr',
        '\uD835\uDD23': 'ffr',
        '\uD835\uDD57': 'fopf',
        '\uD835\uDCBB': 'fscr',
        '\uD835\uDD09': 'Ffr',
        '\uD835\uDD3D': 'Fopf',
        'ℱ': 'Fscr',
        'ﬀ': 'fflig',
        'ﬃ': 'ffilig',
        'ﬄ': 'ffllig',
        'ﬁ': 'filig',
        'fj': 'fjlig',
        'ﬂ': 'fllig',
        'ƒ': 'fnof',
        'ℊ': 'gscr',
        '\uD835\uDD58': 'gopf',
        '\uD835\uDD24': 'gfr',
        '\uD835\uDCA2': 'Gscr',
        '\uD835\uDD3E': 'Gopf',
        '\uD835\uDD0A': 'Gfr',
        'ǵ': 'gacute',
        'ğ': 'gbreve',
        'Ğ': 'Gbreve',
        'ĝ': 'gcirc',
        'Ĝ': 'Gcirc',
        'ġ': 'gdot',
        'Ġ': 'Gdot',
        'Ģ': 'Gcedil',
        '\uD835\uDD25': 'hfr',
        'ℎ': 'planckh',
        '\uD835\uDCBD': 'hscr',
        '\uD835\uDD59': 'hopf',
        'ℋ': 'Hscr',
        'ℌ': 'Hfr',
        'ℍ': 'Hopf',
        'ĥ': 'hcirc',
        'Ĥ': 'Hcirc',
        'ℏ': 'hbar',
        'ħ': 'hstrok',
        'Ħ': 'Hstrok',
        '\uD835\uDD5A': 'iopf',
        '\uD835\uDD26': 'ifr',
        '\uD835\uDCBE': 'iscr',
        'ⅈ': 'ii',
        '\uD835\uDD40': 'Iopf',
        'ℐ': 'Iscr',
        'ℑ': 'Im',
        'í': 'iacute',
        'Í': 'Iacute',
        'ì': 'igrave',
        'Ì': 'Igrave',
        'î': 'icirc',
        'Î': 'Icirc',
        'ï': 'iuml',
        'Ï': 'Iuml',
        'ĩ': 'itilde',
        'Ĩ': 'Itilde',
        'İ': 'Idot',
        'į': 'iogon',
        'Į': 'Iogon',
        'ī': 'imacr',
        'Ī': 'Imacr',
        'ĳ': 'ijlig',
        'Ĳ': 'IJlig',
        'ı': 'imath',
        '\uD835\uDCBF': 'jscr',
        '\uD835\uDD5B': 'jopf',
        '\uD835\uDD27': 'jfr',
        '\uD835\uDCA5': 'Jscr',
        '\uD835\uDD0D': 'Jfr',
        '\uD835\uDD41': 'Jopf',
        'ĵ': 'jcirc',
        'Ĵ': 'Jcirc',
        'ȷ': 'jmath',
        '\uD835\uDD5C': 'kopf',
        '\uD835\uDCC0': 'kscr',
        '\uD835\uDD28': 'kfr',
        '\uD835\uDCA6': 'Kscr',
        '\uD835\uDD42': 'Kopf',
        '\uD835\uDD0E': 'Kfr',
        'ķ': 'kcedil',
        'Ķ': 'Kcedil',
        '\uD835\uDD29': 'lfr',
        '\uD835\uDCC1': 'lscr',
        'ℓ': 'ell',
        '\uD835\uDD5D': 'lopf',
        'ℒ': 'Lscr',
        '\uD835\uDD0F': 'Lfr',
        '\uD835\uDD43': 'Lopf',
        'ĺ': 'lacute',
        'Ĺ': 'Lacute',
        'ľ': 'lcaron',
        'Ľ': 'Lcaron',
        'ļ': 'lcedil',
        'Ļ': 'Lcedil',
        'ł': 'lstrok',
        'Ł': 'Lstrok',
        'ŀ': 'lmidot',
        'Ŀ': 'Lmidot',
        '\uD835\uDD2A': 'mfr',
        '\uD835\uDD5E': 'mopf',
        '\uD835\uDCC2': 'mscr',
        '\uD835\uDD10': 'Mfr',
        '\uD835\uDD44': 'Mopf',
        'ℳ': 'Mscr',
        '\uD835\uDD2B': 'nfr',
        '\uD835\uDD5F': 'nopf',
        '\uD835\uDCC3': 'nscr',
        'ℕ': 'Nopf',
        '\uD835\uDCA9': 'Nscr',
        '\uD835\uDD11': 'Nfr',
        'ń': 'nacute',
        'Ń': 'Nacute',
        'ň': 'ncaron',
        'Ň': 'Ncaron',
        'ñ': 'ntilde',
        'Ñ': 'Ntilde',
        'ņ': 'ncedil',
        'Ņ': 'Ncedil',
        '\u2116': 'numero',
        'ŋ': 'eng',
        'Ŋ': 'ENG',
        '\uD835\uDD60': 'oopf',
        '\uD835\uDD2C': 'ofr',
        'ℴ': 'oscr',
        '\uD835\uDCAA': 'Oscr',
        '\uD835\uDD12': 'Ofr',
        '\uD835\uDD46': 'Oopf',
        'º': 'ordm',
        'ó': 'oacute',
        'Ó': 'Oacute',
        'ò': 'ograve',
        'Ò': 'Ograve',
        'ô': 'ocirc',
        'Ô': 'Ocirc',
        'ö': 'ouml',
        'Ö': 'Ouml',
        'ő': 'odblac',
        'Ő': 'Odblac',
        'õ': 'otilde',
        'Õ': 'Otilde',
        'ø': 'oslash',
        'Ø': 'Oslash',
        'ō': 'omacr',
        'Ō': 'Omacr',
        'œ': 'oelig',
        'Œ': 'OElig',
        '\uD835\uDD2D': 'pfr',
        '\uD835\uDCC5': 'pscr',
        '\uD835\uDD61': 'popf',
        'ℙ': 'Popf',
        '\uD835\uDD13': 'Pfr',
        '\uD835\uDCAB': 'Pscr',
        '\uD835\uDD62': 'qopf',
        '\uD835\uDD2E': 'qfr',
        '\uD835\uDCC6': 'qscr',
        '\uD835\uDCAC': 'Qscr',
        '\uD835\uDD14': 'Qfr',
        'ℚ': 'Qopf',
        'ĸ': 'kgreen',
        '\uD835\uDD2F': 'rfr',
        '\uD835\uDD63': 'ropf',
        '\uD835\uDCC7': 'rscr',
        'ℛ': 'Rscr',
        'ℜ': 'Re',
        'ℝ': 'Ropf',
        'ŕ': 'racute',
        'Ŕ': 'Racute',
        'ř': 'rcaron',
        'Ř': 'Rcaron',
        'ŗ': 'rcedil',
        'Ŗ': 'Rcedil',
        '\uD835\uDD64': 'sopf',
        '\uD835\uDCC8': 'sscr',
        '\uD835\uDD30': 'sfr',
        '\uD835\uDD4A': 'Sopf',
        '\uD835\uDD16': 'Sfr',
        '\uD835\uDCAE': 'Sscr',
        '\u24C8': 'oS',
        'ś': 'sacute',
        'Ś': 'Sacute',
        'ŝ': 'scirc',
        'Ŝ': 'Scirc',
        'š': 'scaron',
        'Š': 'Scaron',
        'ş': 'scedil',
        'Ş': 'Scedil',
        'ß': 'szlig',
        '\uD835\uDD31': 'tfr',
        '\uD835\uDCC9': 'tscr',
        '\uD835\uDD65': 'topf',
        '\uD835\uDCAF': 'Tscr',
        '\uD835\uDD17': 'Tfr',
        '\uD835\uDD4B': 'Topf',
        'ť': 'tcaron',
        'Ť': 'Tcaron',
        'ţ': 'tcedil',
        'Ţ': 'Tcedil',
        '\u2122': 'trade',
        'ŧ': 'tstrok',
        'Ŧ': 'Tstrok',
        '\uD835\uDCCA': 'uscr',
        '\uD835\uDD66': 'uopf',
        '\uD835\uDD32': 'ufr',
        '\uD835\uDD4C': 'Uopf',
        '\uD835\uDD18': 'Ufr',
        '\uD835\uDCB0': 'Uscr',
        'ú': 'uacute',
        'Ú': 'Uacute',
        'ù': 'ugrave',
        'Ù': 'Ugrave',
        'ŭ': 'ubreve',
        'Ŭ': 'Ubreve',
        'û': 'ucirc',
        'Û': 'Ucirc',
        'ů': 'uring',
        'Ů': 'Uring',
        'ü': 'uuml',
        'Ü': 'Uuml',
        'ű': 'udblac',
        'Ű': 'Udblac',
        'ũ': 'utilde',
        'Ũ': 'Utilde',
        'ų': 'uogon',
        'Ų': 'Uogon',
        'ū': 'umacr',
        'Ū': 'Umacr',
        '\uD835\uDD33': 'vfr',
        '\uD835\uDD67': 'vopf',
        '\uD835\uDCCB': 'vscr',
        '\uD835\uDD19': 'Vfr',
        '\uD835\uDD4D': 'Vopf',
        '\uD835\uDCB1': 'Vscr',
        '\uD835\uDD68': 'wopf',
        '\uD835\uDCCC': 'wscr',
        '\uD835\uDD34': 'wfr',
        '\uD835\uDCB2': 'Wscr',
        '\uD835\uDD4E': 'Wopf',
        '\uD835\uDD1A': 'Wfr',
        'ŵ': 'wcirc',
        'Ŵ': 'Wcirc',
        '\uD835\uDD35': 'xfr',
        '\uD835\uDCCD': 'xscr',
        '\uD835\uDD69': 'xopf',
        '\uD835\uDD4F': 'Xopf',
        '\uD835\uDD1B': 'Xfr',
        '\uD835\uDCB3': 'Xscr',
        '\uD835\uDD36': 'yfr',
        '\uD835\uDCCE': 'yscr',
        '\uD835\uDD6A': 'yopf',
        '\uD835\uDCB4': 'Yscr',
        '\uD835\uDD1C': 'Yfr',
        '\uD835\uDD50': 'Yopf',
        'ý': 'yacute',
        'Ý': 'Yacute',
        'ŷ': 'ycirc',
        'Ŷ': 'Ycirc',
        'ÿ': 'yuml',
        'Ÿ': 'Yuml',
        '\uD835\uDCCF': 'zscr',
        '\uD835\uDD37': 'zfr',
        '\uD835\uDD6B': 'zopf',
        'ℨ': 'Zfr',
        'ℤ': 'Zopf',
        '\uD835\uDCB5': 'Zscr',
        'ź': 'zacute',
        'Ź': 'Zacute',
        'ž': 'zcaron',
        'Ž': 'Zcaron',
        'ż': 'zdot',
        'Ż': 'Zdot',
        'Ƶ': 'imped',
        'þ': 'thorn',
        'Þ': 'THORN',
        'ŉ': 'napos',
        'α': 'alpha',
        'Α': 'Alpha',
        'β': 'beta',
        'Β': 'Beta',
        'γ': 'gamma',
        'Γ': 'Gamma',
        'δ': 'delta',
        'Δ': 'Delta',
        'ε': 'epsi',
        'ϵ': 'epsiv',
        'Ε': 'Epsilon',
        'ϝ': 'gammad',
        'Ϝ': 'Gammad',
        'ζ': 'zeta',
        'Ζ': 'Zeta',
        'η': 'eta',
        'Η': 'Eta',
        'θ': 'theta',
        'ϑ': 'thetav',
        'Θ': 'Theta',
        'ι': 'iota',
        'Ι': 'Iota',
        'κ': 'kappa',
        'ϰ': 'kappav',
        'Κ': 'Kappa',
        'λ': 'lambda',
        'Λ': 'Lambda',
        'μ': 'mu',
        'µ': 'micro',
        'Μ': 'Mu',
        'ν': 'nu',
        'Ν': 'Nu',
        'ξ': 'xi',
        'Ξ': 'Xi',
        'ο': 'omicron',
        'Ο': 'Omicron',
        'π': 'pi',
        'ϖ': 'piv',
        'Π': 'Pi',
        'ρ': 'rho',
        'ϱ': 'rhov',
        'Ρ': 'Rho',
        'σ': 'sigma',
        'Σ': 'Sigma',
        'ς': 'sigmaf',
        'τ': 'tau',
        'Τ': 'Tau',
        'υ': 'upsi',
        'Υ': 'Upsilon',
        'ϒ': 'Upsi',
        'φ': 'phi',
        'ϕ': 'phiv',
        'Φ': 'Phi',
        'χ': 'chi',
        'Χ': 'Chi',
        'ψ': 'psi',
        'Ψ': 'Psi',
        'ω': 'omega',
        'Ω': 'ohm',
        'а': 'acy',
        'А': 'Acy',
        'б': 'bcy',
        'Б': 'Bcy',
        'в': 'vcy',
        'В': 'Vcy',
        'г': 'gcy',
        'Г': 'Gcy',
        'ѓ': 'gjcy',
        'Ѓ': 'GJcy',
        'д': 'dcy',
        'Д': 'Dcy',
        'ђ': 'djcy',
        'Ђ': 'DJcy',
        'е': 'iecy',
        'Е': 'IEcy',
        'ё': 'iocy',
        'Ё': 'IOcy',
        'є': 'jukcy',
        'Є': 'Jukcy',
        'ж': 'zhcy',
        'Ж': 'ZHcy',
        'з': 'zcy',
        'З': 'Zcy',
        'ѕ': 'dscy',
        'Ѕ': 'DScy',
        'и': 'icy',
        'И': 'Icy',
        'і': 'iukcy',
        'І': 'Iukcy',
        'ї': 'yicy',
        'Ї': 'YIcy',
        'й': 'jcy',
        'Й': 'Jcy',
        'ј': 'jsercy',
        'Ј': 'Jsercy',
        'к': 'kcy',
        'К': 'Kcy',
        'ќ': 'kjcy',
        'Ќ': 'KJcy',
        'л': 'lcy',
        'Л': 'Lcy',
        'љ': 'ljcy',
        'Љ': 'LJcy',
        'м': 'mcy',
        'М': 'Mcy',
        'н': 'ncy',
        'Н': 'Ncy',
        'њ': 'njcy',
        'Њ': 'NJcy',
        'о': 'ocy',
        'О': 'Ocy',
        'п': 'pcy',
        'П': 'Pcy',
        'р': 'rcy',
        'Р': 'Rcy',
        'с': 'scy',
        'С': 'Scy',
        'т': 'tcy',
        'Т': 'Tcy',
        'ћ': 'tshcy',
        'Ћ': 'TSHcy',
        'у': 'ucy',
        'У': 'Ucy',
        'ў': 'ubrcy',
        'Ў': 'Ubrcy',
        'ф': 'fcy',
        'Ф': 'Fcy',
        'х': 'khcy',
        'Х': 'KHcy',
        'ц': 'tscy',
        'Ц': 'TScy',
        'ч': 'chcy',
        'Ч': 'CHcy',
        'џ': 'dzcy',
        'Џ': 'DZcy',
        'ш': 'shcy',
        'Ш': 'SHcy',
        'щ': 'shchcy',
        'Щ': 'SHCHcy',
        'ъ': 'hardcy',
        'Ъ': 'HARDcy',
        'ы': 'ycy',
        'Ы': 'Ycy',
        'ь': 'softcy',
        'Ь': 'SOFTcy',
        'э': 'ecy',
        'Э': 'Ecy',
        'ю': 'yucy',
        'Ю': 'YUcy',
        'я': 'yacy',
        'Я': 'YAcy',
        'ℵ': 'aleph',
        'ℶ': 'beth',
        'ℷ': 'gimel',
        'ℸ': 'daleth'
    };
    var regexEscape = /["&'<>`]/g;
    var escapeMap = {
        '"': '&quot;',
        '&': '&amp;',
        '\'': '&#x27;',
        '<': '&lt;',
        '>': '&gt;',
        '`': '&#x60;'
    };
    var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
    var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;
    var decodeMap = {
        'aacute': 'á',
        'Aacute': 'Á',
        'abreve': 'ă',
        'Abreve': 'Ă',
        'ac': '\u223E',
        'acd': '\u223F',
        'acE': '\u223E̳',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'acy': 'а',
        'Acy': 'А',
        'aelig': 'æ',
        'AElig': 'Æ',
        'af': '\u2061',
        'afr': '\uD835\uDD1E',
        'Afr': '\uD835\uDD04',
        'agrave': 'à',
        'Agrave': 'À',
        'alefsym': 'ℵ',
        'aleph': 'ℵ',
        'alpha': 'α',
        'Alpha': 'Α',
        'amacr': 'ā',
        'Amacr': 'Ā',
        'amalg': '\u2A3F',
        'amp': '&',
        'AMP': '&',
        'and': '\u2227',
        'And': '\u2A53',
        'andand': '\u2A55',
        'andd': '\u2A5C',
        'andslope': '\u2A58',
        'andv': '\u2A5A',
        'ang': '\u2220',
        'ange': '\u29A4',
        'angle': '\u2220',
        'angmsd': '\u2221',
        'angmsdaa': '\u29A8',
        'angmsdab': '\u29A9',
        'angmsdac': '\u29AA',
        'angmsdad': '\u29AB',
        'angmsdae': '\u29AC',
        'angmsdaf': '\u29AD',
        'angmsdag': '\u29AE',
        'angmsdah': '\u29AF',
        'angrt': '\u221F',
        'angrtvb': '\u22BE',
        'angrtvbd': '\u299D',
        'angsph': '\u2222',
        'angst': 'Å',
        'angzarr': '\u237C',
        'aogon': 'ą',
        'Aogon': 'Ą',
        'aopf': '\uD835\uDD52',
        'Aopf': '\uD835\uDD38',
        'ap': '\u2248',
        'apacir': '\u2A6F',
        'ape': '\u224A',
        'apE': '\u2A70',
        'apid': '\u224B',
        'apos': '\'',
        'ApplyFunction': '\u2061',
        'approx': '\u2248',
        'approxeq': '\u224A',
        'aring': 'å',
        'Aring': 'Å',
        'ascr': '\uD835\uDCB6',
        'Ascr': '\uD835\uDC9C',
        'Assign': '\u2254',
        'ast': '*',
        'asymp': '\u2248',
        'asympeq': '\u224D',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'awconint': '\u2233',
        'awint': '\u2A11',
        'backcong': '\u224C',
        'backepsilon': '\u03F6',
        'backprime': '\u2035',
        'backsim': '\u223D',
        'backsimeq': '\u22CD',
        'Backslash': '\u2216',
        'Barv': '\u2AE7',
        'barvee': '\u22BD',
        'barwed': '\u2305',
        'Barwed': '\u2306',
        'barwedge': '\u2305',
        'bbrk': '\u23B5',
        'bbrktbrk': '\u23B6',
        'bcong': '\u224C',
        'bcy': 'б',
        'Bcy': 'Б',
        'bdquo': '\u201E',
        'becaus': '\u2235',
        'because': '\u2235',
        'Because': '\u2235',
        'bemptyv': '\u29B0',
        'bepsi': '\u03F6',
        'bernou': 'ℬ',
        'Bernoullis': 'ℬ',
        'beta': 'β',
        'Beta': 'Β',
        'beth': 'ℶ',
        'between': '\u226C',
        'bfr': '\uD835\uDD1F',
        'Bfr': '\uD835\uDD05',
        'bigcap': '\u22C2',
        'bigcirc': '\u25EF',
        'bigcup': '\u22C3',
        'bigodot': '\u2A00',
        'bigoplus': '\u2A01',
        'bigotimes': '\u2A02',
        'bigsqcup': '\u2A06',
        'bigstar': '\u2605',
        'bigtriangledown': '\u25BD',
        'bigtriangleup': '\u25B3',
        'biguplus': '\u2A04',
        'bigvee': '\u22C1',
        'bigwedge': '\u22C0',
        'bkarow': '\u290D',
        'blacklozenge': '\u29EB',
        'blacksquare': '\u25AA',
        'blacktriangle': '\u25B4',
        'blacktriangledown': '\u25BE',
        'blacktriangleleft': '\u25C2',
        'blacktriangleright': '\u25B8',
        'blank': '\u2423',
        'blk12': '\u2592',
        'blk14': '\u2591',
        'blk34': '\u2593',
        'block': '\u2588',
        'bne': '=⃥',
        'bnequiv': '\u2261⃥',
        'bnot': '\u2310',
        'bNot': '\u2AED',
        'bopf': '\uD835\uDD53',
        'Bopf': '\uD835\uDD39',
        'bot': '\u22A5',
        'bottom': '\u22A5',
        'bowtie': '\u22C8',
        'boxbox': '\u29C9',
        'boxdl': '\u2510',
        'boxdL': '\u2555',
        'boxDl': '\u2556',
        'boxDL': '\u2557',
        'boxdr': '\u250C',
        'boxdR': '\u2552',
        'boxDr': '\u2553',
        'boxDR': '\u2554',
        'boxh': '\u2500',
        'boxH': '\u2550',
        'boxhd': '\u252C',
        'boxhD': '\u2565',
        'boxHd': '\u2564',
        'boxHD': '\u2566',
        'boxhu': '\u2534',
        'boxhU': '\u2568',
        'boxHu': '\u2567',
        'boxHU': '\u2569',
        'boxminus': '\u229F',
        'boxplus': '\u229E',
        'boxtimes': '\u22A0',
        'boxul': '\u2518',
        'boxuL': '\u255B',
        'boxUl': '\u255C',
        'boxUL': '\u255D',
        'boxur': '\u2514',
        'boxuR': '\u2558',
        'boxUr': '\u2559',
        'boxUR': '\u255A',
        'boxv': '\u2502',
        'boxV': '\u2551',
        'boxvh': '\u253C',
        'boxvH': '\u256A',
        'boxVh': '\u256B',
        'boxVH': '\u256C',
        'boxvl': '\u2524',
        'boxvL': '\u2561',
        'boxVl': '\u2562',
        'boxVL': '\u2563',
        'boxvr': '\u251C',
        'boxvR': '\u255E',
        'boxVr': '\u255F',
        'boxVR': '\u2560',
        'bprime': '\u2035',
        'breve': '\u02D8',
        'Breve': '\u02D8',
        'brvbar': '\xA6',
        'bscr': '\uD835\uDCB7',
        'Bscr': 'ℬ',
        'bsemi': '\u204F',
        'bsim': '\u223D',
        'bsime': '\u22CD',
        'bsol': '\\',
        'bsolb': '\u29C5',
        'bsolhsub': '\u27C8',
        'bull': '\u2022',
        'bullet': '\u2022',
        'bump': '\u224E',
        'bumpe': '\u224F',
        'bumpE': '\u2AAE',
        'bumpeq': '\u224F',
        'Bumpeq': '\u224E',
        'cacute': 'ć',
        'Cacute': 'Ć',
        'cap': '\u2229',
        'Cap': '\u22D2',
        'capand': '\u2A44',
        'capbrcup': '\u2A49',
        'capcap': '\u2A4B',
        'capcup': '\u2A47',
        'capdot': '\u2A40',
        'CapitalDifferentialD': 'ⅅ',
        'caps': '\u2229︀',
        'caret': '\u2041',
        'caron': 'ˇ',
        'Cayleys': 'ℭ',
        'ccaps': '\u2A4D',
        'ccaron': 'č',
        'Ccaron': 'Č',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'ccirc': 'ĉ',
        'Ccirc': 'Ĉ',
        'Cconint': '\u2230',
        'ccups': '\u2A4C',
        'ccupssm': '\u2A50',
        'cdot': 'ċ',
        'Cdot': 'Ċ',
        'cedil': '\xB8',
        'Cedilla': '\xB8',
        'cemptyv': '\u29B2',
        'cent': '\xA2',
        'centerdot': '\xB7',
        'CenterDot': '\xB7',
        'cfr': '\uD835\uDD20',
        'Cfr': 'ℭ',
        'chcy': 'ч',
        'CHcy': 'Ч',
        'check': '\u2713',
        'checkmark': '\u2713',
        'chi': 'χ',
        'Chi': 'Χ',
        'cir': '\u25CB',
        'circ': 'ˆ',
        'circeq': '\u2257',
        'circlearrowleft': '\u21BA',
        'circlearrowright': '\u21BB',
        'circledast': '\u229B',
        'circledcirc': '\u229A',
        'circleddash': '\u229D',
        'CircleDot': '\u2299',
        'circledR': '\xAE',
        'circledS': '\u24C8',
        'CircleMinus': '\u2296',
        'CirclePlus': '\u2295',
        'CircleTimes': '\u2297',
        'cire': '\u2257',
        'cirE': '\u29C3',
        'cirfnint': '\u2A10',
        'cirmid': '\u2AEF',
        'cirscir': '\u29C2',
        'ClockwiseContourIntegral': '\u2232',
        'CloseCurlyDoubleQuote': '\u201D',
        'CloseCurlyQuote': '\u2019',
        'clubs': '\u2663',
        'clubsuit': '\u2663',
        'colon': ':',
        'Colon': '\u2237',
        'colone': '\u2254',
        'Colone': '\u2A74',
        'coloneq': '\u2254',
        'comma': ',',
        'commat': '@',
        'comp': '\u2201',
        'compfn': '\u2218',
        'complement': '\u2201',
        'complexes': 'ℂ',
        'cong': '\u2245',
        'congdot': '\u2A6D',
        'Congruent': '\u2261',
        'conint': '\u222E',
        'Conint': '\u222F',
        'ContourIntegral': '\u222E',
        'copf': '\uD835\uDD54',
        'Copf': 'ℂ',
        'coprod': '\u2210',
        'Coproduct': '\u2210',
        'copy': '\xA9',
        'COPY': '\xA9',
        'copysr': '\u2117',
        'CounterClockwiseContourIntegral': '\u2233',
        'crarr': '\u21B5',
        'cross': '\u2717',
        'Cross': '\u2A2F',
        'cscr': '\uD835\uDCB8',
        'Cscr': '\uD835\uDC9E',
        'csub': '\u2ACF',
        'csube': '\u2AD1',
        'csup': '\u2AD0',
        'csupe': '\u2AD2',
        'ctdot': '\u22EF',
        'cudarrl': '\u2938',
        'cudarrr': '\u2935',
        'cuepr': '\u22DE',
        'cuesc': '\u22DF',
        'cularr': '\u21B6',
        'cularrp': '\u293D',
        'cup': '\u222A',
        'Cup': '\u22D3',
        'cupbrcap': '\u2A48',
        'cupcap': '\u2A46',
        'CupCap': '\u224D',
        'cupcup': '\u2A4A',
        'cupdot': '\u228D',
        'cupor': '\u2A45',
        'cups': '\u222A︀',
        'curarr': '\u21B7',
        'curarrm': '\u293C',
        'curlyeqprec': '\u22DE',
        'curlyeqsucc': '\u22DF',
        'curlyvee': '\u22CE',
        'curlywedge': '\u22CF',
        'curren': '\xA4',
        'curvearrowleft': '\u21B6',
        'curvearrowright': '\u21B7',
        'cuvee': '\u22CE',
        'cuwed': '\u22CF',
        'cwconint': '\u2232',
        'cwint': '\u2231',
        'cylcty': '\u232D',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'daleth': 'ℸ',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'Darr': '\u21A1',
        'dash': '\u2010',
        'dashv': '\u22A3',
        'Dashv': '\u2AE4',
        'dbkarow': '\u290F',
        'dblac': '\u02DD',
        'dcaron': 'ď',
        'Dcaron': 'Ď',
        'dcy': 'д',
        'Dcy': 'Д',
        'dd': 'ⅆ',
        'DD': 'ⅅ',
        'ddagger': '\u2021',
        'ddarr': '\u21CA',
        'DDotrahd': '\u2911',
        'ddotseq': '\u2A77',
        'deg': '\xB0',
        'Del': '\u2207',
        'delta': 'δ',
        'Delta': 'Δ',
        'demptyv': '\u29B1',
        'dfisht': '\u297F',
        'dfr': '\uD835\uDD21',
        'Dfr': '\uD835\uDD07',
        'dHar': '\u2965',
        'dharl': '\u21C3',
        'dharr': '\u21C2',
        'DiacriticalAcute': '\xB4',
        'DiacriticalDot': '\u02D9',
        'DiacriticalDoubleAcute': '\u02DD',
        'DiacriticalGrave': '`',
        'DiacriticalTilde': '\u02DC',
        'diam': '\u22C4',
        'diamond': '\u22C4',
        'Diamond': '\u22C4',
        'diamondsuit': '\u2666',
        'diams': '\u2666',
        'die': '\xA8',
        'DifferentialD': 'ⅆ',
        'digamma': 'ϝ',
        'disin': '\u22F2',
        'div': '\xF7',
        'divide': '\xF7',
        'divideontimes': '\u22C7',
        'divonx': '\u22C7',
        'djcy': 'ђ',
        'DJcy': 'Ђ',
        'dlcorn': '\u231E',
        'dlcrop': '\u230D',
        'dollar': '$',
        'dopf': '\uD835\uDD55',
        'Dopf': '\uD835\uDD3B',
        'dot': '\u02D9',
        'Dot': '\xA8',
        'DotDot': '⃜',
        'doteq': '\u2250',
        'doteqdot': '\u2251',
        'DotEqual': '\u2250',
        'dotminus': '\u2238',
        'dotplus': '\u2214',
        'dotsquare': '\u22A1',
        'doublebarwedge': '\u2306',
        'DoubleContourIntegral': '\u222F',
        'DoubleDot': '\xA8',
        'DoubleDownArrow': '\u21D3',
        'DoubleLeftArrow': '\u21D0',
        'DoubleLeftRightArrow': '\u21D4',
        'DoubleLeftTee': '\u2AE4',
        'DoubleLongLeftArrow': '\u27F8',
        'DoubleLongLeftRightArrow': '\u27FA',
        'DoubleLongRightArrow': '\u27F9',
        'DoubleRightArrow': '\u21D2',
        'DoubleRightTee': '\u22A8',
        'DoubleUpArrow': '\u21D1',
        'DoubleUpDownArrow': '\u21D5',
        'DoubleVerticalBar': '\u2225',
        'downarrow': '\u2193',
        'Downarrow': '\u21D3',
        'DownArrow': '\u2193',
        'DownArrowBar': '\u2913',
        'DownArrowUpArrow': '\u21F5',
        'DownBreve': '̑',
        'downdownarrows': '\u21CA',
        'downharpoonleft': '\u21C3',
        'downharpoonright': '\u21C2',
        'DownLeftRightVector': '\u2950',
        'DownLeftTeeVector': '\u295E',
        'DownLeftVector': '\u21BD',
        'DownLeftVectorBar': '\u2956',
        'DownRightTeeVector': '\u295F',
        'DownRightVector': '\u21C1',
        'DownRightVectorBar': '\u2957',
        'DownTee': '\u22A4',
        'DownTeeArrow': '\u21A7',
        'drbkarow': '\u2910',
        'drcorn': '\u231F',
        'drcrop': '\u230C',
        'dscr': '\uD835\uDCB9',
        'Dscr': '\uD835\uDC9F',
        'dscy': 'ѕ',
        'DScy': 'Ѕ',
        'dsol': '\u29F6',
        'dstrok': 'đ',
        'Dstrok': 'Đ',
        'dtdot': '\u22F1',
        'dtri': '\u25BF',
        'dtrif': '\u25BE',
        'duarr': '\u21F5',
        'duhar': '\u296F',
        'dwangle': '\u29A6',
        'dzcy': 'џ',
        'DZcy': 'Џ',
        'dzigrarr': '\u27FF',
        'eacute': 'é',
        'Eacute': 'É',
        'easter': '\u2A6E',
        'ecaron': 'ě',
        'Ecaron': 'Ě',
        'ecir': '\u2256',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'ecolon': '\u2255',
        'ecy': 'э',
        'Ecy': 'Э',
        'eDDot': '\u2A77',
        'edot': 'ė',
        'eDot': '\u2251',
        'Edot': 'Ė',
        'ee': 'ⅇ',
        'efDot': '\u2252',
        'efr': '\uD835\uDD22',
        'Efr': '\uD835\uDD08',
        'eg': '\u2A9A',
        'egrave': 'è',
        'Egrave': 'È',
        'egs': '\u2A96',
        'egsdot': '\u2A98',
        'el': '\u2A99',
        'Element': '\u2208',
        'elinters': '\u23E7',
        'ell': 'ℓ',
        'els': '\u2A95',
        'elsdot': '\u2A97',
        'emacr': 'ē',
        'Emacr': 'Ē',
        'empty': '\u2205',
        'emptyset': '\u2205',
        'EmptySmallSquare': '\u25FB',
        'emptyv': '\u2205',
        'EmptyVerySmallSquare': '\u25AB',
        'emsp': '\u2003',
        'emsp13': '\u2004',
        'emsp14': '\u2005',
        'eng': 'ŋ',
        'ENG': 'Ŋ',
        'ensp': '\u2002',
        'eogon': 'ę',
        'Eogon': 'Ę',
        'eopf': '\uD835\uDD56',
        'Eopf': '\uD835\uDD3C',
        'epar': '\u22D5',
        'eparsl': '\u29E3',
        'eplus': '\u2A71',
        'epsi': 'ε',
        'epsilon': 'ε',
        'Epsilon': 'Ε',
        'epsiv': 'ϵ',
        'eqcirc': '\u2256',
        'eqcolon': '\u2255',
        'eqsim': '\u2242',
        'eqslantgtr': '\u2A96',
        'eqslantless': '\u2A95',
        'Equal': '\u2A75',
        'equals': '=',
        'EqualTilde': '\u2242',
        'equest': '\u225F',
        'Equilibrium': '\u21CC',
        'equiv': '\u2261',
        'equivDD': '\u2A78',
        'eqvparsl': '\u29E5',
        'erarr': '\u2971',
        'erDot': '\u2253',
        'escr': 'ℯ',
        'Escr': 'ℰ',
        'esdot': '\u2250',
        'esim': '\u2242',
        'Esim': '\u2A73',
        'eta': 'η',
        'Eta': 'Η',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'euro': '\u20AC',
        'excl': '!',
        'exist': '\u2203',
        'Exists': '\u2203',
        'expectation': 'ℰ',
        'exponentiale': 'ⅇ',
        'ExponentialE': 'ⅇ',
        'fallingdotseq': '\u2252',
        'fcy': 'ф',
        'Fcy': 'Ф',
        'female': '\u2640',
        'ffilig': 'ﬃ',
        'fflig': 'ﬀ',
        'ffllig': 'ﬄ',
        'ffr': '\uD835\uDD23',
        'Ffr': '\uD835\uDD09',
        'filig': 'ﬁ',
        'FilledSmallSquare': '\u25FC',
        'FilledVerySmallSquare': '\u25AA',
        'fjlig': 'fj',
        'flat': '\u266D',
        'fllig': 'ﬂ',
        'fltns': '\u25B1',
        'fnof': 'ƒ',
        'fopf': '\uD835\uDD57',
        'Fopf': '\uD835\uDD3D',
        'forall': '\u2200',
        'ForAll': '\u2200',
        'fork': '\u22D4',
        'forkv': '\u2AD9',
        'Fouriertrf': 'ℱ',
        'fpartint': '\u2A0D',
        'frac12': '\xBD',
        'frac13': '\u2153',
        'frac14': '\xBC',
        'frac15': '\u2155',
        'frac16': '\u2159',
        'frac18': '\u215B',
        'frac23': '\u2154',
        'frac25': '\u2156',
        'frac34': '\xBE',
        'frac35': '\u2157',
        'frac38': '\u215C',
        'frac45': '\u2158',
        'frac56': '\u215A',
        'frac58': '\u215D',
        'frac78': '\u215E',
        'frasl': '\u2044',
        'frown': '\u2322',
        'fscr': '\uD835\uDCBB',
        'Fscr': 'ℱ',
        'gacute': 'ǵ',
        'gamma': 'γ',
        'Gamma': 'Γ',
        'gammad': 'ϝ',
        'Gammad': 'Ϝ',
        'gap': '\u2A86',
        'gbreve': 'ğ',
        'Gbreve': 'Ğ',
        'Gcedil': 'Ģ',
        'gcirc': 'ĝ',
        'Gcirc': 'Ĝ',
        'gcy': 'г',
        'Gcy': 'Г',
        'gdot': 'ġ',
        'Gdot': 'Ġ',
        'ge': '\u2265',
        'gE': '\u2267',
        'gel': '\u22DB',
        'gEl': '\u2A8C',
        'geq': '\u2265',
        'geqq': '\u2267',
        'geqslant': '\u2A7E',
        'ges': '\u2A7E',
        'gescc': '\u2AA9',
        'gesdot': '\u2A80',
        'gesdoto': '\u2A82',
        'gesdotol': '\u2A84',
        'gesl': '\u22DB︀',
        'gesles': '\u2A94',
        'gfr': '\uD835\uDD24',
        'Gfr': '\uD835\uDD0A',
        'gg': '\u226B',
        'Gg': '\u22D9',
        'ggg': '\u22D9',
        'gimel': 'ℷ',
        'gjcy': 'ѓ',
        'GJcy': 'Ѓ',
        'gl': '\u2277',
        'gla': '\u2AA5',
        'glE': '\u2A92',
        'glj': '\u2AA4',
        'gnap': '\u2A8A',
        'gnapprox': '\u2A8A',
        'gne': '\u2A88',
        'gnE': '\u2269',
        'gneq': '\u2A88',
        'gneqq': '\u2269',
        'gnsim': '\u22E7',
        'gopf': '\uD835\uDD58',
        'Gopf': '\uD835\uDD3E',
        'grave': '`',
        'GreaterEqual': '\u2265',
        'GreaterEqualLess': '\u22DB',
        'GreaterFullEqual': '\u2267',
        'GreaterGreater': '\u2AA2',
        'GreaterLess': '\u2277',
        'GreaterSlantEqual': '\u2A7E',
        'GreaterTilde': '\u2273',
        'gscr': 'ℊ',
        'Gscr': '\uD835\uDCA2',
        'gsim': '\u2273',
        'gsime': '\u2A8E',
        'gsiml': '\u2A90',
        'gt': '>',
        'Gt': '\u226B',
        'GT': '>',
        'gtcc': '\u2AA7',
        'gtcir': '\u2A7A',
        'gtdot': '\u22D7',
        'gtlPar': '\u2995',
        'gtquest': '\u2A7C',
        'gtrapprox': '\u2A86',
        'gtrarr': '\u2978',
        'gtrdot': '\u22D7',
        'gtreqless': '\u22DB',
        'gtreqqless': '\u2A8C',
        'gtrless': '\u2277',
        'gtrsim': '\u2273',
        'gvertneqq': '\u2269︀',
        'gvnE': '\u2269︀',
        'Hacek': 'ˇ',
        'hairsp': '\u200A',
        'half': '\xBD',
        'hamilt': 'ℋ',
        'hardcy': 'ъ',
        'HARDcy': 'Ъ',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'harrcir': '\u2948',
        'harrw': '\u21AD',
        'Hat': '^',
        'hbar': 'ℏ',
        'hcirc': 'ĥ',
        'Hcirc': 'Ĥ',
        'hearts': '\u2665',
        'heartsuit': '\u2665',
        'hellip': '\u2026',
        'hercon': '\u22B9',
        'hfr': '\uD835\uDD25',
        'Hfr': 'ℌ',
        'HilbertSpace': 'ℋ',
        'hksearow': '\u2925',
        'hkswarow': '\u2926',
        'hoarr': '\u21FF',
        'homtht': '\u223B',
        'hookleftarrow': '\u21A9',
        'hookrightarrow': '\u21AA',
        'hopf': '\uD835\uDD59',
        'Hopf': 'ℍ',
        'horbar': '\u2015',
        'HorizontalLine': '\u2500',
        'hscr': '\uD835\uDCBD',
        'Hscr': 'ℋ',
        'hslash': 'ℏ',
        'hstrok': 'ħ',
        'Hstrok': 'Ħ',
        'HumpDownHump': '\u224E',
        'HumpEqual': '\u224F',
        'hybull': '\u2043',
        'hyphen': '\u2010',
        'iacute': 'í',
        'Iacute': 'Í',
        'ic': '\u2063',
        'icirc': 'î',
        'Icirc': 'Î',
        'icy': 'и',
        'Icy': 'И',
        'Idot': 'İ',
        'iecy': 'е',
        'IEcy': 'Е',
        'iexcl': '\xA1',
        'iff': '\u21D4',
        'ifr': '\uD835\uDD26',
        'Ifr': 'ℑ',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'ii': 'ⅈ',
        'iiiint': '\u2A0C',
        'iiint': '\u222D',
        'iinfin': '\u29DC',
        'iiota': '\u2129',
        'ijlig': 'ĳ',
        'IJlig': 'Ĳ',
        'Im': 'ℑ',
        'imacr': 'ī',
        'Imacr': 'Ī',
        'image': 'ℑ',
        'ImaginaryI': 'ⅈ',
        'imagline': 'ℐ',
        'imagpart': 'ℑ',
        'imath': 'ı',
        'imof': '\u22B7',
        'imped': 'Ƶ',
        'Implies': '\u21D2',
        'in': '\u2208',
        'incare': '\u2105',
        'infin': '\u221E',
        'infintie': '\u29DD',
        'inodot': 'ı',
        'int': '\u222B',
        'Int': '\u222C',
        'intcal': '\u22BA',
        'integers': 'ℤ',
        'Integral': '\u222B',
        'intercal': '\u22BA',
        'Intersection': '\u22C2',
        'intlarhk': '\u2A17',
        'intprod': '\u2A3C',
        'InvisibleComma': '\u2063',
        'InvisibleTimes': '\u2062',
        'iocy': 'ё',
        'IOcy': 'Ё',
        'iogon': 'į',
        'Iogon': 'Į',
        'iopf': '\uD835\uDD5A',
        'Iopf': '\uD835\uDD40',
        'iota': 'ι',
        'Iota': 'Ι',
        'iprod': '\u2A3C',
        'iquest': '\xBF',
        'iscr': '\uD835\uDCBE',
        'Iscr': 'ℐ',
        'isin': '\u2208',
        'isindot': '\u22F5',
        'isinE': '\u22F9',
        'isins': '\u22F4',
        'isinsv': '\u22F3',
        'isinv': '\u2208',
        'it': '\u2062',
        'itilde': 'ĩ',
        'Itilde': 'Ĩ',
        'iukcy': 'і',
        'Iukcy': 'І',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'jcirc': 'ĵ',
        'Jcirc': 'Ĵ',
        'jcy': 'й',
        'Jcy': 'Й',
        'jfr': '\uD835\uDD27',
        'Jfr': '\uD835\uDD0D',
        'jmath': 'ȷ',
        'jopf': '\uD835\uDD5B',
        'Jopf': '\uD835\uDD41',
        'jscr': '\uD835\uDCBF',
        'Jscr': '\uD835\uDCA5',
        'jsercy': 'ј',
        'Jsercy': 'Ј',
        'jukcy': 'є',
        'Jukcy': 'Є',
        'kappa': 'κ',
        'Kappa': 'Κ',
        'kappav': 'ϰ',
        'kcedil': 'ķ',
        'Kcedil': 'Ķ',
        'kcy': 'к',
        'Kcy': 'К',
        'kfr': '\uD835\uDD28',
        'Kfr': '\uD835\uDD0E',
        'kgreen': 'ĸ',
        'khcy': 'х',
        'KHcy': 'Х',
        'kjcy': 'ќ',
        'KJcy': 'Ќ',
        'kopf': '\uD835\uDD5C',
        'Kopf': '\uD835\uDD42',
        'kscr': '\uD835\uDCC0',
        'Kscr': '\uD835\uDCA6',
        'lAarr': '\u21DA',
        'lacute': 'ĺ',
        'Lacute': 'Ĺ',
        'laemptyv': '\u29B4',
        'lagran': 'ℒ',
        'lambda': 'λ',
        'Lambda': 'Λ',
        'lang': '\u27E8',
        'Lang': '\u27EA',
        'langd': '\u2991',
        'langle': '\u27E8',
        'lap': '\u2A85',
        'Laplacetrf': 'ℒ',
        'laquo': '\xAB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'Larr': '\u219E',
        'larrb': '\u21E4',
        'larrbfs': '\u291F',
        'larrfs': '\u291D',
        'larrhk': '\u21A9',
        'larrlp': '\u21AB',
        'larrpl': '\u2939',
        'larrsim': '\u2973',
        'larrtl': '\u21A2',
        'lat': '\u2AAB',
        'latail': '\u2919',
        'lAtail': '\u291B',
        'late': '\u2AAD',
        'lates': '\u2AAD︀',
        'lbarr': '\u290C',
        'lBarr': '\u290E',
        'lbbrk': '\u2772',
        'lbrace': '{',
        'lbrack': '[',
        'lbrke': '\u298B',
        'lbrksld': '\u298F',
        'lbrkslu': '\u298D',
        'lcaron': 'ľ',
        'Lcaron': 'Ľ',
        'lcedil': 'ļ',
        'Lcedil': 'Ļ',
        'lceil': '\u2308',
        'lcub': '{',
        'lcy': 'л',
        'Lcy': 'Л',
        'ldca': '\u2936',
        'ldquo': '\u201C',
        'ldquor': '\u201E',
        'ldrdhar': '\u2967',
        'ldrushar': '\u294B',
        'ldsh': '\u21B2',
        'le': '\u2264',
        'lE': '\u2266',
        'LeftAngleBracket': '\u27E8',
        'leftarrow': '\u2190',
        'Leftarrow': '\u21D0',
        'LeftArrow': '\u2190',
        'LeftArrowBar': '\u21E4',
        'LeftArrowRightArrow': '\u21C6',
        'leftarrowtail': '\u21A2',
        'LeftCeiling': '\u2308',
        'LeftDoubleBracket': '\u27E6',
        'LeftDownTeeVector': '\u2961',
        'LeftDownVector': '\u21C3',
        'LeftDownVectorBar': '\u2959',
        'LeftFloor': '\u230A',
        'leftharpoondown': '\u21BD',
        'leftharpoonup': '\u21BC',
        'leftleftarrows': '\u21C7',
        'leftrightarrow': '\u2194',
        'Leftrightarrow': '\u21D4',
        'LeftRightArrow': '\u2194',
        'leftrightarrows': '\u21C6',
        'leftrightharpoons': '\u21CB',
        'leftrightsquigarrow': '\u21AD',
        'LeftRightVector': '\u294E',
        'LeftTee': '\u22A3',
        'LeftTeeArrow': '\u21A4',
        'LeftTeeVector': '\u295A',
        'leftthreetimes': '\u22CB',
        'LeftTriangle': '\u22B2',
        'LeftTriangleBar': '\u29CF',
        'LeftTriangleEqual': '\u22B4',
        'LeftUpDownVector': '\u2951',
        'LeftUpTeeVector': '\u2960',
        'LeftUpVector': '\u21BF',
        'LeftUpVectorBar': '\u2958',
        'LeftVector': '\u21BC',
        'LeftVectorBar': '\u2952',
        'leg': '\u22DA',
        'lEg': '\u2A8B',
        'leq': '\u2264',
        'leqq': '\u2266',
        'leqslant': '\u2A7D',
        'les': '\u2A7D',
        'lescc': '\u2AA8',
        'lesdot': '\u2A7F',
        'lesdoto': '\u2A81',
        'lesdotor': '\u2A83',
        'lesg': '\u22DA︀',
        'lesges': '\u2A93',
        'lessapprox': '\u2A85',
        'lessdot': '\u22D6',
        'lesseqgtr': '\u22DA',
        'lesseqqgtr': '\u2A8B',
        'LessEqualGreater': '\u22DA',
        'LessFullEqual': '\u2266',
        'LessGreater': '\u2276',
        'lessgtr': '\u2276',
        'LessLess': '\u2AA1',
        'lesssim': '\u2272',
        'LessSlantEqual': '\u2A7D',
        'LessTilde': '\u2272',
        'lfisht': '\u297C',
        'lfloor': '\u230A',
        'lfr': '\uD835\uDD29',
        'Lfr': '\uD835\uDD0F',
        'lg': '\u2276',
        'lgE': '\u2A91',
        'lHar': '\u2962',
        'lhard': '\u21BD',
        'lharu': '\u21BC',
        'lharul': '\u296A',
        'lhblk': '\u2584',
        'ljcy': 'љ',
        'LJcy': 'Љ',
        'll': '\u226A',
        'Ll': '\u22D8',
        'llarr': '\u21C7',
        'llcorner': '\u231E',
        'Lleftarrow': '\u21DA',
        'llhard': '\u296B',
        'lltri': '\u25FA',
        'lmidot': 'ŀ',
        'Lmidot': 'Ŀ',
        'lmoust': '\u23B0',
        'lmoustache': '\u23B0',
        'lnap': '\u2A89',
        'lnapprox': '\u2A89',
        'lne': '\u2A87',
        'lnE': '\u2268',
        'lneq': '\u2A87',
        'lneqq': '\u2268',
        'lnsim': '\u22E6',
        'loang': '\u27EC',
        'loarr': '\u21FD',
        'lobrk': '\u27E6',
        'longleftarrow': '\u27F5',
        'Longleftarrow': '\u27F8',
        'LongLeftArrow': '\u27F5',
        'longleftrightarrow': '\u27F7',
        'Longleftrightarrow': '\u27FA',
        'LongLeftRightArrow': '\u27F7',
        'longmapsto': '\u27FC',
        'longrightarrow': '\u27F6',
        'Longrightarrow': '\u27F9',
        'LongRightArrow': '\u27F6',
        'looparrowleft': '\u21AB',
        'looparrowright': '\u21AC',
        'lopar': '\u2985',
        'lopf': '\uD835\uDD5D',
        'Lopf': '\uD835\uDD43',
        'loplus': '\u2A2D',
        'lotimes': '\u2A34',
        'lowast': '\u2217',
        'lowbar': '_',
        'LowerLeftArrow': '\u2199',
        'LowerRightArrow': '\u2198',
        'loz': '\u25CA',
        'lozenge': '\u25CA',
        'lozf': '\u29EB',
        'lpar': '(',
        'lparlt': '\u2993',
        'lrarr': '\u21C6',
        'lrcorner': '\u231F',
        'lrhar': '\u21CB',
        'lrhard': '\u296D',
        'lrm': '\u200E',
        'lrtri': '\u22BF',
        'lsaquo': '\u2039',
        'lscr': '\uD835\uDCC1',
        'Lscr': 'ℒ',
        'lsh': '\u21B0',
        'Lsh': '\u21B0',
        'lsim': '\u2272',
        'lsime': '\u2A8D',
        'lsimg': '\u2A8F',
        'lsqb': '[',
        'lsquo': '\u2018',
        'lsquor': '\u201A',
        'lstrok': 'ł',
        'Lstrok': 'Ł',
        'lt': '<',
        'Lt': '\u226A',
        'LT': '<',
        'ltcc': '\u2AA6',
        'ltcir': '\u2A79',
        'ltdot': '\u22D6',
        'lthree': '\u22CB',
        'ltimes': '\u22C9',
        'ltlarr': '\u2976',
        'ltquest': '\u2A7B',
        'ltri': '\u25C3',
        'ltrie': '\u22B4',
        'ltrif': '\u25C2',
        'ltrPar': '\u2996',
        'lurdshar': '\u294A',
        'luruhar': '\u2966',
        'lvertneqq': '\u2268︀',
        'lvnE': '\u2268︀',
        'macr': '\xAF',
        'male': '\u2642',
        'malt': '\u2720',
        'maltese': '\u2720',
        'map': '\u21A6',
        'Map': '\u2905',
        'mapsto': '\u21A6',
        'mapstodown': '\u21A7',
        'mapstoleft': '\u21A4',
        'mapstoup': '\u21A5',
        'marker': '\u25AE',
        'mcomma': '\u2A29',
        'mcy': 'м',
        'Mcy': 'М',
        'mdash': '\u2014',
        'mDDot': '\u223A',
        'measuredangle': '\u2221',
        'MediumSpace': '\u205F',
        'Mellintrf': 'ℳ',
        'mfr': '\uD835\uDD2A',
        'Mfr': '\uD835\uDD10',
        'mho': '\u2127',
        'micro': 'µ',
        'mid': '\u2223',
        'midast': '*',
        'midcir': '\u2AF0',
        'middot': '\xB7',
        'minus': '\u2212',
        'minusb': '\u229F',
        'minusd': '\u2238',
        'minusdu': '\u2A2A',
        'MinusPlus': '\u2213',
        'mlcp': '\u2ADB',
        'mldr': '\u2026',
        'mnplus': '\u2213',
        'models': '\u22A7',
        'mopf': '\uD835\uDD5E',
        'Mopf': '\uD835\uDD44',
        'mp': '\u2213',
        'mscr': '\uD835\uDCC2',
        'Mscr': 'ℳ',
        'mstpos': '\u223E',
        'mu': 'μ',
        'Mu': 'Μ',
        'multimap': '\u22B8',
        'mumap': '\u22B8',
        'nabla': '\u2207',
        'nacute': 'ń',
        'Nacute': 'Ń',
        'nang': '\u2220⃒',
        'nap': '\u2249',
        'napE': '\u2A70̸',
        'napid': '\u224B̸',
        'napos': 'ŉ',
        'napprox': '\u2249',
        'natur': '\u266E',
        'natural': '\u266E',
        'naturals': 'ℕ',
        'nbsp': '\xA0',
        'nbump': '\u224E̸',
        'nbumpe': '\u224F̸',
        'ncap': '\u2A43',
        'ncaron': 'ň',
        'Ncaron': 'Ň',
        'ncedil': 'ņ',
        'Ncedil': 'Ņ',
        'ncong': '\u2247',
        'ncongdot': '\u2A6D̸',
        'ncup': '\u2A42',
        'ncy': 'н',
        'Ncy': 'Н',
        'ndash': '\u2013',
        'ne': '\u2260',
        'nearhk': '\u2924',
        'nearr': '\u2197',
        'neArr': '\u21D7',
        'nearrow': '\u2197',
        'nedot': '\u2250̸',
        'NegativeMediumSpace': '\u200B',
        'NegativeThickSpace': '\u200B',
        'NegativeThinSpace': '\u200B',
        'NegativeVeryThinSpace': '\u200B',
        'nequiv': '\u2262',
        'nesear': '\u2928',
        'nesim': '\u2242̸',
        'NestedGreaterGreater': '\u226B',
        'NestedLessLess': '\u226A',
        'NewLine': '\n',
        'nexist': '\u2204',
        'nexists': '\u2204',
        'nfr': '\uD835\uDD2B',
        'Nfr': '\uD835\uDD11',
        'nge': '\u2271',
        'ngE': '\u2267̸',
        'ngeq': '\u2271',
        'ngeqq': '\u2267̸',
        'ngeqslant': '\u2A7E̸',
        'nges': '\u2A7E̸',
        'nGg': '\u22D9̸',
        'ngsim': '\u2275',
        'ngt': '\u226F',
        'nGt': '\u226B⃒',
        'ngtr': '\u226F',
        'nGtv': '\u226B̸',
        'nharr': '\u21AE',
        'nhArr': '\u21CE',
        'nhpar': '\u2AF2',
        'ni': '\u220B',
        'nis': '\u22FC',
        'nisd': '\u22FA',
        'niv': '\u220B',
        'njcy': 'њ',
        'NJcy': 'Њ',
        'nlarr': '\u219A',
        'nlArr': '\u21CD',
        'nldr': '\u2025',
        'nle': '\u2270',
        'nlE': '\u2266̸',
        'nleftarrow': '\u219A',
        'nLeftarrow': '\u21CD',
        'nleftrightarrow': '\u21AE',
        'nLeftrightarrow': '\u21CE',
        'nleq': '\u2270',
        'nleqq': '\u2266̸',
        'nleqslant': '\u2A7D̸',
        'nles': '\u2A7D̸',
        'nless': '\u226E',
        'nLl': '\u22D8̸',
        'nlsim': '\u2274',
        'nlt': '\u226E',
        'nLt': '\u226A⃒',
        'nltri': '\u22EA',
        'nltrie': '\u22EC',
        'nLtv': '\u226A̸',
        'nmid': '\u2224',
        'NoBreak': '\u2060',
        'NonBreakingSpace': '\xA0',
        'nopf': '\uD835\uDD5F',
        'Nopf': 'ℕ',
        'not': '\xAC',
        'Not': '\u2AEC',
        'NotCongruent': '\u2262',
        'NotCupCap': '\u226D',
        'NotDoubleVerticalBar': '\u2226',
        'NotElement': '\u2209',
        'NotEqual': '\u2260',
        'NotEqualTilde': '\u2242̸',
        'NotExists': '\u2204',
        'NotGreater': '\u226F',
        'NotGreaterEqual': '\u2271',
        'NotGreaterFullEqual': '\u2267̸',
        'NotGreaterGreater': '\u226B̸',
        'NotGreaterLess': '\u2279',
        'NotGreaterSlantEqual': '\u2A7E̸',
        'NotGreaterTilde': '\u2275',
        'NotHumpDownHump': '\u224E̸',
        'NotHumpEqual': '\u224F̸',
        'notin': '\u2209',
        'notindot': '\u22F5̸',
        'notinE': '\u22F9̸',
        'notinva': '\u2209',
        'notinvb': '\u22F7',
        'notinvc': '\u22F6',
        'NotLeftTriangle': '\u22EA',
        'NotLeftTriangleBar': '\u29CF̸',
        'NotLeftTriangleEqual': '\u22EC',
        'NotLess': '\u226E',
        'NotLessEqual': '\u2270',
        'NotLessGreater': '\u2278',
        'NotLessLess': '\u226A̸',
        'NotLessSlantEqual': '\u2A7D̸',
        'NotLessTilde': '\u2274',
        'NotNestedGreaterGreater': '\u2AA2̸',
        'NotNestedLessLess': '\u2AA1̸',
        'notni': '\u220C',
        'notniva': '\u220C',
        'notnivb': '\u22FE',
        'notnivc': '\u22FD',
        'NotPrecedes': '\u2280',
        'NotPrecedesEqual': '\u2AAF̸',
        'NotPrecedesSlantEqual': '\u22E0',
        'NotReverseElement': '\u220C',
        'NotRightTriangle': '\u22EB',
        'NotRightTriangleBar': '\u29D0̸',
        'NotRightTriangleEqual': '\u22ED',
        'NotSquareSubset': '\u228F̸',
        'NotSquareSubsetEqual': '\u22E2',
        'NotSquareSuperset': '\u2290̸',
        'NotSquareSupersetEqual': '\u22E3',
        'NotSubset': '\u2282⃒',
        'NotSubsetEqual': '\u2288',
        'NotSucceeds': '\u2281',
        'NotSucceedsEqual': '\u2AB0̸',
        'NotSucceedsSlantEqual': '\u22E1',
        'NotSucceedsTilde': '\u227F̸',
        'NotSuperset': '\u2283⃒',
        'NotSupersetEqual': '\u2289',
        'NotTilde': '\u2241',
        'NotTildeEqual': '\u2244',
        'NotTildeFullEqual': '\u2247',
        'NotTildeTilde': '\u2249',
        'NotVerticalBar': '\u2224',
        'npar': '\u2226',
        'nparallel': '\u2226',
        'nparsl': '\u2AFD⃥',
        'npart': '\u2202̸',
        'npolint': '\u2A14',
        'npr': '\u2280',
        'nprcue': '\u22E0',
        'npre': '\u2AAF̸',
        'nprec': '\u2280',
        'npreceq': '\u2AAF̸',
        'nrarr': '\u219B',
        'nrArr': '\u21CF',
        'nrarrc': '\u2933̸',
        'nrarrw': '\u219D̸',
        'nrightarrow': '\u219B',
        'nRightarrow': '\u21CF',
        'nrtri': '\u22EB',
        'nrtrie': '\u22ED',
        'nsc': '\u2281',
        'nsccue': '\u22E1',
        'nsce': '\u2AB0̸',
        'nscr': '\uD835\uDCC3',
        'Nscr': '\uD835\uDCA9',
        'nshortmid': '\u2224',
        'nshortparallel': '\u2226',
        'nsim': '\u2241',
        'nsime': '\u2244',
        'nsimeq': '\u2244',
        'nsmid': '\u2224',
        'nspar': '\u2226',
        'nsqsube': '\u22E2',
        'nsqsupe': '\u22E3',
        'nsub': '\u2284',
        'nsube': '\u2288',
        'nsubE': '\u2AC5̸',
        'nsubset': '\u2282⃒',
        'nsubseteq': '\u2288',
        'nsubseteqq': '\u2AC5̸',
        'nsucc': '\u2281',
        'nsucceq': '\u2AB0̸',
        'nsup': '\u2285',
        'nsupe': '\u2289',
        'nsupE': '\u2AC6̸',
        'nsupset': '\u2283⃒',
        'nsupseteq': '\u2289',
        'nsupseteqq': '\u2AC6̸',
        'ntgl': '\u2279',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'ntlg': '\u2278',
        'ntriangleleft': '\u22EA',
        'ntrianglelefteq': '\u22EC',
        'ntriangleright': '\u22EB',
        'ntrianglerighteq': '\u22ED',
        'nu': 'ν',
        'Nu': 'Ν',
        'num': '#',
        'numero': '\u2116',
        'numsp': '\u2007',
        'nvap': '\u224D⃒',
        'nvdash': '\u22AC',
        'nvDash': '\u22AD',
        'nVdash': '\u22AE',
        'nVDash': '\u22AF',
        'nvge': '\u2265⃒',
        'nvgt': '>⃒',
        'nvHarr': '\u2904',
        'nvinfin': '\u29DE',
        'nvlArr': '\u2902',
        'nvle': '\u2264⃒',
        'nvlt': '<⃒',
        'nvltrie': '\u22B4⃒',
        'nvrArr': '\u2903',
        'nvrtrie': '\u22B5⃒',
        'nvsim': '\u223C⃒',
        'nwarhk': '\u2923',
        'nwarr': '\u2196',
        'nwArr': '\u21D6',
        'nwarrow': '\u2196',
        'nwnear': '\u2927',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'oast': '\u229B',
        'ocir': '\u229A',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ocy': 'о',
        'Ocy': 'О',
        'odash': '\u229D',
        'odblac': 'ő',
        'Odblac': 'Ő',
        'odiv': '\u2A38',
        'odot': '\u2299',
        'odsold': '\u29BC',
        'oelig': 'œ',
        'OElig': 'Œ',
        'ofcir': '\u29BF',
        'ofr': '\uD835\uDD2C',
        'Ofr': '\uD835\uDD12',
        'ogon': '\u02DB',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ogt': '\u29C1',
        'ohbar': '\u29B5',
        'ohm': 'Ω',
        'oint': '\u222E',
        'olarr': '\u21BA',
        'olcir': '\u29BE',
        'olcross': '\u29BB',
        'oline': '\u203E',
        'olt': '\u29C0',
        'omacr': 'ō',
        'Omacr': 'Ō',
        'omega': 'ω',
        'Omega': 'Ω',
        'omicron': 'ο',
        'Omicron': 'Ο',
        'omid': '\u29B6',
        'ominus': '\u2296',
        'oopf': '\uD835\uDD60',
        'Oopf': '\uD835\uDD46',
        'opar': '\u29B7',
        'OpenCurlyDoubleQuote': '\u201C',
        'OpenCurlyQuote': '\u2018',
        'operp': '\u29B9',
        'oplus': '\u2295',
        'or': '\u2228',
        'Or': '\u2A54',
        'orarr': '\u21BB',
        'ord': '\u2A5D',
        'order': 'ℴ',
        'orderof': 'ℴ',
        'ordf': 'ª',
        'ordm': 'º',
        'origof': '\u22B6',
        'oror': '\u2A56',
        'orslope': '\u2A57',
        'orv': '\u2A5B',
        'oS': '\u24C8',
        'oscr': 'ℴ',
        'Oscr': '\uD835\uDCAA',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'osol': '\u2298',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'otimes': '\u2297',
        'Otimes': '\u2A37',
        'otimesas': '\u2A36',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'ovbar': '\u233D',
        'OverBar': '\u203E',
        'OverBrace': '\u23DE',
        'OverBracket': '\u23B4',
        'OverParenthesis': '\u23DC',
        'par': '\u2225',
        'para': '\xB6',
        'parallel': '\u2225',
        'parsim': '\u2AF3',
        'parsl': '\u2AFD',
        'part': '\u2202',
        'PartialD': '\u2202',
        'pcy': 'п',
        'Pcy': 'П',
        'percnt': '%',
        'period': '.',
        'permil': '\u2030',
        'perp': '\u22A5',
        'pertenk': '\u2031',
        'pfr': '\uD835\uDD2D',
        'Pfr': '\uD835\uDD13',
        'phi': 'φ',
        'Phi': 'Φ',
        'phiv': 'ϕ',
        'phmmat': 'ℳ',
        'phone': '\u260E',
        'pi': 'π',
        'Pi': 'Π',
        'pitchfork': '\u22D4',
        'piv': 'ϖ',
        'planck': 'ℏ',
        'planckh': 'ℎ',
        'plankv': 'ℏ',
        'plus': '+',
        'plusacir': '\u2A23',
        'plusb': '\u229E',
        'pluscir': '\u2A22',
        'plusdo': '\u2214',
        'plusdu': '\u2A25',
        'pluse': '\u2A72',
        'PlusMinus': '\xB1',
        'plusmn': '\xB1',
        'plussim': '\u2A26',
        'plustwo': '\u2A27',
        'pm': '\xB1',
        'Poincareplane': 'ℌ',
        'pointint': '\u2A15',
        'popf': '\uD835\uDD61',
        'Popf': 'ℙ',
        'pound': '\xA3',
        'pr': '\u227A',
        'Pr': '\u2ABB',
        'prap': '\u2AB7',
        'prcue': '\u227C',
        'pre': '\u2AAF',
        'prE': '\u2AB3',
        'prec': '\u227A',
        'precapprox': '\u2AB7',
        'preccurlyeq': '\u227C',
        'Precedes': '\u227A',
        'PrecedesEqual': '\u2AAF',
        'PrecedesSlantEqual': '\u227C',
        'PrecedesTilde': '\u227E',
        'preceq': '\u2AAF',
        'precnapprox': '\u2AB9',
        'precneqq': '\u2AB5',
        'precnsim': '\u22E8',
        'precsim': '\u227E',
        'prime': '\u2032',
        'Prime': '\u2033',
        'primes': 'ℙ',
        'prnap': '\u2AB9',
        'prnE': '\u2AB5',
        'prnsim': '\u22E8',
        'prod': '\u220F',
        'Product': '\u220F',
        'profalar': '\u232E',
        'profline': '\u2312',
        'profsurf': '\u2313',
        'prop': '\u221D',
        'Proportion': '\u2237',
        'Proportional': '\u221D',
        'propto': '\u221D',
        'prsim': '\u227E',
        'prurel': '\u22B0',
        'pscr': '\uD835\uDCC5',
        'Pscr': '\uD835\uDCAB',
        'psi': 'ψ',
        'Psi': 'Ψ',
        'puncsp': '\u2008',
        'qfr': '\uD835\uDD2E',
        'Qfr': '\uD835\uDD14',
        'qint': '\u2A0C',
        'qopf': '\uD835\uDD62',
        'Qopf': 'ℚ',
        'qprime': '\u2057',
        'qscr': '\uD835\uDCC6',
        'Qscr': '\uD835\uDCAC',
        'quaternions': 'ℍ',
        'quatint': '\u2A16',
        'quest': '?',
        'questeq': '\u225F',
        'quot': '"',
        'QUOT': '"',
        'rAarr': '\u21DB',
        'race': '\u223Ḏ',
        'racute': 'ŕ',
        'Racute': 'Ŕ',
        'radic': '\u221A',
        'raemptyv': '\u29B3',
        'rang': '\u27E9',
        'Rang': '\u27EB',
        'rangd': '\u2992',
        'range': '\u29A5',
        'rangle': '\u27E9',
        'raquo': '\xBB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'Rarr': '\u21A0',
        'rarrap': '\u2975',
        'rarrb': '\u21E5',
        'rarrbfs': '\u2920',
        'rarrc': '\u2933',
        'rarrfs': '\u291E',
        'rarrhk': '\u21AA',
        'rarrlp': '\u21AC',
        'rarrpl': '\u2945',
        'rarrsim': '\u2974',
        'rarrtl': '\u21A3',
        'Rarrtl': '\u2916',
        'rarrw': '\u219D',
        'ratail': '\u291A',
        'rAtail': '\u291C',
        'ratio': '\u2236',
        'rationals': 'ℚ',
        'rbarr': '\u290D',
        'rBarr': '\u290F',
        'RBarr': '\u2910',
        'rbbrk': '\u2773',
        'rbrace': '}',
        'rbrack': ']',
        'rbrke': '\u298C',
        'rbrksld': '\u298E',
        'rbrkslu': '\u2990',
        'rcaron': 'ř',
        'Rcaron': 'Ř',
        'rcedil': 'ŗ',
        'Rcedil': 'Ŗ',
        'rceil': '\u2309',
        'rcub': '}',
        'rcy': 'р',
        'Rcy': 'Р',
        'rdca': '\u2937',
        'rdldhar': '\u2969',
        'rdquo': '\u201D',
        'rdquor': '\u201D',
        'rdsh': '\u21B3',
        'Re': 'ℜ',
        'real': 'ℜ',
        'realine': 'ℛ',
        'realpart': 'ℜ',
        'reals': 'ℝ',
        'rect': '\u25AD',
        'reg': '\xAE',
        'REG': '\xAE',
        'ReverseElement': '\u220B',
        'ReverseEquilibrium': '\u21CB',
        'ReverseUpEquilibrium': '\u296F',
        'rfisht': '\u297D',
        'rfloor': '\u230B',
        'rfr': '\uD835\uDD2F',
        'Rfr': 'ℜ',
        'rHar': '\u2964',
        'rhard': '\u21C1',
        'rharu': '\u21C0',
        'rharul': '\u296C',
        'rho': 'ρ',
        'Rho': 'Ρ',
        'rhov': 'ϱ',
        'RightAngleBracket': '\u27E9',
        'rightarrow': '\u2192',
        'Rightarrow': '\u21D2',
        'RightArrow': '\u2192',
        'RightArrowBar': '\u21E5',
        'RightArrowLeftArrow': '\u21C4',
        'rightarrowtail': '\u21A3',
        'RightCeiling': '\u2309',
        'RightDoubleBracket': '\u27E7',
        'RightDownTeeVector': '\u295D',
        'RightDownVector': '\u21C2',
        'RightDownVectorBar': '\u2955',
        'RightFloor': '\u230B',
        'rightharpoondown': '\u21C1',
        'rightharpoonup': '\u21C0',
        'rightleftarrows': '\u21C4',
        'rightleftharpoons': '\u21CC',
        'rightrightarrows': '\u21C9',
        'rightsquigarrow': '\u219D',
        'RightTee': '\u22A2',
        'RightTeeArrow': '\u21A6',
        'RightTeeVector': '\u295B',
        'rightthreetimes': '\u22CC',
        'RightTriangle': '\u22B3',
        'RightTriangleBar': '\u29D0',
        'RightTriangleEqual': '\u22B5',
        'RightUpDownVector': '\u294F',
        'RightUpTeeVector': '\u295C',
        'RightUpVector': '\u21BE',
        'RightUpVectorBar': '\u2954',
        'RightVector': '\u21C0',
        'RightVectorBar': '\u2953',
        'ring': '\u02DA',
        'risingdotseq': '\u2253',
        'rlarr': '\u21C4',
        'rlhar': '\u21CC',
        'rlm': '\u200F',
        'rmoust': '\u23B1',
        'rmoustache': '\u23B1',
        'rnmid': '\u2AEE',
        'roang': '\u27ED',
        'roarr': '\u21FE',
        'robrk': '\u27E7',
        'ropar': '\u2986',
        'ropf': '\uD835\uDD63',
        'Ropf': 'ℝ',
        'roplus': '\u2A2E',
        'rotimes': '\u2A35',
        'RoundImplies': '\u2970',
        'rpar': ')',
        'rpargt': '\u2994',
        'rppolint': '\u2A12',
        'rrarr': '\u21C9',
        'Rrightarrow': '\u21DB',
        'rsaquo': '\u203A',
        'rscr': '\uD835\uDCC7',
        'Rscr': 'ℛ',
        'rsh': '\u21B1',
        'Rsh': '\u21B1',
        'rsqb': ']',
        'rsquo': '\u2019',
        'rsquor': '\u2019',
        'rthree': '\u22CC',
        'rtimes': '\u22CA',
        'rtri': '\u25B9',
        'rtrie': '\u22B5',
        'rtrif': '\u25B8',
        'rtriltri': '\u29CE',
        'RuleDelayed': '\u29F4',
        'ruluhar': '\u2968',
        'rx': '\u211E',
        'sacute': 'ś',
        'Sacute': 'Ś',
        'sbquo': '\u201A',
        'sc': '\u227B',
        'Sc': '\u2ABC',
        'scap': '\u2AB8',
        'scaron': 'š',
        'Scaron': 'Š',
        'sccue': '\u227D',
        'sce': '\u2AB0',
        'scE': '\u2AB4',
        'scedil': 'ş',
        'Scedil': 'Ş',
        'scirc': 'ŝ',
        'Scirc': 'Ŝ',
        'scnap': '\u2ABA',
        'scnE': '\u2AB6',
        'scnsim': '\u22E9',
        'scpolint': '\u2A13',
        'scsim': '\u227F',
        'scy': 'с',
        'Scy': 'С',
        'sdot': '\u22C5',
        'sdotb': '\u22A1',
        'sdote': '\u2A66',
        'searhk': '\u2925',
        'searr': '\u2198',
        'seArr': '\u21D8',
        'searrow': '\u2198',
        'sect': '\xA7',
        'semi': ';',
        'seswar': '\u2929',
        'setminus': '\u2216',
        'setmn': '\u2216',
        'sext': '\u2736',
        'sfr': '\uD835\uDD30',
        'Sfr': '\uD835\uDD16',
        'sfrown': '\u2322',
        'sharp': '\u266F',
        'shchcy': 'щ',
        'SHCHcy': 'Щ',
        'shcy': 'ш',
        'SHcy': 'Ш',
        'ShortDownArrow': '\u2193',
        'ShortLeftArrow': '\u2190',
        'shortmid': '\u2223',
        'shortparallel': '\u2225',
        'ShortRightArrow': '\u2192',
        'ShortUpArrow': '\u2191',
        'shy': '\xAD',
        'sigma': 'σ',
        'Sigma': 'Σ',
        'sigmaf': 'ς',
        'sigmav': 'ς',
        'sim': '\u223C',
        'simdot': '\u2A6A',
        'sime': '\u2243',
        'simeq': '\u2243',
        'simg': '\u2A9E',
        'simgE': '\u2AA0',
        'siml': '\u2A9D',
        'simlE': '\u2A9F',
        'simne': '\u2246',
        'simplus': '\u2A24',
        'simrarr': '\u2972',
        'slarr': '\u2190',
        'SmallCircle': '\u2218',
        'smallsetminus': '\u2216',
        'smashp': '\u2A33',
        'smeparsl': '\u29E4',
        'smid': '\u2223',
        'smile': '\u2323',
        'smt': '\u2AAA',
        'smte': '\u2AAC',
        'smtes': '\u2AAC︀',
        'softcy': 'ь',
        'SOFTcy': 'Ь',
        'sol': '/',
        'solb': '\u29C4',
        'solbar': '\u233F',
        'sopf': '\uD835\uDD64',
        'Sopf': '\uD835\uDD4A',
        'spades': '\u2660',
        'spadesuit': '\u2660',
        'spar': '\u2225',
        'sqcap': '\u2293',
        'sqcaps': '\u2293︀',
        'sqcup': '\u2294',
        'sqcups': '\u2294︀',
        'Sqrt': '\u221A',
        'sqsub': '\u228F',
        'sqsube': '\u2291',
        'sqsubset': '\u228F',
        'sqsubseteq': '\u2291',
        'sqsup': '\u2290',
        'sqsupe': '\u2292',
        'sqsupset': '\u2290',
        'sqsupseteq': '\u2292',
        'squ': '\u25A1',
        'square': '\u25A1',
        'Square': '\u25A1',
        'SquareIntersection': '\u2293',
        'SquareSubset': '\u228F',
        'SquareSubsetEqual': '\u2291',
        'SquareSuperset': '\u2290',
        'SquareSupersetEqual': '\u2292',
        'SquareUnion': '\u2294',
        'squarf': '\u25AA',
        'squf': '\u25AA',
        'srarr': '\u2192',
        'sscr': '\uD835\uDCC8',
        'Sscr': '\uD835\uDCAE',
        'ssetmn': '\u2216',
        'ssmile': '\u2323',
        'sstarf': '\u22C6',
        'star': '\u2606',
        'Star': '\u22C6',
        'starf': '\u2605',
        'straightepsilon': 'ϵ',
        'straightphi': 'ϕ',
        'strns': '\xAF',
        'sub': '\u2282',
        'Sub': '\u22D0',
        'subdot': '\u2ABD',
        'sube': '\u2286',
        'subE': '\u2AC5',
        'subedot': '\u2AC3',
        'submult': '\u2AC1',
        'subne': '\u228A',
        'subnE': '\u2ACB',
        'subplus': '\u2ABF',
        'subrarr': '\u2979',
        'subset': '\u2282',
        'Subset': '\u22D0',
        'subseteq': '\u2286',
        'subseteqq': '\u2AC5',
        'SubsetEqual': '\u2286',
        'subsetneq': '\u228A',
        'subsetneqq': '\u2ACB',
        'subsim': '\u2AC7',
        'subsub': '\u2AD5',
        'subsup': '\u2AD3',
        'succ': '\u227B',
        'succapprox': '\u2AB8',
        'succcurlyeq': '\u227D',
        'Succeeds': '\u227B',
        'SucceedsEqual': '\u2AB0',
        'SucceedsSlantEqual': '\u227D',
        'SucceedsTilde': '\u227F',
        'succeq': '\u2AB0',
        'succnapprox': '\u2ABA',
        'succneqq': '\u2AB6',
        'succnsim': '\u22E9',
        'succsim': '\u227F',
        'SuchThat': '\u220B',
        'sum': '\u2211',
        'Sum': '\u2211',
        'sung': '\u266A',
        'sup': '\u2283',
        'Sup': '\u22D1',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'supdot': '\u2ABE',
        'supdsub': '\u2AD8',
        'supe': '\u2287',
        'supE': '\u2AC6',
        'supedot': '\u2AC4',
        'Superset': '\u2283',
        'SupersetEqual': '\u2287',
        'suphsol': '\u27C9',
        'suphsub': '\u2AD7',
        'suplarr': '\u297B',
        'supmult': '\u2AC2',
        'supne': '\u228B',
        'supnE': '\u2ACC',
        'supplus': '\u2AC0',
        'supset': '\u2283',
        'Supset': '\u22D1',
        'supseteq': '\u2287',
        'supseteqq': '\u2AC6',
        'supsetneq': '\u228B',
        'supsetneqq': '\u2ACC',
        'supsim': '\u2AC8',
        'supsub': '\u2AD4',
        'supsup': '\u2AD6',
        'swarhk': '\u2926',
        'swarr': '\u2199',
        'swArr': '\u21D9',
        'swarrow': '\u2199',
        'swnwar': '\u292A',
        'szlig': 'ß',
        'Tab': '\t',
        'target': '\u2316',
        'tau': 'τ',
        'Tau': 'Τ',
        'tbrk': '\u23B4',
        'tcaron': 'ť',
        'Tcaron': 'Ť',
        'tcedil': 'ţ',
        'Tcedil': 'Ţ',
        'tcy': 'т',
        'Tcy': 'Т',
        'tdot': '⃛',
        'telrec': '\u2315',
        'tfr': '\uD835\uDD31',
        'Tfr': '\uD835\uDD17',
        'there4': '\u2234',
        'therefore': '\u2234',
        'Therefore': '\u2234',
        'theta': 'θ',
        'Theta': 'Θ',
        'thetasym': 'ϑ',
        'thetav': 'ϑ',
        'thickapprox': '\u2248',
        'thicksim': '\u223C',
        'ThickSpace': '\u205F\u200A',
        'thinsp': '\u2009',
        'ThinSpace': '\u2009',
        'thkap': '\u2248',
        'thksim': '\u223C',
        'thorn': 'þ',
        'THORN': 'Þ',
        'tilde': '\u02DC',
        'Tilde': '\u223C',
        'TildeEqual': '\u2243',
        'TildeFullEqual': '\u2245',
        'TildeTilde': '\u2248',
        'times': '\xD7',
        'timesb': '\u22A0',
        'timesbar': '\u2A31',
        'timesd': '\u2A30',
        'tint': '\u222D',
        'toea': '\u2928',
        'top': '\u22A4',
        'topbot': '\u2336',
        'topcir': '\u2AF1',
        'topf': '\uD835\uDD65',
        'Topf': '\uD835\uDD4B',
        'topfork': '\u2ADA',
        'tosa': '\u2929',
        'tprime': '\u2034',
        'trade': '\u2122',
        'TRADE': '\u2122',
        'triangle': '\u25B5',
        'triangledown': '\u25BF',
        'triangleleft': '\u25C3',
        'trianglelefteq': '\u22B4',
        'triangleq': '\u225C',
        'triangleright': '\u25B9',
        'trianglerighteq': '\u22B5',
        'tridot': '\u25EC',
        'trie': '\u225C',
        'triminus': '\u2A3A',
        'TripleDot': '⃛',
        'triplus': '\u2A39',
        'trisb': '\u29CD',
        'tritime': '\u2A3B',
        'trpezium': '\u23E2',
        'tscr': '\uD835\uDCC9',
        'Tscr': '\uD835\uDCAF',
        'tscy': 'ц',
        'TScy': 'Ц',
        'tshcy': 'ћ',
        'TSHcy': 'Ћ',
        'tstrok': 'ŧ',
        'Tstrok': 'Ŧ',
        'twixt': '\u226C',
        'twoheadleftarrow': '\u219E',
        'twoheadrightarrow': '\u21A0',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Uarr': '\u219F',
        'Uarrocir': '\u2949',
        'ubrcy': 'ў',
        'Ubrcy': 'Ў',
        'ubreve': 'ŭ',
        'Ubreve': 'Ŭ',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ucy': 'у',
        'Ucy': 'У',
        'udarr': '\u21C5',
        'udblac': 'ű',
        'Udblac': 'Ű',
        'udhar': '\u296E',
        'ufisht': '\u297E',
        'ufr': '\uD835\uDD32',
        'Ufr': '\uD835\uDD18',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uHar': '\u2963',
        'uharl': '\u21BF',
        'uharr': '\u21BE',
        'uhblk': '\u2580',
        'ulcorn': '\u231C',
        'ulcorner': '\u231C',
        'ulcrop': '\u230F',
        'ultri': '\u25F8',
        'umacr': 'ū',
        'Umacr': 'Ū',
        'uml': '\xA8',
        'UnderBar': '_',
        'UnderBrace': '\u23DF',
        'UnderBracket': '\u23B5',
        'UnderParenthesis': '\u23DD',
        'Union': '\u22C3',
        'UnionPlus': '\u228E',
        'uogon': 'ų',
        'Uogon': 'Ų',
        'uopf': '\uD835\uDD66',
        'Uopf': '\uD835\uDD4C',
        'uparrow': '\u2191',
        'Uparrow': '\u21D1',
        'UpArrow': '\u2191',
        'UpArrowBar': '\u2912',
        'UpArrowDownArrow': '\u21C5',
        'updownarrow': '\u2195',
        'Updownarrow': '\u21D5',
        'UpDownArrow': '\u2195',
        'UpEquilibrium': '\u296E',
        'upharpoonleft': '\u21BF',
        'upharpoonright': '\u21BE',
        'uplus': '\u228E',
        'UpperLeftArrow': '\u2196',
        'UpperRightArrow': '\u2197',
        'upsi': 'υ',
        'Upsi': 'ϒ',
        'upsih': 'ϒ',
        'upsilon': 'υ',
        'Upsilon': 'Υ',
        'UpTee': '\u22A5',
        'UpTeeArrow': '\u21A5',
        'upuparrows': '\u21C8',
        'urcorn': '\u231D',
        'urcorner': '\u231D',
        'urcrop': '\u230E',
        'uring': 'ů',
        'Uring': 'Ů',
        'urtri': '\u25F9',
        'uscr': '\uD835\uDCCA',
        'Uscr': '\uD835\uDCB0',
        'utdot': '\u22F0',
        'utilde': 'ũ',
        'Utilde': 'Ũ',
        'utri': '\u25B5',
        'utrif': '\u25B4',
        'uuarr': '\u21C8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'uwangle': '\u29A7',
        'vangrt': '\u299C',
        'varepsilon': 'ϵ',
        'varkappa': 'ϰ',
        'varnothing': '\u2205',
        'varphi': 'ϕ',
        'varpi': 'ϖ',
        'varpropto': '\u221D',
        'varr': '\u2195',
        'vArr': '\u21D5',
        'varrho': 'ϱ',
        'varsigma': 'ς',
        'varsubsetneq': '\u228A︀',
        'varsubsetneqq': '\u2ACB︀',
        'varsupsetneq': '\u228B︀',
        'varsupsetneqq': '\u2ACC︀',
        'vartheta': 'ϑ',
        'vartriangleleft': '\u22B2',
        'vartriangleright': '\u22B3',
        'vBar': '\u2AE8',
        'Vbar': '\u2AEB',
        'vBarv': '\u2AE9',
        'vcy': 'в',
        'Vcy': 'В',
        'vdash': '\u22A2',
        'vDash': '\u22A8',
        'Vdash': '\u22A9',
        'VDash': '\u22AB',
        'Vdashl': '\u2AE6',
        'vee': '\u2228',
        'Vee': '\u22C1',
        'veebar': '\u22BB',
        'veeeq': '\u225A',
        'vellip': '\u22EE',
        'verbar': '|',
        'Verbar': '\u2016',
        'vert': '|',
        'Vert': '\u2016',
        'VerticalBar': '\u2223',
        'VerticalLine': '|',
        'VerticalSeparator': '\u2758',
        'VerticalTilde': '\u2240',
        'VeryThinSpace': '\u200A',
        'vfr': '\uD835\uDD33',
        'Vfr': '\uD835\uDD19',
        'vltri': '\u22B2',
        'vnsub': '\u2282⃒',
        'vnsup': '\u2283⃒',
        'vopf': '\uD835\uDD67',
        'Vopf': '\uD835\uDD4D',
        'vprop': '\u221D',
        'vrtri': '\u22B3',
        'vscr': '\uD835\uDCCB',
        'Vscr': '\uD835\uDCB1',
        'vsubne': '\u228A︀',
        'vsubnE': '\u2ACB︀',
        'vsupne': '\u228B︀',
        'vsupnE': '\u2ACC︀',
        'Vvdash': '\u22AA',
        'vzigzag': '\u299A',
        'wcirc': 'ŵ',
        'Wcirc': 'Ŵ',
        'wedbar': '\u2A5F',
        'wedge': '\u2227',
        'Wedge': '\u22C0',
        'wedgeq': '\u2259',
        'weierp': '\u2118',
        'wfr': '\uD835\uDD34',
        'Wfr': '\uD835\uDD1A',
        'wopf': '\uD835\uDD68',
        'Wopf': '\uD835\uDD4E',
        'wp': '\u2118',
        'wr': '\u2240',
        'wreath': '\u2240',
        'wscr': '\uD835\uDCCC',
        'Wscr': '\uD835\uDCB2',
        'xcap': '\u22C2',
        'xcirc': '\u25EF',
        'xcup': '\u22C3',
        'xdtri': '\u25BD',
        'xfr': '\uD835\uDD35',
        'Xfr': '\uD835\uDD1B',
        'xharr': '\u27F7',
        'xhArr': '\u27FA',
        'xi': 'ξ',
        'Xi': 'Ξ',
        'xlarr': '\u27F5',
        'xlArr': '\u27F8',
        'xmap': '\u27FC',
        'xnis': '\u22FB',
        'xodot': '\u2A00',
        'xopf': '\uD835\uDD69',
        'Xopf': '\uD835\uDD4F',
        'xoplus': '\u2A01',
        'xotime': '\u2A02',
        'xrarr': '\u27F6',
        'xrArr': '\u27F9',
        'xscr': '\uD835\uDCCD',
        'Xscr': '\uD835\uDCB3',
        'xsqcup': '\u2A06',
        'xuplus': '\u2A04',
        'xutri': '\u25B3',
        'xvee': '\u22C1',
        'xwedge': '\u22C0',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yacy': 'я',
        'YAcy': 'Я',
        'ycirc': 'ŷ',
        'Ycirc': 'Ŷ',
        'ycy': 'ы',
        'Ycy': 'Ы',
        'yen': '\xA5',
        'yfr': '\uD835\uDD36',
        'Yfr': '\uD835\uDD1C',
        'yicy': 'ї',
        'YIcy': 'Ї',
        'yopf': '\uD835\uDD6A',
        'Yopf': '\uD835\uDD50',
        'yscr': '\uD835\uDCCE',
        'Yscr': '\uD835\uDCB4',
        'yucy': 'ю',
        'YUcy': 'Ю',
        'yuml': 'ÿ',
        'Yuml': 'Ÿ',
        'zacute': 'ź',
        'Zacute': 'Ź',
        'zcaron': 'ž',
        'Zcaron': 'Ž',
        'zcy': 'з',
        'Zcy': 'З',
        'zdot': 'ż',
        'Zdot': 'Ż',
        'zeetrf': 'ℨ',
        'ZeroWidthSpace': '\u200B',
        'zeta': 'ζ',
        'Zeta': 'Ζ',
        'zfr': '\uD835\uDD37',
        'Zfr': 'ℨ',
        'zhcy': 'ж',
        'ZHcy': 'Ж',
        'zigrarr': '\u21DD',
        'zopf': '\uD835\uDD6B',
        'Zopf': 'ℤ',
        'zscr': '\uD835\uDCCF',
        'Zscr': '\uD835\uDCB5',
        'zwj': '‍',
        'zwnj': '‌'
    };
    var decodeMapLegacy = {
        'aacute': 'á',
        'Aacute': 'Á',
        'acirc': 'â',
        'Acirc': 'Â',
        'acute': '\xB4',
        'aelig': 'æ',
        'AElig': 'Æ',
        'agrave': 'à',
        'Agrave': 'À',
        'amp': '&',
        'AMP': '&',
        'aring': 'å',
        'Aring': 'Å',
        'atilde': 'ã',
        'Atilde': 'Ã',
        'auml': 'ä',
        'Auml': 'Ä',
        'brvbar': '\xA6',
        'ccedil': 'ç',
        'Ccedil': 'Ç',
        'cedil': '\xB8',
        'cent': '\xA2',
        'copy': '\xA9',
        'COPY': '\xA9',
        'curren': '\xA4',
        'deg': '\xB0',
        'divide': '\xF7',
        'eacute': 'é',
        'Eacute': 'É',
        'ecirc': 'ê',
        'Ecirc': 'Ê',
        'egrave': 'è',
        'Egrave': 'È',
        'eth': 'ð',
        'ETH': 'Ð',
        'euml': 'ë',
        'Euml': 'Ë',
        'frac12': '\xBD',
        'frac14': '\xBC',
        'frac34': '\xBE',
        'gt': '>',
        'GT': '>',
        'iacute': 'í',
        'Iacute': 'Í',
        'icirc': 'î',
        'Icirc': 'Î',
        'iexcl': '\xA1',
        'igrave': 'ì',
        'Igrave': 'Ì',
        'iquest': '\xBF',
        'iuml': 'ï',
        'Iuml': 'Ï',
        'laquo': '\xAB',
        'lt': '<',
        'LT': '<',
        'macr': '\xAF',
        'micro': 'µ',
        'middot': '\xB7',
        'nbsp': '\xA0',
        'not': '\xAC',
        'ntilde': 'ñ',
        'Ntilde': 'Ñ',
        'oacute': 'ó',
        'Oacute': 'Ó',
        'ocirc': 'ô',
        'Ocirc': 'Ô',
        'ograve': 'ò',
        'Ograve': 'Ò',
        'ordf': 'ª',
        'ordm': 'º',
        'oslash': 'ø',
        'Oslash': 'Ø',
        'otilde': 'õ',
        'Otilde': 'Õ',
        'ouml': 'ö',
        'Ouml': 'Ö',
        'para': '\xB6',
        'plusmn': '\xB1',
        'pound': '\xA3',
        'quot': '"',
        'QUOT': '"',
        'raquo': '\xBB',
        'reg': '\xAE',
        'REG': '\xAE',
        'sect': '\xA7',
        'shy': '\xAD',
        'sup1': '\xB9',
        'sup2': '\xB2',
        'sup3': '\xB3',
        'szlig': 'ß',
        'thorn': 'þ',
        'THORN': 'Þ',
        'times': '\xD7',
        'uacute': 'ú',
        'Uacute': 'Ú',
        'ucirc': 'û',
        'Ucirc': 'Û',
        'ugrave': 'ù',
        'Ugrave': 'Ù',
        'uml': '\xA8',
        'uuml': 'ü',
        'Uuml': 'Ü',
        'yacute': 'ý',
        'Yacute': 'Ý',
        'yen': '\xA5',
        'yuml': 'ÿ'
    };
    var decodeMapNumeric = {
        '0': '\uFFFD',
        '128': '\u20AC',
        '130': '\u201A',
        '131': 'ƒ',
        '132': '\u201E',
        '133': '\u2026',
        '134': '\u2020',
        '135': '\u2021',
        '136': 'ˆ',
        '137': '\u2030',
        '138': 'Š',
        '139': '\u2039',
        '140': 'Œ',
        '142': 'Ž',
        '145': '\u2018',
        '146': '\u2019',
        '147': '\u201C',
        '148': '\u201D',
        '149': '\u2022',
        '150': '\u2013',
        '151': '\u2014',
        '152': '\u02DC',
        '153': '\u2122',
        '154': 'š',
        '155': '\u203A',
        '156': 'œ',
        '158': 'ž',
        '159': 'Ÿ'
    };
    var invalidReferenceCodePoints = [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        64976,
        64977,
        64978,
        64979,
        64980,
        64981,
        64982,
        64983,
        64984,
        64985,
        64986,
        64987,
        64988,
        64989,
        64990,
        64991,
        64992,
        64993,
        64994,
        64995,
        64996,
        64997,
        64998,
        64999,
        65000,
        65001,
        65002,
        65003,
        65004,
        65005,
        65006,
        65007,
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
    ];
    var stringFromCharCode = String.fromCharCode;
    var object = {};
    var hasOwnProperty = object.hasOwnProperty;
    var has = function (object, propertyName) {
        return hasOwnProperty.call(object, propertyName);
    };
    var contains = function (array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
            if (array[index] == value) {
                return true;
            }
        }
        return false;
    };
    var merge = function (options, defaults) {
        if (!options) {
            return defaults;
        }
        var result = {};
        var key;
        for (key in defaults) {
            result[key] = has(options, key) ? options[key] : defaults[key];
        }
        return result;
    };
    var codePointToSymbol = function (codePoint, strict) {
        var output = '';
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
            if (strict) {
                parseError('character reference outside the permissible Unicode range');
            }
            return '\uFFFD';
        }
        if (has(decodeMapNumeric, codePoint)) {
            if (strict) {
                parseError('disallowed character reference');
            }
            return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
            parseError('disallowed character reference');
        }
        if (codePoint > 65535) {
            codePoint -= 65536;
            output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
    };
    var hexEscape = function (codePoint) {
        return '&#x' + codePoint.toString(16).toUpperCase() + ';';
    };
    var decEscape = function (codePoint) {
        return '&#' + codePoint + ';';
    };
    var parseError = function (message) {
        throw Error('Parse error: ' + message);
    };
    var encode = function (string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
            parseError('forbidden code point');
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function (symbol) {
            return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
            string = string.replace(regexAsciiWhitelist, function (symbol) {
                if (useNamedReferences && has(encodeMap, symbol)) {
                    return '&' + encodeMap[symbol] + ';';
                }
                return escapeBmpSymbol(symbol);
            });
            if (useNamedReferences) {
                string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
            }
            if (useNamedReferences) {
                string = string.replace(regexEncodeNonAscii, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
        } else if (useNamedReferences) {
            if (!allowUnsafeSymbols) {
                string = string.replace(regexEscape, function (string) {
                    return '&' + encodeMap[string] + ';';
                });
            }
            string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;');
            string = string.replace(regexEncodeNonAscii, function (string) {
                return '&' + encodeMap[string] + ';';
            });
        } else if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function ($0) {
            var high = $0.charCodeAt(0);
            var low = $0.charCodeAt(1);
            var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
            return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
    };
    encode.options = {
        'allowUnsafeSymbols': false,
        'encodeEverything': false,
        'strict': false,
        'useNamedReferences': false,
        'decimal': false
    };
    var decode = function (html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
            parseError('malformed character reference');
        }
        return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7) {
            var codePoint;
            var semicolon;
            var decDigits;
            var hexDigits;
            var reference;
            var next;
            if ($1) {
                decDigits = $1;
                semicolon = $2;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(decDigits, 10);
                return codePointToSymbol(codePoint, strict);
            }
            if ($3) {
                hexDigits = $3;
                semicolon = $4;
                if (strict && !semicolon) {
                    parseError('character reference was not terminated by a semicolon');
                }
                codePoint = parseInt(hexDigits, 16);
                return codePointToSymbol(codePoint, strict);
            }
            if ($5) {
                reference = $5;
                if (has(decodeMap, reference)) {
                    return decodeMap[reference];
                } else {
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                }
            }
            reference = $6;
            next = $7;
            if (next && options.isAttributeValue) {
                if (strict && next == '=') {
                    parseError('`&` did not start a character reference');
                }
                return $0;
            } else {
                if (strict) {
                    parseError('named character reference was not terminated by a semicolon');
                }
                return decodeMapLegacy[reference] + (next || '');
            }
        });
    };
    decode.options = {
        'isAttributeValue': false,
        'strict': false
    };
    var escape = function (string) {
        return string.replace(regexEscape, function ($0) {
            return escapeMap[$0];
        });
    };
    var he = {
        'version': '1.1.1',
        'encode': encode,
        'decode': decode,
        'escape': escape,
        'unescape': decode
    };
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        define('he@1.1.1#he', function () {
            return he;
        });
    } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
            freeModule.exports = he;
        } else {
            for (var key in he) {
                has(he, key) && (freeExports[key] = he[key]);
            }
        }
    } else {
        root.he = he;
    }
}(this));
/*can-simple-dom@1.4.2#lib/html-parser*/
define('can-simple-dom@1.4.2#lib/html-parser', [
    'require',
    'exports',
    'module',
    'he'
], function (require, exports, module) {
    var he = require('he');
    function HTMLParser(tokenize, document, voidMap) {
        this.tokenize = tokenize;
        this.document = document;
        this.voidMap = voidMap;
        this.parentStack = [];
    }
    HTMLParser.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLParser.prototype.pushElement = function (token) {
        var el = this.document.createElement(token.tagName);
        for (var i = 0; i < token.attributes.length; i++) {
            var attr = token.attributes[i];
            if (attr[0] !== 'href' && attr[0] !== 'src') {
                attr[1] = he.encode(attr[1]);
            }
            el.setAttribute(attr[0], attr[1]);
        }
        if (this.isVoid(el) || token.selfClosing) {
            return this.appendChild(el);
        }
        this.parentStack.push(el);
    };
    HTMLParser.prototype.popElement = function (token) {
        var el = this.parentStack.pop();
        if (el.nodeName !== token.tagName.toUpperCase()) {
            throw new Error('unbalanced tag');
        }
        this.appendChild(el);
    };
    HTMLParser.prototype.appendText = function (token) {
        var text = this.document.createTextNode(token.chars);
        this.appendChild(text);
    };
    HTMLParser.prototype.appendComment = function (token) {
        var comment = this.document.createComment(token.chars);
        this.appendChild(comment);
    };
    HTMLParser.prototype.appendChild = function (node) {
        var parentNode = this.parentStack[this.parentStack.length - 1];
        parentNode.appendChild(node);
    };
    HTMLParser.prototype.parse = function (html) {
        var fragment = this.document.createDocumentFragment();
        this.parentStack.push(fragment);
        var tokens = this.tokenize(html);
        for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            switch (token.type) {
            case 'StartTag':
                this.pushElement(token);
                break;
            case 'EndTag':
                this.popElement(token);
                break;
            case 'Chars':
                this.appendText(token);
                break;
            case 'Comment':
                this.appendComment(token);
                break;
            }
        }
        return this.parentStack.pop();
    };
    module.exports = HTMLParser;
});
/*can-simple-dom@1.4.2#lib/html-serializer*/
define('can-simple-dom@1.4.2#lib/html-serializer', function (require, exports, module) {
    var REG_ESCAPE_ALL = /[<>&]/g;
    var REG_ESCAPE_PRESERVE_ENTITIES = /[<>]|&(?:#?[a-zA-Z0-9]+;)?/g;
    function HTMLSerializer(voidMap) {
        this.voidMap = voidMap;
    }
    HTMLSerializer.prototype.openTag = function (element) {
        return '<' + element.nodeName.toLowerCase() + this.attributes(element.attributes) + '>';
    };
    HTMLSerializer.prototype.closeTag = function (element) {
        return '</' + element.nodeName.toLowerCase() + '>';
    };
    HTMLSerializer.prototype.isVoid = function (element) {
        return this.voidMap[element.nodeName] === true;
    };
    HTMLSerializer.prototype.attributes = function (namedNodeMap) {
        var buffer = '';
        for (var i = 0, l = namedNodeMap.length; i < l; i++) {
            buffer += this.attr(namedNodeMap[i]);
        }
        return buffer;
    };
    HTMLSerializer.prototype.escapeAttrValue = function (attrValue) {
        return attrValue.replace(/"|&(?:#?[a-zA-Z0-9]+;)?/g, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '"':
                return '&quot;';
            default:
                return match;
            }
        });
    };
    HTMLSerializer.prototype.attr = function (attr) {
        if (!attr.specified) {
            return '';
        }
        if (attr.value) {
            if (attr.name === 'href' || attr.name === 'src') {
                return ' ' + attr.name + '="' + attr.value + '"';
            }
            return ' ' + attr.name + '="' + this.escapeAttrValue(attr.value) + '"';
        }
        return ' ' + attr.name;
    };
    HTMLSerializer.prototype.escapeText = function (textNodeValue, escapeAll) {
        return textNodeValue.replace(escapeAll ? REG_ESCAPE_ALL : REG_ESCAPE_PRESERVE_ENTITIES, function (match) {
            switch (match) {
            case '&':
                return '&amp;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            default:
                return match;
            }
        });
    };
    var metadataContentTags = {
        style: true,
        script: true,
        template: true
    };
    function isMetadataTag(elem) {
        return !!elem && metadataContentTags[elem.nodeName.toLowerCase()];
    }
    HTMLSerializer.prototype.text = function (text) {
        if (isMetadataTag(text.parentNode)) {
            return text.nodeValue;
        }
        return this.escapeText(text.nodeValue);
    };
    HTMLSerializer.prototype.comment = function (comment) {
        return '<!--' + comment.nodeValue + '-->';
    };
    HTMLSerializer.prototype.serialize = function (node) {
        var buffer = '';
        var next;
        switch (node.nodeType) {
        case 1:
            buffer += this.openTag(node);
            break;
        case 3:
            buffer += this.text(node);
            break;
        case 8:
            buffer += this.comment(node);
            break;
        default:
            break;
        }
        next = node.firstChild;
        if (next) {
            while (next) {
                buffer += this.serialize(next);
                next = next.nextSibling;
            }
        } else if (node.nodeType === 1 && node.textContent) {
            buffer += this.escapeText(node.textContent, true);
        }
        if (node.nodeType === 1 && !this.isVoid(node)) {
            buffer += this.closeTag(node);
        }
        return buffer;
    };
    module.exports = HTMLSerializer;
});
/*can-simple-dom@1.4.2#lib/void-map*/
define('can-simple-dom@1.4.2#lib/void-map', function (require, exports, module) {
    module.exports = {
        AREA: true,
        BASE: true,
        BR: true,
        COL: true,
        COMMAND: true,
        EMBED: true,
        HR: true,
        IMG: true,
        INPUT: true,
        KEYGEN: true,
        LINK: true,
        META: true,
        PARAM: true,
        SOURCE: true,
        TRACK: true,
        WBR: true
    };
});
/*can-simple-dom@1.4.2#lib/dom*/
define('can-simple-dom@1.4.2#lib/dom', [
    'require',
    'exports',
    'module',
    './document/node',
    './document/element',
    './document',
    './event',
    './html-parser',
    './html-serializer',
    './void-map'
], function (require, exports, module) {
    var Node = require('./document/node').Node;
    var Element = require('./document/element');
    var Document = require('./document');
    var Event = require('./event');
    var HTMLParser = require('./html-parser');
    var HTMLSerializer = require('./html-serializer');
    var voidMap = require('./void-map');
    function createDocument(serializer, parser) {
        var doc = new Document();
        doc.__serializer = serializer;
        doc.__parser = parser;
        return doc;
    }
    exports.Node = Node;
    exports.Element = Element;
    exports.Document = Document;
    exports.Event = Event;
    exports.HTMLParser = HTMLParser;
    exports.HTMLSerializer = HTMLSerializer;
    exports.voidMap = voidMap;
    exports.createDocument = createDocument;
});
/*can-simple-dom@1.4.2#can-simple-dom*/
define('can-simple-dom@1.4.2#can-simple-dom', [
    'require',
    'exports',
    'module',
    './lib/dom'
], function (require, exports, module) {
    var SimpleDOM = require('./lib/dom');
    if (typeof window !== 'undefined') {
        window.SimpleDOM = SimpleDOM;
    }
    exports = module.exports = SimpleDOM.Document;
    exports.Node = SimpleDOM.Node;
    exports.Element = SimpleDOM.Element;
    exports.Document = SimpleDOM.Document;
    exports.Event = SimpleDOM.Event;
    exports.HTMLParser = SimpleDOM.HTMLParser;
    exports.HTMLSerializer = SimpleDOM.HTMLSerializer;
    exports.voidMap = SimpleDOM.voidMap;
    exports.createDocument = SimpleDOM.createDocument;
});
/*can-vdom@3.2.5#make-parser/make-parser*/
define('can-vdom@3.2.5#make-parser/make-parser', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'can-simple-dom'
], function (require, exports, module) {
    var canParser = require('can-view-parser');
    var simpleDOM = require('can-simple-dom');
    module.exports = function (document) {
        return new simpleDOM.HTMLParser(function (string) {
            var tokens = [];
            var currentTag, currentAttr;
            canParser(string, {
                start: function (tagName, unary) {
                    currentTag = {
                        type: 'StartTag',
                        attributes: [],
                        tagName: tagName
                    };
                },
                end: function (tagName, unary) {
                    tokens.push(currentTag);
                    currentTag = undefined;
                },
                close: function (tagName) {
                    tokens.push({
                        type: 'EndTag',
                        tagName: tagName
                    });
                },
                attrStart: function (attrName) {
                    currentAttr = [
                        attrName,
                        ''
                    ];
                    currentTag.attributes.push(currentAttr);
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (value) {
                    currentAttr[1] += value;
                },
                chars: function (value) {
                    tokens.push({
                        type: 'Chars',
                        chars: value
                    });
                },
                comment: function (value) {
                    tokens.push({
                        type: 'Comment',
                        chars: value
                    });
                },
                special: function (value) {
                },
                done: function () {
                }
            });
            return tokens;
        }, document, simpleDOM.voidMap);
    };
});
/*can-vdom@3.2.5#make-document/make-document*/
define('can-vdom@3.2.5#make-document/make-document', [
    'require',
    'exports',
    'module',
    'can-simple-dom',
    '../make-parser/make-parser'
], function (require, exports, module) {
    var simpleDOM = require('can-simple-dom');
    var makeParser = require('../make-parser/make-parser');
    function CanSimpleDocument() {
        simpleDOM.Document.apply(this, arguments);
        var serializer = new simpleDOM.HTMLSerializer(simpleDOM.voidMap);
        var parser = makeParser(this);
        this.__addSerializerAndParser(serializer, parser);
    }
    CanSimpleDocument.prototype = new simpleDOM.Document();
    CanSimpleDocument.prototype.constructor = CanSimpleDocument;
    module.exports = function () {
        return new CanSimpleDocument();
    };
});
/*can-component@3.3.10#test/component-map-test*/
define('can-component@3.3.10#test/component-map-test', [
    'require',
    'exports',
    'module',
    './component-define-test',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-construct',
    'can-compute',
    'can-map',
    'can-list',
    'can-event',
    'can-view-model',
    'can-event/batch/batch',
    'can-util/dom/attr/attr',
    'can-util/dom/class-name/class-name',
    'can-util/dom/mutate/mutate',
    'can-util/dom/data/data',
    'can-types',
    'can-util/js/is-promise/is-promise',
    'can-globals',
    'can-vdom/make-document/make-document',
    'can-globals/document/document',
    'can-util/dom/fragment/fragment',
    'can-view-scope',
    'can-view-callbacks',
    'can-util/js/log/log'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        require('./component-define-test');
        var Component = require('can-component');
        var stache = require('can-stache');
        var QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var canCompute = require('can-compute');
        var CanMap = require('can-map');
        var CanList = require('can-list');
        var canEvent = require('can-event');
        var canViewModel = require('can-view-model');
        var canBatch = require('can-event/batch/batch');
        var attr = require('can-util/dom/attr/attr');
        var className = require('can-util/dom/class-name/class-name');
        var domMutate = require('can-util/dom/mutate/mutate');
        var domData = require('can-util/dom/data/data');
        var types = require('can-types');
        var isPromise = require('can-util/js/is-promise/is-promise');
        var globals = require('can-globals');
        var makeDocument = require('can-vdom/make-document/make-document');
        var getDocument = require('can-globals/document/document');
        var getFragment = require('can-util/dom/fragment/fragment');
        var Scope = require('can-view-scope');
        var viewCallbacks = require('can-view-callbacks');
        var canLog = require('can-util/js/log/log');
        var DOC = getDocument();
        var MUT_OBS = globals.getKeyValue('MutationObserver');
        makeTest('can-component - map - dom', document, MUT_OBS);
        makeTest('can-component - map - vdom', makeDocument(), null);
        var innerHTML = function (node) {
            if (node && 'innerHTML' in node) {
                return node.innerHTML;
            }
        };
        var runTasks = function (tasks) {
            var nextTask = function () {
                var next = tasks.shift();
                next();
                if (tasks.length) {
                    setTimeout(nextTask, 100);
                } else {
                    start();
                }
            };
            setTimeout(nextTask, 100);
        };
        function makeTest(name, doc, mutObs) {
            var oldDoc, oldDefaultMap;
            QUnit.module(name, {
                setup: function () {
                    getDocument(doc);
                    if (!mutObs) {
                        globals.setKeyValue('MutationObserver', mutObs);
                    }
                    oldDefaultMap = types.DefaultMap;
                    types.DefaultMap = CanMap;
                    if (doc) {
                        this.fixture = doc.createElement('div');
                        doc.body.appendChild(this.fixture);
                    } else {
                        this.fixture = doc.getElementById('qunit-fixture');
                    }
                },
                teardown: function () {
                    doc.body.removeChild(this.fixture);
                    stop();
                    setTimeout(function () {
                        types.DefaultMap = oldDefaultMap;
                        start();
                        getDocument(DOC);
                        globals.deleteKeyValue('MutationObserver');
                    }, 100);
                }
            });
            var Paginate = CanMap.extend({
                count: Infinity,
                offset: 0,
                limit: 100,
                setCount: function (newCount, success, error) {
                    return newCount < 0 ? 0 : newCount;
                },
                setOffset: function (newOffset) {
                    return newOffset < 0 ? 0 : Math.min(newOffset, !isNaN(this.count - 1) ? this.count - 1 : Infinity);
                },
                next: function () {
                    this.attr('offset', this.offset + this.limit);
                },
                prev: function () {
                    this.attr('offset', this.offset - this.limit);
                },
                canNext: function () {
                    return this.attr('offset') < this.attr('count') - this.attr('limit');
                },
                canPrev: function () {
                    return this.attr('offset') > 0;
                },
                page: function (newVal) {
                    if (newVal === undefined) {
                        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
                    } else {
                        this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));
                    }
                },
                pageCount: function () {
                    return this.attr('count') ? Math.ceil(this.attr('count') / this.attr('limit')) : null;
                }
            });
            test('lexical scoping', function () {
                Component.extend({
                    tag: 'hello-world',
                    view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                    viewModel: { greeting: 'Hello' }
                });
                var renderer = stache('<hello-world>{{greeting}}</hello-world>');
                var frag = renderer({
                    greeting: 'World',
                    exclamation: '!'
                });
                var hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello World');
                Component.extend({
                    tag: 'hello-world-no-template',
                    leakScope: false,
                    viewModel: { greeting: 'Hello' }
                });
                renderer = stache('<hello-world-no-template>{{greeting}}</hello-world-no-template>');
                frag = renderer({
                    greeting: 'World',
                    exclamation: '!'
                });
                hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello', 'If no view is provided to Component, treat <content> bindings as dynamic.');
            });
            test('dynamic scoping', function () {
                Component.extend({
                    tag: 'hello-world',
                    leakScope: true,
                    view: stache('{{greeting}} <content>World</content>{{exclamation}}'),
                    viewModel: { greeting: 'Hello' }
                });
                var renderer = stache('<hello-world>{{greeting}}</hello-world>');
                var frag = renderer({
                    greeting: 'World',
                    exclamation: '!'
                });
                var hello = frag.firstChild;
                equal(innerHTML(hello).trim(), 'Hello Hello!');
            });
            test('treecombo', function () {
                var TreeComboViewModel = CanMap.extend({
                    items: [],
                    breadcrumb: [],
                    selected: [],
                    selectableItems: function () {
                        var breadcrumb = this.attr('breadcrumb');
                        if (breadcrumb.attr('length')) {
                            return breadcrumb.attr('' + (breadcrumb.length - 1) + '.children');
                        } else {
                            return this.attr('items');
                        }
                    },
                    showChildren: function (item, el, ev) {
                        ev.stopPropagation();
                        this.attr('breadcrumb').push(item);
                    },
                    emptyBreadcrumb: function () {
                        this.attr('breadcrumb').attr([], true);
                    },
                    updateBreadcrumb: function (item) {
                        var breadcrumb = this.attr('breadcrumb'), index = breadcrumb.indexOf(item);
                        breadcrumb.splice(index + 1, breadcrumb.length - index - 1);
                    },
                    toggle: function (item) {
                        var selected = this.attr('selected'), index = selected.indexOf(item);
                        if (index === -1) {
                            selected.push(item);
                        } else {
                            selected.splice(index, 1);
                        }
                    },
                    isSelected: function (item) {
                        return this.attr('selected').indexOf(item) > -1;
                    }
                });
                Component.extend({
                    tag: 'treecombo',
                    view: stache('<ul class=\'breadcrumb\'>' + '<li can-click=\'emptyBreadcrumb\'>{{title}}</li>' + '{{#each breadcrumb}}' + '<li can-click=\'updateBreadcrumb\'>{{title}}</li>' + '{{/each}}' + '</ul>' + '<ul class=\'options\'>' + '<content>' + '{{#selectableItems}}' + '<li {{#isSelected(.)}}class=\'active\'{{/isSelected}} can-click=\'toggle\'>' + '<input type=\'checkbox\' {{#isSelected(.)}}checked{{/isSelected}}/>' + '{{title}}' + '{{#if children.length}}' + '<button class=\'showChildren\' can-click=\'showChildren\'>+</button>' + '{{/if}}' + '</li>' + '{{/selectableItems}}' + '</content>' + '</ul>'),
                    ViewModel: TreeComboViewModel
                });
                var renderer = stache('<treecombo {(items)}=\'locations\' title=\'Locations\'></treecombo>');
                var base = new CanMap({});
                var frag = renderer(base);
                var root = doc.createElement('div');
                root.appendChild(frag);
                var items = [
                    {
                        id: 1,
                        title: 'Midwest',
                        children: [
                            {
                                id: 5,
                                title: 'Illinois',
                                children: [
                                    {
                                        id: 23423,
                                        title: 'Chicago'
                                    },
                                    {
                                        id: 4563,
                                        title: 'Springfield'
                                    },
                                    {
                                        id: 4564,
                                        title: 'Naperville'
                                    }
                                ]
                            },
                            {
                                id: 6,
                                title: 'Wisconsin',
                                children: [
                                    {
                                        id: 232423,
                                        title: 'Milwaulkee'
                                    },
                                    {
                                        id: 45463,
                                        title: 'Green Bay'
                                    },
                                    {
                                        id: 45464,
                                        title: 'Madison'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        id: 2,
                        title: 'East Coast',
                        children: [
                            {
                                id: 25,
                                title: 'New York',
                                children: [
                                    {
                                        id: 3413,
                                        title: 'New York'
                                    },
                                    {
                                        id: 4613,
                                        title: 'Rochester'
                                    },
                                    {
                                        id: 4516,
                                        title: 'Syracuse'
                                    }
                                ]
                            },
                            {
                                id: 6,
                                title: 'Pennsylvania',
                                children: [
                                    {
                                        id: 2362423,
                                        title: 'Philadelphia'
                                    },
                                    {
                                        id: 454663,
                                        title: 'Harrisburg'
                                    },
                                    {
                                        id: 454664,
                                        title: 'Scranton'
                                    }
                                ]
                            }
                        ]
                    }
                ];
                stop();
                setTimeout(function () {
                    base.attr('locations', items);
                    var itemsList = base.attr('locations');
                    var treecombo = root.firstChild, breadcrumb = treecombo.firstChild, breadcrumbLIs = function () {
                            return breadcrumb.getElementsByTagName('li');
                        }, options = treecombo.lastChild, optionsLis = function () {
                            return options.getElementsByTagName('li');
                        };
                    equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                    equal(itemsList.length, optionsLis().length, 'first level items are displayed');
                    canEvent.trigger.call(optionsLis()[0], 'click');
                    equal(optionsLis()[0].className, 'active', 'toggling something not selected adds active');
                    ok(optionsLis()[0].getElementsByTagName('input')[0].checked, 'toggling something not selected checks checkbox');
                    equal(canViewModel(treecombo, 'selected').length, 1, 'there is one selected item');
                    equal(canViewModel(treecombo, 'selected.0'), itemsList.attr('0'), 'the midwest is in selected');
                    canViewModel(treecombo, 'selected').pop();
                    equal(optionsLis()[0].className, '', 'toggling something not selected adds active');
                    canEvent.trigger.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                    equal(breadcrumbLIs().length, 2, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                    ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    canEvent.trigger.call(optionsLis()[0].getElementsByTagName('button')[0], 'click');
                    ok(/Chicago/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    ok(!optionsLis()[0].getElementsByTagName('button').length, 'no show children button');
                    canEvent.trigger.call(breadcrumbLIs()[1], 'click');
                    equal(innerHTML(breadcrumbLIs()[1]), 'Midwest', 'The breadcrumb has an item in it');
                    ok(/Illinois/.test(innerHTML(optionsLis()[0])), 'A child of the top breadcrumb is displayed');
                    canEvent.trigger.call(breadcrumbLIs()[0], 'click');
                    equal(breadcrumbLIs().length, 1, 'Only the default title is shown');
                    equal(innerHTML(breadcrumbLIs()[0]), 'Locations', 'The correct title from the attribute is shown');
                    start();
                }, 100);
            });
            test('deferred grid', function () {
                var GridViewModel = CanMap.extend({
                    items: [],
                    waiting: true
                });
                Component.extend({
                    tag: 'grid',
                    ViewModel: GridViewModel,
                    view: stache('<table><tbody><content></content></tbody></table>'),
                    leakScope: true,
                    events: {
                        init: function () {
                            this.update();
                        },
                        '{viewModel} deferreddata': 'update',
                        update: function () {
                            var deferred = this.viewModel.attr('deferreddata'), viewModel = this.viewModel;
                            if (isPromise(deferred)) {
                                this.viewModel.attr('waiting', true);
                                deferred.then(function (items) {
                                    viewModel.attr('items').attr(items, true);
                                });
                            } else {
                                viewModel.attr('items').attr(deferred, true);
                            }
                        },
                        '{items} change': function () {
                            this.viewModel.attr('waiting', false);
                        }
                    }
                });
                var SimulatedScope = CanMap.extend({
                    set: 0,
                    deferredData: function () {
                        var deferred = {};
                        var promise = new Promise(function (resolve, reject) {
                            deferred.resolve = resolve;
                            deferred.reject = reject;
                        });
                        var set = this.attr('set');
                        if (set === 0) {
                            setTimeout(function () {
                                deferred.resolve([{
                                        first: 'Justin',
                                        last: 'Meyer'
                                    }]);
                            }, 100);
                        } else if (set === 1) {
                            setTimeout(function () {
                                deferred.resolve([{
                                        first: 'Brian',
                                        last: 'Moschel'
                                    }]);
                            }, 100);
                        }
                        return promise;
                    }
                });
                var viewModel = new SimulatedScope();
                var renderer = stache('<grid {(deferreddata)}=\'viewModel.deferredData\'>' + '{{#each items}}' + '<tr>' + '<td width=\'40%\'>{{first}}</td>' + '<td width=\'70%\'>{{last}}</td>' + '</tr>' + '{{/each}}' + '</grid>');
                domMutate.appendChild.call(this.fixture, renderer({ viewModel: viewModel }));
                var gridScope = canViewModel(this.fixture.firstChild);
                equal(gridScope.attr('waiting'), true, 'The grid is initially waiting on the deferreddata to resolve');
                stop();
                var self = this;
                var waitingHandler = function () {
                    gridScope.unbind('waiting', waitingHandler);
                    setTimeout(function () {
                        var tds = self.fixture.getElementsByTagName('td');
                        equal(tds.length, 2, 'there are 2 tds');
                        gridScope.bind('waiting', function (ev, newVal) {
                            if (newVal === false) {
                                setTimeout(function () {
                                    equal(innerHTML(tds[0]), 'Brian', 'td changed to brian');
                                    start();
                                }, 100);
                            }
                        });
                        viewModel.attr('set', 1);
                    }, 100);
                };
                gridScope.bind('waiting', waitingHandler);
            });
            test('nextprev', function () {
                Component.extend({
                    tag: 'next-prev',
                    view: stache('<a href="javascript://"' + 'class="prev {{#paginate.canPrev}}enabled{{/paginate.canPrev}}" on:click="paginate.prev()">Prev</a>' + '<a href="javascript://"' + 'class="next {{#paginate.canNext}}enabled{{/paginate.canNext}}" on:click="paginate.next()">Next</a>')
                });
                var paginator = new Paginate({
                    limit: 20,
                    offset: 0,
                    count: 100
                });
                var renderer = stache('<next-prev {(paginate)}=\'paginator\'></next-prev>');
                var frag = renderer({ paginator: paginator });
                var nextPrev = frag.firstChild;
                var prev = nextPrev.firstChild, next = nextPrev.lastChild;
                ok(!/enabled/.test(prev.className), 'prev is not enabled');
                ok(/enabled/.test(next.className), 'next is  enabled');
                canEvent.trigger.call(next, 'click');
                ok(/enabled/.test(prev.className), 'prev is enabled');
            });
            test('page-count', function () {
                Component.extend({
                    tag: 'page-count',
                    view: stache('Page <span>{{page}}</span>.')
                });
                var paginator = new Paginate({
                    limit: 20,
                    offset: 0,
                    count: 100
                });
                var renderer = stache('<page-count {(page)}=\'paginator.page\'></page-count>');
                var frag = renderer(new CanMap({ paginator: paginator }));
                var span = frag.firstChild.getElementsByTagName('span')[0];
                equal(span.firstChild.nodeValue, '1');
                paginator.next();
                equal(span.firstChild.nodeValue, '2');
                paginator.next();
                equal(span.firstChild.nodeValue, '3');
            });
            test('hello-world and whitespace around custom elements', function () {
                Component.extend({
                    tag: 'hello-world',
                    view: stache('{{#if visible}}{{message}}{{else}}Click me{{/if}}'),
                    viewModel: {
                        visible: false,
                        message: 'Hello There!'
                    },
                    events: {
                        click: function () {
                            this.viewModel.attr('visible', true);
                        }
                    }
                });
                var renderer = stache('  <hello-world></hello-world>  ');
                var frag = renderer({});
                var helloWorld = frag.childNodes.item(1);
                canEvent.trigger.call(helloWorld, 'click');
                equal(innerHTML(helloWorld), 'Hello There!');
            });
            test('self closing content tags', function () {
                Component.extend({
                    'tag': 'my-greeting',
                    view: stache('<h1><content/></h1>'),
                    viewModel: { title: 'Component' }
                });
                var renderer = stache('<my-greeting><span>{{site}} - {{title}}</span></my-greeting>');
                var frag = renderer({ site: 'CanJS' });
                equal(frag.firstChild.getElementsByTagName('span').length, 1, 'there is an h1');
            });
            test('canViewModel utility', function () {
                Component({
                    tag: 'my-taggy-tag',
                    view: stache('<h1>hello</h1>'),
                    viewModel: { foo: 'bar' }
                });
                var frag = stache('<my-taggy-tag id=\'x\'></my-taggy-tag>')();
                var el = frag.firstChild;
                equal(canViewModel(el), domData.get.call(el, 'viewModel'), 'one argument grabs the viewModel object');
                equal(canViewModel(el, 'foo'), 'bar', 'two arguments fetches a value');
                canViewModel(el, 'foo', 'baz');
                equal(canViewModel(el, 'foo'), 'baz', 'Three arguments sets the value');
            });
            test('canViewModel creates one if it doesn\'t exist', function () {
                var frag = stache('<div id=\'me\'></div>')();
                var el = frag.firstChild;
                var viewModel = canViewModel(el);
                ok(!!viewModel, 'viewModel created where it didn\'t exist.');
                equal(viewModel, domData.get.call(el, 'viewModel'), 'viewModel is in the data.');
            });
            test('setting passed variables - two way binding', function () {
                Component.extend({
                    tag: 'my-toggler',
                    view: stache('{{#if visible}}<content/>{{/if}}'),
                    leakScope: true,
                    viewModel: {
                        visible: true,
                        show: function () {
                            this.attr('visible', true);
                        },
                        hide: function () {
                            this.attr('visible', false);
                        }
                    }
                });
                Component.extend({
                    tag: 'my-app',
                    viewModel: {
                        visible: true,
                        show: function () {
                            this.attr('visible', true);
                        }
                    }
                });
                var renderer = stache('<my-app>' + '{{^visible}}<button can-click="show">show</button>{{/visible}}' + '<my-toggler {(visible)}="visible">' + 'content' + '<button can-click="hide">hide</button>' + '</my-toggler>' + '</my-app>');
                var frag = renderer({});
                var myApp = frag.firstChild, buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
                canEvent.trigger.call(buttons[0], 'click');
                buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'show', 'the button\'s text is show');
                canEvent.trigger.call(buttons[0], 'click');
                buttons = myApp.getElementsByTagName('button');
                equal(buttons.length, 1, 'there is one button');
                equal(innerHTML(buttons[0]), 'hide', 'the button\'s text is hide');
            });
            test('helpers reference the correct instance (#515)', function () {
                expect(2);
                Component({
                    tag: 'my-text',
                    view: stache('<p>{{valueHelper}}</p>'),
                    helpers: {
                        valueHelper: function () {
                            return this.attr('value');
                        }
                    }
                });
                var renderer = stache('<my-text value="value1"></my-text><my-text value="value2"></my-text>');
                var frag = renderer({});
                equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
                equal(frag.lastChild.firstChild.firstChild.nodeValue, 'value2');
            });
            test('access hypenated attributes via camelCase or hypenated', function () {
                Component({
                    tag: 'hyphen',
                    view: stache('<p>{{valueHelper}}</p>'),
                    helpers: {
                        valueHelper: function () {
                            return this.attr('camelCase');
                        }
                    }
                });
                var renderer = stache('<hyphen camel-case="value1"></hyphen>');
                var frag = renderer({});
                equal(frag.firstChild.firstChild.firstChild.nodeValue, 'value1');
            });
            test('a map as viewModel', function () {
                var me = new CanMap({ name: 'Justin' });
                Component.extend({
                    tag: 'my-viewmodel',
                    view: stache('{{name}}}'),
                    viewModel: me
                });
                var renderer = stache('<my-viewmodel></my-viewmodel>');
                equal(renderer().firstChild.firstChild.nodeValue, 'Justin');
            });
            test('a CanMap constructor as viewModel', function () {
                var MyMap = CanMap.extend({ name: 'Matthew' });
                Component.extend({
                    tag: 'can-map-viewmodel',
                    view: stache('{{name}}'),
                    viewModel: MyMap
                });
                var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
                equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
            });
            test('a CanMap constructor as scope', function () {
                var MyMap = CanMap.extend({ name: 'Matthew' });
                Component.extend({
                    tag: 'can-map-viewmodel',
                    view: stache('{{name}}'),
                    scope: MyMap
                });
                var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
                equal(renderer().firstChild.firstChild.nodeValue, 'Matthew');
            });
            test('an object is turned into a CanMap as viewModel', function () {
                Component.extend({
                    tag: 'can-map-viewmodel',
                    view: stache('{{name}}'),
                    viewModel: { name: 'Matthew' }
                });
                var renderer = stache('<can-map-viewmodel></can-map-viewmodel>');
                var fragOne = renderer();
                var vmOne = canViewModel(fragOne.firstChild);
                var fragTwo = renderer();
                var vmTwo = canViewModel(fragTwo.firstChild);
                vmOne.attr('name', 'Wilbur');
                equal(fragOne.firstChild.firstChild.nodeValue, 'Wilbur', 'The first map changed values');
                equal(fragTwo.firstChild.firstChild.nodeValue, 'Matthew', 'The second map did not change');
            });
            test('Providing viewModel and ViewModel throws', function () {
                try {
                    Component.extend({
                        tag: 'viewmodel-test',
                        view: stache('<div></div>'),
                        viewModel: {},
                        ViewModel: CanMap.extend({})
                    });
                    ok(false, 'Should have thrown because we provided both');
                } catch (er) {
                    ok(true, 'It threw because we provided both viewModel and ViewModel');
                }
            });
            test('content in a list', function () {
                var renderer = stache('<my-list>{{name}}</my-list>');
                Component.extend({
                    tag: 'my-list',
                    view: stache('{{#each items}}<li><content/></li>{{/each}}'),
                    leakScope: true,
                    viewModel: {
                        items: new CanList([
                            { name: 'one' },
                            { name: 'two' }
                        ])
                    }
                });
                var lis = renderer().firstChild.getElementsByTagName('li');
                equal(innerHTML(lis[0]), 'one', 'first li has correct content');
                equal(innerHTML(lis[1]), 'two', 'second li has correct content');
            });
            test('don\'t update computes unnecessarily', function () {
                var sourceAge = 30, timesComputeIsCalled = 0;
                var age = canCompute(function (newVal) {
                    timesComputeIsCalled++;
                    if (timesComputeIsCalled === 1) {
                        ok(true, 'reading initial value to set as years');
                    } else if (timesComputeIsCalled === 2) {
                        equal(newVal, 31, 'updating value to 31');
                    } else if (timesComputeIsCalled === 3) {
                        ok(true, 'called back another time after set to get the value');
                    } else {
                        ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
                    }
                    if (arguments.length) {
                        sourceAge = newVal;
                    } else {
                        return sourceAge;
                    }
                });
                Component.extend({ tag: 'age-er' });
                var renderer = stache('<age-er {(years)}=\'age\'></age-er>');
                renderer({ age: age });
                age(31);
            });
            test('component does not respect canCompute passed via attributes (#540)', function () {
                var data = { compute: canCompute(30) };
                Component.extend({
                    tag: 'my-component',
                    view: stache('<span>{{blocks}}</span>')
                });
                var renderer = stache('<my-component {(blocks)}=\'compute\'></my-component>');
                var frag = renderer(data);
                equal(innerHTML(frag.firstChild.firstChild), '30');
            });
            test('defined view models (#563)', function () {
                var HelloWorldModel = CanMap.extend({
                    visible: true,
                    toggle: function () {
                        this.attr('visible', !this.attr('visible'));
                    }
                });
                Component.extend({
                    tag: 'my-helloworld',
                    view: stache('<h1>{{#if visible}}visible{{else}}invisible{{/if}}</h1>'),
                    ViewModel: HelloWorldModel
                });
                var renderer = stache('<my-helloworld></my-helloworld>');
                var frag = renderer({});
                equal(innerHTML(frag.firstChild.firstChild), 'visible');
            });
            test('viewModel not rebound correctly (#550)', function () {
                var nameChanges = 0;
                Component.extend({
                    tag: 'viewmodel-rebinder',
                    events: {
                        '{name} change': function () {
                            nameChanges++;
                        }
                    }
                });
                var renderer = stache('<viewmodel-rebinder></viewmodel-rebinder>');
                var frag = renderer();
                var viewModel = canViewModel(frag.firstChild);
                var n1 = canCompute(), n2 = canCompute();
                viewModel.attr('name', n1);
                n1('updated');
                viewModel.attr('name', n2);
                n2('updated');
                equal(nameChanges, 2);
            });
            test('content extension stack overflow error', function () {
                Component({
                    tag: 'outer-tag',
                    view: stache('<inner-tag>inner-tag CONTENT <content/></inner-tag>')
                });
                Component({
                    tag: 'inner-tag',
                    view: stache('inner-tag TEMPLATE <content/>')
                });
                var renderer = stache('<outer-tag>outer-tag CONTENT</outer-tag>');
                var frag = renderer();
                equal(innerHTML(frag.firstChild.firstChild), 'inner-tag TEMPLATE inner-tag CONTENT outer-tag CONTENT');
            });
            test('inserted event fires twice if component inside live binding block', function () {
                var inited = 0, inserted = 0;
                Component.extend({
                    tag: 'child-tag',
                    ViewModel: CanMap.extend({
                        init: function () {
                            inited++;
                        }
                    }),
                    events: {
                        ' inserted': function () {
                            inserted++;
                        }
                    }
                });
                Component.extend({
                    tag: 'parent-tag',
                    view: stache('{{#shown}}<child-tag></child-tag>{{/shown}}'),
                    viewModel: { shown: false },
                    events: {
                        ' inserted': function () {
                            this.viewModel.attr('shown', true);
                        }
                    }
                });
                var frag = stache('<parent-tag id=\'pt\'></parent-tag>')({});
                domMutate.appendChild.call(this.fixture, frag);
                stop();
                function checkCount() {
                    if (inserted >= 1) {
                        equal(inited, 1, 'inited');
                        equal(inserted, 1, 'inserted');
                        start();
                    } else {
                        setTimeout(checkCount, 30);
                    }
                }
                checkCount();
            });
            test('@ keeps properties live now', function () {
                Component.extend({
                    tag: 'attr-fun',
                    view: stache('<h1>{{fullName}}</h1>'),
                    ViewModel: CanMap.extend({
                        fullName: function () {
                            return this.attr('firstName') + ' ' + this.attr('lastName');
                        }
                    })
                });
                var frag = stache('<attr-fun first-name=\'Justin\' last-name=\'Meyer\'></attr-fun>')();
                var attrFun = frag.firstChild;
                this.fixture.appendChild(attrFun);
                equal(innerHTML(attrFun.firstChild), 'Justin Meyer');
                attr.set(attrFun, 'first-name', 'Brian');
                stop();
                setTimeout(function () {
                    equal(attrFun.firstChild.firstChild.nodeValue, 'Brian Meyer');
                    start();
                }, 100);
            });
            test('id and class should work now (#694)', function () {
                Component.extend({
                    tag: 'stay-classy',
                    ViewModel: CanMap.extend({
                        notid: 'foo',
                        notclass: 5,
                        notdataviewid: {}
                    })
                });
                var data = {
                    idData: 'id-success',
                    classData: 'class-success'
                };
                var frag = stache('<stay-classy {(id)}=\'idData\'' + ' {(class)}=\'classData\'></stay-classy>')(data);
                var stayClassy = frag.firstChild;
                domMutate.appendChild.call(this.fixture, frag);
                var viewModel = canViewModel(stayClassy);
                equal(viewModel.attr('id'), 'id-success');
                equal(viewModel.attr('class'), 'class-success');
            });
            test('Component can-click method should be not called while component\'s init', function () {
                var called = false;
                Component.extend({ tag: 'child-tag' });
                Component.extend({
                    tag: 'parent-tag',
                    view: stache('<child-tag can-click="method"></child-tag>'),
                    viewModel: {
                        method: function () {
                            called = true;
                        }
                    }
                });
                stache('<parent-tag></parent-tag>')();
                equal(called, false);
            });
            test('Same component tag nested', function () {
                Component({
                    'tag': 'my-tag',
                    view: stache('<p><content/></p>')
                });
                var renderer = stache('<div><my-tag>Outter<my-tag>Inner</my-tag></my-tag></div>');
                var renderer2 = stache('<div><my-tag>3<my-tag>2<my-tag>1<my-tag>0</my-tag></my-tag></my-tag></my-tag></div>');
                var renderer3 = stache('<div><my-tag>First</my-tag><my-tag>Second</my-tag></div>');
                equal(renderer({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
                equal(renderer2({}).firstChild.getElementsByTagName('p').length, 4, 'proper number of p tags');
                equal(renderer3({}).firstChild.getElementsByTagName('p').length, 2, 'proper number of p tags');
            });
            test('Component events bind to window', function () {
                window.tempMap = new CanMap();
                Component.extend({
                    tag: 'window-events',
                    events: {
                        '{tempMap} prop': function () {
                            ok(true, 'called templated event');
                        }
                    }
                });
                var renderer = stache('<window-events></window-events>');
                renderer();
                window.tempMap.attr('prop', 'value');
                window.tempMap = undefined;
                try {
                    delete window.tempMap;
                } catch (e) {
                }
            });
            test('Construct are passed normally', function () {
                var Constructed = Construct.extend({ foo: 'bar' }, {});
                Component.extend({
                    tag: 'con-struct',
                    view: stache('{{con.foo}}')
                });
                var stached = stache('<con-struct {(con)}=\'Constructed\'></con-struct>');
                var res = stached({ Constructed: Constructed });
                equal(innerHTML(res.firstChild), 'bar');
            });
            test('passing id works now', function () {
                Component.extend({
                    tag: 'my-thing',
                    view: stache('hello')
                });
                var renderer = stache('<my-thing {(id)}=\'productId\'></my-tagged>');
                var frag = renderer(new CanMap({ productId: 123 }));
                equal(canViewModel(frag.firstChild).attr('id'), 123);
            });
            test('stache conditionally nested components calls inserted once (#967)', function () {
                expect(1);
                Component.extend({
                    tag: 'can-parent-stache',
                    viewModel: { shown: true },
                    view: stache('{{#if shown}}<can-child></can-child>{{/if}}')
                });
                Component.extend({
                    tag: 'can-child',
                    events: {
                        inserted: function () {
                            ok(true, 'called inserted once');
                        }
                    }
                });
                var renderer = stache('<can-parent-stache></can-parent-stache>');
                domMutate.appendChild.call(this.fixture, renderer());
                stop();
                setTimeout(start, 100);
            });
            test('hyphen-less tag names', function () {
                Component.extend({
                    tag: 'foobar',
                    view: stache('<div>{{name}}</div>'),
                    viewModel: { name: 'Brian' }
                });
                var renderer = stache('<span></span><foobar></foobar>');
                var frag = renderer();
                equal(frag.lastChild.firstChild.firstChild.nodeValue, 'Brian');
            });
            test('nested component within an #if is not live bound(#1025)', function () {
                Component.extend({
                    tag: 'parent-component',
                    view: stache('{{#if shown}}<child-component></child-component>{{/if}}'),
                    viewModel: { shown: false }
                });
                Component.extend({
                    tag: 'child-component',
                    view: stache('Hello world.')
                });
                var renderer = stache('<parent-component></parent-component>');
                var frag = renderer({});
                equal(innerHTML(frag.firstChild), '', 'child component is not inserted');
                canViewModel(frag.firstChild).attr('shown', true);
                equal(innerHTML(frag.firstChild.firstChild), 'Hello world.', 'child component is inserted');
                canViewModel(frag.firstChild).attr('shown', false);
                equal(innerHTML(frag.firstChild), '', 'child component is removed');
            });
            test('component does not update viewModel on id, class, and data-view-id attribute changes (#1079)', function () {
                Component.extend({ tag: 'x-app' });
                var frag = stache('<x-app></x-app>')({});
                var el = frag.firstChild;
                var viewModel = canViewModel(el);
                domMutate.appendChild.call(this.fixture, frag);
                className.add.call(el, 'foo');
                stop();
                setTimeout(function () {
                    equal(viewModel.attr('class'), undefined, 'the viewModel is not updated when the class attribute changes');
                    start();
                }, 100);
            });
            test('viewModel objects with Constructor functions as properties do not get converted (#1261)', 1, function () {
                stop();
                var Test = CanMap.extend({ test: 'Yeah' });
                Component.extend({
                    tag: 'my-app',
                    viewModel: { MyConstruct: Test },
                    events: {
                        '{MyConstruct} something': function () {
                            ok(true, 'Event got triggered');
                            start();
                        }
                    }
                });
                var frag = stache('<my-app></my-app>')();
                domMutate.appendChild.call(this.fixture, frag);
                canEvent.trigger.call(Test, 'something');
            });
            test('removing bound viewModel properties on destroy #1415', function () {
                var state = new CanMap({
                    product: {
                        id: 1,
                        name: 'Tom'
                    }
                });
                Component.extend({
                    tag: 'destroyable-component',
                    events: {
                        destroy: function () {
                            this.viewModel.attr('product', null);
                        }
                    }
                });
                var frag = stache('<destroyable-component product:bind="product"></destroyable-component>')(state);
                domMutate.appendChild.call(this.fixture, frag);
                domMutate.removeChild.call(this.fixture, this.fixture.firstChild);
                stop();
                setTimeout(function () {
                    ok(state.attr('product') == null, 'product was removed');
                    start();
                }, 100);
            });
            test('changing viewModel property rebinds {viewModel.<...>} events (#1529)', 2, function () {
                Component.extend({
                    tag: 'rebind-viewmodel',
                    events: {
                        init: function () {
                            this.viewModel.attr('item', {});
                        },
                        '{scope.item} change': function () {
                            ok(true, 'Change event on scope');
                        },
                        '{viewModel.item} change': function () {
                            ok(true, 'Change event on viewModel');
                        }
                    }
                });
                var frag = stache('<rebind-viewmodel></rebind-viewmodel>')();
                var rebind = frag.firstChild;
                domMutate.appendChild.call(this.fixture, rebind);
                canViewModel(rebind).attr('item.name', 'CDN');
            });
            test('Component two way binding loop (#1579)', function () {
                var changeCount = 0;
                Component.extend({
                    tag: 'product-swatch-color',
                    viewModel: { tag: 'product-swatch-color' }
                });
                Component.extend({
                    tag: 'product-swatch',
                    view: stache('<product-swatch-color variations:bind="variations"></product-swatch-color>'),
                    ViewModel: CanMap.extend({
                        tag: 'product-swatch',
                        define: {
                            variations: {
                                set: function (variations) {
                                    if (changeCount > 500) {
                                        return;
                                    }
                                    changeCount++;
                                    return new CanList(variations.attr());
                                }
                            }
                        }
                    })
                });
                var frag = stache('<product-swatch></product-swatch>')(), productSwatch = frag.firstChild;
                canBatch.start();
                canViewModel(productSwatch).attr('variations', new CanList());
                canBatch.stop();
                ok(changeCount < 500, 'more than 500 events');
            });
            test('references scopes are available to bindings nested in components (#2029)', function () {
                var renderer = stache('<export-er value:to="*reference" />' + '<wrap-er><simple-example key:from="*reference"/></wrap-er>');
                Component.extend({ tag: 'wrap-er' });
                Component.extend({
                    tag: 'export-er',
                    events: {
                        'init': function () {
                            var self = this.viewModel;
                            stop();
                            setTimeout(function () {
                                self.attr('value', 100);
                                var wrapper = frag.lastChild, simpleExample = wrapper.firstChild, textNode = simpleExample.firstChild;
                                equal(textNode.nodeValue, '100', 'updated value with reference');
                                start();
                            }, 100);
                        }
                    }
                });
                Component.extend({
                    tag: 'simple-example',
                    view: stache('{{key}}'),
                    viewModel: {}
                });
                var frag = renderer({});
            });
            test('two-way binding syntax PRIOR to v2.3 shall NOT let a child property initialize an undefined parent property (#2020)', function () {
                var renderer = stache('<pa-rent/>');
                Component.extend({
                    tag: 'pa-rent',
                    view: stache('<chi-ld child-prop="{parentProp}" />')
                });
                Component.extend({
                    tag: 'chi-ld',
                    viewModel: { childProp: 'bar' }
                });
                var frag = renderer({});
                var parentVM = canViewModel(frag.firstChild);
                var childVM = canViewModel(frag.firstChild.firstChild);
                equal(parentVM.attr('parentProp'), undefined, 'parentProp is undefined');
                equal(childVM.attr('childProp'), 'bar', 'childProp is bar');
                parentVM.attr('parentProp', 'foo');
                equal(parentVM.attr('parentProp'), 'foo', 'parentProp is foo');
                equal(childVM.attr('childProp'), 'foo', 'childProp is foo');
                childVM.attr('childProp', 'baz');
                equal(parentVM.attr('parentProp'), 'baz', 'parentProp is baz');
                equal(childVM.attr('childProp'), 'baz', 'childProp is baz');
            });
            test('two-way binding syntax INTRODUCED in v2.3 ALLOWS a child property to initialize an undefined parent property', function () {
                var renderer = stache('<pa-rent/>');
                Component.extend({
                    tag: 'pa-rent',
                    view: stache('<chi-ld {(child-prop)}="parentProp" />')
                });
                Component.extend({
                    tag: 'chi-ld',
                    viewModel: { childProp: 'bar' }
                });
                var frag = renderer({});
                var parentVM = canViewModel(frag.firstChild);
                var childVM = canViewModel(frag.firstChild.firstChild);
                equal(parentVM.attr('parentProp'), 'bar', 'parentProp is bar');
                equal(childVM.attr('childProp'), 'bar', 'childProp is bar');
                parentVM.attr('parentProp', 'foo');
                equal(parentVM.attr('parentProp'), 'foo', 'parentProp is foo');
                equal(childVM.attr('childProp'), 'foo', 'childProp is foo');
                childVM.attr('childProp', 'baz');
                equal(parentVM.attr('parentProp'), 'baz', 'parentProp is baz');
                equal(childVM.attr('childProp'), 'baz', 'childProp is baz');
            });
            test('conditional attributes (#2077)', function () {
                Component.extend({ tag: 'some-comp' });
                var renderer = stache('<some-comp ' + '{{#if preview}}{next}=\'nextPage\'{{/if}} ' + '{swap}=\'{{swapName}}\' ' + '{{#preview}}checked{{/preview}} ' + '></some-comp>');
                var map = new CanMap({
                    preview: true,
                    nextPage: 2,
                    swapName: 'preview'
                });
                var frag = renderer(map);
                var vm = canViewModel(frag.firstChild);
                var threads = [
                    function () {
                        equal(vm.attr('next'), 2, 'has binidng');
                        equal(vm.attr('swap'), true, 'swap - has binding');
                        equal(vm.attr('checked'), '', 'attr - has binding');
                        map.attr('preview', false);
                    },
                    function () {
                        equal(vm.attr('swap'), false, 'swap - updated binidng');
                        ok(vm.attr('checked') === null, 'attr - value set to null');
                        map.attr('nextPage', 3);
                        equal(vm.attr('next'), 2, 'not updating after binding is torn down');
                        map.attr('preview', true);
                    },
                    function () {
                        equal(vm.attr('next'), 3, 're-initialized with binding');
                        equal(vm.attr('swap'), true, 'swap - updated binidng');
                        equal(vm.attr('checked'), '', 'attr - has binding set again');
                        map.attr('swapName', 'nextPage');
                    },
                    function () {
                        equal(vm.attr('swap'), 3, 'swap - updated binding key');
                        map.attr('nextPage', 4);
                        equal(vm.attr('swap'), 4, 'swap - updated binding');
                    }
                ];
                stop();
                var index = 0;
                var next = function () {
                    if (index < threads.length) {
                        threads[index]();
                        index++;
                        setTimeout(next, 150);
                    } else {
                        start();
                    }
                };
                setTimeout(next, 100);
            });
            test('<content> (#2151)', function () {
                var mapInstance = new CanMap({
                    items: [
                        {
                            id: 1,
                            context: 'Item 1',
                            render: false
                        },
                        {
                            id: 2,
                            context: 'Item 2',
                            render: false
                        }
                    ]
                });
                Component.extend({
                    tag: 'list-items',
                    view: stache('<ul>' + '{{#items}}' + '{{#if render}}' + '<li><content /></li>' + '{{/if}}' + '{{/items}}' + '</ul>'),
                    viewModel: mapInstance,
                    leakScope: true
                });
                Component.extend({
                    tag: 'list-item',
                    view: stache('{{item.context}}')
                });
                var renderer = stache('<list-items><list-item item=\'{.}\'/></list-items>');
                var frag = renderer();
                canBatch.start();
                canViewModel(frag.firstChild).attr('items').each(function (item, index) {
                    item.attr('render', true);
                });
                canBatch.stop();
                var lis = frag.firstChild.getElementsByTagName('li');
                ok(innerHTML(lis[0]).indexOf('Item 1') >= 0, 'Item 1 written out');
                ok(innerHTML(lis[1]).indexOf('Item 2') >= 0, 'Item 2 written out');
            });
            test('one-way - child to parent - parent that does not leak scope, but has no view', function () {
                Component.extend({
                    tag: 'outer-noleak',
                    viewModel: { isOuter: true },
                    leakScope: false
                });
                Component.extend({
                    tag: 'my-child',
                    viewModel: { isChild: true },
                    leakScope: false
                });
                var renderer = stache('<outer-noleak><my-child {^.}=\'myChild\'/></outer-noleak>');
                var frag = renderer();
                var vm = canViewModel(frag.firstChild);
                ok(vm.attr('myChild') instanceof CanMap, 'got instance');
            });
            test('two-way - reference - with <content> tag', function () {
                Component.extend({
                    tag: 'other-export',
                    viewModel: { name: 'OTHER-EXPORT' }
                });
                Component.extend({
                    tag: 'ref-export',
                    view: stache('<other-export name:bind="*otherExport"/><content>{{*otherExport}}</content>')
                });
                var t1 = stache('<ref-export></ref-export>');
                var f1 = t1();
                equal(canViewModel(f1.firstChild.firstChild).attr('name'), 'OTHER-EXPORT', 'viewModel set correctly');
                equal(f1.firstChild.lastChild.nodeValue, 'OTHER-EXPORT', 'content');
            });
            test('custom renderer can provide setupBindings', function () {
                getDocument(document);
                var rendererFactory = function (tmpl) {
                    var frag = getFragment(tmpl);
                    return function (scope, options) {
                        scope = scope || new Scope();
                        options = options || new Scope.Options({});
                        if (frag.firstChild.nodeName === 'CUSTOM-RENDERER') {
                            viewCallbacks.tagHandler(frag.firstChild, 'custom-renderer', {
                                scope: scope,
                                options: options,
                                templateType: 'my-renderer',
                                setupBindings: function (el, callback, data) {
                                    callback({ foo: 'qux' });
                                }
                            });
                        } else {
                            var tn = frag.firstChild.firstChild;
                            tn.nodeValue = scope.read('foo').value;
                        }
                        return frag;
                    };
                };
                Component.extend({
                    tag: 'custom-renderer',
                    view: rendererFactory('<div>{{foo}}</div>'),
                    ViewModel: CanMap.extend({})
                });
                var renderer = rendererFactory('<custom-renderer foo=\'bar\'></custom-renderer>');
                var frag = renderer();
                var tn = frag.firstChild.firstChild.firstChild;
                equal(tn.nodeValue, 'qux', 'was bound!');
            });
            if (System.env !== 'canjs-test') {
                test('basic tabs', function () {
                    var TabsViewModel = CanMap.extend({
                        init: function () {
                            this.attr('panels', []);
                        },
                        addPanel: function (panel) {
                            if (this.attr('panels').length === 0) {
                                this.makeActive(panel);
                            }
                            this.attr('panels').push(panel);
                        },
                        removePanel: function (panel) {
                            var panels = this.attr('panels');
                            canBatch.start();
                            var index = panels.indexOf(panel);
                            canLog.log(index);
                            panels.splice(index, 1);
                            if (panel === this.attr('active')) {
                                if (panels.length) {
                                    this.makeActive(panels[0]);
                                } else {
                                    this.removeAttr('active');
                                }
                            }
                            canBatch.stop();
                        },
                        makeActive: function (panel) {
                            this.attr('active', panel);
                            this.attr('panels').each(function (panel) {
                                panel.attr('active', false);
                            });
                            panel.attr('active', true);
                        },
                        isActive: function (panel) {
                            return this.attr('active') === panel;
                        }
                    });
                    Component.extend({
                        tag: 'tabs',
                        ViewModel: TabsViewModel,
                        view: stache('<ul>' + '{{#panels}}' + '<li {{#isActive(.)}}class=\'active\'{{/isActive}} can-click=\'makeActive\'>{{title}}</li>' + '{{/panels}}' + '</ul>' + '<content></content>')
                    });
                    Component.extend({
                        view: stache('{{#if active}}<content></content>{{/if}}'),
                        tag: 'panel',
                        ViewModel: CanMap.extend({ active: false }),
                        events: {
                            ' inserted': function () {
                                canViewModel(this.element.parentNode).addPanel(this.viewModel);
                            },
                            ' beforeremove': function () {
                                canLog.log('I AM BEING REMOVED');
                                canViewModel(this.element.parentNode).removePanel(this.viewModel);
                            }
                        }
                    });
                    var renderer = stache('<tabs>{{#each foodTypes}}<panel title=\'{{title}}\'>{{content}}</panel>{{/each}}</tabs>');
                    var foodTypes = new CanList([
                        {
                            title: 'Fruits',
                            content: 'oranges, apples'
                        },
                        {
                            title: 'Breads',
                            content: 'pasta, cereal'
                        },
                        {
                            title: 'Sweets',
                            content: 'ice cream, candy'
                        }
                    ]);
                    var frag = renderer({ foodTypes: foodTypes });
                    domMutate.appendChild.call(this.fixture, frag);
                    var testArea = this.fixture;
                    stop();
                    runTasks([
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 3, 'three lis added');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            foodTypes.push({
                                title: 'Vegies',
                                content: 'carrots, kale'
                            });
                        },
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 4, 'li added');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            equal(testArea.getElementsByTagName('panel').length, 4, 'panel added');
                            canLog.log('SHIFTY');
                            foodTypes.shift();
                        },
                        function () {
                            var lis = testArea.getElementsByTagName('li');
                            equal(lis.length, 3, 'removed li after shifting a foodType');
                            foodTypes.each(function (type, i) {
                                equal(innerHTML(lis[i]), type.attr('title'), 'li ' + i + ' has the right content');
                            });
                            var panels = testArea.getElementsByTagName('panel');
                            equal(lis[0].className, 'active', 'the first element is active');
                            equal(innerHTML(panels[0]), 'pasta, cereal', 'the first content is shown');
                            equal(innerHTML(panels[1]), '', 'the second content is removed');
                            canEvent.trigger.call(lis[1], 'click');
                            lis = testArea.getElementsByTagName('li');
                            equal(lis[1].className, 'active', 'the second element is active');
                            equal(lis[0].className, '', 'the first element is not active');
                            equal(innerHTML(panels[0]), '', 'the second content is removed');
                            equal(innerHTML(panels[1]), 'ice cream, candy', 'the second content is shown');
                        }
                    ]);
                });
                test('DOM trees not releasing when referencing CanMap inside CanMap in view (#1593)', function () {
                    var baseTemplate = stache('{{#if show}}<my-outside></my-outside>{{/if}}'), show = canCompute(true), state = new CanMap({ inner: 1 });
                    var removeCount = 0;
                    Component.extend({
                        tag: 'my-inside',
                        events: {
                            removed: function () {
                                removeCount++;
                            }
                        },
                        leakScope: true
                    });
                    Component.extend({
                        tag: 'my-outside',
                        view: stache('{{#if state.inner}}<my-inside></my-inside>{{/if}}'),
                        leakScope: true
                    });
                    domMutate.appendChild.call(this.fixture, baseTemplate({
                        show: show,
                        state: state
                    }));
                    runTasks([
                        function () {
                            show(false);
                        },
                        function () {
                            state.removeAttr('inner');
                        },
                        function () {
                            equal(removeCount, 1, 'internal removed once');
                            show(true);
                        },
                        function () {
                            state.attr('inner', 2);
                        },
                        function () {
                            state.removeAttr('inner');
                        },
                        function () {
                            equal(removeCount, 2, 'internal removed twice');
                        }
                    ]);
                    stop();
                });
            }
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-component@3.3.10#test/component-slot-test*/
define('can-component@3.3.10#test/component-slot-test', [
    'require',
    'exports',
    'module',
    'can-component',
    'can-stache',
    'steal-qunit',
    'can-define/map/map',
    'can-view-model'
], function (require, exports, module) {
    var Component = require('can-component');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var viewModel = require('can-view-model');
    QUnit.module('can-components - can-slots');
    test('<can-slot> Works', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Later Gator');
    });
    test('<can-slot> leakScope false acts as expected', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="body" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '<can-template name="body">' + '{{body}}' + '</can-template>' + '</my-email>');
        var testView = renderer({
            subject: 'foo',
            body: 'bar'
        });
        equal(testView.firstChild.childNodes[0].nodeValue, 'foo');
        equal(testView.firstChild.childNodes[1].nodeValue, 'bar');
    });
    test('<can-slot> Re-use templates', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<can-slot name="subject" />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '{{subject}}' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Hello World');
    });
    test('<can-slot> Works with default content', function () {
        var ViewModel = DefineMap.extend({});
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject">' + 'Default Content' + '</can-slot>'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject" />' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.innerHTML, 'Default Content');
    });
    test('<can-slot> Works in a self-closing template', function () {
        var ViewModel = DefineMap.extend({});
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject">' + 'Default Content' + '</can-slot>'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email/>');
        var testView = renderer();
        equal(testView.firstChild.innerHTML, 'Default Content');
    });
    test('<can-slot> Context one-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:from="subject" />'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><span>{{this}}</span></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
    });
    test('<can-slot> Context two-way binding works', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {}, { subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:bind="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}')
        });
        var vm = 'Hello World';
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject subject:bind="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Hello World');
        vm.subject = 'Later Gator';
        equal(frag.firstChild.firstChild.innerHTML, 'Later Gator');
        childVM.subject = 'After a while crocodile';
        equal(vm.subject, 'After a while crocodile');
    });
    test('<can-slot> Context child-to-parent binding works', function () {
        var ViewModel = DefineMap.extend({ subject: { value: 'Hello World' } });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="foo" this:to="subject" />'),
            ViewModel: ViewModel
        });
        Component.extend({
            tag: 'my-subject',
            view: stache('{{subject}}'),
            ViewModel: DefineMap.extend({ subject: { value: 'Yo' } })
        });
        var renderer = stache('<my-email>' + '<can-template name="foo"><my-subject subject:to="this" /></can-template>' + '</my-email>');
        var frag = renderer();
        var vm = viewModel(frag.firstChild);
        var childVM = viewModel(frag.firstChild.firstChild);
        equal(frag.firstChild.firstChild.innerHTML, 'Yo');
        childVM.subject = 'bar';
        equal(frag.firstChild.firstChild.innerHTML, 'bar');
        equal(vm.subject, 'bar');
    });
    test('<can-slot> Works alongside <content>', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content />'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '<span>Some content</span>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].firstChild.nodeValue, 'Some content');
    });
    test('<can-slot> Works alongside <content> with default content', function () {
        var ViewModel = DefineMap.extend({
            subject: { value: 'Hello World' },
            body: { value: 'Later Gator' }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('<can-slot name="subject" />' + '<content>Default content</content>'),
            ViewModel: ViewModel,
            leakScope: true
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{subject}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.childNodes[0].firstChild.nodeValue, 'Hello World');
        equal(testView.firstChild.childNodes[1].nodeValue, 'Default content');
    });
    test('<can-slot> Can be used conditionally and will remove bindings', function () {
        var ViewModel = DefineMap.extend('MyEmailVM', {
            subject: { value: 'Hello World' },
            showSubject: { value: true }
        });
        Component.extend({
            tag: 'my-email',
            view: stache('{{#if showSubject}}<can-slot name="subject" this:from="subject" />{{/if}}'),
            ViewModel: ViewModel
        });
        var renderer = stache('<my-email>' + '<can-template name="subject">' + '<p>{{this}}</p>' + '</can-template>' + '</my-email>');
        var testView = renderer();
        equal(testView.firstChild.firstChild.firstChild.nodeValue, 'Hello World');
        var vm = viewModel(testView.firstChild);
        vm.showSubject = false;
        QUnit.stop();
        QUnit.equal(testView.firstChild.children.length, 0);
        setTimeout(function () {
            QUnit.equal(vm.__bindEvents.subject.length, 0);
            QUnit.start();
        }, 50);
    });
});
/*can-component@3.3.10#test/component-test*/
define('can-component@3.3.10#test/component-test', [
    'require',
    'exports',
    'module',
    './component-define-test',
    './component-map-test',
    './component-slot-test'
], function (require, exports, module) {
    require('./component-define-test');
    require('./component-map-test');
    require('./component-slot-test');
});
/*can@3.14.0#component/component_test*/
define('can@3.14.0#component/component_test', [
    'require',
    'exports',
    'module',
    'can-component/test/component-test'
], function (require, exports, module) {
    require('can-component/test/component-test');
});
/*can-event@3.7.7#async/async*/
define('can-event@3.7.7#async/async', [
    'require',
    'exports',
    'module',
    'can-event',
    'can-event/batch/batch',
    'can-util/js/set-immediate/set-immediate',
    'can-util/js/global/global',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var canEvent = require('can-event');
        var canBatch = require('can-event/batch/batch');
        var setImmediate = require('can-util/js/set-immediate/set-immediate');
        var GLOBAL = require('can-util/js/global/global')();
        var assign = require('can-util/js/assign/assign');
        var timeout;
        var clearImmediate = GLOBAL.clearImmediate || GLOBAL.clearTimeout;
        var syncBatchDispatch = canBatch.dispatch;
        var syncBatchQueue = canBatch.queue;
        var syncBatchFlush = canBatch.flush;
        var asyncMethods = {
            dispatch: function (ev) {
                var batchNum = typeof ev === 'object' && ev.batchNum;
                if (!canBatch.collecting() && (!batchNum || canBatch.batchNum !== batchNum)) {
                    canBatch.start();
                    timeout = setImmediate(canBatch.stop);
                }
                return syncBatchDispatch.apply(this, arguments);
            },
            queue: function () {
                if (!canBatch.collecting()) {
                    canBatch.start();
                    timeout = setImmediate(canBatch.stop);
                }
                return syncBatchQueue.apply(this, arguments);
            },
            flush: function () {
                if (isAsync && canBatch.collecting()) {
                    clearImmediate(timeout);
                    canBatch.stop();
                }
                canBatch.flush();
            }
        };
        var syncMethods = assign({ flush: syncBatchFlush }, canEvent);
        var isAsync = false;
        var eventAsync = {
            async: function () {
                assign(canEvent, asyncMethods);
                isAsync = true;
            },
            sync: function () {
                if (canBatch.collecting()) {
                    clearImmediate(timeout);
                    canBatch.stop();
                }
                assign(canEvent, syncMethods);
                isAsync = false;
            }
        };
        assign(eventAsync, asyncMethods);
        module.exports = eventAsync;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-compute@3.3.10#can-compute-async-test*/
define('can-compute@3.3.10#can-compute-async-test', [
    'require',
    'exports',
    'module',
    'can-compute',
    'steal-qunit',
    'can-event/batch/batch',
    'can-event/async/async',
    'can-event/async/async',
    'can-event/async/async',
    'can-compute'
], function (require, exports, module) {
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    require('can-event/batch/batch');
    var canAsync = require('can-event/async/async');
    QUnit.module('can-compute async', {
        setup: function () {
            canAsync.async();
        },
        teardown: function () {
            canAsync.sync();
        }
    });
    QUnit.asyncTest('async basics', 2, function () {
        var canAsync = require('can-event/async/async');
        canAsync.async();
        var first = compute('Justin');
        var last = compute('Meyer');
        var fullName = compute(function () {
            return first() + ' ' + last();
        });
        fullName.on('change', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Payal Shah', 'newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'oldVal');
            QUnit.start();
        });
        first('Payal');
        last('Shah');
    });
    QUnit.asyncTest('async can immediately read', 4, function () {
        var canAsync = require('can-event/async/async');
        canAsync.async();
        var compute = require('can-compute');
        var first = compute('Justin');
        var last = compute('Meyer');
        var fullName = compute(function () {
            return first() + ' ' + last();
        });
        var firedEvents = false;
        fullName.on('change', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'Payal Shah', 'change newVal');
            QUnit.equal(oldVal, 'Justin Meyer', 'change oldVal');
            firedEvents = true;
            QUnit.start();
        });
        first('Payal');
        last('Shah');
        QUnit.equal(fullName(), 'Payal Shah');
        QUnit.ok(firedEvents, 'fired events');
    });
    test('setting compute.async with a observable dependency gets a new value and can re-compute', 4, function () {
        var c = compute(1);
        var add;
        var async = compute.async(1, function (curVal) {
            add = curVal;
            return c() + add;
        });
        equal(async(), 2, 'can read unbound');
        async.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'change new val');
            equal(oldVal, 2, 'change old val');
        });
        async(2);
        equal(async(), 3, 'can read unbound');
    });
    test('compute.async getter has correct when length === 1', function () {
        var m = {};
        var getterCompute = compute.async(false, function (singleArg) {
            equal(this, m, 'getter has the right context');
        }, m);
        getterCompute.bind('change', function () {
        });
    });
});
/*can-compute@3.3.10#proto-compute_test*/
define('can-compute@3.3.10#proto-compute_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-compute/proto-compute',
    'can-event/batch/',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var Compute = require('can-compute/proto-compute');
    var canBatch = require('can-event/batch/');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    QUnit.module('can/Compute');
    test('single value compute', function () {
        expect(2);
        var num = new Compute(1);
        num.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num.set(2);
    });
    test('inner computes values are not bound to', function () {
        var num = new Compute(1), numBind = num.addEventListener, numUnbind = num.removeEventListener;
        var bindCount = 0;
        num.addEventListener = function () {
            bindCount++;
            return numBind.apply(this, arguments);
        };
        num.removeEventListener = function () {
            bindCount--;
            return numUnbind.apply(this, arguments);
        };
        var outer = new Compute(function () {
            var inner = new Compute(function () {
                return num.get() + 1;
            });
            return 2 * inner.get();
        });
        var handler = function () {
        };
        outer.bind('change', handler);
        stop();
        setTimeout(function () {
            equal(bindCount, 1, 'compute only bound to once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var num = new Compute(3);
        var truthy = Compute.truthy(num);
        var tester = new Compute(function () {
            if (truthy.get()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.bind('change', function (ev, newVal, oldVal) {
            if (num.get() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num.get() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester.get(), 1, 'on bind, we call tester once');
        num.set(2);
        num.set(1);
        num.set(0);
        num.set(-1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = new Compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = new Compute(function () {
            return 'I am ' + age.get();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info.get(), 'I am 30');
        age.set(31);
        equal(info.get(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = new Compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned.set('-');
        equal(cloned.get(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = new Compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value.get(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value.set(2);
        equal(value.get(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value.get(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = new Compute('a');
        var computeB = new Compute('b');
        var combined1 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combined2 = new Compute(function () {
            return computeA.get() + ' ' + computeB.get();
        });
        var combo = new Compute(function () {
            return combined1.get() + ' ' + combined2.get();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        canBatch.start();
        computeA.set('A');
        computeB.set('B');
        canBatch.stop();
    });
    test('Compute.async can be like a normal getter', function () {
        var first = new Compute('Justin'), last = new Compute('Meyer'), fullName = Compute.async('', function () {
                return first.get() + ' ' + last.get();
            });
        equal(fullName.get(), 'Justin Meyer');
    });
    test('Compute.async operate on single value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var obj = Compute.async({}, function (curVal) {
            if (a.get()) {
                curVal.a = a.get();
            } else {
                delete curVal.a;
            }
            if (b.get()) {
                curVal.b = b.get();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj.get(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a.set(0);
        deepEqual(obj.get(), { b: 2 }, 'removed a');
        b.set(0);
        deepEqual(obj.get(), {}, 'removed b');
    });
    test('Compute.async async changing value', function () {
        var a = new Compute(1);
        var b = new Compute(2);
        var async = Compute.async(undefined, function (curVal, setVal) {
            if (a.get()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b.get()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a.set(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b.set(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('Compute.async read without binding', function () {
        var source = new Compute(1);
        var async = Compute.async([], function (curVal, setVal) {
            curVal.push(source.get());
            return curVal;
        });
        ok(async.get(), 'calling async worked');
    });
    test('Compute.async set uses last set or initial value', function () {
        var add = new Compute(1);
        var fnCount = 0;
        var async = Compute.async(10, function (curVal) {
            switch (fnCount++) {
            case 0:
                equal(curVal, 10);
                break;
            case 1:
                equal(curVal, 20);
                break;
            case 2:
                equal(curVal, 30, 'on bind');
                break;
            case 3:
                equal(curVal, 30, 'on bind');
                break;
            }
            return curVal + add.get();
        });
        equal(async.get(), 11, 'initial value');
        async.set(20);
        async.bind('change', function () {
        });
        async.set(20);
        async.set(30);
    });
    test('Change propagation in a batch with late bindings (#2412)', function () {
        var rootA = new Compute('a');
        var rootB = new Compute('b');
        var childA = new Compute(function () {
            return 'childA' + rootA.get();
        });
        var grandChild = new Compute(function () {
            var b = rootB.get();
            if (b === 'b') {
                return 'grandChild->b';
            }
            var a = childA.get();
            return 'grandChild->' + a;
        });
        childA.bind('change', function (ev, newVal, oldVal) {
        });
        grandChild.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 'grandChild->childAA');
        });
        canBatch.start();
        rootA.set('A');
        rootB.set('B');
        canBatch.stop();
    });
    if (Compute.prototype.trace) {
        test('trace', function () {
            var rootA = new Compute('a');
            var rootB = new Compute('b');
            var childA = new Compute(function () {
                return 'childA' + rootA.get();
            });
            var fn = function () {
                var b = rootB.get();
                if (b === 'b') {
                    return 'grandChild->b';
                }
                var a = childA.get();
                return 'grandChild->' + a;
            };
            var grandChild = new Compute(fn);
            childA.bind('change', function (ev, newVal, oldVal) {
            });
            grandChild.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 'grandChild->childAA');
            });
            var out = grandChild.trace();
            equal(out.definition, fn, 'got the right function');
            equal(out.computeValue, 'grandChild->b');
            grandChild.log();
            canBatch.start();
            rootA.set('A');
            rootB.set('B');
            canBatch.stop();
            grandChild.log();
        });
    }
    test('works with can-reflect', 5, function () {
        var c = new Compute(0);
        QUnit.equal(canReflect.getValue(c), 0, 'unbound value');
        QUnit.ok(canReflect.isValueLike(c), 'isValueLike is true');
        QUnit.ok(!canReflect.valueHasDependencies(c), 'valueHasDependencies -- false');
        var d = new Compute(function () {
            return c.get();
        });
        d.on('change', function () {
        });
        QUnit.ok(canReflect.valueHasDependencies(d), 'valueHasDependencies -- true');
        c.set(1);
        QUnit.equal(canReflect.getValue(d), 1, 'bound value');
        c.set(2);
    });
    QUnit.test('can-reflect setValue', function () {
        var a = new Compute('a');
        canReflect.setValue(a, 'A');
        QUnit.equal(a.get(), 'A', 'compute');
    });
    QUnit.test('registered symbols', function () {
        var a = new Compute('a');
        ok(a[canSymbol.for('can.isValueLike')], 'can.isValueLike');
        equal(a[canSymbol.for('can.getValue')](), 'a', 'can.getValue');
        a[canSymbol.for('can.setValue')]('b');
        equal(a.get(), 'b', 'can.setValue');
        function handler(val) {
            equal(val, 'c', 'can.onValue');
        }
        a[canSymbol.for('can.onValue')](handler);
        a.set('c');
        a[canSymbol.for('can.offValue')](handler);
        a.set('d');
    });
});
/*can-compute@3.3.10#can-compute_test*/
define('can-compute@3.3.10#can-compute_test', [
    'require',
    'exports',
    'module',
    './can-compute-async-test',
    './proto-compute_test',
    'can-compute',
    'steal-qunit',
    'can-event/batch/',
    'can-observation',
    'can-util/dom/dispatch/dispatch',
    'can-symbol',
    'can-reflect'
], function (require, exports, module) {
    require('./can-compute-async-test');
    require('./proto-compute_test');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    var canBatch = require('can-event/batch/');
    var Observation = require('can-observation');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    QUnit.module('can/compute');
    test('single value compute', function () {
        var num = compute(1);
        num.on('change', function (ev, newVal, oldVal) {
            equal(newVal, 2, 'newVal');
            equal(oldVal, 1, 'oldVal');
        });
        num(2);
    });
    test('inner computes values are not bound to', function () {
        var num = compute(1);
        var outer = compute(function () {
            var inner = compute(function () {
                return num() + 1;
            });
            return 2 * inner();
        });
        var handler = function () {
        };
        outer.on('change', handler);
        stop();
        setTimeout(function () {
            equal(num.computeInstance.__bindEvents._lifecycleBindings, 1, 'inner compute only bound once');
            equal(outer.computeInstance.__bindEvents._lifecycleBindings, 1, 'outer compute only bound once');
            start();
        }, 50);
    });
    test('compute.truthy', function () {
        var result = 0;
        var numValue;
        var num = compute(numValue = 3);
        var truthy = compute.truthy(num);
        var tester = compute(function () {
            if (truthy()) {
                return ++result;
            } else {
                return ++result;
            }
        });
        tester.addEventListener('change', function (ev, newVal, oldVal) {
            if (num() === 0) {
                equal(newVal, 2, '2 is the new val');
            } else if (num() === -1) {
                equal(newVal, 3, '3 is the new val');
            } else {
                ok(false, 'change should not be called');
            }
        });
        equal(tester(), 1, 'on bind, we call tester once');
        num(numValue = 2);
        num(numValue = 1);
        num(numValue = 0);
        num(numValue = -1);
    });
    test('a binding compute does not double read', function () {
        var sourceAge = 30, timesComputeIsCalled = 0;
        var age = compute(function (newVal) {
            timesComputeIsCalled++;
            if (timesComputeIsCalled === 1) {
                ok(true, 'reading age to get value');
            } else if (timesComputeIsCalled === 2) {
                equal(newVal, 31, 'the second time should be an update');
            } else if (timesComputeIsCalled === 3) {
                ok(true, 'called after set to get the value');
            } else {
                ok(false, 'You\'ve called the callback ' + timesComputeIsCalled + ' times');
            }
            if (arguments.length) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var info = compute(function () {
            return 'I am ' + age();
        });
        var k = function () {
        };
        info.bind('change', k);
        equal(info(), 'I am 30');
        age(31);
        equal(info(), 'I am 31');
    });
    test('cloning a setter compute (#547)', function () {
        var name = compute('', function (newVal) {
            return this.txt + newVal;
        });
        var cloned = name.clone({ txt: '.' });
        cloned('-');
        equal(cloned(), '.-');
    });
    test('compute updated method uses get and old value (#732)', function () {
        expect(9);
        var input = { value: 1 };
        var value = compute('', {
            get: function () {
                return input.value;
            },
            set: function (newVal) {
                input.value = newVal;
            },
            on: function (update) {
                input.onchange = update;
            },
            off: function () {
                delete input.onchange;
            }
        });
        equal(value(), 1, 'original value');
        ok(!input.onchange, 'nothing bound');
        value(2);
        equal(value(), 2, 'updated value');
        equal(input.value, 2, 'updated input.value');
        value.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 3, 'newVal');
            equal(oldVal, 2, 'oldVal');
            value.unbind('change', this.Constructor);
        });
        ok(input.onchange, 'binding to onchange');
        input.value = 3;
        input.onchange({});
        ok(!input.onchange, 'removed binding');
        equal(value(), 3);
    });
    test('a compute updated by source changes within a batch is part of that batch', function () {
        var computeA = compute('a');
        var computeB = compute('b');
        var combined1 = compute(function () {
            return computeA() + ' ' + computeB();
        });
        var combined2 = compute(function () {
            return computeA() + ' ' + computeB();
        });
        var combo = compute(function () {
            return combined1() + ' ' + combined2();
        });
        var callbacks = 0;
        combo.bind('change', function () {
            if (callbacks === 0) {
                ok(true, 'called change once');
            } else {
                ok(false, 'called change multiple times');
            }
            callbacks++;
        });
        canBatch.start();
        computeA('A');
        computeB('B');
        canBatch.stop();
    });
    test('compute.async can be like a normal getter', function () {
        var first = compute('Justin'), last = compute('Meyer'), fullName = compute.async('', function () {
                return first() + ' ' + last();
            });
        equal(fullName(), 'Justin Meyer');
    });
    test('compute.async operate on single value', function () {
        var a = compute(1);
        var b = compute(2);
        var obj = compute.async({}, function (curVal) {
            if (a()) {
                curVal.a = a();
            } else {
                delete curVal.a;
            }
            if (b()) {
                curVal.b = b();
            } else {
                delete curVal.b;
            }
            return curVal;
        });
        obj.bind('change', function () {
        });
        deepEqual(obj(), {
            a: 1,
            b: 2
        }, 'object has all properties');
        a(0);
        deepEqual(obj(), { b: 2 }, 'removed a');
        b(0);
        deepEqual(obj(), {}, 'removed b');
    });
    test('compute.async async changing value', function () {
        var a = compute(1);
        var b = compute(2);
        var async = compute.async(undefined, function (curVal, setVal) {
            if (a()) {
                setTimeout(function () {
                    setVal('a');
                }, 10);
            } else if (b()) {
                setTimeout(function () {
                    setVal('b');
                }, 10);
            } else {
                return null;
            }
        });
        var changeArgs = [
                {
                    newVal: 'a',
                    oldVal: undefined,
                    run: function () {
                        a(0);
                    }
                },
                {
                    newVal: 'b',
                    oldVal: 'a',
                    run: function () {
                        b(0);
                    }
                },
                {
                    newVal: null,
                    oldVal: 'b',
                    run: function () {
                        start();
                    }
                }
            ], changeNum = 0;
        stop();
        async.bind('change', function (ev, newVal, oldVal) {
            var data = changeArgs[changeNum++];
            equal(newVal, data.newVal, 'newVal is correct');
            equal(oldVal, data.oldVal, 'oldVal is correct');
            setTimeout(data.run, 10);
        });
    });
    test('compute.async read without binding', function () {
        var source = compute(1);
        var async = compute.async([], function (curVal, setVal) {
            curVal.push(source());
            return curVal;
        });
        ok(async(), 'calling async worked');
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        canBatch.start();
        root('b');
        canBatch.stop();
        equal(combined(), true);
    });
    test('compute change handler context is set to the function not compute', function () {
        var comp = compute(null);
        comp.bind('change', function () {
            equal(typeof this, 'function');
        });
        comp('test');
    });
    test('Calling .unbind() on un-bound compute does not throw an error', function () {
        var count = compute(0);
        count.unbind('change');
        ok(true, 'No error was thrown');
    });
    test('dependent computes update in the right order (2093)', function () {
        var root = compute('a'), childB = compute(function () {
                return root();
            }), combine = compute(function () {
                return root() + childB();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        root('b');
    });
    test('dependent computes update in the right order with a batch (#2093)', function () {
        var root = compute('a'), child = compute(function () {
                return root();
            }), child2 = compute(function () {
                return root();
            }), grandChild = compute(function () {
                return child();
            }), combine = compute(function () {
                return child2() + grandChild();
            });
        combine.bind('change', function (ev, newVal) {
            equal(newVal, 'bb', 'concat changed');
        });
        canBatch.start();
        root('b');
        canBatch.stop();
    });
    test('bug with nested computes and batch ordering (#1519)', function () {
        var root = compute('a');
        var isA = compute(function () {
            return root() === 'a';
        });
        var isB = compute(function () {
            return root() === 'b';
        });
        var combined = compute(function () {
            var valA = isA(), valB = isB();
            return valA || valB;
        });
        equal(combined(), true);
        combined.bind('change', function () {
        });
        canBatch.start();
        root('b');
        canBatch.stop();
        equal(combined(), true);
    });
    test('binding, unbinding, and rebinding works after a timeout (#2095)', function () {
        var root = compute(1), derived = compute(function () {
                return root();
            });
        var change = function () {
        };
        derived.bind('change', change);
        derived.unbind('change', change);
        stop();
        setTimeout(function () {
            derived.bind('change', function (ev, newVal, oldVal) {
                equal(newVal, 2, 'updated');
                start();
            });
            root(2);
        }, 10);
    });
    test('Observation.isRecording observes doesn\'t understand Observation.ignore (#2099)', function () {
        expect(0);
        var c = compute(1);
        c.computeInstance.bind = function () {
            ok(false);
        };
        var outer = compute(function () {
            Observation.ignore(function () {
                c();
            })();
        });
        outer.bind('change', function () {
        });
    });
    test('handles missing update order items (#2121)', function () {
        var root1 = compute('root1'), child1 = compute(function () {
                return root1();
            }), root2 = compute('root2'), child2 = compute(function () {
                return root2();
            }), gc2 = compute(function () {
                return child2();
            }), res = compute(function () {
                return child1() + gc2();
            });
        res.bind('change', function (ev, newVal) {
            equal(newVal, 'ROOT1root2');
        });
        canBatch.start();
        root1('ROOT1');
        canBatch.stop();
    });
    test('compute should not fire event when NaN is set multiple times #2128', function () {
        var c = compute(NaN);
        compute.bind('change', function () {
            ok(false, 'change event should not be fired');
        });
        ok(isNaN(c()));
        c(NaN);
    });
    test('canBatch.afterPreviousEvents firing too late (#2198)', function () {
        var compute1 = compute('a'), compute2 = compute('b');
        var derived = compute(function () {
            return compute1().toUpperCase();
        });
        derived.bind('change', function () {
            var afterPrevious = false;
            compute2.bind('change', function () {
                ok(afterPrevious, 'after previous should have fired so we would respond to this event');
            });
            canBatch.start();
            canBatch.stop();
            canBatch.afterPreviousEvents(function () {
                afterPrevious = true;
            });
            compute2('c');
        });
        canBatch.start();
        compute1('x');
        canBatch.stop();
    });
    test('Async getter causes infinite loop (#28)', function () {
        var changeCount = 0;
        var idCompute = compute(1);
        stop();
        var comp = compute.async(undefined, function (last, resolve) {
            var id = idCompute();
            setTimeout(function () {
                resolve(changeCount + '|' + id);
            }, 1);
            resolve(changeCount + '|' + id);
        }, null);
        comp.bind('change', function (ev, newVal) {
            changeCount++;
            comp();
        });
        setTimeout(function () {
            idCompute(2);
        }, 50);
        var checkChangeCount = function () {
            if (changeCount === 4) {
                equal(changeCount, 4);
                start();
            } else {
                setTimeout(checkChangeCount, 10);
            }
        };
        checkChangeCount();
    });
    test('Listening to input change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp.on('change', function () {
            ok(true, 'it changed');
        });
        input.value = 'foo';
        domDispatch.call(input, 'input');
    });
    test('Setting an input to change', function () {
        var input = document.createElement('input');
        var comp = compute(input, 'value', 'input');
        comp('foo');
        ok(input.value === 'foo');
    });
    test('compute.truthy with functions (canjs/can-stache#172)', function () {
        var func = compute(function () {
            return function () {
                ok(false, 'should not be run');
            };
        });
        var truthy = compute.truthy(func);
        equal(truthy(), true);
    });
    test('works with can-reflect', 5, function () {
        var c = compute(0);
        QUnit.equal(canReflect.getValue(c), 0, 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 1, 'observed new value');
            canReflect.offValue(c, handler);
        };
        QUnit.ok(canReflect.isValueLike(c), 'isValueLike is true');
        canReflect.onValue(c, handler);
        QUnit.equal(canReflect.valueHasDependencies(c), undefined, 'valueHasDependencies');
        c(1);
        QUnit.equal(canReflect.getValue(c), 1, 'bound value');
        c(2);
    });
    QUnit.test('can-reflect valueHasDependencies', function () {
        var a = compute('a');
        var b = compute('b');
        var c = compute(function () {
            return a() + b();
        });
        c.on('change', function () {
        });
        QUnit.ok(canReflect.valueHasDependencies(c), 'valueHasDependencies');
    });
    QUnit.test('registered symbols', function () {
        var a = compute('a');
        ok(a[canSymbol.for('can.isValueLike')], 'can.isValueLike');
        equal(a[canSymbol.for('can.getValue')](), 'a', 'can.getValue');
        a[canSymbol.for('can.setValue')]('b');
        equal(a(), 'b', 'can.setValue');
        function handler(val) {
            equal(val, 'c', 'can.onValue');
        }
        a[canSymbol.for('can.onValue')](handler);
        a('c');
        a[canSymbol.for('can.offValue')](handler);
        a('d');
    });
    QUnit.test('can-reflect setValue', function () {
        var a = compute('a');
        canReflect.setValue(a, 'A');
        QUnit.equal(a(), 'A', 'compute');
    });
    QUnit.test('Calling .unbind() with no arguments should tear down all event handlers', function () {
        var count = compute(0);
        count.on('change', function () {
            console.log('Count changed');
        });
        QUnit.equal(count.computeInstance.__bindEvents.change.length, 1, 'Change event added');
        count.unbind();
        QUnit.equal(count.computeInstance.__bindEvents.change.length, 0, 'All events for compute removed');
    });
    QUnit.test('.off() unbinds a given handler', function () {
        function handler() {
        }
        var c = compute();
        c.on('change', handler);
        QUnit.equal(c.computeInstance.__bindEvents._lifecycleBindings, 1);
        c.off('change', handler);
        QUnit.equal(c.computeInstance.__bindEvents._lifecycleBindings, 0);
    });
});
/*can@3.14.0#compute/compute_test*/
define('can@3.14.0#compute/compute_test', [
    'require',
    'exports',
    'module',
    'can-compute/can-compute_test'
], function (require, exports, module) {
    require('can-compute/can-compute_test');
});
/*can-construct@3.5.3#can-construct_test*/
define('can-construct@3.5.3#can-construct_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-construct',
    'can-log/dev/dev'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        QUnit = require('steal-qunit');
        var Construct = require('can-construct');
        var dev = require('can-log/dev/dev');
        QUnit.module('can-construct', {
            setup: function () {
                var Animal = this.Animal = Construct.extend({
                    count: 0,
                    test: function () {
                        return this.match ? true : false;
                    }
                }, {
                    init: function () {
                        this.constructor.count++;
                        this.eyes = false;
                    }
                });
                var Dog = this.Dog = this.Animal.extend({ match: /abc/ }, {
                    init: function () {
                        Animal.prototype.init.apply(this, arguments);
                    },
                    talk: function () {
                        return 'Woof';
                    }
                });
                this.Ajax = this.Dog.extend({ count: 0 }, {
                    init: function (hairs) {
                        Dog.prototype.init.apply(this, arguments);
                        this.hairs = hairs;
                        this.setEyes();
                    },
                    setEyes: function () {
                        this.eyes = true;
                    }
                });
            }
        });
        test('inherit', function () {
            var Base = Construct({});
            ok(new Base() instanceof Construct);
            var Inherit = Base({});
            ok(new Inherit() instanceof Base);
        });
        test('Creating', function () {
            new this.Dog();
            var a1 = new this.Animal();
            new this.Animal();
            var ajax = new this.Ajax(1000);
            equal(2, this.Animal.count, 'right number of animals');
            equal(1, this.Dog.count, 'right number of animals');
            ok(this.Dog.match, 'right number of animals');
            ok(!this.Animal.match, 'right number of animals');
            ok(this.Dog.test(), 'right number of animals');
            ok(!this.Animal.test(), 'right number of animals');
            equal(1, this.Ajax.count, 'right number of animals');
            equal(2, this.Animal.count, 'right number of animals');
            equal(true, ajax.eyes, 'right number of animals');
            equal(1000, ajax.hairs, 'right number of animals');
            ok(a1 instanceof this.Animal);
            ok(a1 instanceof Construct);
        });
        test('new instance', function () {
            var d = this.Ajax.newInstance(6);
            equal(6, d.hairs);
        });
        test('namespaces', function () {
            var fb = Construct.extend('Bar');
            ok(!window.Bar, 'not added to global namespace');
            if (Object.getOwnPropertyDescriptor) {
                equal(fb.name, 'Bar', 'name is right');
            }
            equal(fb.shortName, 'Bar', 'short name is right');
        });
        test('setups', function () {
            var order = 0, staticSetup, staticSetupArgs, staticInit, staticInitArgs, protoSetup, protoInitArgs, protoInit, staticProps = {
                    setup: function () {
                        staticSetup = ++order;
                        staticSetupArgs = arguments;
                        return ['something'];
                    },
                    init: function () {
                        staticInit = ++order;
                        staticInitArgs = arguments;
                    }
                }, protoProps = {
                    setup: function (name) {
                        protoSetup = ++order;
                        return ['Ford: ' + name];
                    },
                    init: function () {
                        protoInit = ++order;
                        protoInitArgs = arguments;
                    }
                };
            var Car = Construct.extend('Car', staticProps, protoProps);
            new Car('geo');
            equal(staticSetup, 1);
            equal(staticInit, 2);
            equal(protoSetup, 3);
            equal(protoInit, 4);
            deepEqual(Array.prototype.slice.call(staticInitArgs), ['something']);
            deepEqual(Array.prototype.slice.call(protoInitArgs), ['Ford: geo']);
            deepEqual(Array.prototype.slice.call(staticSetupArgs), [
                Construct,
                'Car',
                staticProps,
                protoProps
            ], 'static construct');
            Car.extend('Truck');
            equal(staticSetup, 5, 'Static setup is called if overwriting');
        });
        test('Creating without extend', function () {
            var Bar = Construct('Bar', {
                ok: function () {
                    ok(true, 'ok called');
                }
            });
            new Bar().ok();
            var Foo = Bar('Foo', {
                dude: function () {
                    ok(true, 'dude called');
                }
            });
            new Foo().dude(true);
        });
        test('setup called with original arguments', function () {
            var o2 = {};
            var o1 = {
                setup: function (base, arg1, arg2) {
                    equal(o1, arg1, 'first argument is correct');
                    equal(o2, arg2, 'second argument is correct');
                }
            };
            Construct.extend(o1, o2);
        });
        test('legacy namespace strings (A.B.C) accepted', function () {
            var Type = Construct.extend('Foo.Bar.Baz');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Foo_Bar_Baz';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes underscored');
            }
        });
        test('reserved words accepted', function () {
            var Type = Construct.extend('const');
            var expectedValue = ~steal.config('env').indexOf('production') ? '' : 'Const';
            ok(new Type() instanceof Construct, 'No unexpected behavior in the prototype chain');
            if (Function.prototype.name) {
                equal(Type.name, expectedValue, 'Name becomes capitalized');
            }
        });
        test('basic injection attacks thwarted', function () {
            var rootToken = typeof window === 'undefined' ? 'global' : 'window';
            var rootObject = typeof window === 'undefined' ? global : window;
            var expando = 'foo' + Math.random().toString(10).slice(2);
            var MalignantType;
            try {
                MalignantType = Construct.extend('(){};' + rootToken + '.' + expando + '=\'bar\';var f=function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
            delete rootObject[expando];
            try {
                MalignantType = Construct.extend('(){},' + rootToken + '.' + expando + '=\'baz\',function');
            } catch (e) {
            } finally {
                equal(rootObject[expando], undefined, 'Injected code doesn\'t run');
            }
        });
        QUnit.test('setters not invoked on extension (#28)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'called when not extending');
                },
                get something() {
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('return alternative value simple', function () {
            var Alternative = function () {
            };
            var Base = Construct.extend({
                setup: function () {
                    return new Construct.ReturnValue(new Alternative());
                }
            });
            QUnit.ok(new Base() instanceof Alternative, 'Should create an instance of Alternative');
        });
        QUnit.test('return alternative value on setup (full case)', function () {
            var Student = function (name, school) {
                this.name = name;
                this.school = school;
                this.isStudent = true;
            };
            var Person = Construct.extend({
                setup: function (opts) {
                    if (opts.age >= 16) {
                        return new Construct.ReturnValue(new Student(opts.name, opts.school));
                    }
                    opts.isStudent = false;
                    return [opts];
                },
                init: function (params) {
                    this.age = params.age;
                    this.name = params.name;
                    this.isStudent = params.isStudent;
                }
            });
            QUnit.equal(new Person({ age: 12 }).isStudent, false, 'Age 12 cannot be a student');
            QUnit.equal(new Person({ age: 30 }).isStudent, true, 'Age 20 can be a student');
            QUnit.ok(new Person({ age: 30 }) instanceof Student, 'Should return an instance of Student');
        });
        QUnit.test('extends defaults right', function () {
            var BASE = Construct.extend({ defaults: { foo: 'bar' } }, {});
            var INHERIT = BASE.extend({ defaults: { newProp: 'newVal' } }, {});
            ok(INHERIT.defaults.foo === 'bar', 'Class must inherit defaults from the parent class');
            ok(INHERIT.defaults.newProp === 'newVal', 'Class must have own defaults');
        });
        QUnit.test('enumerability', function () {
            var Parent = Construct.extend('Parent', {});
            var child = new Parent();
            child.foo = 'bar';
            var props = {};
            for (var prop in child) {
                props[prop] = true;
            }
            QUnit.deepEqual(props, { foo: true }, 'only has ownProps');
        });
        QUnit.test('Has default init, setup functions', function () {
            var instance = new Construct();
            QUnit.equal(typeof instance.init, 'function', 'has init');
            QUnit.equal(typeof instance.setup, 'function', 'has setup');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can@3.14.0#construct/construct_test*/
define('can@3.14.0#construct/construct_test', [
    'require',
    'exports',
    'module',
    'can-construct/can-construct_test'
], function (require, exports, module) {
    require('can-construct/can-construct_test');
});
/*can-construct-super@3.2.0#can-construct-super*/
define('can-construct-super@3.2.0#can-construct-super', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-construct'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var canReflect = require('can-reflect');
        var Construct = require('can-construct');
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var isFunction = function (val) {
                return typeof val === 'function';
            }, fnTest = /xyz/.test(function () {
                return this.xyz;
            }) ? /\b_super\b/ : /.*/, getset = [
                'get',
                'set'
            ], getSuper = function (base, name, fn) {
                return function () {
                    var hasExistingValue = false;
                    var existingValue;
                    var prototype = getPrototypeOf(this);
                    var existingPrototypeValue = prototype._super;
                    if (hasOwnProperty.call(this, '_super')) {
                        hasExistingValue = true;
                        existingValue = this._super;
                        delete this._super;
                    }
                    prototype._super = base[name];
                    var ret = fn.apply(this, arguments);
                    prototype._super = existingPrototypeValue;
                    if (hasExistingValue) {
                        this._super = existingValue;
                    }
                    return ret;
                };
            };
        Construct._defineProperty = function (addTo, base, name, descriptor) {
            var _super = Object.getOwnPropertyDescriptor(base, name);
            if (_super) {
                canReflect.each(getset, function (method) {
                    if (isFunction(_super[method]) && isFunction(descriptor[method])) {
                        descriptor[method] = getSuper(_super, method, descriptor[method]);
                    } else if (!isFunction(descriptor[method])) {
                        descriptor[method] = _super[method];
                    }
                });
            }
            Object.defineProperty(addTo, name, descriptor);
        };
        var getPrototypeOf = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        var getPropertyDescriptor = Object.getPropertyDescriptor || function (subject, name) {
            if (name in subject) {
                var pd = Object.getOwnPropertyDescriptor(subject, name);
                var proto = getPrototypeOf(subject);
                while (pd === undefined && proto !== null) {
                    pd = Object.getOwnPropertyDescriptor(proto, name);
                    proto = getPrototypeOf(proto);
                }
                return pd;
            }
        };
        Construct._overwrite = function (addTo, base, name, val) {
            var baseDescriptor = getPropertyDescriptor(base, name);
            var baseValue = baseDescriptor && baseDescriptor.value;
            Object.defineProperty(addTo, name, {
                value: isFunction(val) && isFunction(baseValue) && fnTest.test(val) ? getSuper(base, name, val) : val,
                configurable: true,
                enumerable: true,
                writable: true
            });
        };
        module.exports = Construct;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-construct-super@3.2.0#test/can-construct-super_test*/
define('can-construct-super@3.2.0#test/can-construct-super_test', [
    'require',
    'exports',
    'module',
    'can-construct-super',
    'steal-qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Construct = require('can-construct-super');
        var QUnit = require('steal-qunit');
        QUnit.module('can-construct-super');
        test('prototype super', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            equal(b.arg, 4);
            equal(b.add(2), 7);
        });
        test('static super', function () {
            var First = Construct.extend({
                raise: function (num) {
                    return num;
                }
            }, {});
            var Second = First.extend({
                raise: function (num) {
                    return this._super(num) * num;
                }
            }, {});
            equal(Second.raise(2), 4);
        });
        test('findAll super', function () {
            var Parent = Construct.extend({
                findAll: function () {
                    equal(this.shortName, 'child');
                    return Promise.resolve();
                },
                shortName: 'parent'
            }, {});
            var Child = Parent.extend({
                findAll: function () {
                    return this._super();
                },
                shortName: 'child'
            }, {});
            stop();
            expect(1);
            Child.findAll({});
            start();
        });
        if (Object.getOwnPropertyDescriptor) {
            test('_super supports getters and setters', function () {
                var Person = Construct.extend({
                    get age() {
                        return 42;
                    },
                    set name(value) {
                        this._name = value;
                    },
                    get name() {
                        return this._name;
                    }
                });
                var OtherPerson = Person.extend({
                    get age() {
                        return this._super() + 8;
                    },
                    set name(value) {
                        this._super(value + '_super');
                    }
                });
                var test = new OtherPerson();
                test.base = 2;
                equal(test.age, 50, 'Getter and _super works');
                test.name = 'David';
                equal(test.name, 'David_super', 'Setter ran');
            });
        }
        QUnit.test('setters not invoked on extension (#9)', function () {
            var extending = true;
            var Base = Construct.extend('Base', {
                set something(value) {
                    QUnit.ok(!extending, 'set not called when not extending');
                },
                get something() {
                    QUnit.ok(!extending, 'get not called when not extending');
                }
            });
            Base.extend('Extended', { something: 'value' });
            extending = false;
            new Base().something = 'foo';
        });
        QUnit.test('_super isn\'t always available (#11)', function () {
            var Parent = Construct.extend({});
            var Child = Parent.extend({
                init: function () {
                    this._super();
                    ok(true);
                }
            });
            new Child();
        });
        QUnit.test('_super should work for sealed instances', function () {
            var A = Construct.extend({
                init: function (arg) {
                    this.arg = arg + 1;
                },
                add: function (num) {
                    return this.arg + num;
                }
            });
            var B = A({
                init: function (arg) {
                    this._super(arg + 2);
                },
                add: function (arg) {
                    return this._super(arg + 1);
                }
            });
            var b = new B(1);
            Object.seal(b);
            equal(b.arg, 4, 'should instantiate properly');
            equal(b.add(2), 7, 'should call methods properly');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-define@1.5.7#list/list*/
define('can-define@1.5.7#list/list', [
    'require',
    'exports',
    'module',
    'can-construct',
    'can-define',
    'can-event',
    'can-event/batch/batch',
    'can-observation',
    'can-log',
    'can-log/dev/dev',
    '../define-helpers/define-helpers',
    'can-util/js/assign/assign',
    'can-util/js/diff/diff',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-types',
    'can-namespace',
    'can-reflect',
    'can-symbol',
    'can-util/js/cid-set/cid-set',
    'can-util/js/cid-map/cid-map',
    'can-util/js/single-reference/single-reference'
], function (require, exports, module) {
    var Construct = require('can-construct');
    var define = require('can-define');
    var make = define.make;
    var canEvent = require('can-event');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var canLog = require('can-log');
    var canLogDev = require('can-log/dev/dev');
    var defineHelpers = require('../define-helpers/define-helpers');
    var assign = require('can-util/js/assign/assign');
    var diff = require('can-util/js/diff/diff');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var types = require('can-types');
    var ns = require('can-namespace');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var CIDSet = require('can-util/js/cid-set/cid-set');
    var CIDMap = require('can-util/js/cid-map/cid-map');
    var singleReference = require('can-util/js/single-reference/single-reference');
    var splice = [].splice;
    var runningNative = false;
    var identity = function (x) {
        return x;
    };
    var makeFilterCallback = function (props) {
        return function (item) {
            for (var prop in props) {
                if (item[prop] !== props[prop]) {
                    return false;
                }
            }
            return true;
        };
    };
    var DefineList = Construct.extend('DefineList', {
        setup: function (base) {
            if (DefineList) {
                var prototype = this.prototype;
                var result = define(prototype, prototype, base.prototype._define);
                var itemsDefinition = result.definitions['#'] || result.defaultDefinition;
                if (itemsDefinition) {
                    if (itemsDefinition.Type) {
                        this.prototype.__type = make.set.Type('*', itemsDefinition.Type, identity);
                    } else if (itemsDefinition.type) {
                        this.prototype.__type = make.set.type('*', itemsDefinition.type, identity);
                    }
                }
            }
        }
    }, {
        setup: function (items) {
            if (!this._define) {
                Object.defineProperty(this, '_define', {
                    enumerable: false,
                    value: {
                        definitions: {
                            length: { type: 'number' },
                            _length: { type: 'number' }
                        }
                    }
                });
                Object.defineProperty(this, '_data', {
                    enumerable: false,
                    value: {}
                });
            }
            define.setup.call(this, {}, false);
            Object.defineProperty(this, '_length', {
                enumerable: false,
                configurable: true,
                writable: true,
                value: 0
            });
            if (items) {
                this.splice.apply(this, [
                    0,
                    0
                ].concat(canReflect.toArray(items)));
            }
        },
        __type: define.types.observable,
        _triggerChange: function (attr, how, newVal, oldVal) {
            var index = +attr;
            if (!~('' + attr).indexOf('.') && !isNaN(index)) {
                var itemsDefinition = this._define.definitions['#'];
                if (how === 'add') {
                    if (itemsDefinition && typeof itemsDefinition.added === 'function') {
                        Observation.ignore(itemsDefinition.added).call(this, newVal, index);
                    }
                    canEvent.dispatch.call(this, how, [
                        newVal,
                        index
                    ]);
                } else if (how === 'remove') {
                    if (itemsDefinition && typeof itemsDefinition.removed === 'function') {
                        Observation.ignore(itemsDefinition.removed).call(this, oldVal, index);
                    }
                    canEvent.dispatch.call(this, how, [
                        oldVal,
                        index
                    ]);
                } else {
                    canEvent.dispatch.call(this, how, [
                        newVal,
                        index
                    ]);
                }
            } else {
                canEvent.dispatch.call(this, {
                    type: '' + attr,
                    target: this
                }, [
                    newVal,
                    oldVal
                ]);
            }
        },
        get: function (index) {
            if (arguments.length) {
                Observation.add(this, '' + index);
                return this[index];
            } else {
                return canReflect.unwrap(this, CIDMap);
            }
        },
        set: function (prop, value) {
            if (typeof prop !== 'object') {
                prop = isNaN(+prop) || prop % 1 ? prop : +prop;
                if (typeof prop === 'number') {
                    if (typeof prop === 'number' && prop > this._length - 1) {
                        var newArr = new Array(prop + 1 - this._length);
                        newArr[newArr.length - 1] = value;
                        this.push.apply(this, newArr);
                        return newArr;
                    }
                    this.splice(prop, 1, value);
                } else {
                    var defined = defineHelpers.defineExpando(this, prop, value);
                    if (!defined) {
                        this[prop] = value;
                    }
                }
            } else {
                if (canReflect.isListLike(prop)) {
                    if (value) {
                        this.replace(prop);
                    } else {
                        canReflect.assignList(this, prop);
                    }
                } else {
                    canReflect.assignMap(this, prop);
                }
            }
            return this;
        },
        assign: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignList(this, prop);
            } else {
                canReflect.assignMap(this, prop);
            }
            return this;
        },
        update: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateList(this, prop);
            } else {
                canReflect.updateMap(this, prop);
            }
            return this;
        },
        assignDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.assignDeepList(this, prop);
            } else {
                canReflect.assignDeepMap(this, prop);
            }
            return this;
        },
        updateDeep: function (prop) {
            if (canReflect.isListLike(prop)) {
                canReflect.updateDeepList(this, prop);
            } else {
                canReflect.updateDeepMap(this, prop);
            }
            return this;
        },
        _items: function () {
            var arr = [];
            this._each(function (item) {
                arr.push(item);
            });
            return arr;
        },
        _each: function (callback) {
            for (var i = 0, len = this._length; i < len; i++) {
                callback(this[i], i);
            }
        },
        splice: function (index, howMany) {
            var args = makeArray(arguments), added = [], i, len, listIndex, allSame = args.length > 2;
            index = index || 0;
            for (i = 0, len = args.length - 2; i < len; i++) {
                listIndex = i + 2;
                args[listIndex] = this.__type(args[listIndex], listIndex);
                added.push(args[listIndex]);
                if (this[i + index] !== args[listIndex]) {
                    allSame = false;
                }
            }
            if (allSame && this._length <= added.length) {
                return added;
            }
            if (howMany === undefined) {
                howMany = args[1] = this._length - index;
            }
            runningNative = true;
            var removed = splice.apply(this, args);
            runningNative = false;
            canBatch.start();
            if (howMany > 0) {
                this._triggerChange('' + index, 'remove', undefined, removed);
            }
            if (args.length > 2) {
                this._triggerChange('' + index, 'add', added, removed);
            }
            canEvent.dispatch.call(this, 'length', [this._length]);
            canBatch.stop();
            return removed;
        },
        serialize: function () {
            return canReflect.serialize(this, CIDMap);
        }
    });
    var getArgs = function (args) {
        return args[0] && Array.isArray(args[0]) ? args[0] : makeArray(args);
    };
    each({
        push: 'length',
        unshift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            var args = [], len = where ? this._length : 0, i = arguments.length, res, val;
            while (i--) {
                val = arguments[i];
                args[i] = this.__type(val, i);
            }
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            if (!this.comparator || args.length) {
                canBatch.start();
                this._triggerChange('' + len, 'add', args, undefined);
                canEvent.dispatch.call(this, 'length', [this._length]);
                canBatch.stop();
            }
            return res;
        };
    });
    each({
        pop: 'length',
        shift: 0
    }, function (where, name) {
        var orig = [][name];
        DefineList.prototype[name] = function () {
            if (!this._length) {
                return undefined;
            }
            var args = getArgs(arguments), len = where && this._length ? this._length - 1 : 0, res;
            runningNative = true;
            res = orig.apply(this, args);
            runningNative = false;
            canBatch.start();
            this._triggerChange('' + len, 'remove', undefined, [res]);
            canEvent.dispatch.call(this, 'length', [this._length]);
            canBatch.stop();
            return res;
        };
    });
    each({
        'map': 3,
        'filter': 3,
        'reduce': 4,
        'reduceRight': 4,
        'every': 3,
        'some': 3
    }, function a(fnLength, fnName) {
        DefineList.prototype[fnName] = function () {
            var self = this;
            var args = [].slice.call(arguments, 0);
            var callback = args[0];
            var thisArg = args[fnLength - 1] || self;
            if (typeof callback === 'object') {
                callback = makeFilterCallback(callback);
            }
            args[0] = function () {
                var cbArgs = [].slice.call(arguments, 0);
                cbArgs[fnLength - 3] = self.get(cbArgs[fnLength - 2]);
                return callback.apply(thisArg, cbArgs);
            };
            var ret = Array.prototype[fnName].apply(this, args);
            if (fnName === 'map') {
                return new DefineList(ret);
            } else if (fnName === 'filter') {
                return new self.constructor(ret);
            } else {
                return ret;
            }
        };
    });
    assign(DefineList.prototype, {
        indexOf: function (item, fromIndex) {
            for (var i = fromIndex || 0, len = this.length; i < len; i++) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        lastIndexOf: function (item, fromIndex) {
            fromIndex = typeof fromIndex === 'undefined' ? this.length - 1 : fromIndex;
            for (var i = fromIndex; i >= 0; i--) {
                if (this.get(i) === item) {
                    return i;
                }
            }
            return -1;
        },
        join: function () {
            Observation.add(this, 'length');
            return [].join.apply(this, arguments);
        },
        reverse: function () {
            var list = [].reverse.call(this._items());
            return this.replace(list);
        },
        slice: function () {
            Observation.add(this, 'length');
            var temp = Array.prototype.slice.apply(this, arguments);
            return new this.constructor(temp);
        },
        concat: function () {
            var args = [];
            each(arguments, function (arg) {
                if (canReflect.isListLike(arg)) {
                    var arr = Array.isArray(arg) ? arg : makeArray(arg);
                    arr.forEach(function (innerArg) {
                        args.push(this.__type(innerArg));
                    }, this);
                } else {
                    args.push(this.__type(arg));
                }
            }, this);
            return new this.constructor(Array.prototype.concat.apply(makeArray(this), args));
        },
        forEach: function (cb, thisarg) {
            var item;
            for (var i = 0, len = this.length; i < len; i++) {
                item = this.get(i);
                if (cb.call(thisarg || item, item, i, this) === false) {
                    break;
                }
            }
            return this;
        },
        replace: function (newList) {
            var patches = diff(this, newList);
            canBatch.start();
            for (var i = 0, len = patches.length; i < len; i++) {
                this.splice.apply(this, [
                    patches[i].index,
                    patches[i].deleteCount
                ].concat(patches[i].insert));
            }
            canBatch.stop();
            return this;
        },
        sort: function (compareFunction) {
            var removed = Array.prototype.slice.call(this);
            Array.prototype.sort.call(this, compareFunction);
            var added = Array.prototype.slice.call(this);
            canBatch.start();
            canEvent.dispatch.call(this, 'remove', [
                removed,
                0
            ]);
            canEvent.dispatch.call(this, 'add', [
                added,
                0
            ]);
            canEvent.dispatch.call(this, 'length', [
                this._length,
                this._length
            ]);
            canBatch.stop();
            return this;
        }
    });
    for (var prop in define.eventsProto) {
        DefineList[prop] = define.eventsProto[prop];
        Object.defineProperty(DefineList.prototype, prop, {
            enumerable: false,
            value: define.eventsProto[prop],
            writable: true
        });
    }
    Object.defineProperty(DefineList.prototype, 'length', {
        get: function () {
            if (!this.__inSetup) {
                Observation.add(this, 'length');
            }
            return this._length;
        },
        set: function (newVal) {
            if (runningNative) {
                this._length = newVal;
                return;
            }
            if (newVal == null || isNaN(+newVal) || newVal === this._length) {
                return;
            }
            if (newVal > this._length - 1) {
                var newArr = new Array(newVal - this._length);
                this.push.apply(this, newArr);
            } else {
                this.splice(newVal);
            }
        },
        enumerable: true
    });
    Object.defineProperty(DefineList.prototype, 'each', {
        enumerable: false,
        writable: true,
        value: DefineList.prototype.forEach
    });
    DefineList.prototype.attr = function (prop, value) {
        canLog.warn('DefineMap::attr shouldn\'t be called');
        if (arguments.length === 0) {
            return this.get();
        } else if (prop && typeof prop === 'object') {
            return this.set.apply(this, arguments);
        } else if (arguments.length === 1) {
            return this.get(prop);
        } else {
            return this.set(prop, value);
        }
    };
    DefineList.prototype.item = function (index, value) {
        if (arguments.length === 1) {
            return this.get(index);
        } else {
            return this.set(index, value);
        }
    };
    DefineList.prototype.items = function () {
        canLog.warn('DefineList::get should should be used instead of DefineList::items');
        return this.get();
    };
    canReflect.assignSymbols(DefineList.prototype, {
        'can.isMoreListLikeThanMapLike': true,
        'can.isMapLike': true,
        'can.isListLike': true,
        'can.isValueLike': false,
        'can.getKeyValue': DefineList.prototype.get,
        'can.setKeyValue': DefineList.prototype.set,
        'can.onKeyValue': function (key, handler) {
            var translationHandler;
            if (isNaN(key)) {
                translationHandler = function (ev, newValue, oldValue) {
                    handler(newValue, oldValue);
                };
                this.addEventListener(key, translationHandler);
            } else {
                translationHandler = function () {
                    handler(this[key]);
                };
                singleReference.set(handler, this, translationHandler, key);
                this.addEventListener('length', translationHandler);
            }
        },
        'can.offKeyValue': function (key, handler) {
            var translationHandler;
            if (isNaN(key)) {
                translationHandler = function (ev, newValue, oldValue) {
                    handler(newValue, oldValue);
                };
                this.removeEventListener(key, translationHandler);
            } else {
                translationHandler = singleReference.getAndDelete(handler, this, key);
                this.removeEventListener('length', translationHandler);
            }
        },
        'can.deleteKeyValue': function (prop) {
            prop = isNaN(+prop) || prop % 1 ? prop : +prop;
            if (typeof prop === 'number') {
                this.splice(prop, 1);
            } else if (prop === 'length' || prop === '_length') {
                return;
            } else {
                this.set(prop, undefined);
            }
            return this;
        },
        'can.assignDeep': function (source) {
            canBatch.start();
            canReflect.assignList(this, source);
            canBatch.stop();
        },
        'can.updateDeep': function (source) {
            canBatch.start();
            this.replace(source);
            canBatch.stop();
        },
        'can.keyHasDependencies': function (key) {
            return !!(this._computed && this._computed[key] && this._computed[key].compute);
        },
        'can.getKeyDependencies': function (key) {
            var ret;
            if (this._computed && this._computed[key] && this._computed[key].compute) {
                ret = {};
                ret.valueDependencies = new CIDSet();
                ret.valueDependencies.add(this._computed[key].compute);
            }
            return ret;
        },
        'can.onKeysAdded': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('add', handler);
        },
        'can.onKeysRemoved': function (handler) {
            this[canSymbol.for('can.onKeyValue')]('remove', handler);
        },
        'can.splice': function (index, deleteCount, insert) {
            this.splice.apply(this, [
                index,
                deleteCount
            ].concat(insert));
        }
    });
    canReflect.setKeyValue(DefineList.prototype, canSymbol.iterator, function () {
        var index = -1;
        if (typeof this.length !== 'number') {
            this.length = 0;
        }
        return {
            next: function () {
                index++;
                return {
                    value: this[index],
                    done: index >= this.length
                };
            }.bind(this)
        };
    });
    types.DefineList = DefineList;
    types.DefaultList = DefineList;
    module.exports = ns.DefineList = DefineList;
});
/*can-define@1.5.7#list/list-test*/
define('can-define@1.5.7#list/list-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/list/list',
    'can-define/map/map',
    'can-observation',
    'can-define',
    'can-compute',
    'can-reflect',
    'can-symbol',
    'can-util/js/assign/assign',
    'can-cid'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var Observation = require('can-observation');
    var define = require('can-define');
    var compute = require('can-compute');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var assign = require('can-util/js/assign/assign');
    var CID = require('can-cid');
    QUnit.module('can-define/list/list');
    QUnit.test('List is an event emitter', function (assert) {
        var Base = DefineList.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var List = Base.extend({});
        assert.ok(List.on, 'List has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var list = new DefineList([
            'a',
            'b',
            'c'
        ]);
        list.on('add', function (ev, newVals, index) {
            QUnit.deepEqual(newVals, ['d']);
            QUnit.equal(index, 3);
        });
        list.push('d');
    });
    test('list attr changes length', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.set(3, 3);
        equal(l.length, 4);
    });
    test('remove on pop', function () {
        var l = new DefineList([
            0,
            1,
            2
        ]);
        l.pop();
        equal(l.length, 2);
        deepEqual(l.get(), [
            0,
            1
        ]);
    });
    test('list splice', function () {
        var l = new DefineList([
            0,
            1,
            2,
            3
        ]);
        l.on('add', function (ev, newVals, index) {
            deepEqual(newVals, [
                'a',
                'b'
            ], 'got the right newVals');
            equal(index, 1, 'adding items');
        });
        l.on('remove', function (ev, oldVals, index) {
            deepEqual(oldVals, [
                1,
                2
            ], 'got the right oldVals');
            equal(index, 1, 'no new Vals');
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.get(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('Array accessor methods', 11, function () {
        var l = new DefineList([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new DefineList([0]));
        ok(sliced instanceof DefineList, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof DefineList, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'DefineList concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new DefineList([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = DefineMap.extend();
        var People = DefineList.extend({ '#': Person });
        var Genius = Person.extend();
        var Animal = DefineMap.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.length === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new DefineList(['a']);
        l.splice(0, 1);
        ok(!l.get(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(4);
        var l = new DefineList([
            1,
            2,
            3
        ]);
        l.on('add', function () {
            ok(true, 'add called');
        });
        l.on('remove', function () {
            ok(true, 'remove called');
        });
        l.on('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
        deepEqual(l.get(), [
            3,
            2,
            1
        ], 'reversed');
    });
    test('filter', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('No Add Events if DefineList Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new DefineList([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new DefineList([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.set(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .set() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new DefineList([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .set()');
        });
        list.set(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new DefineList([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new DefineList();
        l.set('1', 'foo');
        equal(l.get('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new DefineList([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.get(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.get(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = DefineList.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        }, null, {
            updater: function (newVal) {
                deepEqual(newVal.get(), [2], 'got a new DefineList');
            }
        });
        sliced.start();
        var joined = new Observation(function () {
            return list.join(',');
        }, null, {
            updater: function (newVal) {
                equal(newVal, '2,3', 'joined is observable');
            }
        });
        joined.start();
        list.shift();
    });
    test('list.replace', function () {
        var firstArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(firstArray);
        var newArray = [
            {
                id: 4,
                name: 'Aubree'
            },
            {
                id: 5,
                name: 'Leah'
            },
            {
                id: 6,
                name: 'Lily'
            }
        ];
        myList.replace(newArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Aubree');
        equal(myList[1].name, 'Leah');
        equal(myList[2].name, 'Lily', 'Can replace a List with an Array.');
        myList.replace(firstArray);
        equal(myList.length, 3);
        equal(myList[0].name, 'Marshall');
        equal(myList[1].name, 'Austin');
        equal(myList[2].name, 'Hyrum', 'Can replace a List with another List.');
    });
    test('list.map', function () {
        var myArray = [
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ];
        var myList = new DefineList(myArray);
        var newList = myList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        equal(newList.length, 3);
        equal(newList[0].name, 'Marshall');
        equal(newList[0].lastName, 'Thompson');
        equal(newList[1].name, 'Austin');
        equal(newList[1].lastName, 'Thompson');
        equal(newList[2].name, 'Hyrum');
        equal(newList[2].lastName, 'Thompson');
        var ExtendedList = DefineList.extend({
            testMe: function () {
                return 'It Worked!';
            }
        });
        var myExtendedList = new ExtendedList(myArray);
        var newExtendedList = myExtendedList.map(function (person) {
            person.lastName = 'Thompson';
            return person;
        });
        try {
            newExtendedList.testMe();
        } catch (err) {
            QUnit.ok(err.message.match(/testMe/), 'Does not return the same type of list.');
        }
    });
    test('list.sort a simple list', function () {
        var myList = new DefineList([
            'Marshall',
            'Austin',
            'Hyrum'
        ]);
        myList.sort();
        equal(myList.length, 3);
        equal(myList[0], 'Austin');
        equal(myList[1], 'Hyrum');
        equal(myList[2], 'Marshall', 'Basic list was properly sorted.');
    });
    test('list.sort a list of objects', function () {
        var objList = new DefineList([
            {
                id: 1,
                name: 'Marshall'
            },
            {
                id: 2,
                name: 'Austin'
            },
            {
                id: 3,
                name: 'Hyrum'
            }
        ]);
        objList.sort(function (a, b) {
            if (a.name < b.name) {
                return -1;
            } else if (a.name > b.name) {
                return 1;
            } else {
                return 0;
            }
        });
        equal(objList.length, 3);
        equal(objList[0].name, 'Austin');
        equal(objList[1].name, 'Hyrum');
        equal(objList[2].name, 'Marshall', 'List of objects was properly sorted.');
    });
    test('list.sort a list of objects without losing reference (#137)', function () {
        var unSorted = new DefineList([
            { id: 3 },
            { id: 2 },
            { id: 1 }
        ]);
        var sorted = unSorted.slice(0).sort(function (a, b) {
            return a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
        });
        equal(unSorted[0], sorted[2], 'items should be equal');
    });
    test('list defines', 6, function () {
        var Todo = function (props) {
            assign(this, props);
            CID(this);
        };
        define(Todo.prototype, {
            completed: 'boolean',
            destroyed: { value: false }
        });
        Todo.prototype.destroy = function () {
            this.destroyed = true;
        };
        var TodoList = DefineList.extend({
            '*': Todo,
            remaining: {
                get: function () {
                    return this.filter({ completed: false });
                }
            },
            completed: {
                get: function () {
                    return this.filter({ completed: true });
                }
            },
            destroyCompleted: function () {
                this.completed.forEach(function (todo) {
                    todo.destroy();
                });
            },
            setCompletedTo: function (value) {
                this.forEach(function (todo) {
                    todo.completed = value;
                });
            }
        });
        var todos = new TodoList([
            { completed: true },
            { completed: false }
        ]);
        ok(todos.item(0) instanceof Todo, 'correct instance');
        equal(todos.completed.length, 1, 'only one todo');
        todos.on('completed', function (ev, newVal, oldVal) {
            ok(newVal instanceof TodoList, 'right type');
            equal(newVal.length, 2, 'all items');
            ok(oldVal instanceof TodoList, 'right type');
            equal(oldVal.length, 1, 'all items');
        });
        todos.setCompletedTo(true);
    });
    QUnit.test('extending the base supports overwriting _eventSetup', function () {
        var L = DefineList.extend({});
        Object.getOwnPropertyDescriptor(DefineMap.prototype, '_eventSetup');
        L.prototype.arbitraryProp = true;
        ok(true, 'set arbitraryProp');
        L.prototype._eventSetup = function () {
        };
        ok(true, 'worked');
    });
    QUnit.test('setting expandos on a DefineList', function () {
        var DL = DefineList.extend({ count: 'number' });
        var dl = new DL();
        dl.assign({
            count: 5,
            skip: 2
        });
        QUnit.equal(dl.get('count'), 5, 'read with .get defined');
        QUnit.equal(dl.count, 5, 'read with . defined');
        QUnit.equal(dl.get('skip'), 2, 'read with .get expando');
        QUnit.equal(dl.skip, 2, 'read with . expando');
        QUnit.equal(dl.get('limit'), undefined, 'read with .get undefined');
    });
    QUnit.test('passing a DefineList to DefineList (#33)', function () {
        var m = new DefineList([
            {},
            {}
        ]);
        var m2 = new DefineList(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m[0] === m2[0], 'index the same');
        QUnit.ok(m[1] === m2[1], 'index the same');
    });
    QUnit.test('reading and setting expandos', function () {
        var list = new DefineList();
        var countObservation = new Observation(function () {
            return list.get('count');
        }, null, function (newValue) {
            QUnit.equal(newValue, 1000, 'got new value');
        });
        countObservation.start();
        list.set('count', 1000);
        QUnit.equal(countObservation.value, 1000);
        var list2 = new DefineList();
        list2.on('count', function (ev, newVal) {
            QUnit.equal(newVal, 5);
        });
        list2.set('count', 5);
    });
    QUnit.test('extending DefineList constructor functions (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = BList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list = new CList([
            {},
            {}
        ]);
        list.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        list.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        list.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        list.aProp = 'PROP';
        list.bProp = 'FOO';
        list.cProp = 'BAR';
        QUnit.ok(list.aMethod);
        QUnit.ok(list.bMethod);
        QUnit.ok(list.cMethod);
    });
    QUnit.test('extending DefineList constructor functions more than once (#61)', function () {
        var AList = DefineList.extend('AList', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BList = AList.extend('BList', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CList = AList.extend('CList', {
            cProp: {},
            cMethod: function () {
            }
        });
        var list1 = new BList([
            {},
            {}
        ]);
        var list2 = new CList([
            {},
            {},
            {}
        ]);
        list1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on list1');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on list2');
            QUnit.equal(oldVal, undefined);
        });
        list1.aProp = 'PROP';
        list1.bProp = 'FOO';
        list2.aProp = 'PROP';
        list2.cProp = 'BAR';
        QUnit.ok(list1.aMethod, 'list1 aMethod');
        QUnit.ok(list1.bMethod);
        QUnit.ok(list2.aMethod);
        QUnit.ok(list2.cMethod, 'list2 cMethod');
    });
    QUnit.test('extending DefineList constructor functions - value (#61)', function () {
        var AList = DefineList.extend('AList', { aProp: { value: 1 } });
        var BList = AList.extend('BList', {});
        var CList = BList.extend('CList', {});
        var c = new CList([]);
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('\'*\' inheritance works (#61)', function () {
        var Account = DefineMap.extend({
            name: 'string',
            amount: 'number',
            slug: {
                serialize: true,
                get: function () {
                    return this.name.toLowerCase().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
        });
        var BaseList = DefineList.extend({ '*': Account });
        var ExtendedList = BaseList.extend({});
        var xl = new ExtendedList([{}]);
        QUnit.ok(xl[0] instanceof Account);
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var People = DefineList.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new People([]);
        p.fullName = 'Mohamed Cherif';
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('added and removed are called after items are added/removed (#14)', function () {
        var Person = DefineMap.extend({
            id: 'number',
            name: 'string'
        });
        var addedFuncCalled, removedFuncCalled, theList;
        var People = DefineList.extend({
            '#': {
                added: function (items, index) {
                    addedFuncCalled = true;
                    ok(items, 'items added got passed to added');
                    ok(typeof index === 'number', 'index of items was passed to added and is a number');
                    ok(items[0].name === 'John', 'Name was correct');
                    theList = this;
                },
                removed: function (items, index) {
                    removedFuncCalled = true;
                    ok(items, 'items added got passed to removed');
                    ok(typeof index === 'number', 'index of items was passed to removed and is a number');
                    theList = this;
                },
                Type: Person
            },
            outsideProp: {
                type: 'boolean',
                value: true
            }
        });
        var people = new People([]);
        var me = new Person();
        me.name = 'John';
        me.id = '1234';
        ok(!addedFuncCalled, 'added function has not been called yet');
        people.push(me);
        ok(addedFuncCalled, 'added function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to added');
        theList = null;
        ok(!removedFuncCalled, 'removed function has not been called yet');
        people.splice(people.indexOf(me), 1);
        ok(removedFuncCalled, 'removed function was called');
        ok(theList.outsideProp === true && theList instanceof People, 'the list was passed correctly as this to removed');
    });
    QUnit.test('* vs # (#78)', function () {
        var MyList = DefineList.extend({
            '*': 'number',
            '#': {
                added: function () {
                    ok(true, 'called on init');
                },
                removed: function () {
                },
                type: 'string'
            }
        });
        var list = new MyList([
            1,
            2,
            3
        ]);
        QUnit.ok(list[0] === '1', 'converted to string');
        list.set('prop', '4');
        QUnit.ok(list.prop === 4, 'type converted');
    });
    QUnit.test('Array shorthand uses #', function () {
        var MyMap = DefineMap.extend({ 'numbers': ['number'] });
        var map = new MyMap({
            numbers: [
                '1',
                '2'
            ]
        });
        QUnit.ok(map.numbers[0] === 1, 'converted to number');
        map.numbers.set('prop', '4');
        QUnit.ok(map.numbers.prop === '4', 'type left alone');
    });
    QUnit.test('replace-with-self lists are diffed properly (can-view-live#10)', function () {
        var a = new DefineMap({ name: 'A' });
        var b = new DefineMap({ name: 'B' });
        var c = new DefineMap({ name: 'C' });
        var d = new DefineMap({ name: 'D' });
        expect(4);
        var list1 = new DefineList([
            a,
            b
        ]);
        list1.on('add', function (ev, newVals, where) {
            throw new Error('list1 should not add.');
        });
        list1.on('remove', function (ev, oldVals, where) {
            throw new Error('list1 should not remove.');
        });
        list1.replace([
            a,
            b
        ]);
        var list2 = new DefineList([
            a,
            b,
            c
        ]);
        list2.on('add', function (ev, newVals, where) {
            equal(newVals.length, 1, 'list2 added length');
            equal(where, 2, 'list2 added location');
        });
        list2.on('remove', function (ev, oldVals, where) {
            equal(oldVals.length, 1, 'list2 removed length');
            equal(where, 2, 'list2 removed location');
        });
        list2.replace([
            a,
            b,
            d
        ]);
    });
    QUnit.test('set >= length - triggers length event (#152)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(false, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(4);
        l.set(3, 5);
        deepEqual(l.get(), [
            1,
            2,
            3,
            5
        ], 'updated list');
    });
    QUnit.test('set < length - triggers length event (#150)', function () {
        var l = new DefineList([
            1,
            2,
            3
        ]);
        var batchNum = null;
        l.on('add', function (e) {
            ok(true, 'add called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('remove', function (e) {
            ok(true, 'remove called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        l.on('length', function (e) {
            ok(true, 'length called');
            if (batchNum === null) {
                batchNum = e.batchNum;
            } else {
                equal(batchNum, e.batchNum, 'batch numbers match');
            }
        });
        expect(6);
        l.set(2, 4);
        deepEqual(l.get(), [
            1,
            2,
            4
        ], 'updated list');
    });
    QUnit.test('set/splice are observable', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        var count = new Observation(function () {
            var count = 0;
            for (var i = 0; i < list.length; i++) {
                count += list[i] % 2 ? 1 : 0;
            }
            return count;
        }, null, {
            updater: function () {
                ok(true);
            }
        });
        count.start();
        expect(3);
        list.set(3, 5);
        list.set(2, 4);
        list.splice(1, 1, 1);
    });
    QUnit.test('setting length > current (#147)', function () {
        var list = new DefineList([
            1,
            2
        ]);
        list.length = 5;
        equal(list.length, 5);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), true);
        equal(list.hasOwnProperty(4), true);
        equal(list.hasOwnProperty(5), false);
    });
    QUnit.test('setting length < current (#147)', function () {
        var list = new DefineList([
            1,
            2,
            3,
            4,
            5
        ]);
        list.length = 3;
        equal(list.length, 3);
        equal(list.hasOwnProperty(0), true);
        equal(list.hasOwnProperty(1), true);
        equal(list.hasOwnProperty(2), true);
        equal(list.hasOwnProperty(3), false);
        equal(list.hasOwnProperty(4), false);
        equal(list.hasOwnProperty(5), false);
    });
    test('every', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Bob'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.every(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Every works in true case');
        var idOne = l.every(function (item) {
            return item.id === 1;
        });
        ok(!idOne, 'Every works in false case');
        allBobs = l.every({ name: 'Bob' });
        ok(allBobs, 'Every works in true case');
        idOne = l.every({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Every works in false case');
    });
    test('some', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var allBobs = l.some(function (item) {
            return item.name === 'Bob';
        });
        ok(allBobs, 'Some works in true case');
        var idOne = l.some(function (item) {
            return item.name === 'Charlie';
        });
        ok(!idOne, 'Some works in false case');
        allBobs = l.some({ name: 'Bob' });
        ok(allBobs, 'Some works in true case');
        idOne = l.some({
            name: 'Bob',
            id: 1
        });
        ok(!idOne, 'Some works in false case');
    });
    test('lastIndexOf', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 1, 'lastIndexOf found object');
        var charlieIdx = l.lastIndexOf({
            id: 3,
            name: 'Charlie'
        });
        equal(charlieIdx, -1, 'lastIndexOf not found object');
        l.push(l[1]);
        bobIdx = l.lastIndexOf(l[1]);
        equal(bobIdx, 2, 'lastIndexOf found last index of duped object');
    });
    test('reduce', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice',
                score: 10
            },
            {
                id: 2,
                name: 'Bob',
                score: 20
            }
        ]);
        var totalScores = l.reduce(function (total, player) {
            return total + player.score;
        }, 0);
        equal(totalScores, 30, 'Reduce works over list');
    });
    test('reduceRight', function () {
        var l = new DefineList([
            {
                id: 1,
                name: 'Alice'
            },
            {
                id: 2,
                name: 'Bob'
            }
        ]);
        var concatenatedNames = l.reduceRight(function (string, person) {
            return string + person.name;
        }, '');
        equal(concatenatedNames, 'BobAlice', 'ReduceRight works over list');
    });
    test('compute(defineMap, \'property.names\') works (#20)', function () {
        var map = new DefineMap();
        var c = compute(map, 'foo.bar');
        c.on('change', function (ev, newVal) {
            QUnit.equal(newVal, 2);
        });
        map.set('foo', new DefineMap());
        map.foo.set('bar', 2);
    });
    test('compute(DefineList, 0) works (#17)', function (assert) {
        assert.expect(1);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var c = compute(list, 0);
        c.on('change', function (ev, newVal) {
            assert.equal(newVal, 5);
        });
        list.set(0, 5);
    });
    QUnit.test('can-reflect onValue', function (assert) {
        assert.expect(1);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var first = compute(list, 0);
        canReflect.onValue(first, function (newVal) {
            assert.equal(newVal, 5);
        });
        list.set(0, 5);
    });
    QUnit.test('can-reflect onKeyValue', function (assert) {
        assert.expect(3);
        var list = new DefineList([
            1,
            2,
            3
        ]);
        var key = 1;
        canReflect.onKeyValue(list, key, function (newVal) {
            assert.equal(newVal, 5);
        });
        list.set(key, 5);
        canReflect.onKeyValue(list, 'length', function (newVal) {
            assert.equal(newVal, 4);
        });
        list.push(6);
    });
    test('works with can-reflect', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(b), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        QUnit.ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        QUnit.ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        canReflect.setKeyValue(a, 1, 'c');
        QUnit.equal(a[1], 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineList([
            'a',
            'b'
        ]);
        a.set('foo', 'bar');
        canReflect.deleteKeyValue(a, 0);
        QUnit.equal(a[1], undefined, 'last value is now undefined');
        QUnit.equal(a[0], 'b', 'last value is shifted down');
        canReflect.deleteKeyValue(a, 'foo');
        QUnit.equal(a.foo, undefined, 'value not included in serial');
        QUnit.ok(!('foo' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ foo: 4 });
        var b = new DefineList([
            'foo',
            'bar'
        ]);
        var c;
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        define(c = Object.create(b), {
            length: {
                get: function () {
                    return a.foo;
                }
            }
        });
        ok(canReflect.getKeyDependencies(c, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(c, 'length').valueDependencies.has(c._computed.length.compute), 'dependencies returned');
    });
    QUnit.test('assign property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.assign({
            count: 0,
            skip: 2,
            arr: [
                '1',
                '2',
                '3'
            ]
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.assign({
            count: 1000,
            arr: ['first']
        });
        deepEqual(list.get('arr'), new DefineList(['first']), 'Array is set properly');
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), 2, 'Skip is unchanged');
    });
    QUnit.test('update property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.update({
            count: 0,
            skip: 2
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.update({ count: 1000 });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), undefined, 'Skip is changed');
    });
    QUnit.test('assignDeep property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.assignDeep({
            count: 0,
            skip: 2,
            foo: {
                bar: 'zed',
                tar: 'yap'
            }
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.assignDeep({
            count: 1000,
            foo: { bar: 'updated' }
        });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), 2, 'Skip is unchanged');
        propEqual(list.get('foo'), {
            bar: 'updated',
            tar: 'yap'
        }, 'Foo was updated properly');
    });
    QUnit.test('updateDeep property', function () {
        var list = new DefineList([
            'A',
            'B'
        ]);
        list.updateDeep({
            count: 0,
            skip: 2,
            foo: {
                bar: 'zed',
                tar: 'yap'
            }
        });
        equal(list.get('count'), 0, 'Count set properly');
        list.updateDeep({ count: 1000 });
        equal(list.get('count'), 1000, 'Count set properly');
        equal(list.get('skip'), undefined, 'Skip is set to undefined');
        propEqual(list.get('foo'), undefined, 'Foo is set to undefined');
    });
    QUnit.test('registered symbols', function () {
        var a = new DefineMap({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.a, 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.a = 'c';
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.a = 'd';
    });
    QUnit.test('cannot remove length', function () {
        var list = new DefineList(['a']);
        list.set('length', undefined);
        QUnit.equal(list.length, 1, 'list length is unchanged');
    });
    QUnit.test('cannot set length to a non-number', function () {
        var list = new DefineList(['a']);
        list.set('length', null);
        QUnit.equal(list.length, 1, 'list length is unchanged');
        list.set('length', 'foo');
        QUnit.equal(list.length, 1, 'list length is unchanged');
        list.set('length', {});
        QUnit.equal(list.length, 1, 'list length is unchanged');
    });
    QUnit.test('_length is not enumerable', function () {
        QUnit.ok(!Object.getOwnPropertyDescriptor(new DefineList(), '_length').enumerable, '_length is not enumerable');
    });
    QUnit.test('update with no indexed items sets length to 0', function () {
        var list = new DefineList(['a']);
        QUnit.equal(list.length, 1, 'list length is correct before update');
        list.update({ foo: 'bar' });
        QUnit.equal(list.length, 0, 'list length is correct after update');
    });
    [
        'length',
        '_length'
    ].forEach(function (prop) {
        QUnit.test('setting ' + prop + ' does not overwrite definition', function () {
            var list = new DefineList();
            list.get(prop);
            var proto = list, listDef, listDef2;
            while (!listDef && proto) {
                listDef = Object.getOwnPropertyDescriptor(proto, prop);
                proto = Object.getPrototypeOf(proto);
            }
            list.set(prop, 1);
            proto = list;
            while (!listDef2 && proto) {
                listDef2 = Object.getOwnPropertyDescriptor(proto, prop);
                proto = Object.getPrototypeOf(proto);
            }
            delete listDef2.value;
            delete listDef.value;
            QUnit.deepEqual(listDef2, listDef, 'descriptor hasn\'t changed');
        });
    });
    QUnit.test('iterator can recover from bad _length', function () {
        var list = new DefineList(['a']);
        list.set('_length', null);
        QUnit.equal(list._length, null, 'Bad value for _length');
        var iterator = list[canSymbol.iterator]();
        var iteration = iterator.next();
        QUnit.ok(iteration.done, 'Didn\'t fail');
    });
    QUnit.test('Bound serialized lists update when they change length', function () {
        QUnit.expect(1);
        var list = new DefineList(['eggs']);
        var obs = new Observation(function () {
            return list.serialize();
        });
        function onChange(val) {
            QUnit.deepEqual(val, [
                'eggs',
                'toast'
            ]);
        }
        canReflect.onValue(obs, onChange);
        list.push('toast');
        canReflect.offValue(obs, onChange);
    });
});
/*can-test-helpers@1.1.2#lib/dev*/
define('can-test-helpers@1.1.2#lib/dev', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-util/js/make-array/make-array',
    'can-util/js/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var dev = require('can-log/dev/dev');
        var makeArray = require('can-util/js/make-array/make-array');
        var GLOBAL = require('can-util/js/global/global');
        function makeExpectation(type) {
            var original;
            var expectedResults = [];
            function stubbed() {
                var message = makeArray(arguments).map(function (token) {
                    if (typeof token !== 'string' && token.message) {
                        return token.message;
                    } else {
                        return token;
                    }
                }).join(' ');
                expectedResults.forEach(function (expected) {
                    var matched = typeof expected.source === 'string' ? message === expected.source : expected.source.test(message);
                    if (matched) {
                        expected.count++;
                    }
                    if (typeof expected.fn === 'function') {
                        expected.fn.call(null, message, matched);
                    }
                });
            }
            return function (expected, fn) {
                var matchData = {
                    source: expected,
                    fn: fn,
                    count: 0
                };
                expectedResults.push(matchData);
                if (!original) {
                    original = dev[type];
                    dev[type] = stubbed;
                }
                return function () {
                    expectedResults.splice(expectedResults.indexOf(matchData), 1);
                    if (original && expectedResults.length < 1) {
                        dev[type] = original;
                        original = null;
                    }
                    return matchData.count;
                };
            };
        }
        module.exports = {
            willWarn: makeExpectation('warn'),
            willError: makeExpectation('error'),
            devOnlyTest: function () {
                var global = GLOBAL();
                if (!global.System || !global.System.env || global.System.env.indexOf('production') < 0) {
                    global.test.apply(null, arguments);
                }
            }
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-test-helpers@1.1.2#can-test-helpers*/
define('can-test-helpers@1.1.2#can-test-helpers', [
    'require',
    'exports',
    'module',
    'can-test-helpers/lib/dev'
], function (require, exports, module) {
    var dev = require('can-test-helpers/lib/dev');
    module.exports = { dev: dev };
});
/*can-define@1.5.7#map/map-test*/
define('can-define@1.5.7#map/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define/list/list',
    'can-define',
    'can-observation',
    'can-util/js/each/each',
    'can-compute',
    'can-util/js/assign/assign',
    'can-reflect',
    'can-util/js/is-plain-object/is-plain-object',
    'can-test-helpers'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var define = require('can-define');
    var Observation = require('can-observation');
    var each = require('can-util/js/each/each');
    var compute = require('can-compute');
    var assign = require('can-util/js/assign/assign');
    var canReflect = require('can-reflect');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var testHelpers = require('can-test-helpers');
    var sealWorks = function () {
        try {
            var o = {};
            Object.seal(o);
            o.prop = true;
            return false;
        } catch (e) {
            return true;
        }
    }();
    QUnit.module('can-define/map/map');
    QUnit.test('Map is an event emitter', function (assert) {
        var Base = DefineMap.extend({});
        assert.ok(Base.on, 'Base has event methods.');
        var Map = Base.extend({});
        assert.ok(Map.on, 'Map has event methods.');
    });
    QUnit.test('creating an instance', function () {
        var map = new DefineMap({ prop: 'foo' });
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, 'foo');
        });
        map.prop = 'BAR';
    });
    QUnit.test('creating an instance with nested prop', function () {
        var map = new DefineMap({ name: { first: 'Justin' } });
        map.name.on('first', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'David');
            QUnit.equal(oldVal, 'Justin');
        });
        map.name.first = 'David';
    });
    QUnit.test('extending', function () {
        var MyMap = DefineMap.extend({ prop: {} });
        var map = new MyMap();
        map.on('prop', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.prop = 'BAR';
    });
    QUnit.test('loop only through defined serializable props', function () {
        var MyMap = DefineMap.extend({
            propA: {},
            propB: { serialize: false },
            propC: {
                get: function () {
                    return this.propA;
                }
            }
        });
        var inst = new MyMap({
            propA: 1,
            propB: 2
        });
        QUnit.deepEqual(Object.keys(inst.get()), ['propA']);
    });
    QUnit.test('get and set can setup expandos', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.get('foo');
        }, null, {
            updater: function (newVal) {
                QUnit.equal(newVal, 'bar', 'updated to bar');
            }
        });
        oi.start();
        map.set('foo', 'bar');
    });
    QUnit.test('default settings', function () {
        var MyMap = DefineMap.extend({
            '*': 'string',
            foo: {}
        });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    QUnit.test('default settings on unsealed', function () {
        var MyMap = DefineMap.extend({ seal: false }, { '*': 'string' });
        var m = new MyMap();
        m.set('foo', 123);
        QUnit.ok(m.get('foo') === '123');
    });
    if (!System.isEnv('production')) {
        QUnit.test('extends sealed objects (#48)', function () {
            var Map1 = DefineMap.extend({ seal: true }, {
                name: {
                    get: function (curVal) {
                        return 'computed ' + curVal;
                    }
                }
            });
            var Map2 = Map1.extend({ seal: false }, {});
            var Map3 = Map2.extend({ seal: true }, {});
            var map1 = new Map1({ name: 'Justin' });
            try {
                map1.foo = 'bar';
                if (map1.foo) {
                    QUnit.ok(false, 'map1 not sealed');
                } else {
                    QUnit.ok(true, 'map1 sealed - silent failure');
                }
            } catch (ex) {
                QUnit.ok(true, 'map1 sealed');
            }
            QUnit.equal(map1.name, 'computed Justin', 'map1.name property is computed');
            var map2 = new Map2({ name: 'Brian' });
            try {
                map2.foo = 'bar';
                if (map2.foo) {
                    QUnit.ok(true, 'map2 not sealed');
                } else {
                    QUnit.ok(false, 'map2 sealed');
                }
            } catch (ex) {
                QUnit.ok(false, 'map2 sealed');
            }
            QUnit.equal(map2.name, 'computed Brian', 'map2.name property is computed');
            var map3 = new Map3({ name: 'Curtis' });
            try {
                map3.foo = 'bar';
                if (map3.foo) {
                    QUnit.ok(false, 'map3 not sealed');
                } else {
                    QUnit.ok(true, 'map3 sealed');
                }
            } catch (ex) {
                QUnit.ok(true, 'map3 sealed');
            }
            QUnit.equal(map3.name, 'computed Curtis', 'map3.name property is computed');
        });
    }
    QUnit.test('get with dynamically added properties', function () {
        var map = new DefineMap();
        map.set('a', 1);
        map.set('b', 2);
        QUnit.deepEqual(map.get(), {
            a: 1,
            b: 2
        });
    });
    QUnit.test('set multiple props', function () {
        var map = new DefineMap();
        map.assign({
            a: 0,
            b: 2
        });
        QUnit.deepEqual(map.get(), {
            a: 0,
            b: 2
        }, 'added props');
        map.update({ a: 2 });
        QUnit.deepEqual(map.get(), { a: 2 }, 'removed b');
        map.assign({ foo: { bar: 'VALUE' } });
        QUnit.deepEqual(map.get(), {
            foo: { bar: 'VALUE' },
            a: 2
        }, 'works nested');
    });
    QUnit.test('serialize responds to added props', function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        }, null, {
            updater: function (newVal) {
                QUnit.deepEqual(newVal, {
                    a: 1,
                    b: 2
                }, 'updated right');
            }
        });
        oi.start();
        map.assign({
            a: 1,
            b: 2
        });
    });
    QUnit.test('initialize an undefined property', function () {
        var MyMap = DefineMap.extend({ seal: false }, {});
        var instance = new MyMap({ foo: 'bar' });
        equal(instance.foo, 'bar');
    });
    QUnit.test('set an already initialized null property', function () {
        var map = new DefineMap({ foo: null });
        map.assign({ foo: null });
        equal(map.foo, null);
    });
    QUnit.test('creating a new key doesn\'t cause two changes', 1, function () {
        var map = new DefineMap();
        var oi = new Observation(function () {
            return map.serialize();
        }, null, {
            updater: function (newVal) {
                QUnit.deepEqual(newVal, { a: 1 }, 'updated right');
            }
        });
        oi.start();
        map.set('a', 1);
    });
    QUnit.test('setting nested object', function () {
        var m = new DefineMap({});
        m.assign({ foo: {} });
        m.assign({ foo: {} });
        QUnit.deepEqual(m.get(), { foo: {} });
    });
    QUnit.test('passing a DefineMap to DefineMap (#33)', function () {
        var MyMap = DefineMap.extend({ foo: 'observable' });
        var m = new MyMap({
            foo: {},
            bar: {}
        });
        var m2 = new MyMap(m);
        QUnit.deepEqual(m.get(), m2.get());
        QUnit.ok(m.foo === m2.foo, 'defined props the same');
        QUnit.ok(m.bar === m2.bar, 'expando props the same');
    });
    QUnit.test('serialize: function works (#38)', function () {
        var Something = DefineMap.extend({});
        var MyMap = DefineMap.extend({
            somethingRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: function (val) {
                    return val.id;
                }
            },
            somethingElseRef: {
                type: function (val) {
                    return new Something({ id: val });
                },
                serialize: false
            }
        });
        var myMap = new MyMap({
            somethingRef: 2,
            somethingElseRef: 3
        });
        QUnit.ok(myMap.somethingRef instanceof Something);
        QUnit.deepEqual(myMap.serialize(), { somethingRef: 2 }, 'serialize: function and serialize: false works');
        var MyMap2 = DefineMap.extend({
            '*': {
                serialize: function (value) {
                    return '' + value;
                }
            }
        });
        var myMap2 = new MyMap2({
            foo: 1,
            bar: 2
        });
        QUnit.deepEqual(myMap2.serialize(), {
            foo: '1',
            bar: '2'
        }, 'serialize: function on default works');
    });
    QUnit.test('get will not create properties', function () {
        var method = function () {
        };
        var MyMap = DefineMap.extend({ method: method });
        var m = new MyMap();
        m.get('foo');
        QUnit.equal(m.get('method'), method);
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        var VM = DefineMap.extend({ foo: 'string' });
        var vm = new VM({
            foo: 'bar',
            baz: 'qux'
        });
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Getters are not enumerable', function () {
        QUnit.expect(2);
        var MyMap = DefineMap.extend({
            foo: 'string',
            baz: {
                get: function () {
                    return this.foo;
                }
            }
        });
        var map = new MyMap({ foo: 'bar' });
        each(map, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('extending DefineMap constructor functions (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = BType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map = new CType();
        map.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP');
            QUnit.equal(oldVal, undefined);
        });
        map.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO');
            QUnit.equal(oldVal, undefined);
        });
        map.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR');
            QUnit.equal(oldVal, undefined);
        });
        map.aProp = 'PROP';
        map.bProp = 'FOO';
        map.cProp = 'BAR';
        QUnit.ok(map.aMethod);
        QUnit.ok(map.bMethod);
        QUnit.ok(map.cMethod);
    });
    QUnit.test('extending DefineMap constructor functions more than once (#18)', function () {
        var AType = DefineMap.extend('AType', {
            aProp: {},
            aMethod: function () {
            }
        });
        var BType = AType.extend('BType', {
            bProp: {},
            bMethod: function () {
            }
        });
        var CType = AType.extend('CType', {
            cProp: {},
            cMethod: function () {
            }
        });
        var map1 = new BType();
        var map2 = new CType();
        map1.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map1.on('bProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'FOO', 'bProp newVal on map1');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('aProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'PROP', 'aProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map2.on('cProp', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 'BAR', 'cProp newVal on map2');
            QUnit.equal(oldVal, undefined);
        });
        map1.aProp = 'PROP';
        map1.bProp = 'FOO';
        map2.aProp = 'PROP';
        map2.cProp = 'BAR';
        QUnit.ok(map1.aMethod, 'map1 aMethod');
        QUnit.ok(map1.bMethod);
        QUnit.ok(map2.aMethod);
        QUnit.ok(map2.cMethod, 'map2 cMethod');
    });
    QUnit.test('extending DefineMap constructor functions - value (#18)', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var BType = AType.extend('BType', {});
        var CType = BType.extend('CType', {});
        var c = new CType();
        QUnit.equal(c.aProp, 1, 'got initial value');
    });
    QUnit.test('copying DefineMap excludes constructor', function () {
        var AType = DefineMap.extend('AType', { aProp: { value: 1 } });
        var a = new AType();
        var b = assign({}, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.equal(a.aProp, b.aProp, 'Other values are unaffected');
    });
    QUnit.test('cloning from non-defined map excludes special keys on setup', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({ 'foo': 'bar' });
        var b = new DefineMap(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a.__bindEvents, b.__bindEvents, '_bindEvents prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'Other props copied');
    });
    QUnit.test('copying from .set() excludes special keys', function () {
        var MyType = DefineMap.extend({});
        var a = new MyType({
            'foo': 'bar',
            'existing': 'newVal'
        });
        var b = new DefineMap({ 'existing': 'oldVal' });
        b.assign(a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a.__bindEvents, b.__bindEvents, '_bindEvents prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'NEw props copied');
    });
    QUnit.test('copying with assign() excludes special keys', function () {
        var a = {
            _data: {},
            constructor: function () {
            },
            __bindEvents: {},
            _cid: 'object0',
            'foo': 'bar',
            'existing': 'newVal'
        };
        var b = new DefineMap({ 'existing': 'oldVal' });
        assign(b, a);
        QUnit.notEqual(a.constructor, b.constructor, 'Constructor prop not copied');
        QUnit.notEqual(a._data, b._data, '_data prop not copied');
        QUnit.notEqual(a.__bindEvents, b.__bindEvents, '_bindEvents prop not copied');
        QUnit.notEqual(a._cid, b._cid, '_cid prop not copied');
        QUnit.equal(a.foo, b.foo, 'New props copied');
        QUnit.equal(a.existing, b.existing, 'Existing props copied');
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = DefineMap.extend({
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person({
            first: 'Mohamed',
            last: 'Cherif'
        });
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('compute props can be set to null or undefined (#2372)', function () {
        var VM = DefineMap.extend({ computeProp: { type: 'compute' } });
        var vmNull = new VM({ computeProp: null });
        QUnit.equal(vmNull.get('computeProp'), null, 'computeProp is null, no error thrown');
        var vmUndef = new VM({ computeProp: undefined });
        QUnit.equal(vmUndef.get('computeProp'), undefined, 'computeProp is undefined, no error thrown');
    });
    QUnit.test('Inheriting DefineMap .set doesn\'t work if prop is on base map (#74)', function () {
        var Base = DefineMap.extend({ baseProp: 'string' });
        var Inheriting = Base.extend();
        var inherting = new Inheriting();
        inherting.set('baseProp', 'value');
        QUnit.equal(inherting.baseProp, 'value', 'set prop');
    });
    if (sealWorks && System.env.indexOf('production') < 0) {
        QUnit.test('setting not defined property', function () {
            var MyMap = DefineMap.extend({ prop: {} });
            var mymap = new MyMap();
            try {
                mymap.notdefined = 'value';
                ok(false, 'no error');
            } catch (e) {
                ok(true, 'error thrown');
            }
        });
    }
    QUnit.test('.extend errors when re-defining a property (#117)', function () {
        var A = DefineMap.extend('A', {
            foo: {
                type: 'string',
                value: 'blah'
            }
        });
        A.extend('B', {
            foo: {
                type: 'string',
                value: 'flub'
            }
        });
        var C = DefineMap.extend('C', {
            foo: {
                get: function () {
                    return 'blah';
                }
            }
        });
        C.extend('D', {
            foo: {
                get: function () {
                    return 'flub';
                }
            }
        });
        QUnit.ok(true, 'extended without errors');
    });
    QUnit.test('.value functions should not be observable', function () {
        var outer = new DefineMap({ bam: 'baz' });
        var ItemsVM = DefineMap.extend({
            item: {
                value: function () {
                    (function () {
                    }(this.zed, outer.bam));
                    return new DefineMap({ foo: 'bar' });
                }
            },
            zed: 'string'
        });
        var items = new ItemsVM();
        var count = 0;
        var itemsList = compute(function () {
            count++;
            return items.item;
        });
        itemsList.on('change', function () {
        });
        items.item.foo = 'changed';
        items.zed = 'changed';
        equal(count, 1);
    });
    QUnit.test('.value values are overwritten by props in DefineMap construction', function () {
        var Foo = DefineMap.extend({ bar: { value: 'baz' } });
        var foo = new Foo({ bar: 'quux' });
        equal(foo.bar, 'quux', 'Value set properly');
    });
    QUnit.test('can-reflect reflections work with DefineMap', function () {
        var b = new DefineMap({ 'foo': 'bar' });
        var c = new (DefineMap.extend({
            'baz': {
                get: function () {
                    return b.foo;
                }
            }
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
            canReflect.offKeyValue(c, 'baz', handler);
        };
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isObservableLike(c), 'isObservableLike is true');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'foo'), 'keyHasDependencies -- false');
        canReflect.onKeyValue(c, 'baz', handler);
        canReflect.onKeyValue(c, 'thud', handler);
        QUnit.ok(canReflect.keyHasDependencies(c, 'baz'), 'keyHasDependencies -- true');
        b.foo = 'quux';
        c.thud = 'quux';
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.foo = 'thud';
        c.baz = 'jeek';
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.a, 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect deleteKeyValue', function () {
        var a = new DefineMap({ 'a': 'b' });
        canReflect.deleteKeyValue(a, 'a');
        QUnit.equal(a.a, undefined, 'value is now undefined');
        QUnit.ok(!('a' in a.get()), 'value not included in serial');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new DefineMap({ 'a': 'a' });
        var b = new (DefineMap.extend({
            'a': {
                get: function () {
                    return a.a;
                }
            }
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'dependencies exist');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'no dependencies exist for unknown value');
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computed.a.compute), 'dependencies returned');
    });
    QUnit.test('can-reflect assign', function () {
        var aData = { 'a': 'b' };
        var bData = { 'b': 'c' };
        var a = new DefineMap(aData);
        var b = new DefineMap(bData);
        canReflect.assign(a, b);
        QUnit.deepEqual(a.get(), assign(aData, bData), 'when called with an object, should merge into existing object');
    });
    QUnit.test('Does not attempt to redefine _data if already defined', function () {
        var Bar = DefineMap.extend({ seal: false }, { baz: { value: 'thud' } });
        var baz = new Bar();
        define(baz, {
            quux: { value: 'jeek' },
            plonk: {
                get: function () {
                    return 'waldo';
                }
            }
        }, baz._define);
        QUnit.equal(baz.quux, 'jeek', 'New definitions successful');
        QUnit.equal(baz.plonk, 'waldo', 'New computed definitions successful');
        QUnit.equal(baz.baz, 'thud', 'Old definitions still available');
    });
    if (!System.isEnv('production')) {
        QUnit.test('redefines still not allowed on sealed objects', function () {
            QUnit.expect(6);
            var Bar = DefineMap.extend({ seal: true }, { baz: { value: 'thud' } });
            var baz = new Bar();
            try {
                define(baz, { quux: { value: 'jeek' } }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on data property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'quux'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._data, 'quux'), 'nothing set on _data');
            }
            try {
                define(baz, {
                    plonk: {
                        get: function () {
                            return 'waldo';
                        }
                    }
                }, baz._define);
            } catch (e) {
                QUnit.ok(/is not extensible/i.test(e.message), 'Sealed object throws on computed property defines');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz, 'plonk'), 'nothing set on object');
                QUnit.ok(!Object.getOwnPropertyDescriptor(baz._computed, 'plonk'), 'nothing set on _computed');
            }
        });
    }
    QUnit.test('Call .get() when a nested object has its own get method', function () {
        var Bar = DefineMap.extend({ request: '*' });
        var request = {
            prop: 22,
            get: function () {
                if (arguments.length === 0) {
                    throw new Error('This function can\'t be called with 0 arguments');
                }
            }
        };
        var obj = new Bar({ request: request });
        var data = obj.get();
        QUnit.equal(data.request.prop, 22, 'obj did get()');
    });
    QUnit.test('DefineMap short-hand Type (#221)', function () {
        var Child = DefineMap.extend('child', { other: DefineMap });
        var c = new Child();
        c.other = { prop: 'hello' };
        QUnit.ok(c.other instanceof DefineMap, 'is a DefineMap');
    });
    QUnit.test('non-Object constructor', function () {
        var Constructor = DefineMap.extend();
        QUnit.ok(!isPlainObject(new DefineMap()), 'instance of DefineMap is not a plain object');
        QUnit.ok(!isPlainObject(new Constructor()), 'instance of extended DefineMap is not a plain object');
    });
    QUnit.test('Observation bound to getter using lastSetVal updates correctly (canjs#3541)', function () {
        var MyMap = DefineMap.extend({
            foo: {
                get: function (lastSetVal) {
                    if (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new MyMap();
        var oi = new Observation(function () {
            return map.get('foo');
        }, null, {
            updater: function (newVal) {
                QUnit.equal(newVal, 'bar', 'updated to bar');
            }
        });
        oi.start();
        map.set('foo', 'bar');
    });
    QUnit.test('Observation bound to async getter updates correctly (canjs#3541)', function () {
        var MyMap = DefineMap.extend({
            foo: {
                get: function (lastSetVal, resolve) {
                    if (lastSetVal) {
                        return resolve(lastSetVal);
                    }
                }
            }
        });
        var map = new MyMap();
        var oi = new Observation(function () {
            return map.get('foo');
        }, null, {
            updater: function (newVal) {
                QUnit.equal(newVal, 'bar', 'updated to bar');
            }
        });
        oi.start();
        map.set('foo', 'bar');
    });
    testHelpers.dev.devOnlyTest('Setting a value with an object type generates a warning (#148)', function () {
        QUnit.expect(1);
        var message = 'can-define: The value for options is set to an object. This will be shared by all instances of the DefineMap. Use a function that returns the object instead.';
        var finishErrorCheck = testHelpers.dev.willWarn(message);
        DefineMap.extend({ options: { value: {} } });
        DefineMap.extend({ options: { value: [] } });
        DefineMap.extend({
            options: {
                value: function () {
                }
            }
        });
        DefineMap.extend({ options: { value: 2 } });
        QUnit.equal(finishErrorCheck(), 2);
    });
    testHelpers.dev.devOnlyTest('Setting a value to a constructor type generates a warning', function () {
        QUnit.expect(1);
        var message = 'can-define: The "value" for options is set to a constructor. Did you mean "Value" instead?';
        var finishErrorCheck = testHelpers.dev.willWarn(message);
        DefineMap.extend({ options: { value: DefineMap } });
        QUnit.equal(finishErrorCheck(), 1);
    });
    QUnit.test('Assign value on map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'CanJS',
            foo: {
                bar: 'bar',
                zoo: 'say'
            }
        });
        obj.assign({
            list: ['another'],
            foo: { bar: 'zed' }
        });
        QUnit.equal(obj.list.length, 1, 'list length should be 1');
        QUnit.propEqual(obj.foo, { bar: 'zed' }, 'foo.bar is set correctly');
        QUnit.equal(obj.name, 'CanJS', 'name is unchanged');
    });
    QUnit.test('Update value on a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'CanJS',
            foo: { bar: 'bar' }
        });
        obj.update({
            list: ['another'],
            foo: { bar: 'zed' }
        });
        QUnit.equal(obj.list.length, 1, 'list length should be 1');
        QUnit.equal(obj.foo.bar, 'zed', 'foo.bar is set correctly');
        QUnit.equal(obj.name, undefined, 'name is removed');
    });
    QUnit.test('Deep assign a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'Test Name'
        });
        QUnit.equal(obj.list.length, 3, 'list length should be 3');
        obj.assignDeep({ list: ['something'] });
        QUnit.equal(obj.name, 'Test Name', 'Name property is still intact');
        QUnit.equal(obj.list[0], 'something', 'the first element in the list should be updated');
    });
    QUnit.test('Deep updating a map', function () {
        var MyConstruct = DefineMap.extend({
            list: DefineList,
            name: 'string'
        });
        var obj = new MyConstruct({
            list: [
                'data',
                'data',
                'data'
            ],
            name: 'Test Name'
        });
        QUnit.equal(obj.list.length, 3, 'list length should be 3');
        obj.updateDeep({ list: ['something'] });
        QUnit.equal(obj.name, undefined, 'Name property has been reset');
        QUnit.equal(obj.list[0], 'something', 'the first element of the list should be updated');
    });
    testHelpers.dev.devOnlyTest('Error on not using a constructor or string on short-hand definitions (#278)', function () {
        expect(5);
        var message = /.+ on .+ does not match a supported propDefinition. See: https:\/\/canjs.com\/doc\/can-define.types.propDefinition.html/i;
        var finishErrorCheck = testHelpers.dev.willError(message, function (actual, match) {
            var rightProp = /prop0[15]/;
            QUnit.ok(rightProp.test(actual.slice(0, 6)));
            QUnit.ok(match);
        });
        DefineMap.extend('ShortName', {
            prop01: 0,
            prop02: function () {
            },
            prop03: 'string',
            prop04: DefineMap,
            prop05: 'a string that is not a type',
            prop06: [],
            get prop07() {
            },
            set prop07(newVal) {
            },
            prop08: 'boolean'
        });
        QUnit.equal(finishErrorCheck(), 2);
    });
    QUnit.test('Improper shorthand properties are not set', function () {
        var VM = DefineMap.extend({
            prop01: 0,
            prop02: function () {
            },
            prop03: 'some random string'
        });
        QUnit.equal(VM.prototype._define.methods.prop01, undefined);
        QUnit.equal(typeof VM.prototype._define.methods.prop02, 'function');
        QUnit.equal(VM.prototype._define.methods.prop03, undefined);
    });
});
/*can-define@1.5.7#define-test*/
define('can-define@1.5.7#define-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-compute',
    'can-define',
    'can-define/list/list',
    'can-event/batch/batch',
    'can-util/js/each/each',
    'can-symbol',
    'can-test-helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var compute = require('can-compute');
    var define = require('can-define');
    var CanList = require('can-define/list/list');
    var canBatch = require('can-event/batch/batch');
    var each = require('can-util/js/each/each');
    var canSymbol = require('can-symbol');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-define');
    QUnit.test('basics on a prototype', 5, function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.bind('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.bind('first', function (el, newVal, oldVal) {
            QUnit.equal(newVal, 'Justin', 'first new value');
            QUnit.equal(oldVal, 'Mohamed', 'first old value');
        });
        canBatch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        canBatch.stop();
    });
    QUnit.test('basics set', 2, function () {
        var Defined = function (prop) {
            this.prop = prop;
        };
        define(Defined.prototype, {
            prop: {
                set: function (newVal) {
                    return 'foo' + newVal;
                }
            }
        });
        var def = new Defined();
        def.prop = 'bar';
        QUnit.equal(def.prop, 'foobar', 'setter works');
        var DefinedCB = function (prop) {
            this.prop = prop;
        };
        define(DefinedCB.prototype, {
            prop: {
                set: function (newVal, setter) {
                    setter('foo' + newVal);
                }
            }
        });
        var defCallback = new DefinedCB();
        defCallback.prop = 'bar';
        QUnit.equal(defCallback.prop, 'foobar', 'setter callback works');
    });
    QUnit.test('basic type', function () {
        QUnit.expect(6);
        var Typer = function (arrayWithAddedItem, listWithAddedItem) {
            this.arrayWithAddedItem = arrayWithAddedItem;
            this.listWithAddedItem = listWithAddedItem;
        };
        define(Typer.prototype, {
            arrayWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                }
            },
            listWithAddedItem: {
                type: function (value) {
                    if (value && value.push) {
                        value.push('item');
                    }
                    return value;
                },
                Type: CanList
            }
        });
        var t = new Typer();
        deepEqual(Object.keys(t), [], 'no keys');
        var array = [];
        t.arrayWithAddedItem = array;
        deepEqual(array, ['item'], 'updated array');
        QUnit.equal(t.arrayWithAddedItem, array, 'leave value as array');
        t.listWithAddedItem = [];
        QUnit.ok(t.listWithAddedItem instanceof CanList, 'convert to CanList');
        QUnit.equal(t.listWithAddedItem[0], 'item', 'has item in it');
        compute(function () {
            return t.listWithAddedItem.attr('length');
        }).addEventListener('change', function (ev, newVal) {
            QUnit.equal(newVal, 2, 'got a length change');
        });
        t.listWithAddedItem.push('another item');
    });
    QUnit.test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = function (foo) {
            this.foo = foo;
        };
        define(Typer.prototype, { foo: { Type: Foo } });
        var t = new Typer('Justin');
        QUnit.equal(t.foo.getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.foo = brian;
        QUnit.equal(t.foo, brian, 'same instances');
    });
    QUnit.test('type converters', function () {
        var Typer = function (date, string, number, bool, htmlbool, leaveAlone) {
            this.date = date;
            this.string = string;
            this.number = number;
            this.bool = bool;
            this.htmlbool = htmlbool;
            this.leaveAlone = leaveAlone;
        };
        define(Typer.prototype, {
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            bool: { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var obj = {};
        var t = new Typer(1395896701516, 5, '5', 'false', '', obj);
        QUnit.ok(t.date instanceof Date, 'converted to date');
        QUnit.equal(t.string, '5', 'converted to string');
        QUnit.equal(t.number, 5, 'converted to number');
        QUnit.equal(t.bool, false, 'converted to boolean');
        QUnit.equal(t.htmlbool, true, 'converted to htmlbool');
        QUnit.equal(t.leaveAlone, obj, 'left as object');
        t.number = '15';
        QUnit.ok(t.number === 15, 'converted to number');
    });
    QUnit.test('basics value', function () {
        var Typer = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer.prototype, { prop: { value: 'foo' } });
        var t = new Typer();
        QUnit.equal(t.prop, 'foo', 'value is used as default value');
        var Typer2 = function (prop) {
            if (prop !== undefined) {
                this.prop = prop;
            }
        };
        define(Typer2.prototype, {
            prop: {
                value: function () {
                    return [];
                },
                type: '*'
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(Array.isArray(t1.prop), 'its an array');
    });
    test('basics Value', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                Value: Array,
                type: '*'
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        QUnit.ok(t1.prop !== t2.prop, 'different array instances');
        QUnit.ok(Array.isArray(t1.prop), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = function (prop) {
        };
        define(Typer.prototype, {
            prop: {
                set: function () {
                    this.foo = 'bar';
                }
            },
            foo: '*'
        });
        var t = new Typer();
        t.prop = false;
        deepEqual({
            foo: t.foo,
            prop: t.prop
        }, {
            foo: 'bar',
            prop: false
        }, 'got the right props');
    });
    test('type happens before the set', 2, function () {
        var Typer = function () {
        };
        define(Typer.prototype, {
            prop: {
                type: 'number',
                set: function (newValue) {
                    equal(typeof newValue, 'number', 'got a number');
                    return newValue + 1;
                }
            }
        });
        var map = new Typer();
        map.prop = '5';
        equal(map.prop, 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = define.Constructor({
            limit: '*',
            offset: '*',
            page: {
                set: function (newVal) {
                    this.offset = (parseInt(newVal) - 1) * this.limit;
                },
                get: function () {
                    return Math.floor(this.offset / this.limit) + 1;
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.page, 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.page = 2;
        equal(p.page, 2, 'page set right');
        equal(p.offset, 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = compute(1);
        var Grabber = define.Constructor({
            vals: {
                type: '*',
                Value: Array,
                get: function (current, setVal) {
                    if (setVal) {
                        current.push(comp());
                    }
                    return current;
                }
            }
        });
        var g = new Grabber();
        equal(g.vals.length, 0, 'zero items in array');
    });
    test('Value generator can read other properties', function () {
        var Map = define.Constructor({
            letters: { value: 'ABC' },
            numbers: {
                value: [
                    1,
                    2,
                    3
                ]
            },
            definedLetters: { value: 'DEF' },
            definedNumbers: {
                value: [
                    4,
                    5,
                    6
                ]
            },
            generatedLetters: {
                value: function () {
                    return 'GHI';
                }
            },
            generatedNumbers: {
                value: function () {
                    return new CanList([
                        7,
                        8,
                        9
                    ]);
                }
            },
            firstLetter: {
                value: function () {
                    return this.letters.substr(0, 1);
                }
            },
            firstNumber: {
                value: function () {
                    return this.numbers[0];
                }
            },
            middleLetter: {
                value: function () {
                    return this.definedLetters.substr(1, 1);
                }
            },
            middleNumber: {
                value: function () {
                    return this.definedNumbers[1];
                }
            },
            lastLetter: {
                value: function () {
                    return this.generatedLetters.substr(2, 1);
                }
            },
            lastNumber: {
                value: function () {
                    return this.generatedNumbers[2];
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.firstLetter, 'A', prefix + 'traditional can.Map style property definition');
        equal(map.firstNumber, 1, prefix + 'traditional can.Map style property definition');
        equal(map.middleLetter, 'E', prefix + 'define plugin style default property definition');
        equal(map.middleNumber, 5, prefix + 'define plugin style default property definition');
        equal(map.lastLetter, 'I', prefix + 'define plugin style generated default property definition');
        equal(map.lastNumber, 9, prefix + 'define plugin style generated default property definition');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(6);
        var DefaultMap = define.Constructor({
            '*': {
                type: 'number',
                set: function (newVal) {
                    ok(true, 'set called');
                    return newVal;
                }
            },
            someNumber: { value: '5' },
            number: {}
        });
        var map = new DefaultMap();
        equal(map.someNumber, '5', 'default values are not type converted anymore');
        map.someNumber = '5';
        equal(map.someNumber, 5, 'on a set, they should be type converted');
        map.number = '10';
        equal(map.number, 10, 'value of number should be converted to a number');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = define.Constructor({ name: { value: nailedIt } });
        var NestedMap = define.Constructor({
            isEnabled: { value: true },
            test: { Value: Example },
            examples: {
                type: {
                    one: { Value: Example },
                    two: {
                        type: { deep: { Value: Example } },
                        Value: Object
                    }
                },
                Value: Object
            }
        });
        var nested = new NestedMap();
        equal(nested.test.name, nailedIt);
        equal(nested.examples.one.name, nailedIt);
        equal(nested.examples.two.deep.name, nailedIt);
        ok(nested.test instanceof Example);
        ok(nested.examples.one instanceof Example);
        ok(nested.examples.two.deep instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = compute(1);
        var GetMap = define.Constructor({
            value: {
                set: function (newValue, setVal, oldValue) {
                    if (newValue.isComputed) {
                        return newValue;
                    }
                    if (oldValue && oldValue.isComputed) {
                        oldValue(newValue);
                        return oldValue;
                    }
                    return newValue;
                },
                get: function (value) {
                    return value && value.isComputed ? value() : value;
                }
            }
        });
        var getMap = new GetMap();
        getMap.value = computeValue;
        equal(getMap.value, 1, 'initial value read from compute');
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue(2);
        getMap.value = 3;
        equal(getMap.value, 3, 'read value is 3');
        equal(computeValue(), 3, 'the compute value is 3');
        var newComputeValue = compute(4);
        getMap.value = newComputeValue;
    });
    test('value and get (#1521)', function () {
        var MyMap = define.Constructor({
            data: {
                value: function () {
                    return new CanList(['test']);
                }
            },
            size: {
                value: 1,
                get: function (val) {
                    var list = this.data;
                    var length = list.attr('length');
                    return val + length;
                }
            }
        });
        var map = new MyMap({});
        equal(map.size, 2);
    });
    test('One event on getters (#1585)', function () {
        var Person = define.Constructor({
            name: '*',
            id: 'number'
        });
        var AppState = define.Constructor({
            person: {
                get: function (lastSetValue, resolve) {
                    if (lastSetValue) {
                        return lastSetValue;
                    } else if (this.personId) {
                        resolve(new Person({
                            name: 'Jose',
                            id: 5
                        }));
                    } else {
                        return null;
                    }
                },
                Type: Person
            },
            personId: '*'
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function (ev, person) {
            personEvents++;
        });
        equal(appState.person, null, 'no personId and no lastSetValue');
        appState.personId = 5;
        equal(appState.person.name, 'Jose', 'a personId, providing Jose');
        ok(appState.person instanceof Person, 'got a person instance');
        appState.person = { name: 'Julia' };
        ok(appState.person instanceof Person, 'got a person instance');
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        equal(map.foo, '', 'Calling .foo returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .foo returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = define.Constructor({
            foo: {
                value: '',
                set: function (setVal) {
                    return setVal;
                },
                get: function (lastSetVal) {
                    return lastSetVal;
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.foo, '', 'Calling .attr(\'foo\') returned the correct value');
        map.foo = 'baz';
        equal(map.foo, 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = define.Constructor({
            date: { type: 'date' },
            string: { type: 'string' },
            number: { type: 'number' },
            'boolean': { type: 'boolean' },
            htmlbool: { type: 'htmlbool' },
            leaveAlone: { type: '*' }
        });
        var t = new Typer({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.date, undefined, 'converted to date');
        equal(t.string, undefined, 'converted to string');
        equal(t.number, undefined, 'converted to number');
        equal(t.boolean, undefined, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, undefined, 'left as object');
        t = new Typer({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.date, null, 'converted to date');
        equal(t.string, null, 'converted to string');
        equal(t.number, null, 'converted to number');
        equal(t.boolean, null, 'converted to boolean');
        equal(t.htmlbool, false, 'converted to htmlbool');
        equal(t.leaveAlone, null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    ok(false, 'Should not be called');
                    return lastVal;
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = define.Constructor({
            count: {
                get: function (lastVal) {
                    return lastVal;
                }
            }
        });
        var map = new Map();
        map.bind('count', function () {
            ok(true, 'change called');
        });
        map.count = 22;
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = define.Constructor({
            foo: {
                get: function (lastVal, setVal) {
                    setTimeout(function () {
                        if (setVal) {
                            setVal(5);
                        }
                    }, 10);
                }
            },
            bar: {
                get: function () {
                    var foo = this.foo;
                    if (foo) {
                        if (ran) {
                            ok(false, 'Getter ran twice');
                        }
                        ran = true;
                        return foo * 2;
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.bar, 10);
            start();
        }, 200);
    });
    QUnit.test('Default values cannot be set (#8)', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            first: {
                type: 'string',
                value: 'Chris'
            },
            last: {
                type: 'string',
                value: 'Gomez'
            },
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            }
        });
        var p = new Person();
        QUnit.equal(p.fullName, 'Chris Gomez', 'Fullname is correct');
        p.first = 'Sara';
        QUnit.equal(p.fullName, 'Sara Gomez', 'Fullname is correct after update');
    });
    QUnit.test('default type is setable', function () {
        var Person = function () {
        };
        define(Person.prototype, {
            '*': 'string',
            first: { value: 1 },
            last: { value: 2 }
        });
        var p = new Person();
        QUnit.ok(p.first === '1', typeof p.first);
        QUnit.ok(p.last === '2', typeof p.last);
    });
    QUnit.test('expandos are added in define.setup (#25)', function () {
        var MyMap = define.Constructor({});
        var map = new MyMap({ prop: 4 });
        map.on('prop', function () {
            QUnit.ok(true, 'prop event called');
        });
        map.prop = 5;
    });
    if (compute.prototype.trace) {
        QUnit.test('logs work with maps', function () {
            var MyMap = define.Constructor({
                first: 'string',
                last: 'string'
            });
            var m = new MyMap({
                first: 'J',
                last: 'M'
            });
            var fullName = compute(function () {
                return m.first + m.last;
            });
            fullName.on('change', function () {
            });
            var t = fullName.computeInstance.trace();
            QUnit.equal(t.dependencies[0].obj, m);
            QUnit.equal(t.dependencies[1].obj, m);
        });
    }
    QUnit.test('Set property with type compute', function () {
        var MyMap = define.Constructor({ computeProp: { type: 'compute' } });
        var m = new MyMap();
        m.computeProp = compute(0);
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = compute(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property can have a default value', function () {
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return 0;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        m.computeProp = 1;
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Compute type property with compute default value triggers change events when updated', function () {
        var expected = 0;
        var c = compute(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        c.bind('change', function (ev, newVal) {
            equal(newVal, expected, 'Compute fired change event');
        });
        m.on('computeProp', function (ev, newVal) {
            equal(newVal, expected, 'Map fired change event');
        });
        expected = 1;
        m.computeProp = expected;
        expected = 2;
        c(expected);
    });
    QUnit.test('Compute type property can have a default value that is a compute', function () {
        var c = compute(0);
        var MyMap = define.Constructor({
            computeProp: {
                type: 'compute',
                value: function () {
                    return c;
                }
            }
        });
        var m = new MyMap();
        equal(m.computeProp, 0, 'Property has correct value');
        c(1);
        equal(m.computeProp, 1, 'Property has correct value');
    });
    QUnit.test('Extensions can modify definitions', function () {
        var oldExtensions = define.extensions;
        define.behaviors.push('extended');
        define.extensions = function (objPrototype, prop, definition) {
            if (definition.extended) {
                return { value: 'extended' };
            }
        };
        var MyMap = define.Constructor({
            foo: {
                value: 'defined',
                extended: true
            },
            bar: { value: 'defined' }
        });
        var map = new MyMap();
        QUnit.equal(map.foo, 'extended', 'Value was set via extension');
        QUnit.equal(map.bar, 'defined', 'Value was set via definition');
        define.extensions = oldExtensions;
    });
    QUnit.test('Properties are enumerable', function () {
        QUnit.expect(4);
        function VM(foo) {
            this.foo = foo;
        }
        define(VM.prototype, { foo: 'string' });
        var vm = new VM('bar');
        vm.baz = 'qux';
        var i = 0;
        each(vm, function (value, key) {
            if (i === 0) {
                QUnit.equal(key, 'foo');
                QUnit.equal(value, 'bar');
            } else {
                QUnit.equal(key, 'baz');
                QUnit.equal(value, 'qux');
            }
            i++;
        });
    });
    QUnit.test('Doesn\'t override canSymbol.iterator if already on the prototype', function () {
        function MyMap() {
        }
        MyMap.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            var i = 0;
            return {
                next: function () {
                    if (i === 0) {
                        i++;
                        return {
                            value: [
                                'it',
                                'worked'
                            ],
                            done: false
                        };
                    }
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
        };
        define(MyMap.prototype, { foo: 'string' });
        var map = new MyMap();
        map.foo = 'bar';
        each(map, function (value, key) {
            QUnit.equal(value, 'worked');
            QUnit.equal(key, 'it');
        });
    });
    QUnit.test('nullish values are not converted for type or Type', function (assert) {
        var Foo = function () {
        };
        var MyMap = define.Constructor({
            map: { Type: Foo },
            notype: {}
        });
        var vm = new MyMap({
            map: {},
            notype: {}
        });
        assert.ok(vm.map instanceof Foo, 'map is another type');
        assert.ok(vm.notype instanceof Object, 'notype is an Object');
        vm.map = null;
        vm.notype = null;
        assert.equal(vm.map, null, 'map is null');
        assert.equal(vm.map, null, 'notype is null');
    });
    QUnit.test('shorthand getter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        canBatch.start();
        p.first = 'Justin';
        p.last = 'Meyer';
        canBatch.stop();
    });
    QUnit.test('shorthand getter setter (#56)', function () {
        var Person = function (first, last) {
            this.first = first;
            this.last = last;
        };
        define(Person.prototype, {
            first: '*',
            last: '*',
            get fullName() {
                return this.first + ' ' + this.last;
            },
            set fullName(newVal) {
                var parts = newVal.split(' ');
                this.first = parts[0];
                this.last = parts[1];
            }
        });
        var p = new Person('Mohamed', 'Cherif');
        p.on('fullName', function (ev, newVal, oldVal) {
            QUnit.equal(oldVal, 'Mohamed Cherif');
            QUnit.equal(newVal, 'Justin Meyer');
        });
        equal(p.fullName, 'Mohamed Cherif', 'fullName initialized right');
        p.fullName = 'Justin Meyer';
    });
    QUnit.test('set and value work together (#87)', function () {
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num) {
                    return num * num;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used setter');
    });
    QUnit.test('async setter is provided', 5, function () {
        var RESOLVE;
        var Type = define.Constructor({
            prop: {
                value: 2,
                set: function (num, resolve) {
                    resolve(num * num);
                }
            },
            prop2: {
                value: 3,
                set: function (num, resolve) {
                    RESOLVE = resolve;
                }
            }
        });
        var instance = new Type();
        QUnit.equal(instance.prop, 4, 'used async setter');
        QUnit.equal(instance.prop2, undefined, 'used async setter');
        instance.on('prop2', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, 9, 'updated');
            QUnit.equal(oldVal, undefined, 'updated');
        });
        RESOLVE(9);
        QUnit.equal(instance.prop2, 9, 'used async setter updates after');
    });
    QUnit.test('setter with default value causes an infinite loop (#142)', function () {
        var A = define.Constructor({
            val: {
                value: 'hello',
                set: function (val) {
                    if (this.val) {
                    }
                    return val;
                }
            }
        });
        var a = new A();
        QUnit.equal(a.val, 'hello', 'creating an instance should not cause an inifinte loop');
    });
    QUnit.test('defined properties are configurable', function () {
        var A = define.Constructor({
            val: {
                get: function () {
                    return 'foo';
                }
            }
        });
        var dataInitializers = A.prototype._define.dataInitializers, computedInitializers = A.prototype._define.computedInitializers;
        var newDefinition = {
            get: function () {
                return 'bar';
            }
        };
        define.property(A.prototype, 'val', newDefinition, dataInitializers, computedInitializers);
        var a = new A();
        QUnit.equal(a.val, 'bar', 'It was redefined');
    });
    QUnit.test('define() should add a CID (#246)', function () {
        var Greeting = function (message) {
            this.message = message;
        };
        define(Greeting.prototype, { message: { type: 'string' } });
        var g = new Greeting();
        QUnit.ok(g._cid, 'should have a CID property');
    });
    testHelpers.dev.devOnlyTest('Setting a value with only a get() generates a warning (#202)', function () {
        QUnit.expect(7);
        var message = 'can-define: Set value for property derivedProp ignored, as its definition has a zero-argument getter and no setter';
        var finishErrorCheck = testHelpers.dev.willWarn(message, function (actualMessage, success) {
            QUnit.equal(actualMessage, message, 'Warning is expected message');
            QUnit.ok(success);
        });
        var VM = function () {
        };
        define(VM.prototype, {
            derivedProp: {
                get: function () {
                    return 'Hello World';
                }
            }
        });
        var vm = new VM();
        vm.on('derivedProp', function () {
        });
        vm.derivedProp = 'prop is set';
        QUnit.equal(vm.derivedProp, 'Hello World', 'Getter value is preserved');
        VM.shortName = 'VM';
        QUnit.equal(finishErrorCheck(), 1);
        message = 'can-define: Set value for property derivedProp on VM ignored, as its definition has a zero-argument getter and no setter';
        finishErrorCheck = testHelpers.dev.willWarn(message, function (actualMessage, success) {
            QUnit.equal(actualMessage, message, 'Warning is expected message');
            QUnit.ok(success);
        });
        vm.derivedProp = 'prop is set';
        QUnit.equal(finishErrorCheck(), 1);
    });
    testHelpers.dev.devOnlyTest('warn on using a Constructor for small-t type definintions', function () {
        QUnit.expect(2);
        var message = 'can-define: the definition for currency uses a constructor for "type". Did you mean "Type"?';
        var finishErrorCheck = testHelpers.dev.willWarn(message);
        function Currency() {
            return this;
        }
        Currency.prototype = { symbol: 'USD' };
        function VM() {
        }
        define(VM.prototype, {
            currency: {
                type: Currency,
                value: function () {
                    return new Currency({});
                }
            }
        });
        QUnit.equal(finishErrorCheck(), 1);
        message = 'can-define: the definition for currency on VM2 uses a constructor for "type". Did you mean "Type"?';
        finishErrorCheck = testHelpers.dev.willWarn(message);
        function VM2() {
        }
        VM2.shortName = 'VM2';
        define(VM2.prototype, {
            currency: {
                type: Currency,
                value: function () {
                    return new Currency({});
                }
            }
        });
        QUnit.equal(finishErrorCheck(), 1);
    });
});
/*can-define@1.5.7#test/test*/
define('can-define@1.5.7#test/test', [
    'require',
    'exports',
    'module',
    '../list/list-test',
    '../map/map-test',
    '../define-test',
    'can-define/map/map',
    'can-define/list/list',
    'can-util/js/is-plain-object/is-plain-object',
    'can-types',
    'steal-qunit'
], function (require, exports, module) {
    require('../list/list-test');
    require('../map/map-test');
    require('../define-test');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var types = require('can-types');
    var QUnit = require('steal-qunit');
    QUnit.module('can-define: map and list combined');
    QUnit.test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        QUnit.ok(items.people instanceof types.DefineList, 'people is list');
        QUnit.ok(items.people.item(0) instanceof types.DefineMap, '1st object is Map');
        QUnit.ok(items.people.item(1) instanceof types.DefineMap, '2nd object is Map');
        QUnit.equal(items.people.item(1).name, 'Brian', '2nd object\'s name is right');
        QUnit.equal(items.count, 1000, 'count is number');
    });
    QUnit.test('serialize works', function () {
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string'
        });
        var People = DefineList.extend({ '*': Person });
        var people = new People([{
                first: 'j',
                last: 'm'
            }]);
        QUnit.deepEqual(people.serialize(), [{
                first: 'j',
                last: 'm'
            }]);
    });
    QUnit.test('Extended Map with empty def converts to default Observables', function () {
        var School = DefineMap.extend({
            students: {},
            teacher: {}
        });
        var school = new School();
        school.students = [{ name: 'J' }];
        school.teacher = { name: 'M' };
        ok(school.students instanceof types.DefineList, 'converted to DefineList');
        ok(school.teacher instanceof types.DefineMap, 'converted to DefineMap');
    });
    QUnit.test('default \'observable\' type prevents Type from working (#29)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var L = DefineList.extend('L', { '*': M });
        var MyMap = DefineMap.extend({ l: L });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('inline DefineList Type', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        QUnit.ok(m.l[0] instanceof M, 'is instance');
        QUnit.equal(m.l[0].id, 5, 'correct props');
    });
    QUnit.test('recursively `get`s (#31)', function () {
        var M = DefineMap.extend('M', { id: 'number' });
        var MyMap = DefineMap.extend({ l: { Type: [M] } });
        var m = new MyMap({ l: [{ id: 5 }] });
        var res = m.get();
        QUnit.ok(Array.isArray(res.l), 'is a plain array');
        QUnit.ok(isPlainObject(res.l[0]), 'plain object');
    });
    QUnit.test('DefineList trigger deprecation warning when set with Map.set (#93)', 0, function () {
        var map = new DefineMap({ things: [{ foo: 'bar' }] });
        map.things.attr = function () {
            ok(false, 'attr should not be called');
        };
        map.assign({ things: [{ baz: 'luhrmann' }] });
    });
});
/*can-set@1.6.0#src/helpers*/
define('can-set@1.6.0#src/helpers', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-util/js/last/last'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var last = require('can-util/js/last/last');
    var IgnoreType = function () {
    };
    var helpers;
    module.exports = helpers = {
        eachInUnique: function (a, acb, b, bcb, defaultReturn) {
            var bCopy = assign({}, b), res;
            for (var prop in a) {
                res = acb(a[prop], b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
                delete bCopy[prop];
            }
            for (prop in bCopy) {
                res = bcb(undefined, b[prop], a, b, prop);
                if (res !== undefined) {
                    return res;
                }
            }
            return defaultReturn;
        },
        doubleLoop: function (arr, callbacks) {
            if (typeof callbacks === 'function') {
                callbacks = { iterate: callbacks };
            }
            var i = 0;
            while (i < arr.length) {
                if (callbacks.start) {
                    callbacks.start(arr[i]);
                }
                var j = i + 1;
                while (j < arr.length) {
                    if (callbacks.iterate(arr[j], j, arr[i], i) === false) {
                        arr.splice(j, 1);
                    } else {
                        j++;
                    }
                }
                if (callbacks.end) {
                    callbacks.end(arr[i]);
                }
                i++;
            }
        },
        identityMap: function (arr) {
            var map = {};
            each(arr, function (value) {
                map[value] = 1;
            });
            return map;
        },
        arrayUnionIntersectionDifference: function (arr1, arr2) {
            var map = {};
            var intersection = [];
            var union = [];
            var difference = arr1.slice(0);
            each(arr1, function (value) {
                map[value] = true;
                union.push(value);
            });
            each(arr2, function (value) {
                if (map[value]) {
                    intersection.push(value);
                    var index = helpers.indexOf.call(difference, value);
                    if (index !== -1) {
                        difference.splice(index, 1);
                    }
                } else {
                    union.push(value);
                }
            });
            return {
                intersection: intersection,
                union: union,
                difference: difference
            };
        },
        arraySame: function (arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            var map = helpers.identityMap(arr1);
            for (var i = 0; i < arr2.length; i++) {
                var val = map[arr2[i]];
                if (!val) {
                    return false;
                } else if (val > 1) {
                    return false;
                } else {
                    map[arr2[i]]++;
                }
            }
            return true;
        },
        indexOf: Array.prototype.indexOf || function (item) {
            for (var i = 0, thisLen = this.length; i < thisLen; i++) {
                if (this[i] === item) {
                    return i;
                }
            }
            return -1;
        },
        map: Array.prototype.map || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                out.push(cb(this[i], i, this));
            }
            return out;
        },
        filter: Array.prototype.filter || function (cb) {
            var out = [];
            for (var i = 0, len = this.length; i < len; i++) {
                if (cb(this[i], i, this)) {
                    out.push(this[i]);
                }
            }
            return out;
        },
        ignoreType: new IgnoreType(),
        firstProp: function (set) {
            for (var prop in set) {
                return prop;
            }
        },
        index: function (compare, items, props) {
            if (!items || !items.length) {
                return undefined;
            }
            if (compare(props, items[0]) === -1) {
                return 0;
            } else if (compare(props, last(items)) === 1) {
                return items.length;
            }
            var low = 0, high = items.length;
            while (low < high) {
                var mid = low + high >>> 1, item = items[mid], computed = compare(props, item);
                if (computed === -1) {
                    high = mid;
                } else {
                    low = mid + 1;
                }
            }
            return high;
        },
        defaultSort: function (sortPropValue, item1, item2) {
            var parts = sortPropValue.split(' ');
            var sortProp = parts[0];
            var item1Value = item1[sortProp];
            var item2Value = item2[sortProp];
            var temp;
            var desc = parts[1] || '';
            desc = desc.toLowerCase() === 'desc';
            if (desc) {
                temp = item1Value;
                item1Value = item2Value;
                item2Value = temp;
            }
            if (item1Value < item2Value) {
                return -1;
            }
            if (item1Value > item2Value) {
                return 1;
            }
            return 0;
        }
    };
});
/*can-set@1.6.0#src/clause*/
define('can-set@1.6.0#src/clause', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/each/each'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var clause = {};
    module.exports = clause;
    clause.TYPES = [
        'where',
        'order',
        'paginate',
        'id'
    ];
    each(clause.TYPES, function (type) {
        var className = type.charAt(0).toUpperCase() + type.substr(1);
        clause[className] = function (compare) {
            assign(this, compare);
        };
        clause[className].type = type;
    });
});
/*can-set@1.6.0#src/compare*/
define('can-set@1.6.0#src/compare', [
    'require',
    'exports',
    'module',
    './helpers',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array'
], function (require, exports, module) {
    'use strict';
    var h = require('./helpers');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var compareHelpers;
    var loop = function (a, b, aParent, bParent, prop, compares, options) {
        var checks = options.checks;
        for (var i = 0; i < checks.length; i++) {
            var res = checks[i](a, b, aParent, bParent, prop, compares || {}, options);
            if (res !== undefined) {
                return res;
            }
        }
        return options['default'];
    };
    var addIntersectedPropertyToResult = function (a, b, aParent, bParent, prop, compares, options) {
        var subsetCheck;
        if (!(prop in aParent)) {
            subsetCheck = 'subsetB';
        } else if (prop in bParent) {
            return false;
        }
        if (!(prop in bParent)) {
            subsetCheck = 'subsetA';
        }
        if (subsetCheck === 'subsetB') {
            options.result[prop] = b;
        } else {
            options.result[prop] = a;
        }
        return undefined;
    };
    var addToResult = function (fn, name) {
        return function (a, b, aParent, bParent, prop, compares, options) {
            var res = fn.apply(this, arguments);
            if (res === true) {
                if (prop !== undefined && !(prop in options.result)) {
                    options.result[prop] = a;
                }
                return true;
            } else {
                return res;
            }
        };
    };
    var addResultsToNewObject = function (fn, name) {
        return function (a, b, aParent, bParent, prop, compares, options) {
            var existingResult = options.result;
            options.result = {};
            var res = fn.apply(this, arguments);
            if (res) {
                if (prop !== undefined) {
                    existingResult[prop] = options.result;
                } else {
                    assign(existingResult, options.result);
                }
            }
            options.result = existingResult;
            return res;
        };
    };
    module.exports = compareHelpers = {
        equal: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.equalComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.equalObject
            ];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        equalComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && !('difference' in reverseResult);
                    }
                    return false;
                }
                return compareResult;
            }
        },
        equalBasicTypes: function (a, b, aParent, bParent, prop, compares, options) {
            if (a === null || b === null) {
                return a === b;
            }
            if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            if (options.deep === -1) {
                return typeof a === 'object' || a === b;
            }
            if (typeof a !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
                return false;
            }
            if (a === b) {
                return true;
            }
        },
        equalArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) {
                    return false;
                }
                for (var i = 0; i < a.length; i++) {
                    var compare = compares[i] === undefined ? compares['*'] : compares[i];
                    if (!loop(a[i], b[i], a, b, i, compare, options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        equalObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                var bCopy = assign({}, b);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in a) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a[prop], b[prop], a, b, prop, compare, options)) {
                        return false;
                    }
                    delete bCopy[prop];
                }
                for (prop in bCopy) {
                    if (compares[prop] === undefined || !loop(undefined, b[prop], a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return true;
            }
        },
        subset: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.subsetComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.subsetObject
            ];
            options.getSubsets = [];
            options['default'] = false;
            return loop(a, b, aParent, bParent, prop, compares, options);
        },
        subsetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options) && prop in bParent) {
                        return false;
                    }
                }, b, function (a, b, aParent, bParent, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                        return false;
                    }
                }, true);
            }
        },
        subsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getSubset) {
                        if (h.indexOf.call(options.getSubsets, compareResult.getSubset) === -1) {
                            options.getSubsets.push(compareResult.getSubset);
                        }
                    }
                    if (compareResult.intersection === h.ignoreType || compareResult.difference === h.ignoreType) {
                        return true;
                    }
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        properSupersetObject: function (a, b, aParent, bParent, parentProp, compares, options) {
            var bType = typeof b;
            var hasAdditionalProp = false;
            if (bType === 'object' || bType === 'function') {
                var aCopy = assign({}, a);
                if (options.deep === false) {
                    options.deep = -1;
                }
                for (var prop in b) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    var compareResult = loop(a[prop], b[prop], a, b, prop, compare, options);
                    if (compareResult === h.ignoreType) {
                    } else if (!(prop in a) || options.performedDifference) {
                        hasAdditionalProp = true;
                    } else if (!compareResult) {
                        return false;
                    }
                    delete aCopy[prop];
                }
                for (prop in aCopy) {
                    if (compares[prop] === undefined || !loop(a[prop], undefined, a, b, prop, compares[prop], options)) {
                        return false;
                    }
                }
                return hasAdditionalProp;
            }
        },
        properSubsetComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return compareResult;
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult && !('difference' in compareResult)) {
                        var reverseResult = compares(b, a, bParent, aParent, prop, options);
                        return 'intersection' in reverseResult && 'difference' in reverseResult;
                    }
                    return false;
                }
                return compareResult;
            }
        },
        difference: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedDifference = 0;
            options.checks = [
                compareHelpers.differenceComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.equalArrayLike, 'equalArrayLike'),
                addToResult(compareHelpers.properSupersetObject, 'properSubsetObject')
            ];
            options['default'] = true;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true && options.performedDifference) {
                return options.result;
            }
            return res;
        },
        differenceComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('difference' in compareResult) {
                        if (compareResult.difference === h.ignoreType) {
                            return h.ignoreType;
                        } else if (compareResult.difference != null) {
                            options.result[prop] = compareResult.difference;
                            options.performedDifference++;
                            return true;
                        } else {
                            return true;
                        }
                    } else {
                        if (compareHelpers.equalComparesType.apply(this, arguments)) {
                            options.performedDifference++;
                            options.result[prop] = compareResult.union;
                        } else {
                            return false;
                        }
                    }
                }
            }
        },
        union: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedUnion = 0;
            options.checks = [
                compareHelpers.unionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.unionArrayLike, 'unionArrayLike'),
                addResultsToNewObject(compareHelpers.unionObject, 'unionObject')
            ];
            options.getUnions = [];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        unionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if (compareResult.getUnion) {
                        if (h.indexOf.call(options.getUnions, compareResult.getUnion) === -1) {
                            options.getUnions.push(compareResult.getUnion);
                        }
                    }
                    if ('union' in compareResult) {
                        if (compareResult.union === h.ignoreType) {
                            return compareResult.union;
                        }
                        if (compareResult.union !== undefined) {
                            options.result[prop] = compareResult.union;
                        }
                        options.performedUnion++;
                        return true;
                    }
                }
            }
        },
        unionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    var subsetCheck;
                    if (!(prop in aParent)) {
                        subsetCheck = 'subsetB';
                    }
                    if (!(prop in bParent)) {
                        subsetCheck = 'subsetA';
                    }
                    if (subsetCheck) {
                        if (!options.subset) {
                            options.subset = subsetCheck;
                        }
                        return options.subset === subsetCheck ? undefined : false;
                    }
                    return false;
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        unionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var combined = makeArray(a).concat(makeArray(b));
                h.doubleLoop(combined, function (item, j, cur, i) {
                    var res = !compareHelpers.equal(cur, item, aParent, bParent, undefined, compares['*'], { 'default': false });
                    return res;
                });
                options.result[prop] = combined;
                return true;
            }
        },
        count: function (a, b, aParent, bParent, prop, compares, options) {
            options.checks = [
                compareHelpers.countComparesType,
                compareHelpers.equalBasicTypes,
                compareHelpers.equalArrayLike,
                compareHelpers.loopObject
            ];
            options['default'] = false;
            loop(a, b, aParent, bParent, prop, compares, options);
            if (typeof options.count === 'number') {
                return options.count;
            }
            return Infinity;
        },
        countComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    return true;
                } else if (compareResult && typeof compareResult === 'object') {
                    if (typeof compareResult.count === 'number') {
                        if (!('count' in options) || compareResult.count === options.count) {
                            options.count = compareResult.count;
                        } else {
                            options.count = Infinity;
                        }
                    }
                    return true;
                }
            }
        },
        loopObject: function (a, b, aParent, bParent, prop, compares, options) {
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                each(a, function (aValue, prop) {
                    var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                    loop(aValue, b[prop], a, b, prop, compare, options);
                });
                return true;
            }
        },
        intersection: function (a, b, aParent, bParent, prop, compares, options) {
            options.result = {};
            options.performedIntersection = 0;
            options.checks = [
                compareHelpers.intersectionComparesType,
                addToResult(compareHelpers.equalBasicTypes, 'equalBasicTypes'),
                addToResult(compareHelpers.intersectionArrayLike, 'intersectionArrayLike'),
                addResultsToNewObject(compareHelpers.intersectionObject)
            ];
            options['default'] = false;
            var res = loop(a, b, aParent, bParent, prop, compares, options);
            if (res === true) {
                return options.result;
            }
            return false;
        },
        intersectionComparesType: function (a, b, aParent, bParent, prop, compares, options) {
            if (typeof compares === 'function') {
                var compareResult = compares(a, b, aParent, bParent, prop, options);
                if (typeof compareResult === 'boolean') {
                    if (compareResult === true) {
                        options.result[prop] = a;
                        return true;
                    } else {
                        return compareResult;
                    }
                } else if (compareResult && typeof compareResult === 'object') {
                    if ('intersection' in compareResult) {
                        if (compareResult.intersection !== undefined) {
                            options.result[prop] = compareResult.intersection;
                        }
                        options.performedIntersection++;
                        return true;
                    }
                }
            }
        },
        intersectionObject: function (a, b, aParent, bParent, prop, compares, options) {
            var subsetCompare = function (a, b, aParent, bParent, prop) {
                var compare = compares[prop] === undefined ? compares['*'] : compares[prop];
                if (!loop(a, b, aParent, bParent, prop, compare, options)) {
                    return addIntersectedPropertyToResult(a, b, aParent, bParent, prop, compares, options);
                }
            };
            var aType = typeof a;
            if (aType === 'object' || aType === 'function') {
                return h.eachInUnique(a, subsetCompare, b, subsetCompare, true);
            }
        },
        intersectionArrayLike: function (a, b, aParent, bParent, prop, compares, options) {
            if (Array.isArray(a) && Array.isArray(b)) {
                var intersection = [];
                each(makeArray(a), function (cur) {
                    for (var i = 0; i < b.length; i++) {
                        if (compareHelpers.equal(cur, b[i], aParent, bParent, undefined, compares['*'], { 'default': false })) {
                            intersection.push(cur);
                            break;
                        }
                    }
                });
                options.result[prop] = intersection;
                return true;
            }
        }
    };
});
/*can-set@1.6.0#src/get*/
define('can-set@1.6.0#src/get', [
    'require',
    'exports',
    'module',
    './compare',
    './helpers',
    'can-util/js/each/each'
], function (require, exports, module) {
    'use strict';
    var compare = require('./compare');
    var h = require('./helpers');
    var each = require('can-util/js/each/each');
    var filterData = function (data, clause, props) {
        return h.filter.call(data, function (item) {
            var isSubset = compare.subset(item, clause, undefined, undefined, undefined, props, {});
            return isSubset;
        });
    };
    module.exports = {
        subsetData: function (a, b, bData, algebra) {
            var aClauseProps = algebra.getClauseProperties(a);
            var bClauseProps = algebra.getClauseProperties(b);
            var options = {};
            var aData = filterData(bData, aClauseProps.where, algebra.clauses.where);
            if (aData.length && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                aData = aData.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            if (aData.length && (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate)) {
                options = {};
                compare.subset(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, algebra.clauses.paginate, options);
                each(options.getSubsets, function (filter) {
                    aData = filter(a, b, aData, algebra, options);
                });
            }
            return aData;
        }
    };
});
/*can-set@1.6.0#src/set-core*/
define('can-set@1.6.0#src/set-core', [
    'require',
    'exports',
    'module',
    './helpers',
    './clause',
    './compare',
    './get',
    'can-assign',
    'can-util/js/each/each',
    'can-util/js/make-array/make-array',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/get/get'
], function (require, exports, module) {
    'use strict';
    var h = require('./helpers');
    var clause = require('./clause');
    var compare = require('./compare');
    var get = require('./get');
    var assign = require('can-assign');
    var each = require('can-util/js/each/each');
    var makeArray = require('can-util/js/make-array/make-array');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var getProp = require('can-util/js/get/get');
    function concatUnique(aItems, bItems, algebra) {
        var idTree = {};
        var aSet;
        if (typeof Set !== 'undefined') {
            aSet = new Set();
        }
        aItems.forEach(function (item) {
            var keyNode = idTree;
            if (aSet) {
                aSet.add(item);
            }
            each(algebra.clauses.id, function (prop) {
                var propVal = getProp(item, prop);
                if (keyNode && typeof propVal !== 'undefined') {
                    keyNode = keyNode[propVal] = keyNode[propVal] || {};
                } else {
                    keyNode = undefined;
                }
            });
        });
        return aItems.concat(bItems.filter(function (item) {
            var keyNode = idTree;
            if (aSet && aSet.has(item)) {
                return false;
            }
            if (!aSet && aItems.indexOf(item) > -1) {
                return false;
            }
            each(algebra.clauses.id, function (prop) {
                keyNode = keyNode && keyNode[getProp(item, prop)];
            });
            return keyNode === idTree || !keyNode;
        }));
    }
    function Translate(clause, options) {
        if (typeof options === 'string') {
            var path = options;
            options = {
                fromSet: function (set, setRemainder) {
                    return set[path] || {};
                },
                toSet: function (set, wheres) {
                    set[path] = wheres;
                    return set;
                }
            };
        }
        this.clause = clause;
        assign(this, options);
    }
    var Algebra = function () {
        var clauses = this.clauses = {
            where: {},
            order: {},
            paginate: {},
            id: {}
        };
        this.translators = {
            where: new Translate('where', {
                fromSet: function (set, setRemainder) {
                    return setRemainder;
                },
                toSet: function (set, wheres) {
                    return assign(set, wheres);
                }
            })
        };
        var self = this;
        each(arguments, function (arg) {
            if (arg) {
                if (arg instanceof Translate) {
                    self.translators[arg.clause] = arg;
                } else {
                    assign(clauses[arg.constructor.type || 'where'], arg);
                }
            }
        });
    };
    Algebra.make = function (compare, count) {
        if (compare instanceof Algebra) {
            return compare;
        } else {
            return new Algebra(compare, count);
        }
    };
    assign(Algebra.prototype, {
        getClauseProperties: function (set, options) {
            options = options || {};
            var setClone = assign({}, set);
            var clauses = this.clauses;
            var checkClauses = [
                'order',
                'paginate',
                'id'
            ];
            var clauseProps = {
                enabled: {
                    where: true,
                    order: false,
                    paginate: false,
                    id: false
                }
            };
            if (options.omitClauses) {
                checkClauses = h.arrayUnionIntersectionDifference(checkClauses, options.omitClauses).difference;
            }
            each(checkClauses, function (clauseName) {
                var valuesForClause = {};
                var prop;
                for (prop in clauses[clauseName]) {
                    if (prop in setClone) {
                        valuesForClause[prop] = setClone[prop];
                        if (clauseName !== 'id') {
                            delete setClone[prop];
                        }
                    }
                }
                clauseProps[clauseName] = valuesForClause;
                clauseProps.enabled[clauseName] = !isEmptyObject(valuesForClause);
            });
            clauseProps.where = options.isProperties ? setClone : this.translators.where.fromSet(set, setClone);
            return clauseProps;
        },
        getDifferentClauseTypes: function (aClauses, bClauses) {
            var self = this;
            var differentTypes = [];
            each(clause.TYPES, function (type) {
                if (!self.evaluateOperator(compare.equal, aClauses[type], bClauses[type], { isProperties: true }, { isProperties: true })) {
                    differentTypes.push(type);
                }
            });
            return differentTypes;
        },
        updateSet: function (set, clause, result, useSet) {
            if (result && typeof result === 'object' && useSet !== false) {
                if (this.translators[clause]) {
                    set = this.translators.where.toSet(set, result);
                } else {
                    set = assign(set, result);
                }
                return true;
            } else if (result) {
                return useSet === undefined ? undefined : false;
            } else {
                return false;
            }
        },
        evaluateOperator: function (operator, a, b, aOptions, bOptions, evaluateOptions) {
            aOptions = aOptions || {};
            bOptions = bOptions || {};
            evaluateOptions = assign({
                evaluateWhere: operator,
                evaluatePaginate: operator,
                evaluateOrder: operator,
                shouldEvaluatePaginate: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.paginate || bClauseProps.enabled.paginate;
                },
                shouldEvaluateOrder: function (aClauseProps, bClauseProps) {
                    return aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                }
            }, evaluateOptions || {});
            var aClauseProps = this.getClauseProperties(a, aOptions), bClauseProps = this.getClauseProperties(b, bOptions), set = {}, useSet;
            var result = evaluateOptions.evaluateWhere(aClauseProps.where, bClauseProps.where, undefined, undefined, undefined, this.clauses.where, {});
            useSet = this.updateSet(set, 'where', result, useSet);
            if (result && evaluateOptions.shouldEvaluatePaginate(aClauseProps, bClauseProps)) {
                if (evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                    result = evaluateOptions.evaluateOrder(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                    useSet = this.updateSet(set, 'order', result, useSet);
                }
                if (result) {
                    result = evaluateOptions.evaluatePaginate(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, {});
                    useSet = this.updateSet(set, 'paginate', result, useSet);
                }
            } else if (result && evaluateOptions.shouldEvaluateOrder(aClauseProps, bClauseProps)) {
                result = operator(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
                useSet = this.updateSet(set, 'order', result, useSet);
            }
            return result && useSet ? set : result;
        },
        equal: function (a, b) {
            return this.evaluateOperator(compare.equal, a, b);
        },
        subset: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var compatibleSort = true;
            var result;
            if (bClauseProps.enabled.paginate && (aClauseProps.enabled.order || bClauseProps.enabled.order)) {
                compatibleSort = compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {});
            }
            if (!compatibleSort) {
                result = false;
            } else {
                result = this.evaluateOperator(compare.subset, a, b);
            }
            return result;
        },
        properSubset: function (a, b) {
            return this.subset(a, b) && !this.equal(a, b);
        },
        difference: function (a, b) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var differentClauses = this.getDifferentClauseTypes(aClauseProps, bClauseProps);
            var clause, result;
            if (differentClauses.length > 2) {
                result = false;
            } else if (differentClauses.length === 2 && (differentClauses[0] !== 'where' || differentClauses[1] !== 'id')) {
                result = false;
            } else {
                switch (clause = differentClauses[0]) {
                case undefined:
                case 'order': {
                        result = false;
                        break;
                    }
                case 'paginate':
                case 'where': {
                        result = compare.difference(aClauseProps[clause], bClauseProps[clause], undefined, undefined, undefined, this.clauses[clause], {});
                        if (typeof result === 'object') {
                            if (this.translators[clause]) {
                                result = this.translators[clause].toSet({}, result);
                            }
                            assign(result, aClauseProps.order);
                            if (clause === 'paginate') {
                                assign(result, aClauseProps.where);
                            } else if (differentClauses[1] === 'id') {
                                result = compare.difference(aClauseProps.id, bClauseProps.id, undefined, undefined, undefined, this.clauses.id, {});
                            }
                        }
                        break;
                    }
                }
            }
            return result;
        },
        union: function (a, b) {
            return this.evaluateOperator(compare.union, a, b);
        },
        intersection: function (a, b) {
            return this.evaluateOperator(compare.intersection, a, b);
        },
        count: function (set) {
            return this.evaluateOperator(compare.count, set, {});
        },
        has: function (set, props) {
            var result = this.evaluateOperator(compare.subset, props, set, { isProperties: true }, undefined, {
                shouldEvaluatePaginate: function () {
                    return false;
                }
            });
            return result;
        },
        index: function (set, items, item) {
            var aClauseProps = this.getClauseProperties(set);
            var propName = h.firstProp(aClauseProps.order), compare, orderValue;
            if (propName) {
                compare = this.clauses.order[propName];
                orderValue = set[propName];
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            propName = h.firstProp(this.clauses.id);
            if (propName) {
                compare = h.defaultSort;
                orderValue = propName;
                return h.index(function (itemA, itemB) {
                    return compare(orderValue, itemA, itemB);
                }, items, item);
            }
            return;
        },
        getSubset: function (a, b, bData) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var isSubset = this.subset(assign({}, aClauseProps.where, aClauseProps.paginate), assign({}, bClauseProps.where, bClauseProps.paginate));
            if (isSubset) {
                return get.subsetData(a, b, bData, this);
            }
        },
        getUnion: function (a, b, aItems, bItems) {
            var aClauseProps = this.getClauseProperties(a);
            var bClauseProps = this.getClauseProperties(b);
            var algebra = this;
            var options;
            if (this.subset(a, b)) {
                return bItems;
            } else if (this.subset(b, a)) {
                return aItems;
            }
            var combined;
            if (aClauseProps.enabled.paginate || bClauseProps.enabled.paginate) {
                options = {};
                var isUnion = compare.union(aClauseProps.paginate, bClauseProps.paginate, undefined, undefined, undefined, this.clauses.paginate, options);
                if (!isUnion) {
                    return;
                } else {
                    each(options.getUnions, function (filter) {
                        var items = filter(a, b, aItems, bItems, algebra, options);
                        aItems = items[0];
                        bItems = items[1];
                    });
                    combined = concatUnique(aItems, bItems, this);
                }
            } else {
                combined = concatUnique(aItems, bItems, this);
            }
            if (combined.length && aClauseProps.enabled.order && compare.equal(aClauseProps.order, bClauseProps.order, undefined, undefined, undefined, {}, {})) {
                options = {};
                var propName = h.firstProp(aClauseProps.order), compareOrder = algebra.clauses.order[propName];
                combined = combined.sort(function (aItem, bItem) {
                    return compareOrder(a[propName], aItem, bItem);
                });
            }
            return combined;
        },
        id: function (props) {
            var keys = Object.keys(this.clauses.id);
            if (keys.length === 1) {
                return props[keys[0]];
            } else {
                var id = {};
                keys.forEach(function (key) {
                    id[key] = props[key];
                });
                return JSON.stringify(id);
            }
        }
    });
    var callOnAlgebra = function (methodName, algebraArgNumber) {
        return function () {
            var args = makeArray(arguments).slice(0, algebraArgNumber);
            var algebra = Algebra.make(arguments[algebraArgNumber]);
            return algebra[methodName].apply(algebra, args);
        };
    };
    module.exports = {
        Algebra: Algebra,
        Translate: Translate,
        difference: callOnAlgebra('difference', 2),
        equal: callOnAlgebra('equal', 2),
        subset: callOnAlgebra('subset', 2),
        properSubset: callOnAlgebra('properSubset', 2),
        union: callOnAlgebra('union', 2),
        intersection: callOnAlgebra('intersection', 2),
        count: callOnAlgebra('count', 1),
        has: callOnAlgebra('has', 2),
        index: callOnAlgebra('index', 3),
        getSubset: callOnAlgebra('getSubset', 3),
        getUnion: callOnAlgebra('getUnion', 4)
    };
});
/*can-set@1.6.0#src/set-core_test*/
define('can-set@1.6.0#src/set-core_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './set-core'
], function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core');
    test('set.equal', function () {
        var res, now;
        res = set.equal({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.equal({ type: 'folder' }, { type: 'FOLDER' }, {
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        ok(res, 'folder case ignored');
        res = set.equal({ foo: null }, { foo: new Date() });
        ok(!res, 'nulls and Dates are not considered the same. (#773)');
        res = set.equal({ foo: null }, { foo: {} });
        ok(!res, 'nulls and empty objects are not considered the same. (#773)');
        now = new Date();
        res = set.equal({ foo: now }, { foo: new Date(now.getTime()) });
        ok(res, 'date objects with same time values are considered the same. (#35)');
    });
    test('set.subset', function () {
        var res;
        res = set.subset({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.subset({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(res, 'sub set');
        res = set.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'wrong way');
        res = set.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.subset({
            type: 'FOLDER',
            count: 5
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.subset({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.subset({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        equal(set.properSubset({ foo: 'bar' }, {}), true);
        equal(set.properSubset({}, {}), false);
        equal(set.properSubset({}, { foo: 'bar' }), false);
    });
    test('set.difference', function () {
        var res = set.difference({}, { completed: true });
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, { completed: true });
        equal(res, false);
        res = set.difference({ completed: true }, {});
        equal(res, false);
        res = set.difference({ completed: true }, { userId: 5 });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var res = set.difference({
            colors: [
                'red',
                'blue'
            ]
        }, { colors: ['blue'] }, {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        deepEqual(res, { colors: ['red'] });
    });
    test('set.union', function () {
        var res = set.union({}, { completed: true });
        deepEqual(res, {}, 'set / subset');
        res = set.union({ completed: true }, {});
        deepEqual(res, {}, 'subset / set');
        res = set.union({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.union({ foo: 'bar' }, { name: 'A' });
        ok(!res, 'values not equal');
        res = set.union({
            sort: {
                name: {
                    first: 'Rick',
                    last: 'Flair'
                },
                type: 'split'
            }
        }, {
            sort: {
                name: {
                    first: 'Rick',
                    last: 'Flair'
                },
                type: 'split'
            }
        });
        deepEqual(res, {
            sort: {
                name: {
                    first: 'Rick',
                    last: 'Flair'
                },
                type: 'split'
            }
        }, 'correctly unifies nested objects');
    });
    test('set.union Array', function () {
        var res = set.union({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({}) === Infinity, 'defaults to infinity');
        ok(set.count({ foo: 'bar' }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({ foo: 'bar' }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var res = set.intersection({}, { completed: true });
        deepEqual(res, { completed: true }, 'set / subset');
        res = set.intersection({ completed: true }, {});
        deepEqual(res, { completed: true }, 'subset / set');
        res = set.intersection({ foo: 'bar' }, { foo: 'bar' });
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.intersection({ foo: 'bar' }, { foo: 'zed' });
        ok(!res, 'values not equal');
        res = set.intersection({ foo: 'bar' }, { completed: true });
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection should combine definitions');
        res = set.intersection({
            name: {
                title: 'Ravishing',
                last: 'Rude'
            },
            type: 'split'
        }, { name: { first: 'Rick' } });
        deepEqual(res, {
            name: {
                title: 'Ravishing',
                first: 'Rick',
                last: 'Rude'
            },
            type: 'split'
        }, 'intersects nested objects');
    });
    test('set.intersection Array', function () {
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ]
        }, {
            foo: [
                'a',
                'c'
            ]
        });
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.has', function () {
        var res;
        res = set.has({ type: 'FOLDER' }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(res, 'sub set');
        res = set.has({
            type: 'FOLDER',
            parentId: 5
        }, { type: 'FOLDER' });
        ok(!res, 'wrong way');
        res = set.has({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = set.has({ type: 'FOLDER' }, {
            type: 'FOLDER',
            count: 5
        }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = set.has({
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            type: 'FOLDER',
            kind: 'tree'
        }, {
            foo: ignoreProp,
            bar: ignoreProp
        });
        ok(res, 'understands a subset');
        res = set.has({
            type: 'FOLDER',
            kind: 'tree'
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        }, {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(res, 'ignores nulls');
        var algebra = new set.Algebra(set.props.id('invoice_number'), set.props.id('product_code'));
        res = algebra.has({ invoice_number: 5 }, {
            invoice_number: 6,
            product_code: 10,
            product_name: 'Soap'
        });
        ok(res === false, 'understands compound ids subset exclusion');
        res = algebra.has({ invoice_number: 5 }, {
            invoice_number: 5,
            product_code: 10,
            product_name: 'Soap'
        });
        ok(res, 'understands compound id subset inclusion');
    });
    test('set.index', function () {
        var index = set.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, undefined, 'no value if nothing is set');
        var algebra = new set.Algebra(set.props.id('id'));
        index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], {
            id: 0,
            name: 'k'
        });
        equal(index, 0);
    });
    test('algebra.id', function () {
        var algebra = new set.Algebra(set.props.id('_id'));
        QUnit.equal(algebra.id({ _id: 5 }), 5, 'only one id, returns value');
        algebra = new set.Algebra(set.props.id('studentId'), set.props.id('classId'));
        QUnit.equal(algebra.id({
            studentId: 6,
            classId: '7',
            foo: 'bar'
        }), JSON.stringify({
            studentId: 6,
            classId: '7'
        }), 'only one id, returns set as JSON');
    });
    test('set.has algebra with pagination', function () {
        var algebra = new set.Algebra(set.props.offsetLimit('$skip', '$limit'));
        var setA = {
            $limit: 5,
            $skip: 0
        };
        var props = { name: 'My Portfolio' };
        ok(algebra.has(setA, props));
    });
});
/*can-set@1.6.0#src/set-core-nested_test*/
define('can-set@1.6.0#src/set-core-nested_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './set-core'
], function (require, exports, module) {
    QUnit.module('can/set core - nested');
    require('steal-qunit');
    var set = require('./set-core');
    var ignoreProp = function () {
        return true;
    };
    QUnit.module('can-set core - nested where');
    test('set.equal', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            }
        });
        var res;
        res = algebra.equal({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                count: 5
            }
        });
        ok(res, 'count ignored');
        res = algebra.equal({ $where: { type: 'folder' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'folder case ignored');
    });
    test('set.subset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        var res;
        res = algebra.subset({ $where: { type: 'FOLDER' } }, { $where: { type: 'FOLDER' } });
        ok(res, 'equal sets');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'sub set');
        res = algebra.subset({ $where: { type: 'FOLDER' } }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'wrong way');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        });
        ok(!res, 'different values');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { $where: { type: 'FOLDER' } });
        ok(res, 'count ignored');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                category: 'tree'
            }
        }, {
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        });
        ok(res, 'understands a subset');
        res = algebra.subset({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        });
        ok(res, 'ignores nulls');
    });
    test('set.properSubset', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        equal(algebra.properSubset({ $where: { foo: 'bar' } }, { $where: {} }), true);
        equal(algebra.properSubset({ $where: {} }, { $where: {} }), false);
        equal(algebra.properSubset({ $where: {} }, { $where: { foo: 'bar' } }), false);
    });
    test('set.difference', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.difference({ $where: {} }, { $where: { completed: true } });
        ok(res === true, 'diff should be true');
        res = algebra.difference({ $where: { completed: true } }, { $where: { completed: true } });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: {} });
        equal(res, false);
        res = algebra.difference({ $where: { completed: true } }, { $where: { userId: 5 } });
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            $where: {
                colors: [
                    'red',
                    'blue'
                ]
            }
        }, { $where: { colors: ['blue'] } });
        deepEqual(res, { $where: { colors: ['red'] } });
    });
    test('set.union', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: {} }, 'set / subset');
        res = algebra.union({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: {} }, 'subset / set');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.union({ $where: { foo: 'bar' } }, { $where: { name: 'A' } });
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.union({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, {
            $where: {
                foo: [
                    'a',
                    'b',
                    'c'
                ]
            }
        }, 'set / subset');
    });
    test('set.count', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            foo: function () {
                return { count: 100 };
            }
        });
        ok(algebra.count({ $where: {} }) === Infinity, 'defaults to infinity');
        ok(algebra.count({ $where: { bar: 'foo' } }) === Infinity, 'defaults to infinity');
        equal(algebra.count({ $where: { foo: 'bar' } }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({ $where: {} }, { $where: { completed: true } });
        deepEqual(res, { $where: { completed: true } }, 'set / subset');
        res = algebra.intersection({ $where: { completed: true } }, { $where: {} });
        deepEqual(res, { $where: { completed: true } }, 'subset / set');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'bar' } });
        deepEqual(res, { $where: { foo: 'bar' } }, 'equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { foo: 'zed' } });
        ok(!res, 'values not equal');
        res = algebra.intersection({ $where: { foo: 'bar' } }, { $where: { completed: true } });
        deepEqual(res, {
            $where: {
                foo: 'bar',
                completed: true
            }
        }, 'intersection should combine definitions');
    });
    test('set.intersection Array', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'));
        var res = algebra.intersection({
            $where: {
                foo: [
                    'a',
                    'b'
                ]
            }
        }, {
            $where: {
                foo: [
                    'a',
                    'c'
                ]
            }
        });
        deepEqual(res, { $where: { foo: ['a'] } }, 'intersection');
    });
    test('set.has', function () {
        var algebra = new set.Algebra(new set.Translate('where', '$where'), {
            count: ignoreProp,
            type: function (a, b) {
                return ('' + a).toLowerCase() === ('' + b).toLowerCase();
            },
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp
        });
        ok(algebra.has({ $where: { someId: 5 } }, {
            someId: 5,
            name: 'foo'
        }), 'contains');
        var res;
        res = algebra.has({ $where: { type: 'FOLDER' } }, { type: 'FOLDER' });
        ok(res, 'equal sets');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 5
            }
        }, { type: 'FOLDER' });
        equal(res, false, 'doesnt match');
        res = algebra.has({ $where: { type: 'FOLDER' } }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(true, 'is a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                parentId: 7
            }
        }, {
            type: 'FOLDER',
            parentId: 5
        });
        ok(!res, 'different values');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                count: 5
            }
        }, { type: 'FOLDER' }, { count: ignoreProp });
        ok(res, 'count ignored');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                kind: 'tree'
            }
        }, {
            type: 'FOLDER',
            foo: true,
            bar: true
        });
        ok(res, 'understands a subset');
        res = algebra.has({
            $where: {
                type: 'FOLDER',
                foo: true,
                bar: true
            }
        }, {
            type: 'FOLDER',
            kind: 'tree'
        });
        ok(res, 'ignores nulls');
    });
});
/*can-set@1.6.0#src/props*/
define('can-set@1.6.0#src/props', [
    'require',
    'exports',
    'module',
    './helpers',
    './clause',
    'can-util/js/each/each'
], function (require, exports, module) {
    'use strict';
    var h = require('./helpers');
    var clause = require('./clause');
    var each = require('can-util/js/each/each');
    var within = function (value, range) {
        return value >= range[0] && value <= range[1];
    };
    var numericProperties = function (setA, setB, property1, property2) {
        return {
            sAv1: +setA[property1],
            sAv2: +setA[property2],
            sBv1: +setB[property1],
            sBv2: +setB[property2]
        };
    };
    var diff = function (setA, setB, property1, property2) {
        var numProps = numericProperties(setA, setB, property1, property2);
        var sAv1 = numProps.sAv1, sAv2 = numProps.sAv2, sBv1 = numProps.sBv1, sBv2 = numProps.sBv2, count = sAv2 - sAv1 + 1;
        var after = {
            difference: [
                sBv2 + 1,
                sAv2
            ],
            intersection: [
                sAv1,
                sBv2
            ],
            union: [
                sBv1,
                sAv2
            ],
            count: count,
            meta: 'after'
        };
        var before = {
            difference: [
                sAv1,
                sBv1 - 1
            ],
            intersection: [
                sBv1,
                sAv2
            ],
            union: [
                sAv1,
                sBv2
            ],
            count: count,
            meta: 'before'
        };
        if (sAv1 === sBv1 && sAv2 === sBv2) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'equal'
            };
        } else if (sAv1 === sBv1 && sBv2 < sAv2) {
            return after;
        } else if (sAv2 === sBv2 && sBv1 > sAv1) {
            return before;
        } else if (within(sAv1, [
                sBv1,
                sBv2
            ]) && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return {
                intersection: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sBv2
                ],
                count: count,
                meta: 'subset'
            };
        } else if (within(sBv1, [
                sAv1,
                sAv2
            ]) && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return {
                intersection: [
                    sBv1,
                    sBv2
                ],
                difference: [
                    null,
                    null
                ],
                union: [
                    sAv1,
                    sAv2
                ],
                count: count,
                meta: 'superset'
            };
        } else if (sAv1 < sBv1 && within(sAv2, [
                sBv1,
                sBv2
            ])) {
            return before;
        } else if (sBv1 < sAv1 && within(sBv2, [
                sAv1,
                sAv2
            ])) {
            return after;
        } else if (sAv2 === sBv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sAv1,
                    sBv2
                ],
                count: count,
                meta: 'disjoint-before'
            };
        } else if (sBv2 === sAv1 - 1) {
            return {
                difference: [
                    sAv1,
                    sAv2
                ],
                union: [
                    sBv1,
                    sAv2
                ],
                count: count,
                meta: 'disjoint-after'
            };
        }
        if (!isNaN(count)) {
            return {
                count: count,
                meta: 'disjoint'
            };
        }
    };
    var cleanUp = function (value, enumData) {
        if (!value) {
            return enumData;
        }
        if (!Array.isArray(value)) {
            value = [value];
        }
        if (!value.length) {
            return enumData;
        }
        return value;
    };
    var stringConvert = {
        '0': false,
        'false': false,
        'null': undefined,
        'undefined': undefined
    };
    var convertToBoolean = function (value) {
        if (typeof value === 'string') {
            return value.toLowerCase() in stringConvert ? stringConvert[value.toLowerCase()] : true;
        }
        return value;
    };
    var props = {
        'enum': function (prop, enumData) {
            var compares = new clause.Where({});
            compares[prop] = function (vA, vB, A, B) {
                vA = cleanUp(vA, enumData);
                vB = cleanUp(vB, enumData);
                var data = h.arrayUnionIntersectionDifference(vA, vB);
                if (!data.difference.length) {
                    delete data.difference;
                }
                each(data, function (value, prop) {
                    if (Array.isArray(value)) {
                        if (h.arraySame(enumData, value)) {
                            data[prop] = undefined;
                        } else if (value.length === 1) {
                            data[prop] = value[0];
                        }
                    }
                });
                return data;
            };
            return compares;
        },
        paginate: function (propStart, propEnd, translateToStartEnd, reverseTranslate) {
            var compares = {};
            var makeResult = function (result, index) {
                var res = {};
                each([
                    'intersection',
                    'difference',
                    'union'
                ], function (prop) {
                    if (result[prop]) {
                        var set = {
                            start: result[prop][0],
                            end: result[prop][1]
                        };
                        res[prop] = reverseTranslate(set)[index === 0 ? propStart : propEnd];
                    }
                });
                if (result.count) {
                    res.count = result.count;
                }
                return res;
            };
            compares[propStart] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var res = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var result = makeResult(res, 0);
                result.getSubset = function (a, b, bItems, algebra, options) {
                    return bItems;
                };
                result.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    return [
                        aItems,
                        bItems
                    ];
                };
                return result;
            };
            compares[propEnd] = function (vA, vB, A, B) {
                if (vA === undefined) {
                    return;
                }
                var data = diff(translateToStartEnd(A), translateToStartEnd(B), 'start', 'end');
                var res = makeResult(data, 1);
                res.getSubset = function (a, b, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    var numProps = numericProperties(tA, tB, 'start', 'end');
                    var aStartValue = numProps.sAv1, aEndValue = numProps.sAv2;
                    var bStartValue = numProps.sBv1;
                    if (!('end' in tB) || !('end' in tA)) {
                        return bItems.slice(aStartValue, aEndValue + 1);
                    }
                    return bItems.slice(aStartValue - bStartValue, aEndValue - bStartValue + 1);
                };
                res.getUnion = function (a, b, aItems, bItems, algebra, options) {
                    var tA = translateToStartEnd(a);
                    var tB = translateToStartEnd(b);
                    if (data.meta.indexOf('after') >= 0) {
                        if (data.intersection) {
                            bItems = bItems.slice(0, data.intersection[0] - +tB.start);
                        }
                        return [
                            bItems,
                            aItems
                        ];
                    }
                    if (data.intersection) {
                        aItems = aItems.slice(0, data.intersection[0] - +tA.start);
                    }
                    return [
                        aItems,
                        bItems
                    ];
                };
                return res;
            };
            return new clause.Paginate(compares);
        },
        'boolean': function (propertyName) {
            var compares = new clause.Where({});
            compares[propertyName] = function (propA, propB) {
                propA = convertToBoolean(propA);
                propB = convertToBoolean(propB);
                var notA = !propA, notB = !propB;
                if (propA === notB && propB === notA) {
                    return {
                        difference: !propB,
                        union: undefined
                    };
                } else if (propA === undefined) {
                    return {
                        difference: !propB,
                        intersection: propB,
                        union: undefined
                    };
                } else if (propA === propB) {
                    return true;
                }
            };
            return compares;
        },
        'sort': function (prop, sortFunc) {
            if (!sortFunc) {
                sortFunc = h.defaultSort;
            }
            var compares = {};
            compares[prop] = sortFunc;
            return new clause.Order(compares);
        },
        'id': function (prop) {
            var compares = {};
            compares[prop] = prop;
            return new clause.Id(compares);
        }
    };
    var assignExcept = function (d, s, props) {
        for (var prop in s) {
            if (!props[prop]) {
                d[prop] = s[prop];
            }
        }
        return d;
    };
    var translateToOffsetLimit = function (set, offsetProp, limitProp) {
        var newSet = assignExcept({}, set, {
            start: 1,
            end: 1
        });
        if ('start' in set) {
            newSet[offsetProp] = set.start;
        }
        if ('end' in set) {
            newSet[limitProp] = set.end - set.start + 1;
        }
        return newSet;
    };
    var translateToStartEnd = function (set, offsetProp, limitProp) {
        var except = {};
        except[offsetProp] = except[limitProp] = 1;
        var newSet = assignExcept({}, set, except);
        if (offsetProp in set) {
            newSet.start = parseInt(set[offsetProp], 10);
        }
        if (limitProp in set) {
            newSet.end = newSet.start + parseInt(set[limitProp]) - 1;
        }
        return newSet;
    };
    props.offsetLimit = function (offsetProp, limitProp) {
        offsetProp = offsetProp || 'offset';
        limitProp = limitProp || 'limit';
        return props.paginate(offsetProp, limitProp, function (set) {
            return translateToStartEnd(set, offsetProp, limitProp);
        }, function (set) {
            return translateToOffsetLimit(set, offsetProp, limitProp);
        });
    };
    props.rangeInclusive = function (startIndexProperty, endIndexProperty) {
        startIndexProperty = startIndexProperty || 'start';
        endIndexProperty = endIndexProperty || 'end';
        return props.paginate(startIndexProperty, endIndexProperty, function (set) {
            var except = {};
            except[startIndexProperty] = except[endIndexProperty] = 1;
            var newSet = assignExcept({}, set, except);
            if (startIndexProperty in set) {
                newSet.start = set[startIndexProperty];
            }
            if (endIndexProperty in set) {
                newSet.end = set[endIndexProperty];
            }
            return newSet;
        }, function (set) {
            var except = {
                start: 1,
                end: 1
            };
            var newSet = assignExcept({}, set, except);
            newSet[startIndexProperty] = set.start;
            newSet[endIndexProperty] = set.end;
            return newSet;
        });
    };
    var nestedLookup = function (obj, propNameArray) {
        if (obj === undefined) {
            return undefined;
        }
        if (propNameArray.length === 1) {
            return obj[propNameArray[0]];
        } else {
            return nestedLookup(obj[propNameArray[0]], propNameArray.slice(1));
        }
    };
    props.dotNotation = function (dotProperty) {
        var compares = new clause.Where({});
        compares[dotProperty] = function (aVal, bVal, a, b, propertyName) {
            if (aVal === undefined) {
                aVal = nestedLookup(a, propertyName.split('.'));
            }
            if (bVal === undefined) {
                bVal = nestedLookup(b, propertyName.split('.'));
            }
            return aVal === bVal;
        };
        return compares;
    };
    module.exports = props;
});
/*can-set@1.6.0#src/prop_tests/sort_test*/
define('can-set@1.6.0#src/prop_tests/sort_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props',
    'can-util/js/each/each'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    var each = require('can-util/js/each/each');
    QUnit.module('can-set props.sort');
    test('set.difference', function () {
        var prop = props.sort('sort');
        var res = set.difference({ sort: 'foo' }, { completed: true }, prop);
        ok(res === true, 'diff should be true');
        res = set.difference({ completed: true }, {
            completed: true,
            sort: 'foo'
        }, prop);
        equal(res, false, 'the same except for sort');
        res = set.difference({ completed: true }, { sort: 'foo' }, prop);
        equal(res, false);
        res = set.difference({ completed: true }, {
            foo: 'bar',
            sort: 'foo'
        }, prop);
        equal(res, false);
    });
    test('set.difference({ function })', function () {
        var algebra = new set.Algebra(props.sort('sort'), {
            colors: function () {
                return {
                    difference: ['red'],
                    intersection: ['blue']
                };
            }
        });
        var res = algebra.difference({
            colors: [
                'red',
                'blue'
            ],
            sort: 'colors'
        }, { colors: ['blue'] });
        deepEqual(res, {
            colors: ['red'],
            sort: 'colors'
        });
    });
    test('set.union', function () {
        var prop = props.sort('sort');
        var res = set.union({ sort: 'name' }, { completed: true }, prop);
        deepEqual(res, {}, 'set / subset sort left');
        res = set.union({}, {
            completed: true,
            sort: 'name'
        }, prop);
        deepEqual(res, {}, 'set / subset sort right');
        res = set.union({ sort: 'name' }, {
            completed: true,
            sort: 'namer'
        }, prop);
        deepEqual(res, {}, 'set / subset both sorts');
        res = set.union({ completed: true }, { sort: 'foo' }, prop);
        deepEqual(res, {}, 'subset / set');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { foo: 'bar' }, prop);
        deepEqual(res, { foo: 'bar' }, 'equal');
        res = set.union({ foo: 'bar' }, {
            foo: 'zed',
            sort: 'foo'
        }, prop);
        ok(!res, 'values not equal');
        res = set.union({
            foo: 'bar',
            sort: 'foo'
        }, { name: 'A' }, prop);
        ok(!res, 'values not equal');
    });
    test('set.union Array', function () {
        var prop = props.sort('sort');
        var res = set.union({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, {
            foo: [
                'a',
                'b',
                'c'
            ]
        }, 'set / subset');
    });
    test('set.count', function () {
        ok(set.count({ sort: 'name' }) === Infinity, 'defaults to infinity');
        ok(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {}) === Infinity, 'defaults to infinity');
        equal(set.count({
            foo: 'bar',
            sort: 'foo'
        }, {
            foo: function () {
                return { count: 100 };
            }
        }), 100, 'works with a single value');
    });
    test('set.intersection', function () {
        var prop = props.sort('sort');
        var res = set.intersection({}, { sort: 'name' }, prop);
        deepEqual(res, {}, 'no sort if only one is sorted');
        res = set.intersection({ sort: 'name' }, { sort: 'name' }, prop);
        deepEqual(res, { sort: 'name' }, '');
        res = set.intersection({ type: 'new' }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
        res = set.intersection({
            type: 'new',
            sort: 'age'
        }, {
            sort: 'name',
            userId: 5
        }, prop);
        deepEqual(res, {
            type: 'new',
            userId: 5
        }, '');
    });
    test('set.intersection Array', function () {
        var prop = props.sort('sort');
        var res = set.intersection({
            foo: [
                'a',
                'b'
            ],
            sort: 'foo'
        }, {
            foo: [
                'a',
                'c'
            ]
        }, prop);
        deepEqual(res, { foo: ['a'] }, 'intersection');
    });
    test('set.subset', function () {
        var ignoreProp = function () {
            return true;
        };
        var algebra = new set.Algebra(props.sort('sort'), {
            foo: ignoreProp,
            bar: ignoreProp,
            kind: ignoreProp,
            count: ignoreProp
        });
        ok(algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, { type: 'FOLDER' }), 'equal sets with sort on the left');
        ok(algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'equal sets with sort on the right');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }, { type: 'FOLDER' }), 'sub set with sort on the left');
        ok(algebra.subset({
            type: 'FOLDER',
            parentId: 5
        }, {
            type: 'FOLDER',
            sort: 'thing'
        }), 'sub set with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'wrong way with sort on the left');
        ok(!algebra.subset({ type: 'FOLDER' }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'wrong way with sort on the right');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7,
            sort: 'thing'
        }, {
            type: 'FOLDER',
            parentId: 5
        }), 'different values with sort on the left');
        ok(!algebra.subset({
            type: 'FOLDER',
            parentId: 7
        }, {
            type: 'FOLDER',
            parentId: 5,
            sort: 'thing'
        }), 'different values with sort on the right');
    });
    test('set.subset with range', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var addSort = function (set, value) {
            set.sort = value;
        };
        var sort = {
            left: function (setA, setB) {
                addSort(setA, 'prop');
            },
            right: function (setA, setB) {
                addSort(setB, 'prop');
            },
            same: function (setA, setB) {
                addSort(setA, 'prop');
                addSort(setB, 'prop');
            },
            different: function (setA, setB) {
                addSort(setA, 'propA');
                addSort(setB, 'propB');
            }
        };
        var addRange = function (set, start, end) {
            set.start = start;
            set.end = end;
        };
        var range = {
            left: function (setA, setB) {
                addRange(setA, 0, 9);
            },
            right: function (setA, setB) {
                addRange(setB, 0, 9);
            },
            same: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 0, 9);
            },
            superLeft: function (setA, setB) {
                addRange(setA, 0, 9);
                addRange(setB, 3, 7);
            },
            superRight: function (setA, setB) {
                addRange(setB, 0, 9);
                addRange(setA, 3, 7);
            }
        };
        var sets = {
            same: function (setA, setB) {
            },
            superLeft: function (setA, setB) {
                setB.type = 'apples';
            },
            superRight: function (setA, setB) {
                setA.type = 'apples';
            }
        };
        var make = function () {
            var setA = {}, setB = {};
            each(arguments, function (method) {
                method(setA, setB);
            });
            return {
                left: setA,
                right: setB
            };
        };
        var assertSubset = function (methods, result) {
            var sets = make.apply(null, methods);
            equal(algebra.subset(sets.left, sets.right), result, JSON.stringify(sets.left) + ' \u2282 ' + JSON.stringify(sets.right) + ' = ' + result);
        };
        assertSubset([
            sets.superRight,
            range.right,
            sort.right
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.different
        ], false);
        assertSubset([
            sets.same,
            range.same,
            sort.same
        ], true);
        assertSubset([
            sets.same,
            range.superRight,
            sort.left
        ], false);
        assertSubset([
            sets.same,
            range.superRight,
            sort.same
        ], true);
    });
    test('set.index', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var index = algebra.index({ sort: 'name' }, [
            {
                id: 1,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 's'
            }
        ], { name: 'k' });
        equal(index, 2);
    });
    test('set.getSubset (#14)', function () {
        var algebra = new set.Algebra(props.sort('sort'));
        var subset = algebra.getSubset({ sort: 'name' }, {}, [
            {
                id: 1,
                name: 's'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 4,
                name: 'g'
            }
        ]);
        deepEqual(subset, [
            {
                id: 4,
                name: 'g'
            },
            {
                id: 2,
                name: 'j'
            },
            {
                id: 3,
                name: 'm'
            },
            {
                id: 1,
                name: 's'
            }
        ]);
    });
    test('set.getUnion', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.getUnion({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        }, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 3,
                name: 'm',
                complete: true
            }
        ], [
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
        deepEqual(union, [
            {
                id: 4,
                name: 'g',
                complete: true
            },
            {
                id: 2,
                name: 'j',
                complete: false
            },
            {
                id: 3,
                name: 'm',
                complete: true
            },
            {
                id: 1,
                name: 's',
                complete: false
            }
        ]);
    });
    test('set.union keeps sort', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.boolean('complete'));
        var union = algebra.union({
            sort: 'name',
            complete: true
        }, {
            sort: 'name',
            complete: false
        });
        deepEqual(union, { sort: 'name' });
    });
    test('paginated and sorted is subset (#17)', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'parent:paginate+order child:paginate+order (same set)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'parent:paginate+order child:paginate+order (different order)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({ sort: 'name' }, { sort: 'name' });
        equal(res, true, 'parent:order child:order (same)');
        res = algebra.subset({ sort: 'name' }, { sort: 'age' });
        equal(res, true, 'parent:order child:order (different)');
        res = algebra.subset({
            start: 0,
            end: 100
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'age'
        }, { sort: 'name' });
        equal(res, true, 'parent:order child:paginate+order');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:paginate+order');
        res = algebra.subset({ sort: 'name' }, {
            start: 0,
            end: 100
        });
        equal(res, false, 'parent:paginate child:order (same)');
        res = algebra.subset({
            start: 0,
            end: 100,
            sort: 'name'
        }, {});
        equal(res, true, 'parent:-- child:paginate+order');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'name'
        });
        equal(res, true, 'child in smaller range, same sort');
        res = algebra.subset({
            start: 10,
            end: 90,
            sort: 'name'
        }, {
            start: 0,
            end: 100,
            sort: 'age'
        });
        equal(res, false, 'child in smaller range, but different sort');
    });
});
/*can-set@1.6.0#src/prop_tests/rangeInclusive_test*/
define('can-set@1.6.0#src/prop_tests/rangeInclusive_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.rangeInclusive');
    test('rangeInclusive set.equal', function () {
        ok(set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
        ok(!set.equal({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'they are not equal');
    });
    test('rangeInclusive set.subset', function () {
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'self is a subset');
        ok(set.subset({
            start: 0,
            end: 100
        }, {
            start: 0,
            end: 101
        }, props.rangeInclusive('start', 'end')), 'end extends past subset');
        ok(!set.subset({
            start: 0,
            end: 101
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends past end');
        ok(set.subset({
            start: 1,
            end: 100
        }, {
            start: 0,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'start extends before subset');
        ok(!set.subset({
            start: 0,
            end: 100
        }, {
            start: 1,
            end: 100
        }, props.rangeInclusive('start', 'end')), 'non-subset extends before start');
    });
    test('rangeInclusive set.difference', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.difference({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'got a diff');
        res = set.difference({}, {
            start: 0,
            end: 10
        }, prop);
        equal(res, true, 'universal set');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 49
        }, 'side by side');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 0,
            end: 20
        }, prop);
        deepEqual(res, {
            start: 21,
            end: 49
        }, 'first set extends past second');
        res = set.difference({
            start: 0,
            end: 49
        }, {
            start: 20,
            end: 49
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 19
        }, 'first set starts before second');
    });
    test('rangeInclusive set.union', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.union({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 0,
            end: 101
        }, 'got a union');
        res = set.union({}, {
            start: 0,
            end: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            start: 100,
            end: 199
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 199
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'no intersection with either argument order');
        res = set.union({
            start: 200,
            end: 299
        }, {
            start: 100,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect');
        res = set.union({
            start: 100,
            end: 209
        }, {
            start: 200,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'sets can intersect with either argument order');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'first set contains second');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 103,
            end: 209
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'second set contains first');
        res = set.union({
            start: 100,
            end: 299
        }, {
            start: 100,
            end: 299
        }, prop);
        deepEqual(res, {
            start: 100,
            end: 299
        }, 'union of identical sets is the same as those sets');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.count({
            start: 0,
            end: 99
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.rangeInclusive('start', 'end');
        var res = set.intersection({
            start: 0,
            end: 99
        }, {
            start: 50,
            end: 101
        }, prop);
        deepEqual(res, {
            start: 50,
            end: 99
        }, 'got a intersection');
    });
    test('rangeInclusive with string numbers (#17)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        ok(algebra.subset({
            start: '1',
            end: '100'
        }, {
            start: '0',
            end: '100'
        }), '.subset');
        var res = algebra.getSubset({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 2 },
            { id: 3 }
        ], '.getSubset');
        res = algebra.getUnion({
            start: '2',
            end: '3'
        }, {
            start: '1',
            end: '4'
        }, [
            { id: 2 },
            { id: 3 }
        ], [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ]);
        deepEqual(res, [
            { id: 1 },
            { id: 2 },
            { id: 3 },
            { id: 4 }
        ], '.getUnion');
    });
});
/*can-set@1.6.0#src/prop_tests/offsetLimit_test*/
define('can-set@1.6.0#src/prop_tests/offsetLimit_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.limitOffset');
    test('offsetLimit set.equal', function () {
        ok(set.equal({
            offset: 0,
            limit: 99
        }, {
            offset: 0,
            limit: 99
        }, props.offsetLimit('offset', 'limit')), 'they are equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 0,
            limit: 101
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
        ok(!set.equal({
            offset: 0,
            limit: 100
        }, {
            offset: 1,
            limit: 100
        }, props.offsetLimit('offset', 'limit')), 'they are not equal');
    });
    test('offsetLimit set.union', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.union({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 0,
            limit: 102
        }, 'got a union');
        res = set.union({}, {
            offset: 0,
            limit: 10
        }, prop);
        deepEqual(res, {}, 'universal set');
        res = set.union({
            offset: 100,
            limit: 100
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection');
        res = set.union({
            offset: 200,
            limit: 100
        }, {
            offset: 100,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'no intersection with either argument order');
        res = set.union({
            offset: 100,
            limit: 110
        }, {
            offset: 200,
            limit: 100
        }, prop);
        deepEqual(res, {
            offset: 100,
            limit: 200
        }, 'sets can intersect with either argument order');
    });
    test('rangeInclusive set.count', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.count({
            offset: 0,
            limit: 100
        }, prop);
        equal(res, 100, 'count is right');
    });
    test('rangeInclusive set.intersection', function () {
        var prop = props.offsetLimit('offset', 'limit');
        var res = set.intersection({
            offset: 0,
            limit: 100
        }, {
            offset: 50,
            limit: 52
        }, prop);
        deepEqual(res, {
            offset: 50,
            limit: 50
        }, 'got a intersection');
    });
});
/*can-set@1.6.0#src/prop_tests/boolean_test*/
define('can-set@1.6.0#src/prop_tests/boolean_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.boolean');
    test('boolean set.difference', function () {
        var prop = props.boolean('completed');
        var res = set.difference({}, { completed: true }, prop);
        deepEqual(res, { completed: false }, 'inverse of true');
        res = set.difference({}, { completed: false }, prop);
        deepEqual(res, { completed: true }, 'inverse of false');
    });
    test('boolean set.union', function () {
        var prop = props.boolean('completed');
        var res = set.union({ completed: false }, { completed: true }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
    });
    test('boolean set.intersection', function () {
        var prop = props.boolean('completed');
        var res = set.intersection({ foo: 'bar' }, { completed: true }, prop);
        deepEqual(res, {
            foo: 'bar',
            completed: true
        }, 'intersection is false (#4)');
    });
    test('strings false and true are treated as booleans', function () {
        var prop = props.boolean('completed');
        var res = set.subset({}, { completed: 'true' }, prop);
        ok(!res, '{} and \'true\' not a subset');
        res = set.subset({}, { completed: 'false' }, prop);
        ok(!res, '{} and \'false\' not a subset');
        res = set.subset({ completed: 'true' }, {}, prop);
        ok(res, 'subset');
        res = set.subset({ completed: 'false' }, {}, prop);
        ok(res, 'subset');
        res = set.union({ completed: 'false' }, { completed: 'true' }, prop);
        deepEqual(res, {}, 'union of true and false is entire boolean set');
        res = set.equal({ completed: false }, { completed: 'false' }, prop);
        ok(res, 'false and \'false\'');
    });
});
/*can-set@1.6.0#src/prop_tests/enum_test*/
define('can-set@1.6.0#src/prop_tests/enum_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.enum');
    test('enum set.intersection', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.intersection({}, { type: 'new' }, prop);
        deepEqual(res, { type: 'new' }, 'single enum intersected with universal set is idempotent');
        res = set.intersection({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'array enum intersected with unversal set is idempotent');
        res = set.intersection({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, { type: 'prep' }, 'items v items intersection');
        res = set.intersection({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'new',
                'prep'
            ]
        }, 'empty v array intersection');
        res = set.intersection({ type: 'new' }, {}, prop);
        deepEqual(res, { type: 'new' }, 'single v all');
    });
    test('enum set.difference', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.difference({}, { type: 'new' }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'difference from universal set');
        res = set.difference({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, false, 'difference from a superset');
        res = set.difference({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'deliver',
                'delivered'
            ]
        }, 'empty enum definition is same as universal set');
        res = set.difference({ type: 'new' }, {}, prop);
        deepEqual(res, false, 'all');
    });
    test('enum set.union', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.union({}, { type: 'new' }, prop);
        deepEqual(res, {}, 'all');
        res = set.union({}, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: ['prep'] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {
            type: [
                'prep',
                'new'
            ]
        }, 'union of a superset is superset');
        res = set.union({ type: [] }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
        res = set.union({ type: 'new' }, {}, prop);
        deepEqual(res, {}, 'all');
        res = set.union({
            type: [
                'deliver',
                'delivered'
            ]
        }, {
            type: [
                'new',
                'prep'
            ]
        }, prop);
        deepEqual(res, {}, 'intersection');
    });
    test('enum set.equal', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.equal({}, { type: 'new' }, prop);
        deepEqual(res, false, 'proper subset is not the universal set');
        res = set.equal({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'subset of all possible enums is the same as universal set');
        res = set.equal({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'identical sets with single array enum are equal');
        res = set.equal({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'identical sets with single property enum are equal');
        res = set.equal({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'two sets with different enum properties are not equal');
    });
    test('enum set.subset', function () {
        var prop = props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]);
        var res = set.subset({}, { type: 'new' }, prop);
        deepEqual(res, false, 'universal set is not a subset');
        res = set.subset({ type: 'new' }, {}, prop);
        deepEqual(res, true, 'any single enum is a subset of universal set');
        res = set.subset({}, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'enum set matching definition of universal set is a subset of universal set');
        res = set.subset({ type: ['prep'] }, { type: ['prep'] }, prop);
        deepEqual(res, true, 'any list of possible enums are subset of universal set');
        res = set.subset({ type: 'prep' }, { type: 'prep' }, prop);
        deepEqual(res, true, 'intersection');
        res = set.subset({ type: 'new' }, { type: 'prep' }, prop);
        deepEqual(res, false, 'all');
        res = set.subset({ type: 'prep' }, {
            type: [
                'new',
                'prep',
                'deliver',
                'delivered'
            ]
        }, prop);
        deepEqual(res, true, 'intersection');
    });
});
/*can-set@1.6.0#src/prop_tests/dotNotation_test*/
define('can-set@1.6.0#src/prop_tests/dotNotation_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.dotNotation');
    test('dotNotation set membership', function () {
        var prop = props.dotNotation('n.p'), alg = new set.Algebra(prop), res = alg.has({ 'n.p': 'IL' }, { n: { p: 'IL' } });
        ok(res, 'object with nested property is member of set using dotNotation');
        res = alg.has({ 'n.p': 'IL' }, { n: { p: 'MI' } });
        ok(res === false, 'object with nested property not a member of set using dotNotation');
        prop = props.dotNotation('n.p.s');
        alg = new set.Algebra(prop);
        res = alg.has({ 'n.p.s': 'IL' }, { n: { p: { s: 'IL' } } });
        ok(res, 'object with deep nested property is member of set using dotNotation');
    });
    test('dotNotation set equality', function () {
        var prop = props.dotNotation('n.p'), alg = new set.Algebra(prop), set1 = { 'n.p': 'IL' }, set2 = { 'n.p': 'IL' }, set3 = { 'n.p': 'MI' }, set4 = { n: { p: 'MI' } };
        ok(alg.equal(set1, set2) && alg.equal(set2, set1), 'sets with dotNotation properties are equivalent');
        ok(alg.equal(set1, set3) === false, 'sets with dotNotation properties are not equivalent');
        ok(alg.equal(set4, set3) === false, 'sets with dotNotation properties are equivalent to sets with nested properties');
    });
    test('dotNotation set subset', function () {
        var alg = new set.Algebra(props.dotNotation('address.state'), props.dotNotation('address.city')), set1 = { 'address.state': 'IL' }, set2 = {
                'address.state': 'IL',
                'address.city': 'Chicago'
            }, set3 = {
                address: {
                    state: 'IL',
                    city: 'Chicago'
                }
            };
        ok(alg.subset(set2, set1), 'sets with dotNotation property is a subset of another dotNotation set');
        ok(alg.subset(set3, set1), 'sets with nested property notation is a subset of a dotNotation set');
        ok(alg.subset(set1, {}), 'sets with dotNotation properties are subsets of the universal set');
        ok(alg.subset({}, set1) === false, 'the universal set is not a subset of a set with dotNotation');
    });
});
/*can-set@1.6.0#src/prop_tests/id_test*/
define('can-set@1.6.0#src/prop_tests/id_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../set-core',
    '../props'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var set = require('../set-core'), props = require('../props');
    QUnit.module('can-set props.id');
    test('id set.difference', function () {
        var idProps = props.id('color');
        var res;
        res = set.difference({ color: 'red' }, { color: 'blue' }, idProps);
        deepEqual(res, false, 'id changes always false');
        res = set.difference({ color: 'red' }, {}, idProps);
        deepEqual(res, false, 'id removal always false');
        res = set.difference({}, { color: 'blue' }, idProps);
        deepEqual(res, true, 'id addition always true');
    });
    test('id set.difference with where', function () {
        var algebra = new set.Algebra(props.id('color'), props.enum('type', [
            'light',
            'dark'
        ]));
        var res;
        res = set.difference({
            color: 'red',
            type: [
                'light',
                'dark'
            ]
        }, {
            color: 'blue',
            type: 'light'
        }, algebra);
        deepEqual(res, false, 'id changes always false');
        res = set.difference({
            color: 'red',
            type: [
                'light',
                'dark'
            ]
        }, { type: 'light' }, algebra);
        deepEqual(res, false, 'id removal always false');
        res = set.difference({
            type: [
                'light',
                'dark'
            ]
        }, {
            type: 'light',
            color: 'blue'
        }, algebra);
        deepEqual(res, true, 'id addition always true');
        res = set.difference({
            type: [
                'light',
                'dark'
            ]
        }, { type: 'light' }, algebra);
        deepEqual(res, { type: 'dark' }, 'no id clause, fall back to where');
        res = set.difference({
            color: 'red',
            type: [
                'light',
                'dark'
            ]
        }, {
            color: 'red',
            type: 'light'
        }, algebra);
        deepEqual(res, {
            color: 'red',
            type: 'dark'
        }, 'no id change, fall back to where');
    });
});
/*can-set@1.6.0#src/props_test*/
define('can-set@1.6.0#src/props_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './prop_tests/sort_test',
    './prop_tests/rangeInclusive_test',
    './prop_tests/offsetLimit_test',
    './prop_tests/boolean_test',
    './prop_tests/enum_test',
    './prop_tests/dotNotation_test',
    './prop_tests/id_test'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    QUnit.module('can-set props');
    require('./prop_tests/sort_test');
    require('./prop_tests/rangeInclusive_test');
    require('./prop_tests/offsetLimit_test');
    require('./prop_tests/boolean_test');
    require('./prop_tests/enum_test');
    require('./prop_tests/dotNotation_test');
    require('./prop_tests/id_test');
});
/*can-set@1.6.0#src/set*/
define('can-set@1.6.0#src/set', [
    'require',
    'exports',
    'module',
    './set-core',
    'can-namespace',
    './props',
    './clause',
    './helpers'
], function (require, exports, module) {
    'use strict';
    var set = require('./set-core');
    var ns = require('can-namespace');
    var props = require('./props');
    var clause = require('./clause');
    set.comparators = props;
    set.props = props;
    set.helpers = require('./helpers');
    set.clause = clause;
    module.exports = ns.set = set;
});
/*can-set@1.6.0#src/get_test*/
define('can-set@1.6.0#src/get_test', [
    'require',
    'exports',
    'module',
    './set',
    'steal-qunit',
    './props',
    './helpers',
    'can-assign'
], function (require, exports, module) {
    var set = require('./set');
    var QUnit = require('steal-qunit');
    var props = require('./props');
    var h = require('./helpers');
    var assign = require('can-assign');
    QUnit.module('can-set get');
    var getId = function (d) {
        return d.id;
    };
    var items = [
        {
            id: 0,
            note: 'C',
            type: 'eh'
        },
        {
            id: 1,
            note: 'D',
            type: 'critical'
        },
        {
            id: 2,
            note: 'E',
            type: 'critical'
        },
        {
            id: 3,
            note: 'F',
            type: 'eh'
        },
        {
            id: 4,
            note: 'G',
            type: 'critical'
        },
        {
            id: 5,
            note: 'A'
        },
        {
            id: 6,
            note: 'B',
            type: 'critical'
        },
        {
            id: 7,
            note: 'C',
            type: 'critical'
        }
    ];
    test('getSubset against non ranged set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3
        }, {}, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset ordered ascending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note AsC'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            7,
            1,
            2
        ]);
    });
    test('getSubset ordered descending and paginated', function () {
        var algebra = new set.Algebra(props.sort('sort'), props.rangeInclusive('start', 'end'));
        var res = set.getSubset({
            type: 'critical',
            start: 1,
            end: 3,
            sort: 'note deSc'
        }, {}, items, algebra);
        deepEqual(res && h.map.call(res, getId), [
            2,
            1,
            7
        ]);
    });
    test('getSubset against paginated set', function () {
        var res = set.getSubset({
            type: 'critical',
            start: 21,
            end: 23
        }, {
            type: 'critical',
            start: 20,
            end: 27
        }, items, props.rangeInclusive('start', 'end'));
        deepEqual(res && h.map.call(res, getId), [
            2,
            4,
            6
        ]);
    });
    test('getSubset returns undefined against incompatible set', function () {
        var res = set.getSubset({ note: 'C' }, { type: 'critical' }, items);
        strictEqual(res, undefined);
    });
    test('getUnion basics', function () {
        var union = set.getUnion({}, { foo: 'bar' }, items, items.slice(0, 3));
        deepEqual(union, items);
    });
    test('getUnion against ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 13
        }, {
            start: 14,
            end: 17
        }, items.slice(0, 4), items.slice(4, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 14,
            end: 17
        }, {
            start: 10,
            end: 13
        }, items.slice(4, 8), items.slice(0, 4), props.rangeInclusive('start', 'end'));
        deepEqual(union, items, 'disjoint after');
    });
    test('getUnion against overlapping ranged sets', function () {
        var union = set.getUnion({
            start: 10,
            end: 14
        }, {
            start: 13,
            end: 17
        }, items.slice(0, 5), items.slice(3, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 10,
            end: 11
        }, {
            start: 11,
            end: 17
        }, items.slice(0, 2), items.slice(1, 8), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
        union = set.getUnion({
            start: 11,
            end: 17
        }, {
            start: 10,
            end: 11
        }, items.slice(1, 8), items.slice(0, 2), props.rangeInclusive('start', 'end'));
        deepEqual(union, items);
    });
    test('getUnion filters for uniqueness', function () {
        var aItems = items.filter(function (a) {
            return a.type === 'critical';
        });
        var bItems = items.filter(function (b) {
            return b.note === 'C';
        });
        var unionItems = aItems.concat([bItems[0]]);
        var union = set.getUnion({ type: 'critical' }, { note: 'C' }, aItems, bItems, props.id('id'));
        deepEqual(union, unionItems);
        union = set.getUnion({ type: 'critical' }, { note: 'C' }, aItems, bItems, {});
        deepEqual(union, unionItems);
        bItems = bItems.map(function (b) {
            return assign({}, b);
        });
        union = set.getUnion({ type: 'critical' }, { note: 'C' }, aItems, bItems, props.id('id'));
        deepEqual(union, unionItems);
    });
    test('getSubset passed same object works (#3)', function () {
        var algebra = new set.Algebra(props.rangeInclusive('start', 'end'));
        var setObj = {
            start: 1,
            end: 2
        };
        var items = algebra.getSubset(setObj, setObj, [{ id: 1 }]);
        deepEqual(items, [{ id: 1 }]);
    });
});
/*can-set@1.6.0#src/set_test*/
define('can-set@1.6.0#src/set_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './set'
], function (require, exports, module) {
    require('steal-qunit');
    var set = require('./set');
    QUnit.module('can-set');
    test('set.Algebra constructors', function () {
        var algebra = new set.Algebra(set.props.rangeInclusive('start', 'end'), set.props.boolean('completed'), set.props['enum']('type', [
            'new',
            'prep',
            'deliver',
            'delivered'
        ]));
        var res = algebra.subset({ type: ['new'] }, {
            type: [
                'new',
                'prep'
            ]
        });
        deepEqual(res, true, 'enum');
    });
    test('set.clause', function () {
        QUnit.ok(set.clause);
    });
});
/*can-set@1.6.0#test/test*/
define('can-set@1.6.0#test/test', [
    'require',
    'exports',
    'module',
    '../src/set-core_test',
    '../src/set-core-nested_test',
    '../src/props_test',
    '../src/get_test',
    '../src/set_test'
], function (require, exports, module) {
    require('../src/set-core_test');
    require('../src/set-core-nested_test');
    require('../src/props_test');
    require('../src/get_test');
    require('../src/set_test');
});
/*can-util@3.14.0#dom/mutation-observer/mutation-observer*/
define('can-util@3.14.0#dom/mutation-observer/mutation-observer', [
    'require',
    'exports',
    'module',
    'can-globals',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var globals = require('can-globals');
        var namespace = require('can-namespace');
        module.exports = namespace.mutationObserver = function (setMO) {
            if (setMO !== undefined) {
                globals.setKeyValue('MutationObserver', function () {
                    return setMO;
                });
            }
            return globals.getKeyValue('MutationObserver');
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/document/document*/
define('can-util@3.14.0#dom/document/document', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        module.exports = namespace.document = require('can-globals/document/document');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-bindings@3.11.12#test/mock-component-simple-map*/
define('can-stache-bindings@3.11.12#test/mock-component-simple-map', [
    'require',
    'exports',
    'module',
    'can-stache-bindings',
    'can-simple-map',
    'can-view-callbacks',
    'can-view-scope',
    'can-view-nodelist',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate'
], function (require, exports, module) {
    var stacheBindings = require('can-stache-bindings');
    var CanSimpleMap = require('can-simple-map');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var MockComponent;
    module.exports = MockComponent = {
        extend: function (proto) {
            viewCallbacks.tag(proto.tag, function (el, componentTagData) {
                var viewModel;
                var teardownBindings = stacheBindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    if (typeof proto.viewModel === 'function') {
                        return viewModel = new proto.viewModel(initialViewModelData);
                    } else if (proto.viewModel instanceof CanSimpleMap) {
                        proto.viewModel.set(initialViewModelData);
                        return viewModel = proto.viewModel;
                    } else {
                        var VM = CanSimpleMap.extend(proto.viewModel);
                        return viewModel = new VM(initialViewModelData);
                    }
                }, {});
                domData.set.call(el, 'viewModel', viewModel);
                domData.set.call(el, 'preventDataBindings', true);
                if (proto.template) {
                    var shadowScope = componentTagData.scope.add(new Scope.Refs()).add(viewModel, { viewModel: true });
                    domData.set.call(el, 'shadowScope', shadowScope);
                    var nodeList = nodeLists.register([], function () {
                        teardownBindings();
                    }, componentTagData.parentNodeList || true, false);
                    var frag = proto.template(shadowScope, componentTagData.options, nodeList);
                    domMutate.appendChild.call(el, frag);
                }
            });
        }
    };
});
/*can-stache-bindings@3.11.12#test/bindings-colon-test*/
define('can-stache-bindings@3.11.12#test/bindings-colon-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-stache-bindings',
    'can-vdom/make-document/make-document',
    'can-util/dom/mutation-observer/mutation-observer',
    'can-util/dom/document/document',
    'can-util/dom/events/events',
    'can-util/dom/mutate/mutate',
    'can-util/dom/data/data',
    './mock-component-simple-map',
    'can-stache',
    'can-simple-map',
    'can-define/map/map',
    'can-event'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var stacheBindings = require('can-stache-bindings');
    var makeDocument = require('can-vdom/make-document/make-document');
    var MUTATION_OBSERVER = require('can-util/dom/mutation-observer/mutation-observer');
    var DOCUMENT = require('can-util/dom/document/document');
    var domEvents = require('can-util/dom/events/events');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domData = require('can-util/dom/data/data');
    var MockComponent = require('./mock-component-simple-map');
    var stache = require('can-stache');
    var SimpleMap = require('can-simple-map');
    var DefineMap = require('can-define/map/map');
    var canEvent = require('can-event');
    function afterMutation(cb) {
        var doc = DOCUMENT();
        var div = doc.createElement('div');
        domEvents.addEventListener.call(div, 'inserted', function () {
            doc.body.removeChild(div);
            setTimeout(cb, 5);
        });
        domMutate.appendChild.call(doc.body, div);
    }
    var DOC = DOCUMENT();
    var MUT_OBS = MUTATION_OBSERVER();
    makeTest('can-stache-bindings - colon - dom', document, MUT_OBS);
    makeTest('can-stache-bindings - colon - vdom', makeDocument(), null);
    function makeTest(name, doc, mutObs) {
        QUnit.module(name, {
            setup: function () {
                DOCUMENT(doc);
                MUTATION_OBSERVER(mutObs);
                if (doc === document) {
                    this.fixture = document.getElementById('qunit-fixture');
                } else {
                    this.fixture = doc.createElement('qunit-fixture');
                    doc.body.appendChild(this.fixture);
                }
            },
            teardown: function () {
                if (doc !== document) {
                    doc.body.removeChild(this.fixture);
                }
                stop();
                afterMutation(function () {
                    DOCUMENT(DOC);
                    MUTATION_OBSERVER(MUT_OBS);
                    var fixture = document.getElementById('qunit-fixture');
                    while (fixture && fixture.hasChildNodes()) {
                        domData.delete.call(fixture.lastChild);
                        fixture.removeChild(fixture.lastChild);
                    }
                    start();
                });
            }
        });
        test('basics', 5, function () {
            var viewModel = new SimpleMap({
                toChild: 'toChild',
                toParent: 'toParent',
                twoWay: 'twoWay'
            });
            MockComponent.extend({
                tag: 'basic-colon',
                viewModel: viewModel
            });
            var template = stache('<basic-colon ' + 'toChild:from=\'valueA\' toParent:to=\'valueB\' twoWay:bind=\'valueC\' ' + 'on:vmevent=\'methodD()\'' + '/>');
            var MySimpleMap = SimpleMap.extend({
                methodD: function () {
                    QUnit.ok(true, 'on:vmevent bindings work');
                }
            });
            var parent = new MySimpleMap({
                valueA: 'A',
                valueB: 'B',
                valueC: 'C'
            });
            template(parent);
            QUnit.deepEqual(parent.get(), {
                valueA: 'A',
                valueB: 'toParent',
                valueC: 'C'
            }, 'initial scope values correct');
            QUnit.deepEqual(viewModel.get(), {
                toChild: 'A',
                toParent: 'toParent',
                twoWay: 'C'
            }, 'initial VM values correct');
            parent.set({
                valueA: 'a',
                valueB: 'b',
                valueC: 'c'
            });
            QUnit.deepEqual(viewModel.get(), {
                toChild: 'a',
                toParent: 'toParent',
                twoWay: 'c'
            }, 'scope set VM values correct');
            viewModel.set({
                toChild: 'to-child',
                toParent: 'to-parent',
                twoWay: 'two-way'
            });
            QUnit.deepEqual(parent.get(), {
                valueA: 'a',
                valueB: 'to-parent',
                valueC: 'two-way'
            }, 'vm set scope values correct');
            viewModel.dispatch({ type: 'vmevent' });
        });
        QUnit.test('scope child-to-parent propagates undefined value', function () {
            var viewModel = new SimpleMap({ toParent: 'toParent' });
            MockComponent.extend({
                tag: 'basic-colon',
                viewModel: viewModel
            });
            var template = stache('<basic-colon toParent:to=\'valueB\' />');
            var parent = new SimpleMap({ valueB: 'B' });
            template(parent);
            QUnit.deepEqual(parent.get(), { valueB: 'toParent' }, 'initial scope values correct');
            QUnit.deepEqual(viewModel.get(), { toParent: 'toParent' }, 'initial VM values correct');
            viewModel.set({ toParent: undefined });
            QUnit.deepEqual(parent.get(), { valueB: undefined }, 'vm set undefined correctly');
        });
        test('getBindingInfo', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('getBindingInfo for vm:', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'vm:foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModel',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'vm:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('getBindingInfo for el:', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:from',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:bind',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:to',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:from',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: false,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:from',
                initializeValues: true,
                syncChildWithParent: false
            }, ':from, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:bind',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: true,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:bind',
                initializeValues: true,
                syncChildWithParent: true
            }, ':bind, favorViewModel=true');
            info = stacheBindings.getBindingInfo({
                name: 'el:foo-ed:to',
                value: 'bar'
            }, null, null, null, true);
            deepEqual(info, {
                parent: 'scope',
                child: 'attribute',
                childEvent: undefined,
                parentToChild: false,
                childToParent: true,
                childName: 'foo-ed',
                parentName: 'bar',
                bindingAttributeName: 'el:foo-ed:to',
                initializeValues: true,
                syncChildWithParent: false
            }, ':to, favorViewModel=true');
        });
        test('value:from works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:from=\'theProp\'/>' + '<input value:from=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            equal(camelPropInput.value, '', 'input bound to camelCase prop value set correctly if camelCase key does not exist in map');
            equal(kebabPropInput.value, '', 'input bound to kebab-case prop value set correctly if kebab-case key does not exist in map');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '30', 'input bound to camelCase prop value set correctly when camelCase prop changes');
            equal(kebabPropInput.value, '', 'input bound to kebab-case prop value not updated when camelCase prop changes');
            map.attr('theProp', '31');
            equal(camelPropInput.value, '31', 'input bound to camelCase prop value updated correctly when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebab-case prop value not updated when camelCase prop changes');
            camelPropInput.value = '32';
            canEvent.trigger.call(camelPropInput, 'change');
            equal(map.attr('theProp'), '31', 'camelCase prop NOT updated when input bound to camelCase prop changes');
            ok(!map.attr('the-prop'), 'kebabCase prop NOT updated when input bound to camelCase prop changes');
            map.attr('the-prop', '33');
            equal(kebabPropInput.value, '33', 'input bound to kebab-case prop value set correctly when kebab-case prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase prop value not updated when kebab-case prop changes');
            map.attr('the-prop', '34');
            equal(kebabPropInput.value, '34', 'input bound to kebab-case prop value updated correctly when kebab-case prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase prop value not updated when kebab-case prop changes');
            kebabPropInput.value = '35';
            canEvent.trigger.call(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '34', 'kebab-case prop NOT updated from input bound to kebab-case prop');
            equal(map.attr('theProp'), '31', 'camelCase prop NOT updated from input bound to kebab-case prop');
        });
        test('value:to works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:to=\'theProp\'/>' + '<input value:to=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            camelPropInput.value = '32';
            canEvent.trigger.call(camelPropInput, 'change');
            equal(map.attr('theProp'), '32', 'camelCaseProp updated from input bound to camelCase Prop');
            ok(!map.attr('the-prop'), 'kebabCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '32', 'input bound to camelCase Prop value NOT updated when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebabCase Prop value NOT updated when camelCase prop changes');
            kebabPropInput.value = '33';
            canEvent.trigger.call(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '33', 'kebabCaseProp updated from input bound to kebabCase Prop');
            equal(map.attr('theProp'), '30', 'camelCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '34');
            equal(kebabPropInput.value, '33', 'input bound to kebabCase Prop value NOT updated when kebabCase prop changes');
            equal(camelPropInput.value, '32', 'input bound to camelCase Prop value NOT updated when kebabCase prop changes');
        });
        test('value:bind works with camelCase and kebab-case properties', function () {
            var template = stache('<input value:bind=\'theProp\'/>' + '<input value:bind=\'the-prop\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var camelPropInput = ta.getElementsByTagName('input')[0];
            var kebabPropInput = ta.getElementsByTagName('input')[1];
            camelPropInput.value = '32';
            canEvent.trigger.call(camelPropInput, 'change');
            equal(map.attr('theProp'), '32', 'camelCaseProp updated from input bound to camelCase Prop');
            ok(!map.attr('the-prop'), 'kebabCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '30');
            equal(camelPropInput.value, '30', 'input bound to camelCase Prop value updated when camelCase prop changes');
            ok(!kebabPropInput.value, 'input bound to kebabCase Prop value NOT updated when camelCase prop changes');
            kebabPropInput.value = '33';
            canEvent.trigger.call(kebabPropInput, 'change');
            equal(map.attr('the-prop'), '33', 'kebabCaseProp updated from input bound to kebabCase Prop');
            equal(map.attr('theProp'), '30', 'camelCaseProp NOT updated from input bound to camelCase Prop');
            map.attr('theProp', '34');
            equal(kebabPropInput.value, '33', 'input bound to kebabCase Prop value NOT updated when kebabCase prop changes');
            equal(camelPropInput.value, '34', 'input bound to camelCase Prop value updated when kebabCase prop changes');
        });
        test('Bracket expression with dot and no explicit root and value:bind', function () {
            var template;
            var div = this.fixture;
            template = stache('<input value:bind="[\'two.hops\']" >');
            var Data = DefineMap.extend({ 'two.hops': 'string' });
            var data = new Data();
            var dom = template(data);
            div.appendChild(dom);
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            data['two.hops'] = 'slide to the left';
            equal(input.value, 'slide to the left', 'input value set correctly');
            data['two.hops'] = 'slide to the right';
            equal(input.value, 'slide to the right', 'input value update correctly');
            input.value = 'REVERSE REVERSE';
            canEvent.trigger.call(input, 'change');
            equal(data['two.hops'], 'REVERSE REVERSE', 'updated from input');
        });
        test('Bracket expression with colon and no explicit root and value:bind', function () {
            var template;
            var div = this.fixture;
            template = stache('<input value:bind="[\'two:hops\']" >');
            var Data = DefineMap.extend({ 'two:hops': 'string' });
            var data = new Data();
            var dom = template(data);
            div.appendChild(dom);
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, '', 'input value set correctly if key does not exist in map');
            data['two:hops'] = 'slide to the left';
            equal(input.value, 'slide to the left', 'input value set correctly');
            data['two:hops'] = 'slide to the right';
            equal(input.value, 'slide to the right', 'input value update correctly');
            input.value = 'REVERSE REVERSE';
            canEvent.trigger.call(input, 'change');
            equal(data['two:hops'], 'REVERSE REVERSE', 'updated from input');
        });
        test('can listen to camelCase events using on:', function () {
            QUnit.stop();
            expect(1);
            var map = new DefineMap({
                someProp: 'foo',
                someMethod: function () {
                    QUnit.start();
                    ok(true);
                }
            });
            var template = stache('<div on:someProp:by:this=\'someMethod\'/>');
            template(map);
            map.someProp = 'baz';
        });
        test('can listen to kebab-case events using on:', function () {
            QUnit.stop();
            expect(1);
            var map = new DefineMap({
                'some-prop': 'foo',
                someMethod: function () {
                    QUnit.start();
                    ok(true);
                }
            });
            var template = stache('<div on:some-prop:by:this=\'someMethod\'/>');
            template(map);
            map['some-prop'] = 'baz';
        });
        test('can bind to property on scope using :by:', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able on:prop:by:obj=\'someMethod\'/>');
            var map = new DefineMap({
                obj: { prop: 'Mercury' },
                someMethod: function (scope, el, ev, newVal) {
                    start();
                    equal(newVal, 'Venus', 'method called');
                }
            });
            template(map);
            map.obj.prop = 'Venus';
        });
        test('can bind to entire scope using :by:this', function () {
            stop();
            expect(1);
            MockComponent.extend({ tag: 'view-model-able' });
            var template = stache('<view-model-able on:prop:by:this=\'someMethod\'/>');
            var map = new DefineMap({
                prop: 'Mercury',
                someMethod: function (scope, el, ev, newVal) {
                    start();
                    equal(newVal, 'Venus', 'method called');
                }
            });
            template(map);
            map.prop = 'Venus';
        });
        test('can bind to viewModel using on:vm:prop', function () {
            stop();
            expect(1);
            var map = new SimpleMap({ prop: 'Mercury' });
            var MySimpleMap = SimpleMap.extend({
                someMethod: function (scope, el, ev, newVal) {
                    start();
                    equal(newVal, 'Venus', 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able on:vm:prop=\'someMethod\'/>');
            template(parent);
            map.attr('prop', 'Venus');
        });
        test('can bind to element using on:el:prop', function () {
            stop();
            expect(1);
            var map = new SimpleMap({ prop: 'Mercury' });
            var MySimpleMap = SimpleMap.extend({
                someMethod: function () {
                    start();
                    ok(true, 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able on:el:prop=\'someMethod\'/>');
            var frag = template(parent);
            var element = frag.firstChild;
            canEvent.trigger.call(element, 'prop');
        });
        QUnit.test('getBindingInfo works for value:to:on:click (#269)', function () {
            var info = stacheBindings.getBindingInfo({
                name: 'value:to:on:click',
                value: 'bar'
            });
            deepEqual(info, {
                parent: 'scope',
                child: 'viewModelOrAttribute',
                childEvent: 'click',
                parentToChild: false,
                childToParent: true,
                childName: 'value',
                parentName: 'bar',
                bindingAttributeName: 'value:to:on:click',
                initializeValues: false,
                syncChildWithParent: false
            }, 'new vm binding');
        });
        test('value:to:on:click and on:click:value:to work (#269)', function () {
            var template = stache('<input value:to:on:click=\'theProp\'/>' + '<input on:click:value:to=\'theProp\'/>');
            var map = new SimpleMap({});
            var frag = template(map);
            var ta = this.fixture;
            ta.appendChild(frag);
            var bindFirstInput = ta.getElementsByTagName('input')[0];
            bindFirstInput.value = '22';
            canEvent.trigger.call(bindFirstInput, 'click');
            QUnit.equal(map.get('theProp'), '22');
            var eventFirstInput = ta.getElementsByTagName('input')[1];
            eventFirstInput.value = '23';
            canEvent.trigger.call(eventFirstInput, 'click');
            QUnit.equal(map.get('theProp'), '23');
        });
        QUnit.test('on:el:click works inside {{#if}} on element with a viewModel (#279)', function () {
            var map = new SimpleMap({});
            var MySimpleMap = SimpleMap.extend({
                show: true,
                method: function () {
                    ok(true, 'method called');
                }
            });
            var parent = new MySimpleMap();
            MockComponent.extend({
                tag: 'view-model-able',
                viewModel: map
            });
            var template = stache('<view-model-able {{#if show}} on:el:click=\'method()\' {{/if}} />');
            var frag = template(parent);
            var el = frag.firstChild;
            canEvent.trigger.call(el, 'click');
        });
        QUnit.test('vm:prop:to/:from/:bind work (#280)', function () {
            var vm1 = new SimpleMap({ value: 'vm1' });
            var vm2 = new SimpleMap({ value: 'vm2' });
            var vm3 = new SimpleMap({ value: 'vm3' });
            MockComponent.extend({
                tag: 'comp-1',
                viewModel: vm1
            });
            MockComponent.extend({
                tag: 'comp-2',
                viewModel: vm2
            });
            MockComponent.extend({
                tag: 'comp-3',
                viewModel: vm3
            });
            var template = stache('<comp-1 vm:value:to=\'scope1\'/>' + '<comp-2 vm:value:from=\'scope2\'/>' + '<comp-3 vm:value:bind=\'scope3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            template(scope);
            equal(scope.attr('scope1'), 'vm1', 'vm:value:to - scope value set from vm');
            vm1.attr('value', 'vm4');
            equal(scope.attr('scope1'), 'vm4', 'vm:value:to - scope updated when vm changes');
            scope.attr('scope1', 'scope4');
            equal(vm1.attr('value'), 'vm4', 'vm:value:to - vm not updated when scope changes');
            equal(vm2.attr('value'), 'scope2', 'vm:value:from - vm value set from scope');
            scope.attr('scope2', 'scope5');
            equal(vm2.attr('value'), 'scope5', 'vm:value:from - vm updated when scope changes');
            vm2.attr('value', 'vm5');
            equal(scope.attr('scope2'), 'scope5', 'vm:value:from - scope not updated when vm changes');
            equal(vm3.attr('value'), 'scope3', 'vm:value:bind - vm value set from scope');
            scope.attr('scope3', 'scope6');
            equal(vm3.attr('value'), 'scope6', 'vm:value:bind - vm updated when scope changes');
            vm3.attr('value', 'vm6');
            equal(scope.attr('scope3'), 'vm6', 'vm:value:bind - scope updated when vm changes');
        });
        QUnit.test('el:prop:to/:from/:bind work (#280)', function () {
            var template = stache('<input el:value:to=\'scope1\' value=\'1\'/>' + '<input el:value:from=\'scope2\' value=\'2\'/>' + '<input el:value:bind=\'scope3\' value=\'3\'/>');
            var scope = new SimpleMap({
                scope1: 'scope1',
                scope2: 'scope2',
                scope3: 'scope3'
            });
            var frag = template(scope);
            var ta = this.fixture;
            ta.appendChild(frag);
            var inputTo = ta.getElementsByTagName('input')[0];
            var inputFrom = ta.getElementsByTagName('input')[1];
            var inputBind = ta.getElementsByTagName('input')[2];
            equal(scope.attr('scope1'), '1', 'el:value:to - scope value set from attribute');
            inputTo.value = '4';
            canEvent.trigger.call(inputTo, 'change');
            equal(scope.attr('scope1'), '4', 'el:value:to - scope updated when attribute changed');
            scope.attr('scope1', 'scope4');
            equal(inputTo.value, '4', 'el:value:to - attribute not updated when scope changed');
            equal(inputFrom.value, 'scope2', 'el:value:from - attribute set from scope');
            inputFrom.value = 'scope5';
            canEvent.trigger.call(inputFrom, 'change');
            equal(scope.attr('scope2'), 'scope2', 'el:value:from - scope not updated when attribute changed');
            scope.attr('scope2', 'scope6');
            equal(inputFrom.value, 'scope6', 'el:value:from - attribute updated when scope changed');
            equal(inputBind.value, 'scope3', 'el:value:bind - attribute set from scope prop (parent -> child wins)');
            inputBind.value = 'scope6';
            canEvent.trigger.call(inputBind, 'change');
            equal(scope.attr('scope3'), 'scope6', 'el:value:bind - scope updated when attribute changed');
            scope.attr('scope3', 'scope7');
            equal(inputBind.value, 'scope7', 'el:value:bind - attribute updated when scope changed');
        });
        QUnit.test('on:input:value:to works (#289)', function () {
            var scope = new SimpleMap({ myProp: '' });
            var renderer = stache('<input type=\'text\' value=\'hai\' on:input:value:to=\'myProp\' />');
            var view = renderer(scope);
            var ta = this.fixture;
            ta.appendChild(view);
            var inputTo = ta.getElementsByTagName('input')[0];
            inputTo.value = 'wurld';
            canEvent.trigger.call(inputTo, 'input');
            equal(scope.get('myProp'), 'wurld', 'Got the value on the scope');
        });
        QUnit.test('on:input:value:to does not initialize values (#289)', function () {
            try {
                stache('<input on:input:value:to=\'*editing.licensePlate\'/>')();
                ok(true, 'renderer was made without error');
            } catch (e) {
                ok(false, e.message);
            }
        });
        QUnit.test('errors subproperties of undefined properties (#298)', function () {
            try {
                stache('<input value:to=\'prop.subprop\'/>')();
                ok(true, 'renderer was made without error');
            } catch (e) {
                ok(false, e.message);
            }
        });
    }
});
/*can-stache-bindings@3.11.12#test/mock-component*/
define('can-stache-bindings@3.11.12#test/mock-component', [
    'require',
    'exports',
    'module',
    'can-stache-bindings',
    'can-map',
    'can-view-callbacks',
    'can-view-scope',
    'can-view-nodelist',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate'
], function (require, exports, module) {
    var stacheBindings = require('can-stache-bindings');
    var CanMap = require('can-map');
    var viewCallbacks = require('can-view-callbacks');
    var Scope = require('can-view-scope');
    var nodeLists = require('can-view-nodelist');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var MockComponent;
    module.exports = MockComponent = {
        extend: function (proto) {
            viewCallbacks.tag(proto.tag, function (el, componentTagData) {
                var viewModel;
                var teardownBindings = stacheBindings.behaviors.viewModel(el, componentTagData, function (initialViewModelData) {
                    if (typeof proto.viewModel === 'function') {
                        return viewModel = new proto.viewModel(initialViewModelData);
                    } else if (proto.viewModel instanceof CanMap) {
                        return viewModel = proto.viewModel;
                    } else {
                        var VM = CanMap.extend(proto.viewModel);
                        return viewModel = new VM(initialViewModelData);
                    }
                }, {});
                domData.set.call(el, 'viewModel', viewModel);
                domData.set.call(el, 'preventDataBindings', true);
                if (proto.template) {
                    var shadowScope = componentTagData.scope.add(new Scope.Refs()).add(viewModel, { viewModel: true });
                    domData.set.call(el, 'shadowScope', shadowScope);
                    var nodeList = nodeLists.register([], function () {
                        teardownBindings();
                    }, componentTagData.parentNodeList || true, false);
                    var frag = proto.template(shadowScope, componentTagData.options, nodeList);
                    domMutate.appendChild.call(el, frag);
                }
            });
        }
    };
});
/*can-stache-bindings@3.11.12#test/bindings-define-test*/
define('can-stache-bindings@3.11.12#test/bindings-define-test', [
    'require',
    'exports',
    'module',
    'can-stache-bindings',
    'can-compute',
    'steal-qunit',
    'can-define/map/map',
    'can-stache',
    'can-view-model',
    'can-define',
    'can-event',
    'can-view-callbacks',
    'can-util/dom/attr/attr',
    'can-util/dom/data/data',
    'can-util/dom/dispatch/dispatch',
    './mock-component'
], function (require, exports, module) {
    var bindings = require('can-stache-bindings');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var canViewModel = require('can-view-model');
    var define = require('can-define');
    var canEvent = require('can-event');
    var viewCallbacks = require('can-view-callbacks');
    var domAttr = require('can-util/dom/attr/attr');
    var domData = require('can-util/dom/data/data');
    var domDispatch = require('can-util/dom/dispatch/dispatch');
    var MockComponent = require('./mock-component');
    var viewModelFor = function (tag, viewModel) {
        viewCallbacks.tag(tag, function (el) {
            domData.set.call(el, 'viewModel', viewModel);
        });
    };
    QUnit.module('can-stache-bindings (can-define)');
    test('two way - viewModel', 7, function () {
        var ViewModel = define.Constructor({ vmProp: {} });
        MockComponent.extend({
            tag: 'two-way-viewmodel',
            viewModel: ViewModel
        });
        var template = stache('<two-way-viewmodel {(vm-prop)}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Bing!' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        ok(viewModel instanceof ViewModel, 'ViewModel is a can-define object');
        equal(viewModel.vmProp, 'Bing!', 'ViewModel property set via scope property set');
        equal(context.scopeProp, 'Bing!', 'Scope property is correct');
        viewModel.vmProp = 'Bang!';
        equal(viewModel.vmProp, 'Bang!', 'ViewModel property was set');
        equal(context.scopeProp, 'Bang!', 'Scope property set via viewModel property set');
        context.scopeProp = 'BOOM!';
        equal(context.scopeProp, 'BOOM!', 'Scope property was set');
        equal(viewModel.vmProp, 'BOOM!', 'ViewModel property set via scope property set');
    });
    test('one-way - parent to child - viewModel', function () {
        var VM = DefineMap.extend({ viewModelProp: '*' });
        viewModelFor('parent-to-child', new VM());
        var template = stache('<parent-to-child {view-model-prop}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Venus' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        equal(viewModel.viewModelProp, 'Venus', 'ViewModel property initially set from scope');
        viewModel.viewModelProp = 'Earth';
        equal(context.scopeProp, 'Venus', 'Scope property unchanged by viewModel set');
        context.scopeProp = 'Mars';
        equal(viewModel.viewModelProp, 'Mars', 'ViewModel property was set via scope set');
    });
    test('one-way - child to parent - viewModel', function () {
        var ViewModel = define.Constructor({ viewModelProp: { value: 'Mercury' } });
        MockComponent.extend({
            tag: 'view-model-able',
            viewModel: ViewModel
        });
        var template = stache('<view-model-able {^view-model-prop}="scopeProp" />');
        var Context = define.Constructor({ scopeProp: { value: 'Venus' } });
        var context = new Context();
        var frag = template(context);
        var viewModel = canViewModel(frag.firstChild);
        equal(viewModel.viewModelProp, 'Mercury', 'ViewModel property unchanged by scope property');
        equal(context.scopeProp, 'Mercury', 'Scope property initially set from viewModel');
        viewModel.viewModelProp = 'Earth';
        equal(context.scopeProp, 'Earth', 'Scope property set via viewModel set');
        context.scopeProp = 'Mars';
        equal(viewModel.viewModelProp, 'Earth', 'ViewModel property unchanged by scope set');
    });
    test('two-way - DOM - input text (#1700)', function () {
        var template = stache('<input {($value)}=\'age\'/>');
        var MyMap = define.Constructor({ age: { type: 'string' } });
        var map = new MyMap();
        var frag = template(map);
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        equal(input.value, '', 'input value set correctly if key does not exist in map');
        map.age = 30;
        equal(input.value, '30', 'input value set correctly');
        map.age = '31';
        equal(input.value, '31', 'input value update correctly');
        input.value = '32';
        canEvent.trigger.call(input, 'change');
        equal(map.age, '32', 'updated from input');
    });
    test('Bracket expression with `this` root and 2 way binding', function () {
        var div = document.getElementById('qunit-fixture');
        var template = stache('<input {($value)}="this[\'two.hops\']" >');
        var data = new DefineMap({ 'two.hops': undefined });
        var dom = template(data);
        div.appendChild(dom);
        var input = div.getElementsByTagName('input')[0];
        equal(input.value, '', 'input value set correctly if key does not exist in map');
        data['two.hops'] = 'slide to the left';
        equal(input.value, 'slide to the left', 'input value set correctly');
        data['two.hops'] = 'slide to the right';
        equal(input.value, 'slide to the right', 'input value update correctly');
        input.value = 'REVERSE REVERSE';
        canEvent.trigger.call(input, 'change');
        equal(data['two.hops'], 'REVERSE REVERSE', 'updated from input');
    });
    test('Bracket expression with `.` root and 2 way binding', function () {
        var div = document.getElementById('qunit-fixture');
        var template = stache('<input {($value)}=".[\'two.hops\']" >');
        var data = new DefineMap({ 'two.hops': undefined });
        var dom = template(data);
        div.appendChild(dom);
        var input = div.getElementsByTagName('input')[0];
        equal(input.value, '', 'input value set correctly if key does not exist in map');
        data['two.hops'] = 'slide to the left';
        equal(input.value, 'slide to the left', 'input value set correctly');
        data['two.hops'] = 'slide to the right';
        equal(input.value, 'slide to the right', 'input value update correctly');
        input.value = 'REVERSE REVERSE';
        canEvent.trigger.call(input, 'change');
        equal(data['two.hops'], 'REVERSE REVERSE', 'updated from input');
    });
    test('Bracket expression with no explicit root and 2 way binding', function () {
        var div = document.getElementById('qunit-fixture');
        var template = stache('<input {($value)}="[\'two.hops\']" >');
        var data = new DefineMap({ 'two.hops': undefined });
        var dom = template(data);
        div.appendChild(dom);
        var input = div.getElementsByTagName('input')[0];
        equal(input.value, '', 'input value set correctly if key does not exist in map');
        data['two.hops'] = 'slide to the left';
        equal(input.value, 'slide to the left', 'input value set correctly');
        data['two.hops'] = 'slide to the right';
        equal(input.value, 'slide to the right', 'input value update correctly');
        input.value = 'REVERSE REVERSE';
        canEvent.trigger.call(input, 'change');
        equal(data['two.hops'], 'REVERSE REVERSE', 'updated from input');
    });
    test('Binding to a special property - values', function () {
        var template = stache('<select multiple {($values)}=\'values\'><option value=\'one\'>One</option><option value=\'two\'></option></select>');
        var map = new DefineMap({ values: [] });
        var slice = [].slice;
        var select = template(map).firstChild;
        var option1 = select.firstChild;
        var option2 = option1.nextSibling;
        option2.selected = true;
        canEvent.trigger.call(select, 'change');
        deepEqual(slice.call(map.values), ['two'], 'two is chosen');
        map.values = ['one'];
        equal(option1.selected, true, 'option1 selected');
        equal(option2.selected, false, 'option2 not selected');
    });
    test('Binding to a special property - option\'s selected', function () {
        var template = stache('<select><option {($selected)}=\'a\' value=\'one\'>One</option><option {($selected)}=\'b\' value=\'two\'>Two</option></select>');
        var map = new DefineMap({
            a: true,
            b: false
        });
        var select = template(map).firstChild;
        var option1 = select.firstChild;
        var option2 = option1.nextSibling;
        option2.selected = true;
        canEvent.trigger.call(select, 'change');
        equal(map.a, false, 'map.a false');
        equal(map.b, true, 'map.b true');
    });
    if (System.env !== 'canjs-test') {
        test('Can two way bind to focused', function () {
            stop();
            var template = stache('<input {($focused)}=\'show\' type=\'text\'/>');
            var map = new DefineMap({ show: false });
            var ta = document.getElementById('qunit-fixture');
            var frag = template(map);
            var input = frag.firstChild;
            ta.appendChild(frag);
            map.show = true;
            if (!document.hasFocus()) {
                domDispatch.call(input, 'focus');
            }
            setTimeout(function () {
                ok(input === document.activeElement, 'now focused');
                domAttr.set(input, 'focused', false);
                if (!document.hasFocus()) {
                    domDispatch.call(input, 'blur');
                }
                setTimeout(function () {
                    ok(input !== document.activeElement, 'not focused');
                    equal(map.show, false, 'set the boolean');
                    start();
                }, 50);
            }, 50);
        });
    }
    function makeKeyboardEvent() {
        var event;
        try {
            event = new KeyboardEvent('keyup', { key: 'Enter' });
            return event;
        } catch (e) {
            event = document.createEvent('KeyboardEvent');
            event.initKeyboardEvent('keyup', true, false, document.parentWindow, 'Enter', 16, '', false, 'en-US');
            return event;
        }
    }
    var supportsKeyboardEvents = function () {
        if (typeof KeyboardEvent !== 'undefined') {
            try {
                var supports = false;
                var el = document.createElement('div');
                el.addEventListener('keyup', function (ev) {
                    supports = ev.key === 'Enter';
                });
                el.dispatchEvent(makeKeyboardEvent());
                return supports;
            } catch (e) {
                return false;
            }
        } else {
            return false;
        }
    }();
    if (supportsKeyboardEvents) {
        QUnit.test('KeyboardEvent dispatching works with .key (#93)', function () {
            var template = stache('<input ($enter)=\'method(%event)\' type=\'text\'/>');
            var frag = template({
                method: function (event) {
                    QUnit.ok(true, 'method was called');
                }
            });
            var input = frag.firstChild;
            var event = makeKeyboardEvent();
            input.dispatchEvent(event);
        });
    }
    QUnit.test('Two way bindings should be sticky (#122)', function () {
        var template = stache('<input {($value)}=\'firstName\'/>');
        var MyMap = define.Constructor({
            firstName: {
                set: function (newVal) {
                    return newVal.toLowerCase();
                }
            }
        });
        var map = new MyMap({ firstName: 'matthew' });
        var frag = template(map);
        var ta = document.getElementById('qunit-fixture');
        ta.appendChild(frag);
        var input = ta.getElementsByTagName('input')[0];
        QUnit.equal(input.value, 'matthew', 'input value set correctly');
        input.value = 'MATTHEW';
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.firstName, 'matthew', 'vm stays the same');
        QUnit.equal(input.value, 'matthew', 'input stays the same');
    });
    test('scope method called when scope property changes on DefineMap (#197)', function () {
        stop();
        expect(1);
        MockComponent.extend({ tag: 'view-model-able' });
        var template = stache('<view-model-able (. prop)=\'someMethod\'/>');
        var map = new DefineMap({
            prop: 'Mercury',
            someMethod: function (scope, el, ev, newVal) {
                start();
                ok(true, 'method called');
            }
        });
        template(map);
        map.prop = 'Venus';
    });
    test('.viewModel() can work with this {^this}=\'bar\'', function () {
        expect(2);
        var vm, teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            domData.set.call(el, 'preventDataBindings', true);
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData, hasDataBindings) {
                QUnit.ok(hasDataBindings, 'has data bindings');
                return vm = compute(initialData);
            });
        });
        var myMap = new DefineMap({ value: null });
        var template = stache('<export-this {^this}="value"/>');
        template(myMap);
        vm(10);
        QUnit.equal(myMap.value, 10, 'changed the value');
    });
    test('.viewModel() can work with this {this}=\'bar\'', function () {
        expect(3);
        var vm, teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            domData.set.call(el, 'preventDataBindings', true);
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData, hasDataBindings) {
                QUnit.ok(hasDataBindings, 'has data bindings');
                QUnit.equal(initialData, 10, 'initial value right');
                return vm = compute(initialData);
            });
        });
        var myMap = new DefineMap({ value: 10 });
        var template = stache('<export-this {this}="value"/>');
        template(myMap);
        myMap.value = 11;
        QUnit.equal(vm(), 11, 'updated VM by changing scope');
    });
    test('Will not accept more than one data binding if this is bound', function () {
        expect(2);
        var vm, teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData) {
                return vm = compute(initialData);
            });
        });
        var myMap = new DefineMap({
            value: 10,
            bar: 'baz'
        });
        var template = stache('<export-this {this}="value" {foo}="bar" />');
        try {
            template(myMap);
        } catch (error) {
            QUnit.equal(error.message, 'can-stache-bindings - you can not have contextual bindings ( this:from=\'value\' ) and key bindings ( prop:from=\'value\' ) on one element.', 'Succesfully errored');
        }
        template = stache('<export-this {foo}="bar" {this}="value" />');
        try {
            template(myMap);
        } catch (error) {
            QUnit.equal(error.message, 'can-stache-bindings - you can not have contextual bindings ( this:from=\'value\' ) and key bindings ( prop:from=\'value\' ) on one element.', 'Succesfully errored');
        }
    });
    test('.viewModel() can bypass dynamic bindings', function () {
        expect(1);
        var teardown;
        viewCallbacks.tag('export-this', function (el, componentTagData) {
            domData.set.call(el, 'preventDataBindings', true);
            teardown = bindings.behaviors.viewModel(el, componentTagData, function (initialData, hasDataBindings) {
                QUnit.ok(false, 'no bindings, this shouldn\'t be called');
            }, undefined, true);
            QUnit.notOk(teardown, 'we should get no teardown b/c there\'s no bindings');
        });
        var myMap = new DefineMap({ value: 10 });
        var template = stache('<export-this/>');
        template(myMap);
    });
    QUnit.test('($click) works inside {{#if}} on element with a viewModel (#279)', function () {
        var ViewModel = DefineMap.extend({});
        MockComponent.extend({
            tag: 'view-model-able',
            viewModel: ViewModel
        });
        var template = stache('<view-model-able {{#if show}} ($click)=\'method()\' {{/if}} />');
        var Parent = DefineMap.extend({
            show: { value: true },
            method: function () {
                QUnit.ok(true, '($click) worked');
            }
        });
        var parent = new Parent();
        var frag = template(parent);
        var el = frag.firstChild;
        canEvent.trigger.call(el, 'click');
    });
    QUnit.test('events starting with `to`, `from`, and `bind` work (#285)', function () {
        expect(3);
        var ViewModel = DefineMap.extend({
            toevent: { value: '1' },
            fromevent: { value: '1' },
            bindevent: { value: '1' }
        });
        MockComponent.extend({
            tag: 'view-model-able',
            viewModel: ViewModel
        });
        var template = stache('<view-model-able (toevent)=\'toMethod()\' (fromevent)=\'fromMethod()\' (bindevent)=\'bindMethod()\' />');
        var Parent = DefineMap.extend({
            toMethod: function () {
                QUnit.ok(true, '(toevent) worked');
            },
            fromMethod: function () {
                QUnit.ok(true, '(fromevent) worked');
            },
            bindMethod: function () {
                QUnit.ok(true, '(bindevent) worked');
            }
        });
        var parent = new Parent();
        var frag = template(parent);
        var el = frag.firstChild;
        var vm = canViewModel(el);
        vm.toevent = '2';
        vm.fromevent = '2';
        vm.bindevent = '2';
    });
    QUnit.test('errors on subproperties of undefined properties (#298)', function () {
        try {
            stache('<input {($value)}=\'prop.subprop\'/>')();
            ok(true, 'renderer was made without error');
        } catch (e) {
            ok(false, e.message);
        }
    });
});
/*can-stache-bindings@3.11.12#test/bindings-test*/
define('can-stache-bindings@3.11.12#test/bindings-test', [
    'require',
    'exports',
    'module',
    './bindings-colon-test',
    './bindings-define-test',
    'can-stache-bindings',
    'steal-qunit',
    'can-list',
    'can-map',
    'can-stache',
    'can-event',
    'can-event/batch/batch',
    'can-view-callbacks',
    'can-compute',
    'can-view-model',
    'can-symbol',
    'can-reflect',
    'can-stache/src/expression',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate',
    'can-util/dom/events/events',
    'can-util/dom/events/inserted/inserted',
    'can-globals',
    'can-vdom/make-document/make-document',
    'can-util/js/each/each',
    'can-types',
    'can-test-helpers',
    'can-cid/set/set',
    './mock-component'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        require('./bindings-colon-test');
        require('./bindings-define-test');
        var stacheBindings = require('can-stache-bindings');
        var QUnit = require('steal-qunit');
        var CanList = require('can-list');
        var CanMap = require('can-map');
        var stache = require('can-stache');
        var canEvent = require('can-event');
        var canBatch = require('can-event/batch/batch');
        var viewCallbacks = require('can-view-callbacks');
        var canCompute = require('can-compute');
        var canViewModel = require('can-view-model');
        var canSymbol = require('can-symbol');
        var canReflect = require('can-reflect');
        var stacheExpression = require('can-stache/src/expression');
        var domData = require('can-util/dom/data/data');
        var domMutate = require('can-util/dom/mutate/mutate');
        var domEvents = require('can-util/dom/events/events');
        require('can-util/dom/events/inserted/inserted');
        var globals = require('can-globals');
        var makeDocument = require('can-vdom/make-document/make-document');
        var canEach = require('can-util/js/each/each');
        var types = require('can-types');
        var testHelpers = require('can-test-helpers');
        var CIDSet = require('can-cid/set/set');
        var MockComponent = require('./mock-component');
        var DefaultMap = types.DefaultMap;
        function afterMutation(cb) {
            var doc = globals.getKeyValue('document');
            var div = doc.createElement('div');
            domEvents.addEventListener.call(div, 'inserted', function () {
                doc.body.removeChild(div);
                setTimeout(cb, 5);
            });
            domMutate.appendChild.call(doc.body, div);
        }
        makeTest('can-stache-bindings - dom', document, true);
        makeTest('can-stache-bindings - vdom', makeDocument(), false);
        function makeTest(name, doc, enableMO) {
            var testIfRealDocument = function () {
                if (doc === document) {
                    test.apply(null, arguments);
                } else {
                }
            };
            var isRealDocument = function () {
                return doc === document;
            };
            QUnit.module(name, {
                setup: function () {
                    globals.setKeyValue('document', doc);
                    if (!enableMO) {
                        globals.setKeyValue('MutationObserver', null);
                    }
                    types.DefaultMap = CanMap;
                    if (doc === document) {
                        this.fixture = document.getElementById('qunit-fixture');
                    } else {
                        this.fixture = doc.createElement('qunit-fixture');
                        doc.body.appendChild(this.fixture);
                    }
                },
                teardown: function () {
                    if (doc !== document) {
                        doc.body.removeChild(this.fixture);
                    }
                    stop();
                    afterMutation(function () {
                        types.DefaultMap = DefaultMap;
                        globals.deleteKeyValue('document');
                        globals.deleteKeyValue('MutationObserver');
                        var fixture = document.getElementById('qunit-fixture');
                        while (fixture && fixture.hasChildNodes()) {
                            domData.delete.call(fixture.lastChild);
                            fixture.removeChild(fixture.lastChild);
                        }
                        start();
                    });
                }
            });
            test('attributeNameInfo', function () {
                var info = stacheBindings.getBindingInfo({
                    name: 'foo',
                    value: 'bar'
                }, { foo: '@' }, 'legacy');
                deepEqual(info, {
                    parent: 'attribute',
                    child: 'viewModel',
                    parentToChild: true,
                    childToParent: true,
                    childName: 'foo',
                    parentName: 'foo',
                    bindingAttributeName: 'foo',
                    syncChildWithParent: true
                }, 'legacy with @');
                info = stacheBindings.getBindingInfo({
                    name: 'foo-ed',
                    value: 'bar'
                }, {}, 'legacy');
                deepEqual(info, {
                    parent: 'scope',
                    child: 'viewModel',
                    parentToChild: true,
                    childToParent: true,
                    childName: 'fooEd',
                    parentName: 'bar',
                    bindingAttributeName: 'foo-ed',
                    syncChildWithParent: true
                }, 'legacy');
                info = stacheBindings.getBindingInfo({
                    name: 'foo-ed',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'attribute',
                    child: 'viewModel',
                    parentToChild: true,
                    childToParent: true,
                    childName: 'fooEd',
                    parentName: 'foo-ed',
                    bindingAttributeName: 'foo-ed',
                    syncChildWithParent: true
                }, 'OG stache attr binding');
                info = stacheBindings.getBindingInfo({
                    name: 'foo-ed',
                    value: '{bar}'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'viewModel',
                    parentToChild: true,
                    childToParent: true,
                    childName: 'fooEd',
                    parentName: 'bar',
                    bindingAttributeName: 'foo-ed',
                    syncChildWithParent: true
                }, 'OG stache vm binding');
                info = stacheBindings.getBindingInfo({
                    name: '{$foo-ed}',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'attribute',
                    childToParent: false,
                    parentToChild: true,
                    parentName: 'bar',
                    childName: 'foo-ed',
                    bindingAttributeName: '{$foo-ed}',
                    initializeValues: true,
                    syncChildWithParent: false
                }, 'new el binding');
                info = stacheBindings.getBindingInfo({
                    name: '{($foo-ed)}',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'attribute',
                    childToParent: true,
                    parentToChild: true,
                    parentName: 'bar',
                    childName: 'foo-ed',
                    bindingAttributeName: '{($foo-ed)}',
                    initializeValues: true,
                    syncChildWithParent: true
                }, 'new el binding');
                info = stacheBindings.getBindingInfo({
                    name: '{^$foo-ed}',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'attribute',
                    childToParent: true,
                    parentToChild: false,
                    parentName: 'bar',
                    childName: 'foo-ed',
                    bindingAttributeName: '{^$foo-ed}',
                    initializeValues: true,
                    syncChildWithParent: false
                }, 'new el binding');
                info = stacheBindings.getBindingInfo({
                    name: '{foo-ed}',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'viewModel',
                    parentToChild: true,
                    childToParent: false,
                    childName: 'fooEd',
                    parentName: 'bar',
                    bindingAttributeName: '{foo-ed}',
                    initializeValues: true,
                    syncChildWithParent: false
                }, 'new vm binding');
                info = stacheBindings.getBindingInfo({
                    name: '{(foo-ed)}',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'viewModel',
                    parentToChild: true,
                    childToParent: true,
                    childName: 'fooEd',
                    parentName: 'bar',
                    bindingAttributeName: '{(foo-ed)}',
                    initializeValues: true,
                    syncChildWithParent: true
                }, 'new el binding');
                info = stacheBindings.getBindingInfo({
                    name: '{^foo-ed}',
                    value: 'bar'
                });
                deepEqual(info, {
                    parent: 'scope',
                    child: 'viewModel',
                    parentToChild: false,
                    childToParent: true,
                    childName: 'fooEd',
                    parentName: 'bar',
                    bindingAttributeName: '{^foo-ed}',
                    initializeValues: true,
                    syncChildWithParent: false
                }, 'new el binding');
            });
            var foodTypes = new CanList([
                {
                    title: 'Fruits',
                    content: 'oranges, apples'
                },
                {
                    title: 'Breads',
                    content: 'pasta, cereal'
                },
                {
                    title: 'Sweets',
                    content: 'ice cream, candy'
                }
            ]);
            if (typeof doc.getElementsByClassName === 'function') {
                test('can-event handlers', function () {
                    var ta = this.fixture;
                    var template = stache('<div>' + '{{#each foodTypes}}' + '<p can-click=\'doSomething\'>{{content}}</p>' + '{{/each}}' + '</div>');
                    function doSomething(foodType, el, ev) {
                        ok(true, 'doSomething called');
                        equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                        equal(ev.type, 'click', '1st argument is the event');
                        equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                    }
                    var frag = template({
                        foodTypes: foodTypes,
                        doSomething: doSomething
                    });
                    ta.appendChild(frag);
                    var p0 = ta.getElementsByTagName('p')[0];
                    canEvent.trigger.call(p0, 'click');
                });
                test('can-event special keys', function () {
                    var scope = new CanMap({ test: 'testval' });
                    var ta = this.fixture;
                    MockComponent.extend({
                        tag: 'can-event-args-tester',
                        viewModel: scope
                    });
                    var template = stache('<div>' + '{{#each foodTypes}}' + '<can-event-args-tester class=\'with-args\' can-click=\'{withArgs @event @element @viewModel @viewModel.test . title content=content}\'/>' + '{{/each}}' + '</div>');
                    function withArgs(ev1, el1, compScope, testVal, context, title, hash) {
                        ok(true, 'withArgs called');
                        equal(el1.nodeName.toLowerCase(), 'can-event-args-tester', '@element is the event\'s DOM element');
                        equal(ev1.type, 'click', '@event is the click event');
                        equal(scope, compScope, 'Component scope accessible through @viewModel');
                        equal(testVal, scope.attr('test'), 'Attributes accessible');
                        equal(context.title, foodTypes[0].title, 'Context passed in');
                        equal(title, foodTypes[0].title, 'Title passed in');
                        equal(hash.content, foodTypes[0].content, 'Args with = passed in as a hash');
                    }
                    var frag = template({
                        foodTypes: foodTypes,
                        withArgs: withArgs
                    });
                    ta.innerHTML = '';
                    ta.appendChild(frag);
                    var p0 = ta.getElementsByClassName('with-args')[0];
                    canEvent.trigger.call(p0, 'click');
                });
                test('(event) handlers', 12, function () {
                    var ta = this.fixture;
                    var template = stache('<div>' + '{{#each foodTypes}}' + '<p ($click)=\'doSomething\'>{{content}}</p>' + '{{/each}}' + '</div>');
                    var foodTypes = new CanList([
                        {
                            title: 'Fruits',
                            content: 'oranges, apples'
                        },
                        {
                            title: 'Breads',
                            content: 'pasta, cereal'
                        },
                        {
                            title: 'Sweets',
                            content: 'ice cream, candy'
                        }
                    ]);
                    function doSomething(foodType, el, ev) {
                        ok(true, 'doSomething called');
                        equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                        equal(ev.type, 'click', '1st argument is the event');
                        equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                    }
                    var frag = template({
                        foodTypes: foodTypes,
                        doSomething: doSomething
                    });
                    ta.appendChild(frag);
                    var p0 = ta.getElementsByTagName('p')[0];
                    canEvent.trigger.call(p0, 'click');
                    var scope = new CanMap({ test: 'testval' });
                    MockComponent.extend({
                        tag: 'fancy-event-args-tester',
                        viewModel: scope
                    });
                    template = stache('<div>' + '{{#each foodTypes}}' + '<fancy-event-args-tester class=\'with-args\' ($click)=\'withArgs @event @element @viewModel @viewModel.test . title content=content\'/>' + '{{/each}}' + '</div>');
                    function withArgs(ev1, el1, compScope, testVal, context, title, hash) {
                        ok(true, 'withArgs called');
                        equal(el1.nodeName.toLowerCase(), 'fancy-event-args-tester', '@element is the event\'s DOM element');
                        equal(ev1.type, 'click', '@event is the click event');
                        equal(scope, compScope, 'Component scope accessible through @viewModel');
                        equal(testVal, scope.attr('test'), 'Attributes accessible');
                        equal(context.title, foodTypes[0].title, 'Context passed in');
                        equal(title, foodTypes[0].title, 'Title passed in');
                        equal(hash.content, foodTypes[0].content, 'Args with = passed in as a hash');
                    }
                    frag = template({
                        foodTypes: foodTypes,
                        withArgs: withArgs
                    });
                    ta.innerHTML = '';
                    ta.appendChild(frag);
                    p0 = ta.getElementsByClassName('with-args')[0];
                    canEvent.trigger.call(p0, 'click');
                });
            }
            test('{($value)} input text', function () {
                var template = stache('<input {($value)}=\'age\'/>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                equal(input.value, '', 'input value set correctly if key does not exist in map');
                map.attr('age', '30');
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                equal(input.value, '31', 'input value update correctly');
                input.value = '32';
                canEvent.trigger.call(input, 'change');
                equal(map.attr('age'), '32', 'updated from input');
            });
            test('can-value input text', function () {
                var template = stache('<input can-value=\'age\'/>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                equal(input.value, '', 'input value set correctly if key does not exist in map');
                map.attr('age', '30');
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                equal(input.value, '31', 'input value update correctly');
                input.value = '32';
                canEvent.trigger.call(input, 'change');
                equal(map.attr('age'), '32', 'updated from input');
            });
            test('can-value with spaces (#1477)', function () {
                var template = stache('<input can-value=\'{ age }\'/>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                equal(input.value, '', 'input value set correctly if key does not exist in map');
                map.attr('age', '30');
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                equal(input.value, '31', 'input value update correctly');
                input.value = '32';
                canEvent.trigger.call(input, 'change');
                equal(map.attr('age'), '32', 'updated from input');
            });
            test('can-value input radio', function () {
                var template = stache('<input type=\'radio\' can-value=\'color\' value=\'red\'/> Red<br/>' + '<input type=\'radio\' can-value=\'color\' value=\'green\'/> Green<br/>');
                var map = new CanMap({ color: 'red' });
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var inputs = ta.getElementsByTagName('input');
                ok(inputs[0].checked, 'first input checked');
                ok(!inputs[1].checked, 'second input not checked');
                map.attr('color', 'green');
                ok(!inputs[0].checked, 'first notinput checked');
                ok(inputs[1].checked, 'second input checked');
                inputs[0].checked = true;
                inputs[1].checked = false;
                canEvent.trigger.call(inputs[0], 'change');
                equal(map.attr('color'), 'red', 'updated from input');
            });
            test('can-enter', function () {
                var template = stache('<input can-enter=\'update\'/>');
                var called = 0;
                var frag = template({
                    update: function () {
                        called++;
                        equal(called, 1, 'update called once');
                    }
                });
                var input = frag.childNodes.item(0);
                canEvent.trigger.call(input, {
                    type: 'keyup',
                    keyCode: 38
                });
                canEvent.trigger.call(input, {
                    type: 'keyup',
                    keyCode: 13
                });
            });
            testIfRealDocument('{($checked)} should trigger a radiochange event for radio buttons', function () {
                var template = stache([
                    '<input type="radio" name="baz" {($checked)}="foo"/><span>{{foo}}</span>',
                    '<input type="radio" name="baz" {($checked)}="bar"/><span>{{bar}}</span>'
                ].join(''));
                var data = new CanMap({
                    foo: false,
                    bar: false
                });
                var fragment = template(data);
                domMutate.appendChild.call(this.fixture, fragment);
                var self = this;
                function child(index) {
                    return self.fixture.childNodes.item(index);
                }
                var fooRadio = child(0);
                var fooText = child(1);
                var barRadio = child(2);
                var barText = child(3);
                function text(node) {
                    while (node && node.nodeType !== 3) {
                        node = node.firstChild;
                    }
                    return node && node.nodeValue;
                }
                fooRadio.checked = true;
                canEvent.trigger.call(fooRadio, 'change');
                barRadio.checked = true;
                canEvent.trigger.call(barRadio, 'change');
                equal(text(fooText), 'false');
                equal(text(barText), 'true');
                equal(data.foo, false);
                equal(data.bar, true);
            });
            testIfRealDocument('{($checked)} radio elements should update via the radiochange event', function () {
                var template = stache([
                    '<input type="radio" name="baz" {($checked)}="foo"/><span>{{foo}}</span>',
                    '<input type="radio" name="baz"/>'
                ].join(''));
                var data = new CanMap({ foo: false });
                var fragment = template(data);
                domMutate.appendChild.call(this.fixture, fragment);
                var self = this;
                function child(index) {
                    return self.fixture.childNodes.item(index);
                }
                var fooRadio = child(0);
                var fooText = child(1);
                var barRadio = child(2);
                function text(node) {
                    while (node && node.nodeType !== 3) {
                        node = node.firstChild;
                    }
                    return node && node.nodeValue;
                }
                fooRadio.checked = true;
                canEvent.trigger.call(fooRadio, 'change');
                equal(text(fooText), 'true');
                equal(data.foo, true);
                barRadio.checked = true;
                canEvent.trigger.call(barRadio, 'change');
                equal(text(fooText), 'false');
                equal(data.foo, false);
            });
            test('two bindings on one element call back the correct method', function () {
                expect(2);
                var template = stache('<input can-mousemove=\'first\' can-click=\'second\'/>');
                var callingFirst = false, callingSecond = false;
                var frag = template({
                    first: function () {
                        ok(callingFirst, 'called first');
                    },
                    second: function () {
                        ok(callingSecond, 'called second');
                    }
                });
                var input = frag.childNodes.item(0);
                callingFirst = true;
                canEvent.trigger.call(input, { type: 'mousemove' });
                callingFirst = false;
                callingSecond = true;
                canEvent.trigger.call(input, { type: 'click' });
            });
            test('event behavior event bindings should be removed when the bound element is', function (assert) {
                var template = stache('<div>{{#if isShowing}}<input ($click)="onClick()"><span></span>{{/if}}</div>');
                var viewModel = new CanMap({
                    isShowing: false,
                    onClick: function () {
                    }
                });
                var bindingListenerCount = 0;
                var hasAddedBindingListener = false;
                var hasRemovedBindingListener = false;
                var fragment = template(viewModel);
                domMutate.appendChild.call(this.fixture, fragment);
                var isInputBindingEvent = function (element, eventName) {
                    return element.nodeName === 'INPUT' && eventName === 'click';
                };
                var realAddEventListener = domEvents.addEventListener;
                var realRemoveEventListener = domEvents.removeEventListener;
                domEvents.addEventListener = function (eventName) {
                    if (isInputBindingEvent(this, eventName)) {
                        bindingListenerCount++;
                        hasAddedBindingListener = true;
                    }
                    return realAddEventListener.apply(this, arguments);
                };
                domEvents.removeEventListener = function (eventName) {
                    if (isInputBindingEvent(this, eventName)) {
                        bindingListenerCount--;
                        hasRemovedBindingListener = true;
                    }
                    return realRemoveEventListener.apply(this, arguments);
                };
                viewModel.attr('isShowing', true);
                var andThen = function () {
                    domEvents.removeEventListener.call(span, 'removed', andThen);
                    start();
                    domEvents.addEventListener = realAddEventListener;
                    domEvents.removeEventListener = realRemoveEventListener;
                    assert.ok(hasAddedBindingListener, 'An event listener should have been added for the binding');
                    assert.ok(hasRemovedBindingListener, 'An event listener should have been removed for the binding');
                    var message = bindingListenerCount + ' event listeners were added but not removed';
                    if (removeEventListener < 0) {
                        message = 'Event listeners were removed more than necessary';
                    }
                    assert.equal(bindingListenerCount, 0, message);
                };
                var span = this.fixture.firstChild.lastChild;
                domEvents.addEventListener.call(span, 'removed', andThen);
                viewModel.attr('isShowing', false);
                stop();
            });
            function interceptDomEvents(addFn, removeFn) {
                var realAddEventListener = domEvents.addEventListener;
                var realRemoveEventListener = domEvents.removeEventListener;
                domEvents.addEventListener = function (eventName) {
                    addFn.call(this, arguments);
                    return realAddEventListener.apply(this, arguments);
                };
                domEvents.removeEventListener = function (eventName) {
                    removeFn.call(this, arguments);
                    return realRemoveEventListener.apply(this, arguments);
                };
                return function undo() {
                    domEvents.addEventListener = realAddEventListener;
                    domEvents.removeEventListener = realRemoveEventListener;
                };
            }
            test('viewModel behavior event bindings should be removed when the bound element is', function (assert) {
                MockComponent.extend({
                    tag: 'view-model-binder',
                    viewModel: {},
                    template: stache('<span />')
                });
                var done = assert.async();
                var isTarget = function (target) {
                    return target.nodeName === 'VIEW-MODEL-BINDER';
                };
                var listenerCount = 0;
                var hasAddedBindingListener = false;
                var hasRemovedBindingListener = false;
                var undo = interceptDomEvents(function add() {
                    if (isTarget(this)) {
                        listenerCount++;
                        hasAddedBindingListener = true;
                    }
                }, function remove() {
                    if (isTarget(this)) {
                        listenerCount--;
                        hasRemovedBindingListener = true;
                    }
                });
                var viewModel = new CanMap({
                    isShowing: true,
                    bar: 'baz'
                });
                var template = stache('<div>{{#if isShowing}}<view-model-binder {foo}="bar"/><hr/>{{/isShowing}}</div>');
                var fragment = template(viewModel);
                domMutate.appendChild.call(this.fixture, fragment);
                var hr = this.fixture.firstChild.lastChild;
                domEvents.addEventListener.call(hr, 'removed', function andThen() {
                    domEvents.removeEventListener.call(hr, 'removed', andThen);
                    assert.ok(hasAddedBindingListener, 'An event listener should have been added for the binding');
                    assert.ok(hasRemovedBindingListener, 'An event listener should have been removed for the binding');
                    assert.equal(listenerCount, 0, 'all listeners should be removed');
                    undo();
                    done();
                });
                viewModel.attr('isShowing', false);
            });
            test('data behavior event bindings should be removed when the bound element is', function (assert) {
                var done = assert.async();
                var template = stache('<div>{{#if isShowing}}<span {foo}="bar"></span><hr/>{{/if}}</div>');
                var viewModel = new CanMap({
                    isShowing: true,
                    bar: 'baz'
                });
                var isTarget = function (target) {
                    return target.nodeName === 'SPAN';
                };
                var listeners = new CIDSet();
                var hasAddedBindingListener = false;
                var hasRemovedBindingListener = false;
                var undo = interceptDomEvents(function add(event, handler) {
                    if (isTarget(this)) {
                        listeners.add(handler);
                        hasAddedBindingListener = true;
                    }
                }, function remove(event, handler) {
                    if (isTarget(this)) {
                        listeners.delete(handler);
                        hasRemovedBindingListener = true;
                    }
                });
                var fragment = template(viewModel);
                domMutate.appendChild.call(this.fixture, fragment);
                var hr = this.fixture.firstChild.lastChild;
                domEvents.addEventListener.call(hr, 'removed', function andThen() {
                    domEvents.removeEventListener.call(hr, 'removed', andThen);
                    assert.ok(hasAddedBindingListener, 'An event listener should have been added for the binding');
                    assert.ok(hasRemovedBindingListener, 'An event listener should have been removed for the binding');
                    assert.equal(listeners.size, 0, 'all listeners should be removed');
                    undo();
                    done();
                });
                viewModel.attr('isShowing', false);
            });
            test('can-value select remove from DOM', function () {
                stop();
                expect(1);
                var template = stache('<select can-value=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>'), frag = template(), ta = this.fixture;
                domMutate.appendChild.call(ta, frag);
                domMutate.removeChild.call(ta, ta.firstChild);
                afterMutation(function () {
                    start();
                    ok(true, 'Nothing should break if we just add and then remove the select');
                });
            });
            test('checkboxes with can-value bind properly (#628)', function () {
                var data = new CanMap({ completed: true }), frag = stache('<input type="checkbox" can-value="completed"/>')(data);
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr check)');
                data.attr('completed', false);
                equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr uncheck)');
                input.checked = true;
                canEvent.trigger.call(input, 'change');
                equal(input.checked, true, 'checkbox value bound (via check)');
                equal(data.attr('completed'), true, 'checkbox value bound (via check)');
                input.checked = false;
                canEvent.trigger.call(input, 'change');
                equal(input.checked, false, 'checkbox value bound (via uncheck)');
                equal(data.attr('completed'), false, 'checkbox value bound (via uncheck)');
            });
            test('checkboxes with can-true-value bind properly', function () {
                var data = new CanMap({ sex: 'male' }), frag = stache('<input type="checkbox" can-value="sex" can-true-value="male" can-false-value="female"/>')(data);
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                stop();
                afterMutation(function () {
                    start();
                    equal(input.checked, true, 'checkbox value bound (via attr check)');
                    data.attr('sex', 'female');
                    equal(input.checked, false, 'checkbox value unbound (via attr uncheck)');
                    input.checked = true;
                    canEvent.trigger.call(input, 'change');
                    equal(input.checked, true, 'checkbox value bound (via check)');
                    equal(data.attr('sex'), 'male', 'checkbox value bound (via check)');
                    input.checked = false;
                    canEvent.trigger.call(input, 'change');
                    equal(input.checked, false, 'checkbox value bound (via uncheck)');
                    equal(data.attr('sex'), 'female', 'checkbox value bound (via uncheck)');
                });
            });
            testIfRealDocument('can-value select single', function () {
                var template = stache('<select can-value=\'color\'>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
                var map = new CanMap({ color: 'red' });
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var inputs = ta.getElementsByTagName('select');
                equal(inputs[0].value, 'red', 'default value set');
                map.attr('color', 'green');
                equal(inputs[0].value, 'green', 'alternate value set');
                canEach(ta.getElementsByTagName('option'), function (opt) {
                    if (opt.value === 'red') {
                        opt.selected = 'selected';
                    }
                });
                equal(map.attr('color'), 'green', 'not yet updated from input');
                canEvent.trigger.call(inputs[0], 'change');
                equal(map.attr('color'), 'red', 'updated from input');
                canEach(ta.getElementsByTagName('option'), function (opt) {
                    if (opt.value === 'green') {
                        opt.selected = 'selected';
                    }
                });
                equal(map.attr('color'), 'red', 'not yet updated from input');
                canEvent.trigger.call(inputs[0], 'change');
                equal(map.attr('color'), 'green', 'updated from input');
            });
            testIfRealDocument('can-value select multiple with values cross bound to an array', function () {
                var template = stache('<select can-value=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
                var map = new CanMap({});
                stop();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
                setTimeout(function () {
                    options[0].selected = true;
                    canEvent.trigger.call(select, 'change');
                    deepEqual(map.attr('colors').attr(), ['red'], 'A CanList property is set even if none existed');
                    options[1].selected = true;
                    canEvent.trigger.call(select, 'change');
                    deepEqual(map.attr('colors').attr(), [
                        'red',
                        'green'
                    ], 'Adds items to the list');
                    options[0].selected = false;
                    canEvent.trigger.call(select, 'change');
                    deepEqual(map.attr('colors').attr(), ['green'], 'Removes items from the list');
                    map.attr('colors').push('ultraviolet');
                    options[0].selected = false;
                    options[1].selected = true;
                    options[2].selected = true;
                    ta.removeChild(select);
                    start();
                }, 1);
            });
            testIfRealDocument('can-value multiple select with a CanList', function () {
                var template = stache('<select can-value=\'colors\' multiple>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '<option value=\'ultraviolet\'>Ultraviolet</option>' + '</select>');
                var list = new CanList();
                stop();
                var frag = template({ colors: list });
                var ta = this.fixture;
                ta.appendChild(frag);
                var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
                setTimeout(function () {
                    options[0].selected = true;
                    canEvent.trigger.call(select, 'change');
                    deepEqual(list.attr(), ['red'], 'A CanList property is set even if none existed');
                    options[1].selected = true;
                    canEvent.trigger.call(select, 'change');
                    deepEqual(list.attr(), [
                        'red',
                        'green'
                    ], 'Adds items to the list');
                    options[0].selected = false;
                    canEvent.trigger.call(select, 'change');
                    deepEqual(list.attr(), ['green'], 'Removes items from the list');
                    list.push('ultraviolet');
                    options[0].selected = false;
                    options[1].selected = true;
                    options[2].selected = true;
                    ta.removeChild(select);
                    start();
                }, 1);
            });
            test('can-value contenteditable', function () {
                var template = stache('<div id=\'cdiv\' contenteditable can-value=\'age\'></div>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var div = doc.getElementById('cdiv');
                equal(div.innerHTML, '', 'contenteditable set correctly if key does not exist in map');
                map.attr('age', '30');
                equal(div.innerHTML, '30', 'contenteditable set correctly');
                map.attr('age', '31');
                equal(div.innerHTML, '31', 'contenteditable update correctly');
                div.innerHTML = '32';
                canEvent.trigger.call(div, 'blur');
                equal(map.attr('age'), '32', 'updated from contenteditable');
            });
            test('can-event handlers work with {} (#905)', function () {
                expect(4);
                var template = stache('<div>' + '{{#each foodTypes}}' + '<p can-click=\'{doSomething}\'>{{content}}</p>' + '{{/each}}' + '</div>');
                var foodTypes = new CanList([
                    {
                        title: 'Fruits',
                        content: 'oranges, apples'
                    },
                    {
                        title: 'Breads',
                        content: 'pasta, cereal'
                    },
                    {
                        title: 'Sweets',
                        content: 'ice cream, candy'
                    }
                ]);
                var doSomething = function (foodType, el, ev) {
                    ok(true, 'doSomething called');
                    equal(el.nodeName.toLowerCase(), 'p', 'this is the element');
                    equal(ev.type, 'click', '1st argument is the event');
                    equal(foodType, foodTypes[0], '2nd argument is the 1st foodType');
                };
                var frag = template({
                    foodTypes: foodTypes,
                    doSomething: doSomething
                });
                var ta = this.fixture;
                ta.appendChild(frag);
                var p0 = ta.getElementsByTagName('p')[0];
                canEvent.trigger.call(p0, 'click');
            });
            test('can-value works with {} (#905)', function () {
                var template = stache('<input can-value=\'{age}\'/>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                equal(input.value, '', 'input value set correctly if key does not exist in map');
                map.attr('age', '30');
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                equal(input.value, '31', 'input value update correctly');
                input.value = '32';
                canEvent.trigger.call(input, 'change');
                equal(map.attr('age'), '32', 'updated from input');
            });
            test('can-value select with null or undefined value (#813)', function () {
                var template = stache('<select id=\'null-select\' can-value=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' can-value=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
                var map = new CanMap({
                    'color-1': null,
                    'color-2': undefined
                });
                stop();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var nullInput = doc.getElementById('null-select');
                var nullInputOptions = nullInput.getElementsByTagName('option');
                var undefinedInput = doc.getElementById('undefined-select');
                var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
                afterMutation(function () {
                    ok(nullInputOptions[0].selected, 'default (null) value set');
                    ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                    start();
                });
            });
            test('radio type conversion (#811)', function () {
                var data = new CanMap({ id: 1 }), frag = stache('<input type="radio" can-value="id" value="1"/>')(data);
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                ok(input.checked, 'checkbox value bound');
            });
            test('template with view binding breaks in stache, not in mustache (#966)', function () {
                var templateString = '<a href="javascript://" can-click="select">' + '{{#if thing}}\n<div />{{/if}}' + '<span>{{name}}</span>' + '</a>';
                var stacheRenderer = stache(templateString);
                var obj = new CanMap({ thing: 'stuff' });
                stacheRenderer(obj);
                ok(true, 'stache worked without errors');
            });
            test('can-event throws an error when inside #if block (#1182)', function (assert) {
                var done = assert.async();
                var flag = canCompute(false), clickHandlerCount = 0;
                var frag = stache('<div {{#if flag}}can-click=\'foo\'{{/if}}>Click</div>')({
                    flag: flag,
                    foo: function () {
                        clickHandlerCount++;
                    }
                });
                var fixture = this.fixture;
                var trig = function () {
                    var div = fixture.getElementsByTagName('div')[0];
                    canEvent.trigger.call(div, { type: 'click' });
                };
                domMutate.appendChild.call(this.fixture, frag);
                trig();
                afterMutation(function () {
                    equal(clickHandlerCount, 0, 'click handler not called');
                    done();
                });
            });
            testIfRealDocument('can-EVENT removed in live bindings doesn\'t unbind (#1112)', function () {
                var flag = canCompute(true), clickHandlerCount = 0;
                var frag = stache('<div {{#if flag}}can-click=\'foo\'{{/if}}>Click</div>')({
                    flag: flag,
                    foo: function () {
                        clickHandlerCount++;
                    }
                });
                var testEnv = this;
                var trig = function () {
                    var div = testEnv.fixture.getElementsByTagName('div')[0];
                    canEvent.trigger.call(div, { type: 'click' });
                };
                domMutate.appendChild.call(this.fixture, frag);
                stop();
                var numTrigs = 3;
                var testTimer = setInterval(function () {
                    if (numTrigs--) {
                        trig();
                        flag(!flag());
                    } else {
                        clearTimeout(testTimer);
                        equal(clickHandlerCount, 2, 'click handler called twice');
                        start();
                    }
                }, 100);
            });
            test('can-value compute rejects new value (#887)', function () {
                var template = stache('<input can-value=\'age\'/>');
                var compute = canCompute(30, function (newVal, oldVal) {
                    if (isNaN(+newVal)) {
                        return oldVal;
                    } else {
                        return +newVal;
                    }
                });
                var frag = template({ age: compute });
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                input.value = '30f';
                canEvent.trigger.call(input, 'change');
                equal(compute(), 30, 'Still the old value');
                equal(input.value, '30', 'Text input has also not changed');
            });
            testIfRealDocument('can-value select multiple applies initial value, when options rendered from array (#1414)', function () {
                var template = stache('<select can-value=\'colors\' multiple>' + '{{#each allColors}}<option value=\'{{value}}\'>{{label}}</option>{{/each}}' + '</select>');
                var map = new CanMap({
                    colors: [
                        'red',
                        'green'
                    ],
                    allColors: [
                        {
                            value: 'red',
                            label: 'Red'
                        },
                        {
                            value: 'green',
                            label: 'Green'
                        },
                        {
                            value: 'blue',
                            label: 'Blue'
                        }
                    ]
                });
                stop();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var select = ta.getElementsByTagName('select')[0], options = select.getElementsByTagName('option');
                afterMutation(function () {
                    ok(options[0].selected, 'red should be set initially');
                    ok(options[1].selected, 'green should be set initially');
                    ok(!options[2].selected, 'blue should not be set initially');
                    start();
                });
            });
            test('can-value with truthy and falsy values binds to checkbox (#1478)', function () {
                var data = new CanMap({ completed: 1 }), frag = stache('<input type="checkbox" can-value="completed"/>')(data);
                stop();
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                equal(input.checked, true, 'checkbox value bound (via attr check)');
                data.attr('completed', 0);
                equal(input.checked, false, 'checkbox value bound (via attr check)');
                afterMutation(start);
            });
            test('can-EVENT can call intermediate functions before calling the final function(#1474)', function () {
                var ta = this.fixture;
                var template = stache('<div id=\'click-me\' can-click=\'{does.some.thing}\'></div>');
                var frag = template({
                    does: function () {
                        return {
                            some: function () {
                                return {
                                    thing: function (context) {
                                        ok(typeof context.does === 'function');
                                        start();
                                    }
                                };
                            }
                        };
                    }
                });
                stop();
                ta.appendChild(frag);
                canEvent.trigger.call(doc.getElementById('click-me'), 'click');
            });
            test('by default can-EVENT calls with values, not computes', function () {
                stop();
                var ta = this.fixture;
                var template = stache('<div id=\'click-me\' can-click=\'{map.method one map.two map.three}\'></div>');
                var one = canCompute(1);
                var three = canCompute(3);
                var MyMap = CanMap.extend({
                    method: function (ONE, two, three) {
                        equal(ONE, 1);
                        equal(two, 2);
                        equal(three, 3);
                        equal(this, map, 'this set right');
                        start();
                    }
                });
                var map = new MyMap({
                    'two': 2,
                    'three': three
                });
                var frag = template({
                    one: one,
                    map: map
                });
                ta.appendChild(frag);
                canEvent.trigger.call(doc.getElementById('click-me'), 'click');
            });
            test('Conditional can-EVENT bindings are bound/unbound', 2, function () {
                var state = new CanMap({
                    enableClick: true,
                    clickHandler: function () {
                        ok(true, '"click" was handled');
                    }
                });
                var template = stache('<button id="find-me" {{#if enableClick}}can-click="{clickHandler}"{{/if}}></button>');
                var frag = template(state);
                var sandbox = this.fixture;
                sandbox.appendChild(frag);
                var btn = doc.getElementById('find-me');
                canEvent.trigger.call(btn, 'click');
                state.attr('enableClick', false);
                stop();
                afterMutation(function () {
                    canEvent.trigger.call(btn, 'click');
                    state.attr('enableClick', true);
                    afterMutation(function () {
                        canEvent.trigger.call(btn, 'click');
                        start();
                    });
                });
            });
            testIfRealDocument('<select can-value={value}> with undefined value selects option without value', function () {
                var template = stache('<select can-value=\'opt\'><option>Loading...</option></select>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var select = ta.childNodes.item(0);
                QUnit.equal(select.selectedIndex, 0, 'Got selected index');
            });
            testIfRealDocument('<select can-value> keeps its value as <option>s change with {{#list}} (#1762)', function () {
                var template = stache('<select can-value=\'{id}\'>{{#values}}<option value=\'{{.}}\'>{{.}}</option>{{/values}}</select>');
                var values = canCompute([
                    '1',
                    '2',
                    '3',
                    '4'
                ]);
                var id = canCompute('2');
                var frag = template({
                    values: values,
                    id: id
                });
                stop();
                var select = frag.firstChild;
                afterMutation(function () {
                    ok(select.childNodes.item(1).selected, 'value is initially selected');
                    values([
                        '7',
                        '2',
                        '5',
                        '4'
                    ]);
                    ok(select.childNodes.item(1).selected, 'after changing options, value should still be selected');
                    start();
                });
            });
            testIfRealDocument('<select can-value> keeps its value as <option>s change with {{#each}} (#1762)', function () {
                var template = stache('<select can-value=\'{id}\'>{{#each values}}<option value=\'{{.}}\'>{{.}}</option>{{/each}}</select>');
                var values = canCompute([
                    '1',
                    '2',
                    '3',
                    '4'
                ]);
                var id = canCompute('2');
                var frag = template({
                    values: values,
                    id: id
                });
                stop();
                var select = frag.firstChild;
                var options = select.getElementsByTagName('option');
                afterMutation(function () {
                    ok(options[1].selected, 'value is initially selected');
                    values([
                        '7',
                        '2',
                        '5',
                        '4'
                    ]);
                    afterMutation(function () {
                        ok(options[1].selected, 'after changing options, value should still be selected');
                        start();
                    });
                });
            });
            test('(event) methods on objects are called (#1839)', function () {
                var template = stache('<div ($click)=\'setSomething person.message\'/>');
                var data = {
                    setSomething: function (message) {
                        equal(message, 'Matthew P finds good bugs');
                        equal(this, data, 'setSomething called with correct scope');
                    },
                    person: {
                        name: 'Matthew P',
                        message: function () {
                            return this.name + ' finds good bugs';
                        }
                    }
                };
                var frag = template(data);
                canEvent.trigger.call(frag.firstChild, 'click');
            });
            test('(event) methods on objects are called with call expressions (#1839)', function () {
                var template = stache('<div ($click)=\'setSomething(person.message)\'/>');
                var data = {
                    setSomething: function (message) {
                        equal(message, 'Matthew P finds good bugs');
                        equal(this, data, 'setSomething called with correct scope');
                    },
                    person: {
                        name: 'Matthew P',
                        message: function () {
                            return this.name + ' finds good bugs';
                        }
                    }
                };
                var frag = template(data);
                canEvent.trigger.call(frag.firstChild, 'click');
            });
            test('two way - viewModel (#1700)', function () {
                var template = stache('<div {(view-model-prop)}=\'scopeProp\'/>');
                var map = new CanMap({ scopeProp: 'Hello' });
                var scopeMapSetCalled = 0;
                var origMapSetKeyValue = map[canSymbol.for('can.setKeyValue')];
                map[canSymbol.for('can.setKeyValue')] = function (attrName, value) {
                    if (typeof attrName === 'string' && arguments.length > 1) {
                        scopeMapSetCalled++;
                    }
                    return origMapSetKeyValue.apply(this, arguments);
                };
                var origMapSet = map._set;
                map._set = function (attrName, value) {
                    if (typeof attrName === 'string' && arguments.length > 1) {
                        scopeMapSetCalled++;
                    }
                    return origMapSet.apply(this, arguments);
                };
                var frag = template(map);
                var viewModel = canViewModel(frag.firstChild);
                equal(scopeMapSetCalled, 0, 'set is not called on scope map');
                equal(viewModel.attr('viewModelProp'), 'Hello', 'initial value set');
                viewModel = canViewModel(frag.firstChild);
                var viewModelSetCalled = 1;
                var origViewModelSet = viewModel[canSymbol.for('can.setKeyValue')];
                viewModel[canSymbol.for('can.setKeyValue')] = function (attrName) {
                    if (typeof attrName === 'string' && arguments.length > 1) {
                        viewModelSetCalled++;
                    }
                    return origViewModelSet.apply(this, arguments);
                };
                viewModel.attr('viewModelProp', 'HELLO');
                equal(map.attr('scopeProp'), 'HELLO', 'binding from child to parent');
                equal(scopeMapSetCalled, 1, 'set is called on scope map');
                equal(viewModelSetCalled, 2, 'set is called viewModel');
                map.attr('scopeProp', 'WORLD');
                equal(viewModel.attr('viewModelProp'), 'WORLD', 'binding from parent to child');
                equal(scopeMapSetCalled, 2, 'set is called again on scope map');
                equal(viewModelSetCalled, 3, 'set is called again on viewModel');
            });
            test('two-way - DOM - input text (#1700)', function () {
                var template = stache('<input {($value)}=\'age\'/>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                equal(input.value, '', 'input value set correctly if key does not exist in map');
                map.attr('age', '30');
                stop();
                afterMutation(function () {
                    start();
                    equal(input.value, '30', 'input value set correctly');
                    map.attr('age', '31');
                    stop();
                    afterMutation(function () {
                        start();
                        equal(input.value, '31', 'input value update correctly');
                        input.value = '32';
                        canEvent.trigger.call(input, 'change');
                        stop();
                        afterMutation(function () {
                            start();
                            equal(map.attr('age'), '32', 'updated from input');
                        });
                    });
                });
            });
            test('two-way - DOM - {($checked)} with truthy and falsy values binds to checkbox (#1700)', function () {
                var data = new CanMap({ completed: 1 }), frag = stache('<input type="checkbox" {($checked)}="completed"/>')(data);
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                equal(input.checked, true, 'checkbox value bound (via attr check)');
                data.attr('completed', 0);
                stop();
                afterMutation(function () {
                    start();
                    equal(input.checked, false, 'checkbox value bound (via attr check)');
                });
            });
            test('one-way - DOM - {$checked} with undefined (#135)', function () {
                var data = new CanMap({ completed: undefined }), frag = stache('<input type="checkbox" {$checked}="completed"/>')(data);
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                equal(input.checked, false, 'checkbox value should be false for undefined');
            });
            test('one-way - DOM - parent value undefined (#189)', function () {
                MockComponent.extend({
                    tag: 'toggle-button',
                    viewModel: {
                        value: false,
                        toggle: function () {
                            this.attr('value', !this.attr('value'));
                        }
                    },
                    template: stache('<button type="button" ($click)="toggle()">{{value}}</button>')
                });
                var template = stache('<toggle-button {(value)}="./does-not-exist" />');
                var fragment = template({});
                domMutate.appendChild.call(this.fixture, fragment);
                var button = this.fixture.getElementsByTagName('button')[0];
                function text(node) {
                    while (node && node.nodeType !== 3) {
                        node = node.firstChild;
                    }
                    return node && node.nodeValue;
                }
                equal(text(button), 'false', 'Initial value is "false"');
                canEvent.trigger.call(button, 'click');
                equal(text(button), 'true', 'Value is "true" after first click');
                canEvent.trigger.call(button, 'click');
                equal(text(button), 'false', 'Value is "false" after second click');
            });
            test('two-way - reference - {(child)}="*ref" (#1700)', function () {
                var data = new CanMap({ person: { name: {} } });
                MockComponent.extend({
                    tag: 'reference-export',
                    viewModel: { tag: 'reference-export' }
                });
                MockComponent.extend({
                    tag: 'ref-import',
                    viewModel: { tag: 'ref-import' }
                });
                var template = stache('<reference-export {(name)}=\'*refName\'/>' + '<ref-import {(name)}=\'*refName\'/> {{helperToGetScope}}');
                var scope;
                var frag = template(data, {
                    helperToGetScope: function (options) {
                        scope = options.scope;
                    }
                });
                var refExport = canViewModel(frag.firstChild);
                var refImport = canViewModel(frag.firstChild.nextSibling);
                refExport.attr('name', 'v1');
                equal(scope.getRefs().read('*refName').value, 'v1', 'reference scope updated');
                equal(refImport.attr('name'), 'v1', 'updated ref-import');
                refImport.attr('name', 'v2');
                equal(refExport.attr('name'), 'v2', 'updated ref-export');
                equal(scope.getRefs().read('*refName').value, 'v2', 'actually put in refs scope');
            });
            test('two-way - reference shorthand (#1700)', function () {
                var data = new CanMap({ person: { name: {} } });
                MockComponent.extend({
                    tag: 'reference-export',
                    template: stache('<span>{{*referenceExport.name}}</span>'),
                    viewModel: {}
                });
                var template = stache('{{#person}}{{#name}}' + '<reference-export *reference-export/>' + '{{/name}}{{/person}}<span>{{*referenceExport.name}}</span>');
                var frag = template(data);
                var refExport = canViewModel(frag.firstChild);
                refExport.attr('name', 'done');
                equal(frag.lastChild.firstChild.nodeValue, 'done');
                equal(frag.firstChild.firstChild.firstChild.nodeValue, '', 'not done');
            });
            test('one-way - parent to child - viewModel', function () {
                var template = stache('<div {view-model-prop}=\'scopeProp\'/>');
                var map = new CanMap({ scopeProp: 'Venus' });
                var frag = template(map);
                var viewModel = canViewModel(frag.firstChild);
                equal(viewModel.attr('viewModelProp'), 'Venus', 'initial value set');
                viewModel.attr('viewModelProp', 'Earth');
                equal(map.attr('scopeProp'), 'Venus', 'no binding from child to parent');
                map.attr('scopeProp', 'Mars');
                equal(viewModel.attr('viewModelProp'), 'Mars', 'binding from parent to child');
            });
            test('one-way - child to parent - viewModel', function () {
                MockComponent.extend({
                    tag: 'view-model-able',
                    viewModel: { viewModelProp: 'Mercury' }
                });
                var template = stache('<view-model-able {^view-model-prop}=\'scopeProp\'/>');
                var map = new CanMap({ scopeProp: 'Venus' });
                var frag = template(map);
                var viewModel = canViewModel(frag.firstChild);
                equal(viewModel.attr('viewModelProp'), 'Mercury', 'initial value kept');
                equal(map.attr('scopeProp'), 'Mercury', 'initial value set on parent');
                viewModel.attr('viewModelProp', 'Earth');
                equal(map.attr('scopeProp'), 'Earth', 'binding from child to parent');
                map.attr('scopeProp', 'Mars');
                equal(viewModel.attr('viewModelProp'), 'Earth', 'no binding from parent to child');
            });
            test('one way - child to parent - importing viewModel {^.}="test"', function () {
                MockComponent.extend({
                    tag: 'import-scope',
                    template: stache('Hello {{name}}'),
                    viewModel: {
                        name: 'David',
                        age: 7
                    }
                });
                MockComponent.extend({
                    tag: 'import-parent',
                    template: stache('<import-scope {^.}="test"></import-scope>' + '<div>Imported: {{test.name}} {{test.age}}</div>')
                });
                var template = stache('<import-parent></import-parent>');
                var frag = template({});
                equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David 7', '{.} component scope imported into variable');
            });
            test('one way - child to parent - importing viewModel {^prop}="test"', function () {
                MockComponent.extend({
                    tag: 'import-prop-scope',
                    template: stache('Hello {{name}}'),
                    viewModel: {
                        name: 'David',
                        age: 7
                    }
                });
                MockComponent.extend({
                    tag: 'import-prop-parent',
                    template: stache('<import-prop-scope {^name}="test"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
                });
                var template = stache('<import-prop-parent></import-prop-parent>');
                var frag = template({});
                equal(frag.childNodes.item(0).childNodes.item(1).innerHTML, 'Imported: David', '{name} component scope imported into variable');
            });
            test('one way - child to parent - importing viewModel {^hyphenated-prop}="test"', function () {
                MockComponent.extend({
                    tag: 'import-prop-scope',
                    template: stache('Hello {{userName}}'),
                    viewModel: {
                        userName: 'David',
                        age: 7,
                        updateName: function () {
                            this.attr('userName', 'Justin');
                        }
                    }
                });
                MockComponent.extend({
                    tag: 'import-prop-parent',
                    template: stache('<import-prop-scope {^user-name}="test" {^.}="childComponent"></import-prop-scope>' + '<div>Imported: {{test}}</div>')
                });
                var template = stache('<import-prop-parent></import-prop-parent>');
                var frag = template({});
                var importPropParent = frag.firstChild;
                var importPropScope = importPropParent.getElementsByTagName('import-prop-scope')[0];
                canViewModel(importPropScope).updateName();
                var importPropParentViewModel = canViewModel(importPropParent);
                equal(importPropParentViewModel.attr('test'), 'Justin', 'got hyphenated prop');
                equal(importPropParentViewModel.attr('childComponent'), canViewModel(importPropScope), 'got view model');
            });
            test('viewModel binding (event)', function () {
                MockComponent.extend({
                    tag: 'viewmodel-binding',
                    viewModel: {
                        makeMyEvent: function () {
                            this.dispatch('myevent');
                        }
                    }
                });
                var frag = stache('<viewmodel-binding (myevent)=\'doSomething()\'/>')({
                    doSomething: function () {
                        ok(true, 'called!');
                    }
                });
                canViewModel(frag.firstChild).makeMyEvent();
            });
            test('checkboxes with {($checked)} bind properly', function () {
                var data = new CanMap({ completed: true }), frag = stache('<input type="checkbox" {($checked)}="completed"/>')(data);
                domMutate.appendChild.call(this.fixture, frag);
                var input = this.fixture.getElementsByTagName('input')[0];
                equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr check)');
                data.attr('completed', false);
                equal(input.checked, data.attr('completed'), 'checkbox value bound (via attr uncheck)');
                input.checked = true;
                canEvent.trigger.call(input, 'change');
                stop();
                afterMutation(function () {
                    start();
                    equal(input.checked, true, 'checkbox value bound (via check)');
                    equal(data.attr('completed'), true, 'checkbox value bound (via check)');
                    input.checked = false;
                    canEvent.trigger.call(input, 'change');
                    stop();
                    afterMutation(function () {
                        start();
                        equal(input.checked, false, 'checkbox value bound (via uncheck)');
                        equal(data.attr('completed'), false, 'checkbox value bound (via uncheck)');
                    });
                });
            });
            test('two-way element empty value (1996)', function () {
                var template = stache('<input can-value=\'age\'/>');
                var map = new CanMap();
                var frag = template(map);
                var ta = this.fixture;
                ta.appendChild(frag);
                var input = ta.getElementsByTagName('input')[0];
                equal(input.value, '', 'input value set correctly if key does not exist in map');
                map.attr('age', '30');
                equal(input.value, '30', 'input value set correctly');
                map.attr('age', '31');
                equal(input.value, '31', 'input value update correctly');
                input.value = '';
                canEvent.trigger.call(input, 'change');
                equal(map.attr('age'), '', 'updated from input');
            });
            test('exporting methods (#2051)', function () {
                expect(2);
                MockComponent.extend({
                    tag: 'foo-bar',
                    viewModel: {
                        method: function () {
                            ok(true, 'foo called');
                            return 5;
                        }
                    }
                });
                var template = stache('<foo-bar {^@method}=\'@*refKey\'></foo-bar>{{*refKey()}}');
                var frag = template({});
                equal(frag.lastChild.nodeValue, '5');
            });
            test('renders dynamic custom attributes (#1800)', function () {
                var template = stache('<ul>{{#actions}}<li can-click=\'{{.}}\'>{{.}}</li>{{/actions}}</ul>');
                var map = new CanMap({
                    actions: [
                        'action1',
                        'action2'
                    ],
                    action1: function () {
                        equal(calling, 0, 'action1');
                    },
                    action2: function () {
                        equal(calling, 1, 'action2');
                    }
                });
                var frag = template(map), lis = frag.firstChild.getElementsByTagName('li');
                var calling = 0;
                canEvent.trigger.call(lis[0], 'click');
                calling = 1;
                canEvent.trigger.call(lis[1], 'click');
            });
            testHelpers.dev.devOnlyTest('warning on a mismatched quote (#1995)', function () {
                var teardown = testHelpers.dev.willWarn('can-stache-bindings: mismatched binding syntax - (foo}');
                stache('<div (foo}=\'bar\'/>')();
                equal(teardown(), 1, 'can-stache-bindings: mismatched binding syntax - (foo}');
                teardown = testHelpers.dev.willWarn('can-stache-bindings: mismatched binding syntax - {foo)');
                stache('<div {foo)=\'bar\'/>')();
                equal(teardown(), 1, 'can-stache-bindings: mismatched binding syntax - {foo)');
                teardown = testHelpers.dev.willWarn('can-stache-bindings: mismatched binding syntax - {(foo})');
                stache('<div {(foo})=\'bar\'/>')();
                equal(teardown(), 1, 'can-stache-bindings: mismatched binding syntax - {(foo})');
                teardown = testHelpers.dev.willWarn('can-stache-bindings: mismatched binding syntax - ({foo})');
                stache('<div ({foo})=\'bar\'/>')();
                equal(teardown(), 1, 'can-stache-bindings: mismatched binding syntax - ({foo})');
            });
            testIfRealDocument('One way binding from a select\'s value to a parent compute updates the parent with the select\'s initial value (#2027)', function () {
                var template = stache('<select {^$value}=\'value\'><option value=\'One\'>One</option></select>');
                var map = new CanMap();
                var frag = template(map);
                var select = frag.childNodes.item(0);
                afterMutation(function () {
                    equal(select.selectedIndex, 0, 'selectedIndex is 0 because no value exists on the map');
                    equal(map.attr('value'), 'One', 'The map\'s value property is set to the select\'s value');
                    start();
                });
                stop();
            });
            testIfRealDocument('two way binding from a select\'s value to null has no selection (#2027)', function () {
                var template = stache('<select {($value)}=\'key\'><option value=\'One\'>One</option></select>');
                var map = new CanMap({ key: null });
                var frag = template(map);
                var select = frag.childNodes.item(0);
                afterMutation(function () {
                    equal(select.selectedIndex, -1, 'selectedIndex is 0 because no value exists on the map');
                    equal(map.attr('key'), null, 'The map\'s value property is set to the select\'s value');
                    start();
                });
                stop();
            });
            testIfRealDocument('two-way bound values that do not match a select option set selectedIndex to -1 (#2027)', function () {
                var renderer = stache('<select {($value)}="key"><option value="foo">foo</option><option value="bar">bar</option></select>');
                var map = new CanMap({});
                var frag = renderer(map);
                equal(frag.firstChild.selectedIndex, 0, 'undefined <- {($first value)}: selectedIndex = 0');
                map.attr('key', 'notfoo');
                stop();
                afterMutation(function () {
                    start();
                    equal(frag.firstChild.selectedIndex, -1, 'notfoo: selectedIndex = -1');
                    map.attr('key', 'foo');
                    strictEqual(frag.firstChild.selectedIndex, 0, 'foo: selectedIndex = 0');
                    map.attr('key', 'notbar');
                    stop();
                    afterMutation(function () {
                        start();
                        equal(frag.firstChild.selectedIndex, -1, 'notbar: selectedIndex = -1');
                        map.attr('key', 'bar');
                        strictEqual(frag.firstChild.selectedIndex, 1, 'bar: selectedIndex = 1');
                        map.attr('key', 'bar');
                        strictEqual(frag.firstChild.selectedIndex, 1, 'bar (no change): selectedIndex = 1');
                    });
                });
            });
            testIfRealDocument('two way bound select empty string null or undefined value (#2027)', function () {
                var template = stache('<select id=\'null-select\' {($value)}=\'color-1\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'undefined-select\' {($value)}=\'color-2\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>' + '<select id=\'string-select\' {($value)}=\'color-3\'>' + '<option value=\'\'>Choose</option>' + '<option value=\'red\'>Red</option>' + '<option value=\'green\'>Green</option>' + '</select>');
                var map = new CanMap({
                    'color-1': null,
                    'color-2': undefined,
                    'color-3': ''
                });
                stop();
                var frag = template(map);
                domMutate.appendChild.call(this.fixture, frag);
                var nullInput = doc.getElementById('null-select');
                var nullInputOptions = nullInput.getElementsByTagName('option');
                var undefinedInput = doc.getElementById('undefined-select');
                var undefinedInputOptions = undefinedInput.getElementsByTagName('option');
                var stringInput = doc.getElementById('string-select');
                var stringInputOptions = stringInput.getElementsByTagName('option');
                afterMutation(function () {
                    ok(!nullInputOptions[0].selected, 'default (null) value set');
                    ok(undefinedInputOptions[0].selected, 'default (undefined) value set');
                    ok(stringInputOptions[0].selected, 'default (\'\') value set');
                    start();
                });
            });
            if (System.env !== 'canjs-test') {
                test('dynamic attribute bindings (#2016)', function (assert) {
                    var done = assert.async();
                    var template = stache('<input {($value)}=\'{{propName}}\'/>');
                    var map = new CanMap({
                        propName: 'first',
                        first: 'Justin',
                        last: 'Meyer'
                    });
                    var frag = template(map);
                    var ta = this.fixture;
                    ta.appendChild(frag);
                    var input = ta.getElementsByTagName('input')[0];
                    afterMutation(function () {
                        equal(input.value, 'Justin', 'input value set correctly if key does not exist in map');
                        map.attr('propName', 'last');
                        afterMutation(function () {
                            equal(input.value, 'Meyer', 'input value set correctly if key does not exist in map');
                            input.value = 'Lueke';
                            canEvent.trigger.call(input, 'change');
                            afterMutation(function () {
                                equal(map.attr('last'), 'Lueke', 'updated from input');
                                done();
                            });
                        });
                    });
                });
            }
            test('select bindings respond to changes immediately or during insert (#2134)', function () {
                var countries = [
                    {
                        code: 'MX',
                        countryName: 'MEXICO'
                    },
                    {
                        code: 'US',
                        countryName: 'USA'
                    },
                    {
                        code: 'IND',
                        countryName: 'INDIA'
                    },
                    {
                        code: 'RUS',
                        countryName: 'RUSSIA'
                    }
                ];
                var template = stache('<select {($value)}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
                var data = new CanMap({
                    countryCode: 'US',
                    countries: countries
                });
                var frag = template(data);
                data.attr('countryCode', 'IND');
                stop();
                afterMutation(function () {
                    start();
                    equal(frag.firstChild.value, 'IND', 'got last updated value');
                });
            });
            test('select bindings respond to changes immediately or during insert using can-value (#2134)', function () {
                var countries = [
                    {
                        code: 'MX',
                        countryName: 'MEXICO'
                    },
                    {
                        code: 'US',
                        countryName: 'USA'
                    },
                    {
                        code: 'IND',
                        countryName: 'INDIA'
                    },
                    {
                        code: 'RUS',
                        countryName: 'RUSSIA'
                    }
                ];
                var template = stache('<select can-value="{countryCode}">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
                var data = new CanMap({
                    countryCode: 'US',
                    countries: countries
                });
                var frag = template(data);
                data.attr('countryCode', 'IND');
                stop();
                afterMutation(function () {
                    start();
                    equal(frag.firstChild.value, 'IND', 'got last updated value');
                });
            });
            testIfRealDocument('two-way <select> bindings update to `undefined` if options are replaced (#1762)', function () {
                var countries = [
                    {
                        code: 'MX',
                        countryName: 'MEXICO'
                    },
                    {
                        code: 'US',
                        countryName: 'USA'
                    }
                ];
                var data = new CanMap({
                    countryCode: 'US',
                    countries: countries
                });
                var template = stache('<select {($value)}="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
                template(data);
                stop();
                afterMutation(function () {
                    data.attr('countries').replace([]);
                    afterMutation(function () {
                        equal(data.attr('countryCode'), undefined, 'countryCode set to undefined');
                        start();
                    });
                });
            });
            testIfRealDocument('two-way <select> bindings update to `undefined` if options are replaced - each (#1762)', function () {
                var countries = [
                    {
                        code: 'MX',
                        countryName: 'MEXICO'
                    },
                    {
                        code: 'US',
                        countryName: 'USA'
                    }
                ];
                var data = new CanMap({
                    countryCode: 'US',
                    countries: countries
                });
                var template = stache('<select {($value)}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
                template(data);
                stop();
                afterMutation(function () {
                    data.attr('countries').replace([]);
                    afterMutation(function () {
                        equal(data.attr('countryCode'), undefined, 'countryCode set to undefined');
                        start();
                    });
                });
            });
            testIfRealDocument('previously non-existing select value gets selected from a list when it is added (#1762)', function () {
                var template = stache('<select {($value)}="{person}">' + '<option></option>' + '{{#each people}}<option value="{{.}}">{{.}}</option>{{/each}}' + '</select>' + '<input type="text" size="5" {($value)}="person">');
                var people = new CanList([
                    'Alexis',
                    'Mihael',
                    'Curtis',
                    'David'
                ]);
                var vm = new CanMap({
                    person: 'Brian',
                    people: people
                });
                stop();
                vm.bind('person', function (ev, newVal, oldVal) {
                    ok(false, 'person attribute should not change');
                });
                var frag = template(vm);
                equal(vm.attr('person'), 'Brian', 'Person is still set');
                afterMutation(function () {
                    people.push('Brian');
                    afterMutation(function () {
                        var select = frag.firstChild;
                        ok(select.lastChild.selected, 'New child should be selected');
                        start();
                    });
                });
            });
            test('one-way <select> bindings keep value if options are replaced (#1762)', function () {
                var countries = [
                    {
                        code: 'MX',
                        countryName: 'MEXICO'
                    },
                    {
                        code: 'US',
                        countryName: 'USA'
                    }
                ];
                var data = new CanMap({
                    countryCode: 'US',
                    countries: countries
                });
                var template = stache('<select {$value}="countryCode">' + '{{#countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/countries}}' + '</select>');
                var frag = template(data);
                var select = frag.firstChild;
                stop();
                afterMutation(function () {
                    data.attr('countries').replace([]);
                    afterMutation(function () {
                        data.attr('countries').replace(countries);
                        equal(data.attr('countryCode'), 'US', 'country kept as USA');
                        afterMutation(function () {
                            ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                        });
                        start();
                    });
                });
            });
            test('one-way <select> bindings keep value if options are replaced - each (#1762)', function () {
                var countries = [
                    {
                        code: 'MX',
                        countryName: 'MEXICO'
                    },
                    {
                        code: 'US',
                        countryName: 'USA'
                    }
                ];
                var data = new CanMap({
                    countryCode: 'US',
                    countries: countries
                });
                var template = stache('<select {$value}="countryCode">' + '{{#each countries}}' + '<option value="{{code}}">{{countryName}}</option>' + '{{/each}}' + '</select>');
                var frag = template(data);
                var select = frag.firstChild;
                stop();
                afterMutation(function () {
                    data.attr('countries').replace([]);
                    afterMutation(function () {
                        data.attr('countries').replace(countries);
                        equal(data.attr('countryCode'), 'US', 'country kept as USA');
                        afterMutation(function () {
                            ok(select.getElementsByTagName('option')[1].selected, 'USA still selected');
                        });
                        start();
                    });
                });
            });
            test('@function reference to child (#2116)', function () {
                expect(2);
                var template = stache('<foo-bar {@child}="@parent"></foo-bar>');
                MockComponent.extend({
                    tag: 'foo-bar',
                    viewModel: {
                        method: function () {
                            ok(false, 'should not be called');
                        }
                    }
                });
                var VM = CanMap.extend({
                    parent: function () {
                        ok(false, 'should not be called');
                    }
                });
                var vm = new VM({});
                var frag = template(vm);
                equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
                template = stache('<foo-bar {^@method}="@vmMethod"></foo-bar>');
                vm = new VM({});
                template(vm);
                ok(typeof vm.attr('vmMethod') === 'function', 'parent export function');
            });
            test('setter only gets called once (#2117)', function () {
                expect(1);
                var VM = CanMap.extend({
                    __set: function (prop, val) {
                        if (prop === 'bar') {
                            equal(val, 'BAR');
                        }
                        return CanMap.prototype.__set.apply(this, arguments);
                    }
                });
                MockComponent.extend({
                    tag: 'foo-bar',
                    viewModel: VM
                });
                var template = stache('<foo-bar {bar}="bar"/>');
                template(new CanMap({ bar: 'BAR' }));
            });
            test('function reference to child binding (#2116)', function () {
                expect(2);
                var template = stache('<foo-bar {child}="@parent"></foo-bar>');
                MockComponent.extend({
                    tag: 'foo-bar',
                    viewModel: {}
                });
                var VM = CanMap.extend({});
                var vm = new VM({});
                var frag = template(vm);
                vm.attr('parent', function () {
                    ok(false, 'should not be called');
                });
                equal(typeof canViewModel(frag.firstChild).attr('child'), 'function', 'to child binding');
                template = stache('<foo-bar {^@method}="vmMethod"></foo-bar>');
                vm = new VM({});
                frag = template(vm);
                canViewModel(frag.firstChild).attr('method', function () {
                    ok(false, 'method should not be called');
                });
                equal(typeof vm.attr('vmMethod'), 'function', 'parent export function');
            });
            test('backtrack path in to-parent bindings (#2132)', function () {
                MockComponent.extend({
                    tag: 'parent-export',
                    viewModel: { value: 'VALUE' }
                });
                var template = stache('{{#innerMap}}<parent-export {^value}=\'../parentValue\'/>{{/innerMap}}');
                var data = new CanMap({ innerMap: {} });
                template(data);
                equal(data.attr('parentValue'), 'VALUE', 'set on correct context');
                equal(data.attr('innerMap.parentValue'), undefined, 'nothing on innerMap');
            });
            test('two-way binding with empty strings (#2147)', function () {
                var template = stache('<select {($value)}=\'val\'>' + '<option value="">Loading...</option>' + '<option>Empty...</option>' + '</select>');
                var map = new CanMap({
                    foo: true,
                    val: ''
                });
                var frag = template(map);
                afterMutation(function () {
                    equal(frag.firstChild.value, '', 'is an empty string');
                    if (isRealDocument()) {
                        equal(frag.firstChild.selectedIndex, 0, 'empty strings are bound');
                    }
                    start();
                });
                stop();
            });
            test('double render with batched / unbatched events (#2223)', function () {
                var template = stache('{{#page}}{{doLog}}<input {($value)}=\'notAHelper\'/>{{/page}}');
                var appVM = new CanMap();
                var logCalls = 0;
                stache.registerHelper('doLog', function () {
                    logCalls++;
                });
                template(appVM);
                canBatch.start();
                appVM.attr('page', true);
                canBatch.stop();
                appVM.attr('notAHelper', 'bar');
                stop();
                afterMutation(function () {
                    start();
                    equal(logCalls, 1, 'input rendered the right number of times');
                });
            });
            test('Child bindings updated before parent (#2252)', function () {
                var template = stache('{{#eq page \'view\'}}<child-binder {page}=\'page\'/>{{/eq}}');
                MockComponent.extend({
                    tag: 'child-binder',
                    template: stache('<span/>'),
                    viewModel: {
                        __set: function (prop, val) {
                            if (prop === 'page') {
                                equal(val, 'view', 'value should not be edit');
                            }
                            return CanMap.prototype.__set.apply(this, arguments);
                        }
                    }
                });
                var vm = new CanMap({ page: 'view' });
                template(vm);
                canBatch.start();
                vm.attr('page', 'edit');
                canBatch.stop();
            });
            test('can-value memory leak (#2270)', function () {
                var template = stache('<div><input can-value="foo"></div>');
                var vm = new CanMap({ foo: '' });
                var frag = template(vm);
                var ta = this.fixture;
                domMutate.appendChild.call(ta, frag);
                stop();
                afterMutation(function () {
                    domMutate.removeChild.call(ta, ta.firstChild);
                    afterMutation(function () {
                        var checkLifecycleBindings = function () {
                            if (vm.__bindEvents._lifecycleBindings === 0) {
                                equal(vm.__bindEvents._lifecycleBindings, 0, 'no bindings');
                                start();
                            } else {
                                setTimeout(checkLifecycleBindings, 10);
                            }
                        };
                        checkLifecycleBindings();
                    });
                });
            });
            test('converters work (#2299)', function () {
                stache.registerHelper('numberToString', function (newVal, source) {
                    if (newVal instanceof stacheExpression.SetIdentifier) {
                        source(newVal.value === '' ? null : +newVal.value);
                    } else {
                        source = newVal;
                        return source() + '';
                    }
                });
                var template = stache('<input {($value)}="numberToString(~age)">');
                var map = new CanMap({ age: 25 });
                var frag = template(map);
                equal(frag.firstChild.value, '25');
                equal(map.attr('age'), 25);
                map.attr('age', 33);
                equal(frag.firstChild.value, '33');
                equal(map.attr('age'), 33);
                frag.firstChild.value = '1';
                canEvent.trigger.call(frag.firstChild, 'change');
                stop();
                afterMutation(function () {
                    start();
                    equal(frag.firstChild.value, '1');
                    equal(map.attr('age'), 1);
                });
            });
            test('Multi-select empty string works(#1263)', function () {
                var data = {
                    isMultiple: 1,
                    isSelect: 1,
                    name: 'attribute_ 0',
                    options: [
                        {
                            label: 'empty',
                            value: ''
                        },
                        {
                            label: 'zero',
                            value: 0
                        },
                        {
                            label: 'one',
                            value: 1
                        },
                        {
                            label: 'two',
                            value: 2
                        },
                        {
                            label: 'three',
                            value: 3
                        },
                        {
                            label: 'four',
                            value: 4
                        }
                    ],
                    value: [1]
                };
                var template = stache('<select {{#if isMultiple}}multiple{{/if}} can-value=\'value\'> ' + '{{#each options}} <option value=\'{{value}}\' >{{label}}</option>{{/each}} </select>');
                var frag = template(new CanMap(data));
                equal(frag.firstChild.getElementsByTagName('option')[0].selected, false, 'The first empty value is not selected');
            });
            test('$element is wrapped with types.wrapElement', function () {
                var $ = function (element) {
                    this.element = element;
                };
                var wrapElement = types.wrapElement, unwrapElement = types.unwrapElement;
                types.wrapElement = function (element) {
                    return new $(element);
                };
                types.unwrapElement = function (object) {
                    return object.element;
                };
                var template = stache('<button ($click)=\'doSomething($element)\'>Clicky</button>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (element) {
                        types.wrapElement = wrapElement;
                        types.unwrapElement = unwrapElement;
                        ok(element instanceof $);
                    }
                });
                var button = template(new MyMap()).firstChild;
                canEvent.trigger.call(button, 'click');
            });
            testHelpers.dev.devOnlyTest('No warn on id=\'{{foo}}\' or class=\'{{bar}}\' expressions', function () {
                delete viewCallbacks._tags['special-attrs'];
                MockComponent.extend({
                    tag: 'special-attrs',
                    viewModel: {
                        foo: 'skippy',
                        baz: 'xyzzy'
                    }
                });
                var teardown = testHelpers.dev.willWarn(/special-attrs/);
                stache('<special-attrs id=\'{{foo}}\' class=\'{{baz}}\'></special-attrs>')({
                    foo: 'bar',
                    baz: 'quux'
                });
                stache('<special-attrs id=\'foo\' class=\'baz\'></special-attrs>')({
                    foo: 'bar',
                    baz: 'quux'
                });
                equal(teardown(), 0, 'dev.warn should not be called');
                teardown = testHelpers.dev.willWarn(/special-attrs/);
                stache('<special-attrs id=\'{foo}\' class=\'{baz}\'></special-attrs>')({
                    foo: 'bar',
                    baz: 'quux'
                });
                equal(teardown(), 0, 'dev.warn was called');
            });
            test('one-way pass computes to components with ~', function (assert) {
                expect(7);
                MockComponent.extend({ tag: 'foo-bar' });
                var baseVm = new CanMap({ foo: 'bar' });
                this.fixture.appendChild(stache('<foo-bar {compute}="~foo"></foo-bar>')(baseVm));
                var vm = canViewModel(this.fixture.firstChild);
                ok(vm.attr('compute')[canSymbol.for('can.getValue')], 'observable returned');
                equal(vm.attr('compute')(), 'bar', 'Compute has correct value');
                canReflect.onValue(vm.attr('compute'), function () {
                    ok(true, 'Change handler called');
                });
                baseVm.attr('foo', 'quux');
                equal(vm.attr('compute')(), 'quux', 'Compute updates');
                vm.attr('compute')('xyzzy');
                equal(baseVm.attr('foo'), 'quux', 'Compute does not update the other direction');
                vm.attr('compute', 'notACompute');
                baseVm.attr('foo', 'thud');
                equal(vm.attr('compute')(), 'thud', 'Back to being a compute');
            });
            test('special values get called', function (assert) {
                assert.expect(2);
                var done = assert.async(1);
                MockComponent.extend({
                    tag: 'ref-syntax',
                    template: stache('<input ($change)="%scope.attr(\'*foo\', $element.value)">'),
                    viewModel: new CanMap({
                        method: function () {
                            assert.ok(true, 'method called');
                            done();
                        }
                    })
                });
                var template = stache('<ref-syntax ($inserted)="%viewModel.method()"></ref-syntax>');
                var frag = template({});
                domMutate.appendChild.call(this.fixture, frag);
                stop();
                afterMutation(function () {
                    var input = doc.getElementsByTagName('input')[0];
                    input.value = 'bar';
                    canEvent.trigger.call(input, 'change');
                    var scope = domData.get.call(this.fixture.firstChild).shadowScope;
                    assert.equal(scope.get('*foo'), 'bar', 'Reference attribute set');
                    start();
                }.bind(this));
            });
            test('%arguments gives the event arguments', function () {
                var template = stache('<button ($click)=\'doSomething(%event, %arguments)\'>Default Args</button>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (ev, args) {
                        equal(args[0], ev, 'default arg is ev');
                    }
                });
                var frag = template(new MyMap());
                var button = frag.firstChild;
                canEvent.trigger.call(button, 'click');
            });
            testHelpers.dev.devOnlyTest('Warning happens when changing the map that a to-parent binding points to.', function () {
                var step1 = { 'baz': 'quux' };
                var overwrite = { 'plonk': 'waldo' };
                var useCanMap = true;
                delete viewCallbacks._tags['merge-warn-test'];
                MockComponent.extend({
                    tag: 'merge-warn-test',
                    viewModel: function () {
                        if (useCanMap) {
                            return new CanMap({ 'foo': {} });
                        } else {
                            return new DefaultMap({ 'foo': {} });
                        }
                    }
                });
                var template = stache('<merge-warn-test {(foo)}=\'bar\'/>');
                var viewModel = { bar: new DefaultMap(step1) };
                this.fixture.appendChild(template(viewModel));
                var teardown = testHelpers.dev.willWarn('can-view-scope: Merging data into "bar" because its parent is non-observable');
                canViewModel(this.fixture.firstChild).attr('foo', overwrite);
                equal(teardown(), 1, 'first message was logged');
                deepEqual(viewModel.bar.get(), overwrite, 'sanity check: parent binding set (default map -> default map)');
                this.fixture.removeChild(this.fixture.firstChild);
                useCanMap = false;
                viewModel.bar = new CanMap(step1);
                this.fixture.appendChild(template(viewModel));
                teardown = testHelpers.dev.willWarn('can-view-scope: Merging data into "bar" because its parent is non-observable');
                canViewModel(this.fixture.firstChild).set('foo', overwrite);
                equal(teardown(), 1, 'first message was logged');
                deepEqual(viewModel.bar.attr(), overwrite, 'sanity check: parent binding set (can map -> default map)');
            });
            test('updates happen on two-way even when one binding is satisfied', function () {
                var template = stache('<input {($value)}="firstName"/>');
                var ViewModel = DefaultMap.extend({
                    firstName: {
                        set: function (newValue) {
                            if (newValue) {
                                return newValue.toLowerCase();
                            }
                        }
                    }
                });
                var viewModel = new ViewModel({ firstName: 'jeffrey' });
                stop();
                var frag = template(viewModel);
                domMutate.appendChild.call(this.fixture, frag);
                equal(this.fixture.firstChild.value, 'jeffrey');
                this.fixture.firstChild.value = 'JEFFREY';
                canEvent.trigger.call(this.fixture.firstChild, 'change');
                equal(this.fixture.firstChild.value, 'jeffrey');
                afterMutation(start);
            });
            test('updates happen on changed two-way even when one binding is satisfied', function () {
                stop();
                var template = stache('<input {($value)}="{{bindValue}}"/>');
                var ViewModel = DefaultMap.extend({
                    firstName: {
                        set: function (newValue) {
                            if (newValue) {
                                return newValue.toLowerCase();
                            }
                        }
                    },
                    lastName: {
                        set: function (newValue) {
                            if (newValue) {
                                return newValue.toLowerCase();
                            }
                        }
                    },
                    bindValue: 'string'
                });
                var viewModel = new ViewModel({
                    firstName: 'Jeffrey',
                    lastName: 'King',
                    bindValue: 'firstName'
                });
                var frag = template(viewModel);
                domMutate.appendChild.call(this.fixture, frag);
                afterMutation(function () {
                    equal(this.fixture.firstChild.value, 'jeffrey');
                    viewModel.bindValue = 'lastName';
                    afterMutation(function () {
                        equal(this.fixture.firstChild.value, 'king');
                        this.fixture.firstChild.value = 'KING';
                        canEvent.trigger.call(this.fixture.firstChild, 'change');
                        equal(this.fixture.firstChild.value, 'king');
                        start();
                    }.bind(this));
                }.bind(this));
            });
            test('plain data objects should work for checkboxes [can-value] (#161)', function () {
                var template = stache([
                    '<input type="checkbox" name="status1" value="yes" can-value="status" can-true-value="yes"/>',
                    '<input type="checkbox" name="status2" value="no" can-value="status" can-true-value="no"/>'
                ].join(''));
                var object = { status: 'yes' };
                var fragment = template(object);
                domMutate.appendChild.call(this.fixture, fragment);
                var yesInput = this.fixture.firstChild;
                var noInput = this.fixture.firstChild.nextSibling;
                equal(yesInput.checked, true, 'yes-checkbox is initially checked');
                equal(noInput.checked, false, 'no-checkbox is initially not checked');
            });
            test('plain data objects should work for radio buttons [can-value] (#161)', function () {
                var template = stache([
                    '<input type="radio" name="status" value="no" can-value="status"/>',
                    '<input type="radio" name="status" value="yes" can-value="status"/>'
                ].join(''));
                var object = { status: 'no' };
                var fragment = template(object);
                domMutate.appendChild.call(this.fixture, fragment);
                var noInput = this.fixture.firstChild;
                var yesInput = this.fixture.firstChild.nextSibling;
                equal(noInput.checked, true, 'no-radio is initially checked');
                equal(yesInput.checked, false, 'yes-radio is initially not checked');
            });
            testHelpers.dev.devOnlyTest('warning when binding to non-existing value (#136) (#119)', function () {
                var teardown = testHelpers.dev.willWarn('This element does not have a viewModel. (Attempting to bind `target:vm:bind="source.bar"`)');
                var template = stache('<div target:vm:bind=\'source.bar\'/>');
                var map = new CanMap({ source: { foo: 'foo' } });
                template(map);
                equal(teardown(), 1, 'warning was given');
            });
            test('changing a scope property calls registered stache helper', function () {
                expect(1);
                stop();
                var scope = new CanMap({ test: 'testval' });
                MockComponent.extend({
                    tag: 'test-component',
                    viewModel: scope,
                    template: stache('<span>Hello world</span>')
                });
                stache.registerHelper('propChangeEventStacheHelper', function () {
                    start();
                    ok(true, 'helper called');
                });
                var template = stache('<test-component (test)="propChangeEventStacheHelper" />');
                template(new CanMap({}));
                scope.attr('test', 'changed');
            });
            test('changing a scope property calls registered stache helper\'s returned function', function () {
                expect(1);
                stop();
                var scope = new CanMap({ test: 'testval' });
                MockComponent.extend({
                    tag: 'test-component',
                    viewModel: scope,
                    template: stache('<span>Hello world</span>')
                });
                stache.registerHelper('propChangeEventStacheHelper', function () {
                    return function () {
                        start();
                        ok(true, 'helper\'s returned function called');
                    };
                });
                var template = stache('<test-component (test)="propChangeEventStacheHelper" />');
                template(new CanMap({}));
                scope.attr('test', 'changed');
            });
            test('scope method called when scope property changes (#197)', function () {
                stop();
                expect(1);
                MockComponent.extend({ tag: 'view-model-able' });
                var template = stache('<view-model-able (. prop)=\'someMethod\'/>');
                var map = new CanMap({
                    prop: 'Mercury',
                    someMethod: function (scope, el, ev, newVal) {
                        start();
                        ok(true, 'method called');
                    }
                });
                template(map);
                map.attr('prop', 'Venus');
            });
            test('scope method called when nested scope property changes (#216)', function () {
                stop();
                expect(1);
                var template = stache('<div (./prop nestedprop)=\'someMethod\'/>');
                var map = new CanMap({
                    prop: new CanMap({ nestedprop: 'Mercury' }),
                    someMethod: function (scope, el, ev, newVal) {
                        start();
                        ok(true, 'method called');
                    }
                });
                template(map);
                map.attr('prop.nestedprop', 'Venus');
            });
            test('change event handler set up when binding on radiochange (#206)', function () {
                stop();
                var template = stache('<input type="radio" {($checked)}="attending" />');
                var map = new CanMap({
                    attending: function () {
                        start();
                        ok(true, 'method called');
                    }
                });
                var frag = template(map);
                var input = frag.firstChild;
                input.checked = true;
                canEvent.trigger.call(input, 'change');
                QUnit.equal(map.attr('attending'), true, 'now it is true');
            });
            test('call expressions work (#208)', function () {
                expect(2);
                stache.registerHelper('addTwo', function (arg) {
                    return arg + 2;
                });
                stache.registerHelper('helperWithArgs', function (arg) {
                    QUnit.equal(arg, 3, 'got the helper');
                    ok(true, 'helper called');
                });
                var template = stache('<p ($click)=\'helperWithArgs(addTwo(arg))\'></p>');
                var frag = template({ arg: 1 });
                this.fixture.appendChild(frag);
                var p0 = this.fixture.getElementsByTagName('p')[0];
                canEvent.trigger.call(p0, 'click');
            });
            testHelpers.dev.devOnlyTest('warn when using bracket syntax for data bindings (#294)', function () {
                var vm = new CanMap();
                var teardown = testHelpers.dev.willWarn(/{\$foo} is deprecated. Use foo:from instead/);
                stache('<div {$foo}="bar"/>')(vm);
                equal(teardown(), 1, '{$foo} should warn');
                teardown = testHelpers.dev.willWarn(/foo:from/);
                stache('<div foo:from="bar"/>')(vm);
                equal(teardown(), 0, 'foo:from should not warn');
                teardown = testHelpers.dev.willWarn(/{\^\$foo} is deprecated. Use foo:to instead/);
                stache('<div {^$foo}="bar"/>')(vm);
                equal(teardown(), 1, '{^$foo} should warn');
                teardown = testHelpers.dev.willWarn(/foo:to/);
                stache('<div foo:to="bar"/>')(vm);
                equal(teardown(), 0, 'foo:to should not warn');
                teardown = testHelpers.dev.willWarn(/{\(\$foo\)} is deprecated. Use foo:bind instead/);
                stache('<div {($foo)}="bar"/>')(vm);
                equal(teardown(), 1, '{($foo)} should warn');
                teardown = testHelpers.dev.willWarn(/foo:bind/);
                stache('<div foo:bind="bar"/>')(vm);
                equal(teardown(), 0, 'foo:bind should not warn');
            });
            testHelpers.dev.devOnlyTest('warn when using bracket syntax for event bindings (#294)', function () {
                var vm = new CanMap();
                var teardown = testHelpers.dev.willWarn(/\(\$foo\) is deprecated. Use on:foo instead/);
                stache('<div ($foo)="bar"/>')(vm);
                equal(teardown(), 1, '($foo) should warn');
                teardown = testHelpers.dev.willWarn(/on:foo/);
                stache('<div on:foo="bar"/>')(vm);
                equal(teardown(), 0, 'on:foo should not warn');
                teardown = testHelpers.dev.willWarn(/\(foo baz\) is deprecated. Use on:baz:by:foo instead/);
                stache('<div (foo baz)="bar"/>')(vm);
                equal(teardown(), 1, '(foo baz) should warn');
                teardown = testHelpers.dev.willWarn(/on:baz:by:foo/);
                stache('<div on:baz:by:foo="bar"/>')(vm);
                equal(teardown(), 0, 'on:baz:by:foo should not warn');
            });
            QUnit.test('legacy events should bind when using a plain object', function () {
                var flip = false;
                var template = stache('<div {{#if test}}($foo)="log()"{{/if}}>Test</div>');
                var frag = template({
                    log: function () {
                        flip = true;
                    },
                    test: true
                });
                canEvent.trigger.call(frag.firstChild, 'foo');
                QUnit.ok(flip, 'Plain object method successfully called');
            });
            QUnit.test('events should bind when using a plain object', function () {
                var flip = false;
                var template = stache('<div {{#if test}}on:foo="log()"{{/if}}>Test</div>');
                var frag = template({
                    log: function () {
                        flip = true;
                    },
                    test: true
                });
                canEvent.trigger.call(frag.firstChild, 'foo');
                QUnit.ok(flip, 'Plain object method successfully called');
            });
            testHelpers.dev.devOnlyTest('warn when using reference shorthand', function () {
                MockComponent.extend({ tag: 'reference-export' });
                var template = stache('<reference-export *reference-export/>');
                var teardown = testHelpers.dev.willWarn('*reference-export shorthand is deprecated. Use this:to="scope.vars.referenceExport" instead.');
                template({});
                QUnit.equal(teardown(), 1, 'warning shown');
            });
            QUnit.test('element is on the scope', function () {
                var template = stache('<input on:click="doSomething(scope.element)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (element) {
                        equal(element, frag.firstChild);
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
            });
            QUnit.test('event is on the scope', function () {
                var template = stache('<input on:click="doSomething(scope.event)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (event) {
                        equal(frag.firstChild, event.target);
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
            });
            QUnit.test('viewModel is on the scope', function () {
                var template = stache('<input on:click="doSomething(scope.viewModel)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                        ok(viewModel instanceof CanMap);
                    }
                });
                var map = new MyMap();
                var frag = template(map);
                canEvent.trigger.call(frag.firstChild, 'click');
            });
            QUnit.test('arguments is on the scope', function () {
                var template = stache('<input on:click="doSomething(scope.arguments)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (args) {
                        equal(args[0].target, frag.firstChild);
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
            });
            testHelpers.dev.devOnlyTest('using %element shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/%element is deprecated\. Use scope.element instead\./);
                var template = stache('<input on:click="doSomething(%element)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            testHelpers.dev.devOnlyTest('using %event shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/%event is deprecated\. Use scope.event instead\./);
                var template = stache('<input on:click="doSomething(%event)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            testHelpers.dev.devOnlyTest('using %viewModel shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/%viewModel is deprecated\. Use scope.viewModel instead\./);
                var template = stache('<input on:click="doSomething(%viewModel)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            testHelpers.dev.devOnlyTest('using %arguments shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/%arguments is deprecated\. Use scope.arguments instead\./);
                var template = stache('<input on:click="doSomething(%arguments)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            testHelpers.dev.devOnlyTest('using @element shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/@element is deprecated\. Use scope.element instead\./);
                var template = stache('<input on:click="doSomething(@element)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            testHelpers.dev.devOnlyTest('using @event shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/@event is deprecated\. Use scope.event instead\./);
                var template = stache('<input on:click="doSomething(@event)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            testHelpers.dev.devOnlyTest('using @viewModel shows a deprecation warning', function () {
                var teardown = testHelpers.dev.willWarn(/@viewModel is deprecated\. Use scope.viewModel instead\./);
                var template = stache('<input on:click="doSomething(@viewModel)"/>');
                var MyMap = DefaultMap.extend({
                    doSomething: function (viewModel) {
                    }
                });
                var frag = template(new MyMap());
                canEvent.trigger.call(frag.firstChild, 'click');
                equal(teardown(), 1);
            });
            test('set string on the viewModel', function () {
                expect(2);
                var ViewModel = DefaultMap.extend({
                    foo: {
                        type: 'string',
                        set: function (val) {
                            equal(val, 'bar');
                        }
                    },
                    baz: {
                        type: 'string',
                        set: function (val) {
                            equal(val, 'qux');
                        }
                    }
                });
                MockComponent.extend({
                    tag: 'test-elem',
                    viewModel: ViewModel
                });
                var template = stache('<test-elem foo:from="\'bar\'" baz:from="\'qux\'"/>');
                template();
            });
            testHelpers.dev.devOnlyTest('warn about using attributes to set values on the viewModel', function () {
                var teardown = testHelpers.dev.willWarn('file.stache:1: foo="bar" is deprecated. Use foo:from="\'bar\'" instead.');
                var ViewModel = DefaultMap.extend({ foo: { type: 'string' } });
                MockComponent.extend({
                    tag: 'test-elem',
                    viewModel: ViewModel
                });
                var template = stache('file.stache', '<test-elem foo="bar" baz="qux"/>');
                template();
                equal(teardown(), 1);
            });
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-stache-converters@3.3.1#can-stache-converters*/
define('can-stache-converters@3.3.1#can-stache-converters', [
    'require',
    'exports',
    'module',
    'can-stache',
    'can-util/js/string-to-any/string-to-any',
    'can-util/js/make-array/make-array',
    'can-util/js/dev/dev',
    'can-stache-bindings'
], function (require, exports, module) {
    var stache = require('can-stache');
    var stringToAny = require('can-util/js/string-to-any/string-to-any');
    var makeArray = require('can-util/js/make-array/make-array');
    var dev = require('can-util/js/dev/dev');
    require('can-stache-bindings');
    stache.registerConverter('boolean-to-inList', {
        get: function (item, list) {
            if (!list) {
                return false;
            } else {
                return list.indexOf(item) !== -1;
            }
        },
        set: function (newVal, item, list) {
            if (!list) {
                return;
            }
            if (!newVal) {
                var idx = list.indexOf(item);
                if (idx !== -1) {
                    list.splice(idx, 1);
                }
            } else {
                list.push(item);
            }
        }
    });
    stache.registerConverter('string-to-any', {
        get: function (compute) {
            return '' + compute();
        },
        set: function (newVal, compute) {
            var converted = stringToAny(newVal);
            compute(converted);
        }
    });
    stache.registerConverter('not', {
        get: function (compute) {
            return !compute();
        },
        set: function (newVal, compute) {
            compute(!newVal);
        }
    });
    stache.registerConverter('index-to-selected', {
        get: function (item, list) {
            var val = item.isComputed ? item() : item;
            var idx = list.indexOf(val);
            return idx;
        },
        set: function (idx, item, list) {
            var newVal = list[idx];
            if (item.isComputed) {
                item(newVal);
            }
        }
    });
    stache.registerConverter('selected-to-index', {
        get: function (idx, list) {
            var val = idx.isComputed ? idx() : idx;
            var item = list[val];
            return item;
        },
        set: function (item, idx, list) {
            var newVal = list.indexOf(item);
            if (idx.isComputed) {
                idx(newVal);
            }
        }
    });
    stache.registerConverter('either-or', {
        get: function (chosen, a, b) {
            var matchA = a === chosen();
            var matchB = b === chosen();
            if (!matchA && !matchB) {
                return;
            } else {
                return matchA;
            }
        },
        set: function (newVal, chosen, a, b) {
            chosen(newVal ? a : b);
        }
    });
    stache.registerConverter('equal', {
        get: function () {
            var args = makeArray(arguments);
            if (args.length > 1) {
                var comparer = args.pop();
                return args.every(function (compute) {
                    return (compute && compute.isComputed ? compute() : compute) === comparer;
                });
            }
        },
        set: function () {
            var args = makeArray(arguments);
            if (args.length > 2) {
                var b = args.shift();
                var comparer = args.pop();
                if (b) {
                    for (var i = 0; i < args.length; i++) {
                        args[i](comparer);
                    }
                }
            }
        }
    });
});
/*can-stache-converters@3.3.1#test/boolean-to-inList_test*/
define('can-stache-converters@3.3.1#test/boolean-to-inList_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('boolean-to-inList', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    QUnit.test('Works with checkboxes', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(input.checked, 'it is initially checked');
        QUnit.equal(map.list.indexOf(2), 1, 'two is in the list');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(2), -1, 'No longer in the list');
        map.item = 3;
        QUnit.ok(input.checked, '3 is in the list');
        map.item = 5;
        QUnit.ok(!input.checked, '5 is not in the list');
        map.list.push(5);
        QUnit.ok(input.checked, 'Now 5 is in the list');
        map.item = 6;
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(6), 3, 'pushed into the list');
    });
    QUnit.test('If there is no list, treated as false', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'boolean-to-inList(item, list)\' />');
        var map = new DefineMap({
            item: 2,
            list: undefined
        });
        var frag = template(map);
        var input = frag.firstChild;
        QUnit.ok(!input.checked, 'not checked because there is no list');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.ok(true, 'no errors thrown');
    });
    QUnit.test('works with radio buttons', function () {
        var template = stache('<form><input type=\'radio\' name=\'name\' value=\'Matthew\' {($checked)}=\'boolean-to-inList("Matthew", names)\' /><input type=\'radio\' name=\'name\' value=\'Wilbur\' {($checked)}=\'boolean-to-inList("Wilbur", names)\' /></form>');
        var map = new DefineMap({ names: ['Wilbur'] });
        var frag = template(map);
        var radioOne = frag.firstChild.firstChild;
        var radioTwo = radioOne.nextSibling;
        this.fixture.appendChild(frag);
        QUnit.equal(radioOne.checked, false, 'Matthew not checked');
        QUnit.equal(radioTwo.checked, true, 'Wilbur is checked');
        radioOne.checked = true;
        canEvent.trigger.call(radioOne, 'change');
        QUnit.equal(radioOne.checked, true, 'Matthew is checked');
        QUnit.equal(radioTwo.checked, false, 'Wilbur is not checked');
    });
});
/*can-stache-converters@3.3.1#test/index-to-selected_test*/
define('can-stache-converters@3.3.1#test/index-to-selected_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('index-to-selected');
    QUnit.test('chooses select option by the index from a list', function () {
        var template = stache('<select {($value)}="index-to-selected(~person, people)"><option value="none"></option>{{#each people}}<option value="{{%index}}">{{name}}</option>{{/each}}</select>');
        var map = new DefineMap({
            person: 'Anne',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var select = template(map).firstChild;
        QUnit.equal(select.value, 1, 'initially set to the first value');
        select.value = 2;
        canEvent.trigger.call(select, 'change');
        QUnit.equal(map.person, 'Wilbur', 'now it is me');
        map.person = map.people.item(0);
        QUnit.equal(select.value, 0, 'set back');
        select.value = 'none';
        canEvent.trigger.call(select, 'change');
        QUnit.equal(map.person, undefined, 'now undefined because not in the list');
    });
});
/*can-stache-converters@3.3.1#test/selected-to-index_test*/
define('can-stache-converters@3.3.1#test/selected-to-index_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('selected-to-index');
    QUnit.test('sets index by the value from a list', function () {
        var template = stache('<input value:bind="selected-to-index(~index, people)" />');
        var map = new DefineMap({
            index: '1',
            people: [
                'Matthew',
                'Anne',
                'Wilbur'
            ]
        });
        var input = template(map).firstChild;
        QUnit.equal(input.value, 'Anne', 'initially set to the first value');
        input.value = 'Wilbur';
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.index, '2', 'now it is me');
        map.index = '0';
        QUnit.equal(input.value, 'Matthew', 'set back');
        input.value = 'none';
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.index, -1, 'now -1 because not in the list');
    });
});
/*can-stache-converters@3.3.1#test/string-to-any_test*/
define('can-stache-converters@3.3.1#test/string-to-any_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('string-to-any');
    QUnit.test('Works on all the types', function () {
        var types = {
            '22.3': 22.3,
            'foo': 'foo',
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity,
            'NaN': {
                expected: NaN,
                equalityTest: function (a) {
                    return isNaN(a);
                }
            }
        };
        var defaultEquality = function (a, b) {
            return a === b;
        };
        each(types, function (expected, type) {
            var template = stache('<select {($value)}="string-to-any(~val)"><option value="test">test</option><option value="' + type + '">' + type + '</option></select>');
            var map = new DefineMap({ val: 'test' });
            var frag = template(map);
            var select = frag.firstChild;
            var option = select.firstChild.nextSibling;
            var equality = defaultEquality;
            if (expected != null && expected.equalityTest) {
                equality = expected.equalityTest;
                expected = expected.expected;
            }
            select.value = type;
            canEvent.trigger.call(select, 'change');
            QUnit.ok(equality(map.val, expected), 'map\'s value updated to: ' + type);
            map.val = 'test';
            map.val = expected;
            QUnit.equal(select.value, type, 'select\'s value updated to: ' + type);
        });
    });
});
/*can-stache-converters@3.3.1#test/not_test*/
define('can-stache-converters@3.3.1#test/not_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('not');
    QUnit.test('saves the inverse of the selected value', function () {
        var template = stache('<input type="checkbox" {($checked)}="not(~val)" />');
        var map = new DefineMap({ val: true });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        map.val = false;
        QUnit.equal(input.checked, true, 'true because map val is false');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.val, true, 'map is now true because checkbox is false');
    });
    QUnit.test('works with boolean-to-inList', function () {
        var template = stache('<input type=\'checkbox\' {($checked)}=\'not(~boolean-to-inList(item, list))\' />');
        var map = new DefineMap({
            item: 2,
            list: new DefineList([
                1,
                2,
                3
            ])
        });
        var input = template(map).firstChild;
        QUnit.equal(input.checked, false, 'not checked because it is in the list');
        map.item = 4;
        QUnit.equal(input.checked, true, 'checked because not in the list');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.list.indexOf(4), 3, 'it was pushed into the list');
        map.list.splice(3, 1);
        QUnit.equal(input.checked, true, 'now it\'s checked because not in the list');
    });
});
/*can-stache-converters@3.3.1#test/either-or_test*/
define('can-stache-converters@3.3.1#test/either-or_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-compute',
    'can-define/map/map',
    'can-stache',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var QUnit = require('steal-qunit');
    QUnit.module('either-or');
    QUnit.test('can bind to a checkbox', function () {
        var renderer = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, "Star Trek", "Star Wars")\' />');
        var map = new DefineMap({ pref: 'Star Trek' });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, true, 'initial value is right');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref, 'Star Wars', 'changed because input changed');
        map.pref = 'Star Trek';
        QUnit.equal(input.checked, true, 'changed because map changed');
    });
    QUnit.test('initial null selection', function () {
        var renderer = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, "Yes", "No")\' />');
        var map = new DefineMap({ pref: null });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref, 'No', 'null value changed to falsey case by checkbox');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref, 'Yes', 'map updated because check was checked');
    });
    QUnit.test('initial undefined selection', function () {
        var renderer = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, "Yes", "No")\' />');
        var map = new DefineMap({ pref: undefined });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref, 'No', 'undefined value changed to falsey case by checkbox');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref, 'Yes', 'map updated because check was checked');
    });
    QUnit.test('initial no match selection', function () {
        var renderer = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, "Yes", "No")\' />');
        var map = new DefineMap({ pref: 'fubar' });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref, 'No', 'fubar value changed to falsey case by checkbox');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref, 'Yes', 'map updated because check was checked');
    });
    QUnit.test('supports computes', function () {
        var renderer = stache('<input type=\'checkbox\' {($checked)}=\'either-or(~pref, a, b)\' />');
        var map = new DefineMap({
            pref: compute('Maybe'),
            a: compute('Yes'),
            b: compute('No')
        });
        var input = renderer(map).firstChild;
        QUnit.equal(input.checked, false, 'checkbox is unchecked');
        QUnit.strictEqual(map.pref(), 'No', 'chosen value changed to falsey case by checkbox');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref(), 'Yes', 'map updated because check was checked');
        input.checked = false;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(map.pref(), 'No', 'map updated because check was unchecked');
    });
});
/*can-stache-converters@3.3.1#test/equal_test*/
define('can-stache-converters@3.3.1#test/equal_test', [
    'require',
    'exports',
    'module',
    'can-stache-converters',
    'can-event',
    'can-compute',
    'can-define/list/list',
    'can-define/map/map',
    'can-stache',
    'can-util/js/each/each',
    'steal-qunit'
], function (require, exports, module) {
    require('can-stache-converters');
    var canEvent = require('can-event');
    var compute = require('can-compute');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var stache = require('can-stache');
    var each = require('can-util/js/each/each');
    var QUnit = require('steal-qunit');
    QUnit.module('equal');
    QUnit.test('Basics works', function () {
        var template = stache('<input type="radio" {($checked)}="equal(~attending, \'yes\'" /><input type="radio" {($checked)}="equal(~attending, \'no\'" />');
        var attending = compute('yes');
        var yes = template({ attending: attending }).firstChild, no = yes.nextSibling;
        QUnit.equal(yes.checked, true, 'initially a yes');
        QUnit.equal(no.checked, false, 'initially unchecked');
        attending('no');
        QUnit.equal(yes.checked, false, 'now not checked');
        QUnit.equal(no.checked, true, 'now checked');
        yes.checked = true;
        canEvent.trigger.call(yes, 'change');
        QUnit.equal(attending(), 'yes', 'now it is yes');
        QUnit.equal(yes.checked, true, 'yes is checked');
        QUnit.equal(no.checked, false, 'no is unchecked');
    });
    QUnit.test('Allows one-way binding when passed a non-compute as the first argument', function () {
        var template = stache('<input type="radio" {($checked)}="equal(attending, true)" />');
        var attending = compute(false);
        var input = template({ attending: attending }).firstChild;
        QUnit.equal(input.checked, false, 'initially false');
        attending(true);
        QUnit.equal(input.checked, true, 'can be changed to true');
        input.checked = false;
        QUnit.equal(attending(), true, 'does not change compute');
    });
    QUnit.test('Allow multiple expressions to be passed in', function () {
        var template = stache('<input type="radio" {($checked)}="equal(~foo, ~bar, true)" />');
        var foo = compute(true);
        var bar = compute(false);
        var input = template({
            foo: foo,
            bar: bar
        }).firstChild;
        QUnit.equal(input.checked, false, 'initially unchecked');
        bar(true);
        QUnit.equal(input.checked, true, 'now checked');
        foo(false);
        bar(false);
        QUnit.equal(input.checked, false, 'now unchecked');
        input.checked = true;
        canEvent.trigger.call(input, 'change');
        QUnit.equal(foo(), true, 'computed foo value is true');
        QUnit.equal(bar(), true, 'computed bar value is true');
    });
});
/*can-stache-converters@3.3.1#test/test*/
define('can-stache-converters@3.3.1#test/test', [
    'require',
    'exports',
    'module',
    './boolean-to-inList_test',
    './index-to-selected_test',
    './selected-to-index_test',
    './string-to-any_test',
    './not_test',
    './either-or_test',
    './equal_test'
], function (require, exports, module) {
    require('./boolean-to-inList_test');
    require('./index-to-selected_test');
    require('./selected-to-index_test');
    require('./string-to-any_test');
    require('./not_test');
    require('./either-or_test');
    require('./equal_test');
});
/*can-deparam@1.2.0#can-deparam*/
define('can-deparam@1.2.0#can-deparam', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    var digitTest = /^\d+$/, keyBreaker = /([^\[\]]+)|(\[\])/g, paramTest = /([^?#]*)(#.*)?$/, entityRegex = /%([^0-9a-f][0-9a-f]|[0-9a-f][^0-9a-f]|[^0-9a-f][^0-9a-f])/i, prep = function (str) {
            str = str.replace(/\+/g, ' ');
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return decodeURIComponent(str.replace(entityRegex, function (match, hex) {
                    return '%25' + hex;
                }));
            }
        };
    function isArrayLikeName(name) {
        return digitTest.test(name) || name === '[]';
    }
    function idenity(value) {
        return value;
    }
    module.exports = namespace.deparam = function (params, valueDeserializer) {
        valueDeserializer = valueDeserializer || idenity;
        var data = {}, pairs, lastPart;
        if (params && paramTest.test(params)) {
            pairs = params.split('&');
            pairs.forEach(function (pair) {
                var parts = pair.split('='), key = prep(parts.shift()), value = prep(parts.join('=')), current = data;
                if (key) {
                    parts = key.match(keyBreaker);
                    for (var j = 0, l = parts.length - 1; j < l; j++) {
                        var currentName = parts[j], nextName = parts[j + 1], currentIsArray = isArrayLikeName(currentName) && current instanceof Array;
                        if (!current[currentName]) {
                            if (currentIsArray) {
                                current.push(isArrayLikeName(nextName) ? [] : {});
                            } else {
                                current[currentName] = isArrayLikeName(nextName) ? [] : {};
                            }
                        }
                        if (currentIsArray) {
                            current = current[current.length - 1];
                        } else {
                            current = current[currentName];
                        }
                    }
                    lastPart = parts.pop();
                    if (isArrayLikeName(lastPart)) {
                        current.push(valueDeserializer(value));
                    } else {
                        current[lastPart] = valueDeserializer(value);
                    }
                }
            });
        }
        return data;
    };
});
/*can-string-to-any@1.2.0#can-string-to-any*/
define('can-string-to-any@1.2.0#can-string-to-any', function (require, exports, module) {
    'use strict';
    module.exports = function (str) {
        switch (str) {
        case 'NaN':
        case 'Infinity':
            return +str;
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        case 'true':
        case 'false':
            return str === 'true';
        default:
            var val = +str;
            if (!isNaN(val)) {
                return val;
            } else {
                return str;
            }
        }
    };
});
/*can-deparam@1.2.0#can-deparam-test*/
define('can-deparam@1.2.0#can-deparam-test', [
    'require',
    'exports',
    'module',
    './can-deparam',
    'steal-qunit',
    'can-string-to-any'
], function (require, exports, module) {
    var deparam = require('./can-deparam');
    var QUnit = require('steal-qunit');
    var stringToAny = require('can-string-to-any');
    QUnit.module('can-deparam');
    test('Nested deparam', function () {
        var data = deparam('a[b]=1&a[c]=2');
        equal(data.a.b, 1);
        equal(data.a.c, 2);
        data = deparam('a[]=1&a[]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
        data = deparam('a[b][]=1&a[b][]=2');
        equal(data.a.b[0], 1);
        equal(data.a.b[1], 2);
        data = deparam('a[0]=1&a[1]=2');
        equal(data.a[0], 1);
        equal(data.a[1], 2);
    });
    test('Remaining ampersand', function () {
        var data = deparam('a[b]=1&a[c]=2&');
        deepEqual(data, {
            a: {
                b: '1',
                c: '2'
            }
        });
    });
    test('Invalid encoding', function () {
        var data = deparam('foo=%0g');
        deepEqual(data, { foo: '%0g' });
    });
    QUnit.test('deparam deep', function () {
        QUnit.deepEqual(deparam('age[or][][lte]=5&age[or][]=null'), {
            age: {
                or: [
                    { lte: '5' },
                    'null'
                ]
            }
        });
    });
    QUnit.test('takes value deserializer', function () {
        QUnit.deepEqual(deparam('age[or][][lte]=5&age[or][]=null', stringToAny), {
            age: {
                or: [
                    { lte: 5 },
                    null
                ]
            }
        });
        QUnit.deepEqual(deparam('undefined=undefined&null=null&NaN=NaN&true=true&false=false', stringToAny), {
            'undefined': undefined,
            'null': null,
            'NaN': NaN,
            'true': true,
            'false': false
        });
    });
});
/*can-param@1.1.0#can-param*/
define('can-param@1.1.0#can-param', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    function buildParam(prefix, obj, add) {
        if (Array.isArray(obj)) {
            for (var i = 0, l = obj.length; i < l; ++i) {
                buildParam(prefix + '[]', obj[i], add);
            }
        } else if (obj && typeof obj === 'object') {
            for (var name in obj) {
                buildParam(prefix + '[' + name + ']', obj[name], add);
            }
        } else {
            add(prefix, obj);
        }
    }
    module.exports = namespace.param = function param(object) {
        var pairs = [], add = function (key, value) {
                pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
            };
        for (var name in object) {
            buildParam(name, object[name], add);
        }
        return pairs.join('&').replace(/%20/g, '+');
    };
});
/*can-param@1.1.0#can-param-test*/
define('can-param@1.1.0#can-param-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-param'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var param = require('./can-param');
    QUnit.module('can-param');
    QUnit.test('can-param', function () {
        QUnit.deepEqual(param({
            foo: 'bar',
            baz: 'zed'
        }), 'foo=bar&baz=zed', 'Regular object');
        QUnit.deepEqual(param({ foo: { bar: 'baz' } }), encodeURI('foo[bar]=baz'), 'Nested object');
        QUnit.deepEqual(param({
            foo: [
                'bar',
                'baz'
            ]
        }), encodeURI('foo[]=bar&foo[]=baz'), 'Nested array');
        QUnit.deepEqual(param({ foo: 'bar & baz' }), 'foo=bar+%26+baz', 'Spec chars values');
        QUnit.equal(param({
            age: {
                or: [
                    { lte: 5 },
                    null
                ]
            }
        }), encodeURI('age[or][][lte]=5&age[or][]=null'));
        QUnit.deepEqual(param({
            'undefined': undefined,
            'null': null,
            'NaN': NaN,
            'true': true,
            'false': false
        }), 'undefined=undefined&null=null&NaN=NaN&true=true&false=false', 'true, false, undefined, etc');
    });
});
/*can-event@3.7.7#batch/batch-test*/
define('can-event@3.7.7#batch/batch-test', [
    'require',
    'exports',
    'module',
    'can-event',
    'steal-qunit',
    'can-util/js/assign/assign',
    'can-event/batch/batch',
    'can-event/async/async',
    'can-util/js/dev/dev',
    'can-util/dom/events/delegate/delegate'
], function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var canBatch = require('can-event/batch/batch');
    var eventAsync = require('can-event/async/async');
    var canDev = require('can-util/js/dev/dev');
    require('can-util/dom/events/delegate/delegate');
    QUnit.module('can-event/batch', {
        setup: function () {
            eventAsync.sync();
        },
        teardown: function () {
            eventAsync.async();
        }
    });
    QUnit.test('basics', function () {
        var collecting;
        var secondFired = false;
        var obj = assign({}, canEvent);
        obj.on('first', function (ev, arg1, arg2) {
            QUnit.equal(collecting.number, ev.batchNum, 'same batch num');
            QUnit.equal(canBatch.dispatching(), collecting, 'dispatching old collecting');
            QUnit.equal(arg1, 1, 'first arg');
            QUnit.equal(arg2, 2, 'second arg');
            collecting = canBatch.collecting();
            QUnit.ok(!collecting, 'not collecting b/c we\'re not in a batch yet');
            obj.dispatch('second');
            collecting = canBatch.collecting();
            QUnit.ok(collecting, 'forced a batch');
            QUnit.equal(secondFired, false, 'don\'t fire yet, put in next batch');
        });
        obj.on('second', function (ev) {
            secondFired = true;
            QUnit.equal(collecting.number, ev.batchNum, 'same batch num on second');
            QUnit.equal(canBatch.dispatching(), collecting, 'dispatching second collecting');
        });
        canBatch.start();
        collecting = canBatch.collecting();
        QUnit.ok(canBatch.collecting(), 'is collecting');
        obj.dispatch('first', [
            1,
            2
        ]);
        canBatch.stop();
    });
    QUnit.test('events are queued and dispatched without .stop being called (#14)', function () {
        var obj = assign({}, canEvent);
        obj.on('first', function (ev) {
            obj.dispatch('second');
            QUnit.ok(canBatch.collecting() !== canBatch.dispatching(), 'dispatching is not collecting');
        });
        obj.on('second', function () {
            QUnit.ok(canBatch.collecting() !== canBatch.dispatching(), 'dispatching is not collecting');
            QUnit.ok(true, 'called');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
    test('Everything is part of a batch', function () {
        var obj = {};
        assign(obj, canEvent);
        obj.on('foo', function (ev) {
            ok(ev.batchNum);
        });
        obj.dispatch('foo');
    });
    test('batch.queue callback called after events fired in the same fn', function () {
        var obj = assign({}, canEvent);
        var thirdCalled = false, firstBatch;
        obj.on('third', function (ev) {
            QUnit.equal(firstBatch, ev.batchNum, 'third is right');
            thirdCalled = true;
        });
        obj.on('first', function (ev) {
            equal(typeof ev.batchNum, 'number', 'got a batch number');
            firstBatch = ev.batchNum;
            canBatch.queue([
                function () {
                    equal(thirdCalled, true, 'third called before this');
                },
                null,
                []
            ]);
            obj.dispatch({
                type: 'third',
                batchNum: ev.batchNum
            });
        });
        obj.dispatch('first');
    });
    QUnit.test('afterPreviousEvents doesn\'t run after all collecting previous events (#17)', function () {
        var obj = assign({}, canEvent);
        var afterPreviousEventsFired = false;
        obj.on('first', function () {
            QUnit.ok(!afterPreviousEventsFired, 'after previous should fire after');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.afterPreviousEvents(function () {
            afterPreviousEventsFired = true;
        });
        canBatch.stop();
    });
    QUnit.test('flushing works (#18)', function () {
        var firstFired, secondFired, thirdFired;
        var obj = assign({}, canEvent);
        obj.on('first', function () {
            canBatch.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        canBatch.start();
        obj.dispatch('first');
        obj.dispatch('second');
        obj.dispatch('third');
        canBatch.stop();
    });
    QUnit.test('flush is non enumerable (#18)', 1, function () {
        QUnit.equal(canEvent.flush, canBatch.flush);
        for (var prop in canEvent) {
            if (prop === 'flush') {
                ok(false, 'flush is enumerable');
            }
        }
    });
    QUnit.test('flushing a future batch (#18)', function () {
        var firstFired, secondFired, thirdFired;
        var obj = assign({}, canEvent);
        obj.on('first', function () {
            canBatch.start();
            obj.dispatch('second');
            obj.dispatch('third');
            canBatch.stop();
            canBatch.flush();
            QUnit.ok(firstFired, 'first fired');
            QUnit.ok(secondFired, 'second fired');
            QUnit.ok(thirdFired, 'third fired');
        });
        obj.on('first', function () {
            firstFired = true;
        });
        obj.on('second', function () {
            secondFired = true;
        });
        obj.on('third', function () {
            thirdFired = true;
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
    QUnit.test('batchNumber is set by .dispatch that has a batchNum', function () {
        var obj = assign({}, canEvent);
        var firstBN;
        obj.on('first', function (ev) {
            firstBN = ev.batchNum;
            canEvent.flush();
            obj.dispatch({
                type: 'second',
                batchNum: ev.batchNum
            });
        });
        obj.on('second', function (ev) {
            QUnit.equal(firstBN, ev.batchNum, 'batch num set');
            QUnit.equal(canBatch.batchNum, ev.batchNum, 'batch num set');
        });
        canBatch.start();
        obj.dispatch('first');
        canBatch.stop();
    });
    QUnit.test('debounce - basics (#3)', function () {
        var obj = assign({}, canEvent);
        obj.on('event', canBatch.debounce(function (event, arg1, arg2) {
            ok(true, 'event run');
            equal(arg1, 3);
            equal(arg2, 4);
        }));
        expect(3);
        canBatch.start();
        obj.dispatch('event', [
            1,
            2
        ]);
        obj.dispatch('event', [
            3,
            4
        ]);
        canBatch.stop();
    });
    QUnit.test('debounce - is not inherited', function () {
        var obj = assign({}, canEvent);
        ok(!obj.debounce);
    });
    QUnit.test('debounce - handles multiple batches', function () {
        var obj = assign({}, canEvent);
        var count = 0;
        obj.on('event', canBatch.debounce(function (event, arg1, arg2) {
            ok(true, 'event run');
            count++;
            if (count === 1) {
                equal(arg1, 7);
                equal(arg2, 8);
            }
            if (count === 2) {
                equal(arg1, 10);
                equal(arg2, 11);
            }
        }));
        expect(6);
        canBatch.start();
        obj.dispatch('event', [
            5,
            6
        ]);
        obj.dispatch('event', [
            7,
            8
        ]);
        canBatch.stop();
        canBatch.start();
        obj.dispatch('event', [
            9,
            0
        ]);
        obj.dispatch('event', [
            10,
            11
        ]);
        canBatch.stop();
    });
    QUnit.test('debounce - only triggers if event was triggered', function () {
        var obj = assign({}, canEvent);
        obj.on('event', canBatch.debounce(function () {
            ok(true, 'event run');
        }));
        expect(1);
        canBatch.start();
        obj.dispatch('event');
        obj.dispatch('event');
        canBatch.stop();
        canBatch.start();
        obj.dispatch('foo');
        obj.dispatch('foo');
        canBatch.stop();
    });
    if (System.env.indexOf('production') < 0) {
        QUnit.test('missing stop should logs a Warning Timeout', function () {
            var oldMissingStopWarningTimeout = canBatch.missingStopWarningTimeout;
            canBatch.missingStopWarningTimeout = 1000;
            var oldWarn = canDev.warn;
            QUnit.stop();
            canDev.warn = function () {
                QUnit.start();
                ok(true, 'received warning');
                canBatch.missingStopWarningTimeout = oldMissingStopWarningTimeout;
                canDev.warn = oldWarn;
                canBatch.stop();
            };
            var obj = assign({}, canEvent);
            canBatch.start();
            obj.dispatch('anEvent');
        });
    }
});
/*can-event@3.7.7#async/async-test*/
define('can-event@3.7.7#async/async-test', [
    'require',
    'exports',
    'module',
    'can-event',
    'steal-qunit',
    'can-util/js/assign/assign',
    'can-event/async/async',
    'can-util/dom/events/delegate/delegate'
], function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/assign');
    var eventAsync = require('can-event/async/async');
    require('can-util/dom/events/delegate/delegate');
    QUnit.module('can-event/async', {
        setup: function () {
            eventAsync.async();
        },
        teardown: function () {
            eventAsync.sync();
        }
    });
    QUnit.asyncTest('removing an event handler, nothing called', 5, function () {
        var obj = {};
        assign(obj, canEvent);
        var handler = function (ev, arg1, arg2) {
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.addEventListener('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        obj.removeEventListener('foo', handler);
        obj.addEventListener('foo', function () {
            QUnit.ok(true, 'this handler called');
            QUnit.start();
        });
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    QUnit.asyncTest('removing an event handler, nothing called with on', 6, function () {
        var obj = {};
        assign(obj, canEvent);
        var dispatched = false;
        var handler = function (ev, arg1, arg2) {
            ok(dispatched, 'dispatched should be async');
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.on('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        dispatched = true;
        obj.off('foo', handler);
        obj.on('foo', function () {
            QUnit.ok(true, 'this handler called');
            QUnit.start();
        });
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    QUnit.asyncTest('async with same batch number is fired right away', function () {
        var obj = assign({}, canEvent);
        var secondDispatched = false;
        var secondBatchNum;
        obj.on('first', function (ev) {
            obj.dispatch({
                batchNum: ev.batchNum,
                type: 'second'
            });
            equal(secondBatchNum, ev.batchNum, 'batch nums the same');
            ok(secondDispatched, 'dispatched event immediately');
            QUnit.start();
        });
        obj.on('second', function (ev) {
            secondDispatched = true;
            secondBatchNum = ev.batchNum;
        });
        obj.dispatch('first');
    });
});
/*can-event@3.7.7#lifecycle/lifecycle-test*/
define('can-event@3.7.7#lifecycle/lifecycle-test', [
    'require',
    'exports',
    'module',
    'can-event',
    'can-event/lifecycle/lifecycle',
    'steal-qunit'
], function (require, exports, module) {
    var canEvent = require('can-event');
    var lifecycle = require('can-event/lifecycle/lifecycle');
    var QUnit = require('steal-qunit');
    QUnit.module('can-event/lifecycle');
    QUnit.test('Mixins your addEventListener', function () {
        var proto = {
            addEventListener: function () {
                QUnit.ok(true, 'this was called');
            },
            removeEventListener: function () {
            }
        };
        var obj = lifecycle(proto);
        obj.addEventListener('Hello world!');
    });
    QUnit.test('Mixins your removeEventListener', function () {
        var proto = {
            removeEventListener: function () {
                QUnit.ok(true, 'this was called');
            },
            addEventListener: canEvent.addEventListener
        };
        var obj = lifecycle(proto);
        obj.addEventListener('some-event');
        obj.removeEventListener('some-event');
    });
    QUnit.test('Calls _eventSetup on the first addEventListener', function () {
        var proto = {
            _eventSetup: function () {
                QUnit.ok(true, 'eventSetup was called');
            },
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var obj = lifecycle(proto);
        obj.addEventListener('Something');
    });
    QUnit.test('Calls _eventTeardown on the last removeEventListener', function () {
        var proto = {
            _eventTeardown: function () {
                QUnit.ok(true, 'eventTeardown was called');
            },
            addEventListener: canEvent.addEventListener,
            removeEventListener: canEvent.removeEventListener
        };
        var obj = lifecycle(proto);
        var handler = function () {
        };
        obj.addEventListener('Something', handler);
        obj.removeEventListener('Something', handler);
    });
    QUnit.test('removeEventListener removes all events when no arguments are passed', function () {
        expect(2);
        var obj = {
            removeEventListener: canEvent.removeEventListener,
            addEventListener: canEvent.addEventListener,
            _eventTeardown: function () {
                ok(true, 'eventTeardown called');
            },
            _eventSetup: function () {
                ok(true, 'eventSetup called');
            }
        };
        lifecycle(obj);
        obj.addEventListener('first', function () {
            return;
        });
        obj.addEventListener('second', function () {
            return;
        });
        obj.removeEventListener();
    });
});
/*can-event@3.7.7#can-event_test*/
define('can-event@3.7.7#can-event_test', [
    'require',
    'exports',
    'module',
    'can-event',
    'steal-qunit',
    'can-util/js/assign/',
    'can-util/js/dev/dev',
    'can-util/dom/events/delegate/',
    'can-event/batch/batch-test',
    'can-event/async/async-test',
    'can-event/lifecycle/lifecycle-test'
], function (require, exports, module) {
    var canEvent = require('can-event');
    var QUnit = require('steal-qunit');
    var assign = require('can-util/js/assign/');
    var canDev = require('can-util/js/dev/dev');
    require('can-util/dom/events/delegate/');
    require('can-event/batch/batch-test');
    require('can-event/async/async-test');
    require('can-event/lifecycle/lifecycle-test');
    QUnit.module('can-event');
    test('basics', 4, function () {
        var obj = {
            addEvent: canEvent.addEvent,
            removeEvent: canEvent.removeEvent,
            dispatch: canEvent.dispatch
        };
        var handler = function (ev, arg1, arg2) {
            ok(true, 'foo called');
            equal(ev.type, 'foo');
            equal(arg1, 1, 'one');
            equal(arg2, 2, 'two');
        };
        obj.addEvent('foo', handler);
        obj.dispatch({ type: 'foo' }, [
            1,
            2
        ]);
        obj.removeEvent('foo', handler);
        obj.dispatch({
            type: 'foo',
            data: [
                1,
                2
            ]
        });
    });
    test('listenTo and stopListening', 9, function () {
        var parent = {
            bind: canEvent.bind,
            unbind: canEvent.unbind,
            listenTo: canEvent.listenTo,
            stopListening: canEvent.stopListening
        };
        var child1 = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        var child2 = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        var change1WithId = 0;
        parent.listenTo(child1, 'change', function () {
            change1WithId++;
            if (change1WithId === 1) {
                ok(true, 'child 1 handler with id called');
            } else {
                ok(false, 'child 1 handler with id should only be called once');
            }
        });
        child1.bind('change', function () {
            ok(true, 'child 1 handler without id called');
        });
        var foo1WidthId = 0;
        parent.listenTo(child1, 'foo', function () {
            foo1WidthId++;
            if (foo1WidthId === 1) {
                ok(true, 'child 1 foo handler with id called');
            } else {
                ok(false, 'child 1 foo handler should not be called twice');
            }
        });
        (function () {
            var okToCall = true;
            parent.listenTo(child2, 'change', function () {
                ok(okToCall, 'child 2 handler with id called');
                okToCall = false;
            });
        }());
        child2.bind('change', function () {
            ok(true, 'child 2 handler without id called');
        });
        parent.listenTo(child2, 'foo', function () {
            ok(true, 'child 2 foo handler with id called');
        });
        canEvent.trigger.call(child1, 'change');
        canEvent.trigger.call(child1, 'foo');
        canEvent.trigger.call(child2, 'change');
        canEvent.trigger.call(child2, 'foo');
        parent.stopListening(child1);
        parent.stopListening(child2, 'change');
        canEvent.trigger.call(child1, 'change');
        canEvent.trigger.call(child1, 'foo');
        canEvent.trigger.call(child2, 'change');
        canEvent.trigger.call(child2, 'foo');
    });
    test('stopListening on something you\'ve never listened to ', function () {
        var parent = {
            bind: canEvent.bind,
            unbind: canEvent.unbind,
            listenTo: canEvent.listenTo,
            stopListening: canEvent.stopListening
        };
        var child = {
            bind: canEvent.bind,
            unbind: canEvent.unbind
        };
        parent.listenTo({}, 'foo');
        parent.stopListening(child, 'change');
        ok(true, 'did not error');
    });
    test('bind on document', function () {
        var called = false, handler = function () {
                called = true;
            };
        canEvent.on.call(document, 'click', handler);
        canEvent.trigger.call(document, 'click');
        ok(called, 'got click event');
        ok(true, 'did not error');
        canEvent.off.call(document, 'click', handler);
    });
    test('delegate on document', function () {
        var called = false, handler = function () {
                called = true;
            };
        canEvent.delegate.call(document, 'click', 'body', handler);
        canEvent.trigger.call(document.body, 'click');
        ok(called, 'got click event');
        ok(true, 'did not error');
        canEvent.undelegate.call(document, 'body', 'click', handler);
    });
    test('One will listen to an event once, then unbind', function () {
        var obj = {}, count = 0, mixin = 0;
        canEvent.one.call(obj, 'action', function () {
            count++;
        });
        canEvent.dispatch.call(obj, 'action');
        canEvent.dispatch.call(obj, 'action');
        canEvent.dispatch.call(obj, 'action');
        equal(count, 1, 'one should only fire a handler once (direct)');
        assign(obj, canEvent);
        obj.one('mixin', function () {
            mixin++;
        });
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        obj.dispatch('mixin');
        equal(mixin, 1, 'one should only fire a handler once (mixin)');
    });
    test('Test events using mixin', function () {
        var obj = {}, fn;
        assign(obj, canEvent);
        var bindCount = 0;
        obj.bind('action', fn = function () {
            ++bindCount;
        });
        obj.dispatch('action');
        obj.dispatch('action');
        obj.unbind('action', fn);
        obj.dispatch('action');
        equal(bindCount, 2, 'action triggered twice');
        bindCount = 0;
        obj.one('action', fn = function () {
            ++bindCount;
        });
        obj.dispatch('action');
        obj.dispatch('action');
        equal(bindCount, 1, 'action triggered only once, then unbound');
        var other = {};
        bindCount = 0;
        assign(other, canEvent);
        obj.listenTo(other, 'action', fn = function () {
            ++bindCount;
        });
        other.dispatch('action');
        other.dispatch('action');
        obj.stopListening(other, 'action', fn);
        other.dispatch('action');
        equal(bindCount, 2, 'action triggered twice');
    });
    QUnit.test('makeHandlerArgs and handlers are non enumerable', 0, function () {
        for (var prop in canEvent) {
            if (prop === 'makeHandlerArgs' || prop === 'handlers') {
                ok(false, prop + ' is enumerable');
            }
        }
    });
    QUnit.test('removeEventListener removes all events when no arguments are passed', function () {
        expect(2);
        var obj = {};
        assign(obj, canEvent);
        obj.addEventListener('first', function () {
            ok(true, 'first event listener called');
        });
        obj.addEventListener('second', function () {
            ok(true, 'second event listener called');
        });
        obj.dispatch({ type: 'first' });
        obj.dispatch({ type: 'second' });
        obj.removeEventListener();
        obj.dispatch({ type: 'first' });
        obj.dispatch({ type: 'second' });
    });
    QUnit.test('removeEventListener removes all handlers for specified event when no handlers are passed', function () {
        expect(2);
        var obj = {};
        assign(obj, canEvent);
        obj.addEventListener('first', function () {
            ok(true, 'first handler called');
        });
        obj.addEventListener('first', function () {
            ok(true, 'second handler called');
        });
        obj.dispatch({ type: 'first' });
        obj.removeEventListener('first');
        obj.dispatch({ type: 'first' });
    });
    QUnit.test('removeEventListener removes a specific handler for an event', function () {
        expect(5);
        var obj = {};
        assign(obj, canEvent);
        var firstHandler = function () {
            ok(true, 'first handler called');
        };
        var secondHandler = function () {
            ok(true, 'second handler called');
        };
        var thirdHandler = function () {
            ok(true, 'third handler called');
        };
        obj.addEventListener('first', firstHandler);
        obj.addEventListener('first', secondHandler);
        obj.addEventListener('first', thirdHandler);
        obj.dispatch({ type: 'first' });
        obj.removeEventListener('first', secondHandler);
        obj.dispatch({ type: 'first' });
    });
});
/*can@3.14.0#event/event_test*/
define('can@3.14.0#event/event_test', [
    'require',
    'exports',
    'module',
    'can-event/can-event_test'
], function (require, exports, module) {
    require('can-event/can-event_test');
});
/*can-util@3.14.0#js/set-not-enumerable/set-not-enumerable*/
define('can-util@3.14.0#js/set-not-enumerable/set-not-enumerable', function (require, exports, module) {
    'use strict';
    module.exports = function (obj, prop, value) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value
        });
    };
});
/*can-util@3.14.0#js/assign-non-enumerable/assign-non-enumerable*/
define('can-util@3.14.0#js/assign-non-enumerable/assign-non-enumerable', [
    'require',
    'exports',
    'module',
    '../set-not-enumerable/set-not-enumerable'
], function (require, exports, module) {
    'use strict';
    var setNotEnumerable = require('../set-not-enumerable/set-not-enumerable');
    module.exports = function (d, s) {
        for (var prop in s) {
            setNotEnumerable(d, prop, s[prop]);
        }
        return d;
    };
});
/*qunitjs@2.4.1#qunit/qunit*/
(function (global$1) {
    'use strict';
    global$1 = 'default' in global$1 ? global$1['default'] : global$1;
    var window = global$1.window;
    var self$1 = global$1.self;
    var console = global$1.console;
    var setTimeout = global$1.setTimeout;
    var clearTimeout = global$1.clearTimeout;
    var document = window && window.document;
    var navigator = window && window.navigator;
    var localSessionStorage = function () {
        var x = 'qunit-test-string';
        try {
            global$1.sessionStorage.setItem(x, x);
            global$1.sessionStorage.removeItem(x);
            return global$1.sessionStorage;
        } catch (e) {
            return undefined;
        }
    }();
    var _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj;
    };
    var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    };
    var createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                    descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function (Constructor, protoProps, staticProps) {
            if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
                defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
                arr2[i] = arr[i];
            return arr2;
        } else {
            return Array.from(arr);
        }
    };
    var toString = Object.prototype.toString;
    var hasOwn = Object.prototype.hasOwnProperty;
    var now = Date.now || function () {
        return new Date().getTime();
    };
    var defined = {
        document: window && window.document !== undefined,
        setTimeout: setTimeout !== undefined
    };
    function diff(a, b) {
        var i, j, result = a.slice();
        for (i = 0; i < result.length; i++) {
            for (j = 0; j < b.length; j++) {
                if (result[i] === b[j]) {
                    result.splice(i, 1);
                    i--;
                    break;
                }
            }
        }
        return result;
    }
    function inArray(elem, array) {
        return array.indexOf(elem) !== -1;
    }
    function objectValues(obj) {
        var key, val, vals = is('array', obj) ? [] : {};
        for (key in obj) {
            if (hasOwn.call(obj, key)) {
                val = obj[key];
                vals[key] = val === Object(val) ? objectValues(val) : val;
            }
        }
        return vals;
    }
    function extend(a, b, undefOnly) {
        for (var prop in b) {
            if (hasOwn.call(b, prop)) {
                if (b[prop] === undefined) {
                    delete a[prop];
                } else if (!(undefOnly && typeof a[prop] !== 'undefined')) {
                    a[prop] = b[prop];
                }
            }
        }
        return a;
    }
    function objectType(obj) {
        if (typeof obj === 'undefined') {
            return 'undefined';
        }
        if (obj === null) {
            return 'null';
        }
        var match = toString.call(obj).match(/^\[object\s(.*)\]$/), type = match && match[1];
        switch (type) {
        case 'Number':
            if (isNaN(obj)) {
                return 'nan';
            }
            return 'number';
        case 'String':
        case 'Boolean':
        case 'Array':
        case 'Set':
        case 'Map':
        case 'Date':
        case 'RegExp':
        case 'Function':
        case 'Symbol':
            return type.toLowerCase();
        default:
            return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
        }
    }
    function is(type, obj) {
        return objectType(obj) === type;
    }
    function generateHash(module, testName) {
        var str = module + '\x1C' + testName;
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash = (hash << 5) - hash + str.charCodeAt(i);
            hash |= 0;
        }
        var hex = (4294967296 + hash).toString(16);
        if (hex.length < 8) {
            hex = '0000000' + hex;
        }
        return hex.slice(-8);
    }
    var equiv = function () {
        var pairs = [];
        var getProto = Object.getPrototypeOf || function (obj) {
            return obj.__proto__;
        };
        function useStrictEquality(a, b) {
            if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
                a = a.valueOf();
            }
            if ((typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object') {
                b = b.valueOf();
            }
            return a === b;
        }
        function compareConstructors(a, b) {
            var protoA = getProto(a);
            var protoB = getProto(b);
            if (a.constructor === b.constructor) {
                return true;
            }
            if (protoA && protoA.constructor === null) {
                protoA = null;
            }
            if (protoB && protoB.constructor === null) {
                protoB = null;
            }
            if (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {
                return true;
            }
            return false;
        }
        function getRegExpFlags(regexp) {
            return 'flags' in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];
        }
        function isContainer(val) {
            return [
                'object',
                'array',
                'map',
                'set'
            ].indexOf(objectType(val)) !== -1;
        }
        function breadthFirstCompareChild(a, b) {
            if (a === b) {
                return true;
            }
            if (!isContainer(a)) {
                return typeEquiv(a, b);
            }
            if (pairs.every(function (pair) {
                    return pair.a !== a || pair.b !== b;
                })) {
                pairs.push({
                    a: a,
                    b: b
                });
            }
            return true;
        }
        var callbacks = {
            'string': useStrictEquality,
            'boolean': useStrictEquality,
            'number': useStrictEquality,
            'null': useStrictEquality,
            'undefined': useStrictEquality,
            'symbol': useStrictEquality,
            'date': useStrictEquality,
            'nan': function nan() {
                return true;
            },
            'regexp': function regexp(a, b) {
                return a.source === b.source && getRegExpFlags(a) === getRegExpFlags(b);
            },
            'function': function _function() {
                return false;
            },
            'array': function array(a, b) {
                var i, len;
                len = a.length;
                if (len !== b.length) {
                    return false;
                }
                for (i = 0; i < len; i++) {
                    if (!breadthFirstCompareChild(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            },
            'set': function set$$1(a, b) {
                var innerEq, outerEq = true;
                if (a.size !== b.size) {
                    return false;
                }
                a.forEach(function (aVal) {
                    if (!outerEq) {
                        return;
                    }
                    innerEq = false;
                    b.forEach(function (bVal) {
                        var parentPairs;
                        if (innerEq) {
                            return;
                        }
                        parentPairs = pairs;
                        if (innerEquiv(bVal, aVal)) {
                            innerEq = true;
                        }
                        pairs = parentPairs;
                    });
                    if (!innerEq) {
                        outerEq = false;
                    }
                });
                return outerEq;
            },
            'map': function map(a, b) {
                var innerEq, outerEq = true;
                if (a.size !== b.size) {
                    return false;
                }
                a.forEach(function (aVal, aKey) {
                    if (!outerEq) {
                        return;
                    }
                    innerEq = false;
                    b.forEach(function (bVal, bKey) {
                        var parentPairs;
                        if (innerEq) {
                            return;
                        }
                        parentPairs = pairs;
                        if (innerEquiv([
                                bVal,
                                bKey
                            ], [
                                aVal,
                                aKey
                            ])) {
                            innerEq = true;
                        }
                        pairs = parentPairs;
                    });
                    if (!innerEq) {
                        outerEq = false;
                    }
                });
                return outerEq;
            },
            'object': function object(a, b) {
                var i, aProperties = [], bProperties = [];
                if (compareConstructors(a, b) === false) {
                    return false;
                }
                for (i in a) {
                    aProperties.push(i);
                    if (a.constructor !== Object && typeof a.constructor !== 'undefined' && typeof a[i] === 'function' && typeof b[i] === 'function' && a[i].toString() === b[i].toString()) {
                        continue;
                    }
                    if (!breadthFirstCompareChild(a[i], b[i])) {
                        return false;
                    }
                }
                for (i in b) {
                    bProperties.push(i);
                }
                return typeEquiv(aProperties.sort(), bProperties.sort());
            }
        };
        function typeEquiv(a, b) {
            var type = objectType(a);
            return objectType(b) === type && callbacks[type](a, b);
        }
        function innerEquiv(a, b) {
            var i, pair;
            if (arguments.length < 2) {
                return true;
            }
            pairs = [{
                    a: a,
                    b: b
                }];
            for (i = 0; i < pairs.length; i++) {
                pair = pairs[i];
                if (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {
                    return false;
                }
            }
            return arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));
        }
        return function () {
            var result = innerEquiv.apply(undefined, arguments);
            pairs.length = 0;
            return result;
        };
    }();
    var config = {
        queue: [],
        blocking: true,
        reorder: true,
        altertitle: true,
        collapse: true,
        scrolltop: true,
        maxDepth: 5,
        requireExpects: false,
        urlConfig: [],
        modules: [],
        currentModule: {
            name: '',
            tests: [],
            childModules: [],
            testsRun: 0,
            unskippedTestsRun: 0,
            hooks: {
                before: [],
                beforeEach: [],
                afterEach: [],
                after: []
            }
        },
        callbacks: {},
        storage: localSessionStorage
    };
    var globalConfig = window && window.QUnit && window.QUnit.config;
    if (window && window.QUnit && !window.QUnit.version) {
        extend(config, globalConfig);
    }
    config.modules.push(config.currentModule);
    var dump = function () {
        function quote(str) {
            return '"' + str.toString().replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
        }
        function literal(o) {
            return o + '';
        }
        function join(pre, arr, post) {
            var s = dump.separator(), base = dump.indent(), inner = dump.indent(1);
            if (arr.join) {
                arr = arr.join(',' + s + inner);
            }
            if (!arr) {
                return pre + post;
            }
            return [
                pre,
                inner + arr,
                base + post
            ].join(s);
        }
        function array(arr, stack) {
            var i = arr.length, ret = new Array(i);
            if (dump.maxDepth && dump.depth > dump.maxDepth) {
                return '[object Array]';
            }
            this.up();
            while (i--) {
                ret[i] = this.parse(arr[i], undefined, stack);
            }
            this.down();
            return join('[', ret, ']');
        }
        function isArray(obj) {
            return toString.call(obj) === '[object Array]' || typeof obj.length === 'number' && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined);
        }
        var reName = /^function (\w+)/, dump = {
                parse: function parse(obj, objType, stack) {
                    stack = stack || [];
                    var res, parser, parserType, objIndex = stack.indexOf(obj);
                    if (objIndex !== -1) {
                        return 'recursion(' + (objIndex - stack.length) + ')';
                    }
                    objType = objType || this.typeOf(obj);
                    parser = this.parsers[objType];
                    parserType = typeof parser === 'undefined' ? 'undefined' : _typeof(parser);
                    if (parserType === 'function') {
                        stack.push(obj);
                        res = parser.call(this, obj, stack);
                        stack.pop();
                        return res;
                    }
                    return parserType === 'string' ? parser : this.parsers.error;
                },
                typeOf: function typeOf(obj) {
                    var type;
                    if (obj === null) {
                        type = 'null';
                    } else if (typeof obj === 'undefined') {
                        type = 'undefined';
                    } else if (is('regexp', obj)) {
                        type = 'regexp';
                    } else if (is('date', obj)) {
                        type = 'date';
                    } else if (is('function', obj)) {
                        type = 'function';
                    } else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {
                        type = 'window';
                    } else if (obj.nodeType === 9) {
                        type = 'document';
                    } else if (obj.nodeType) {
                        type = 'node';
                    } else if (isArray(obj)) {
                        type = 'array';
                    } else if (obj.constructor === Error.prototype.constructor) {
                        type = 'error';
                    } else {
                        type = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
                    }
                    return type;
                },
                separator: function separator() {
                    if (this.multiline) {
                        return this.HTML ? '<br />' : '\n';
                    } else {
                        return this.HTML ? '&#160;' : ' ';
                    }
                },
                indent: function indent(extra) {
                    if (!this.multiline) {
                        return '';
                    }
                    var chr = this.indentChar;
                    if (this.HTML) {
                        chr = chr.replace(/\t/g, '   ').replace(/ /g, '&#160;');
                    }
                    return new Array(this.depth + (extra || 0)).join(chr);
                },
                up: function up(a) {
                    this.depth += a || 1;
                },
                down: function down(a) {
                    this.depth -= a || 1;
                },
                setParser: function setParser(name, parser) {
                    this.parsers[name] = parser;
                },
                quote: quote,
                literal: literal,
                join: join,
                depth: 1,
                maxDepth: config.maxDepth,
                parsers: {
                    window: '[Window]',
                    document: '[Document]',
                    error: function error(_error) {
                        return 'Error("' + _error.message + '")';
                    },
                    unknown: '[Unknown]',
                    'null': 'null',
                    'undefined': 'undefined',
                    'function': function _function(fn) {
                        var ret = 'function', name = 'name' in fn ? fn.name : (reName.exec(fn) || [])[1];
                        if (name) {
                            ret += ' ' + name;
                        }
                        ret += '(';
                        ret = [
                            ret,
                            dump.parse(fn, 'functionArgs'),
                            '){'
                        ].join('');
                        return join(ret, dump.parse(fn, 'functionCode'), '}');
                    },
                    array: array,
                    nodelist: array,
                    'arguments': array,
                    object: function object(map, stack) {
                        var keys, key, val, i, nonEnumerableProperties, ret = [];
                        if (dump.maxDepth && dump.depth > dump.maxDepth) {
                            return '[object Object]';
                        }
                        dump.up();
                        keys = [];
                        for (key in map) {
                            keys.push(key);
                        }
                        nonEnumerableProperties = [
                            'message',
                            'name'
                        ];
                        for (i in nonEnumerableProperties) {
                            key = nonEnumerableProperties[i];
                            if (key in map && !inArray(key, keys)) {
                                keys.push(key);
                            }
                        }
                        keys.sort();
                        for (i = 0; i < keys.length; i++) {
                            key = keys[i];
                            val = map[key];
                            ret.push(dump.parse(key, 'key') + ': ' + dump.parse(val, undefined, stack));
                        }
                        dump.down();
                        return join('{', ret, '}');
                    },
                    node: function node(_node) {
                        var len, i, val, open = dump.HTML ? '&lt;' : '<', close = dump.HTML ? '&gt;' : '>', tag = _node.nodeName.toLowerCase(), ret = open + tag, attrs = _node.attributes;
                        if (attrs) {
                            for (i = 0, len = attrs.length; i < len; i++) {
                                val = attrs[i].nodeValue;
                                if (val && val !== 'inherit') {
                                    ret += ' ' + attrs[i].nodeName + '=' + dump.parse(val, 'attribute');
                                }
                            }
                        }
                        ret += close;
                        if (_node.nodeType === 3 || _node.nodeType === 4) {
                            ret += _node.nodeValue;
                        }
                        return ret + open + '/' + tag + close;
                    },
                    functionArgs: function functionArgs(fn) {
                        var args, l = fn.length;
                        if (!l) {
                            return '';
                        }
                        args = new Array(l);
                        while (l--) {
                            args[l] = String.fromCharCode(97 + l);
                        }
                        return ' ' + args.join(', ') + ' ';
                    },
                    key: quote,
                    functionCode: '[code]',
                    attribute: quote,
                    string: quote,
                    date: quote,
                    regexp: literal,
                    number: literal,
                    'boolean': literal,
                    symbol: function symbol(sym) {
                        return sym.toString();
                    }
                },
                HTML: false,
                indentChar: '  ',
                multiline: true
            };
        return dump;
    }();
    var LISTENERS = Object.create(null);
    var SUPPORTED_EVENTS = [
        'runStart',
        'suiteStart',
        'testStart',
        'assertion',
        'testEnd',
        'suiteEnd',
        'runEnd'
    ];
    function emit(eventName, data) {
        if (objectType(eventName) !== 'string') {
            throw new TypeError('eventName must be a string when emitting an event');
        }
        var originalCallbacks = LISTENERS[eventName];
        var callbacks = originalCallbacks ? [].concat(toConsumableArray(originalCallbacks)) : [];
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](data);
        }
    }
    function on(eventName, callback) {
        if (objectType(eventName) !== 'string') {
            throw new TypeError('eventName must be a string when registering a listener');
        } else if (!inArray(eventName, SUPPORTED_EVENTS)) {
            var events = SUPPORTED_EVENTS.join(', ');
            throw new Error('"' + eventName + '" is not a valid event; must be one of: ' + events + '.');
        } else if (objectType(callback) !== 'function') {
            throw new TypeError('callback must be a function when registering a listener');
        }
        if (!LISTENERS[eventName]) {
            LISTENERS[eventName] = [];
        }
        if (!inArray(callback, LISTENERS[eventName])) {
            LISTENERS[eventName].push(callback);
        }
    }
    function registerLoggingCallbacks(obj) {
        var i, l, key, callbackNames = [
                'begin',
                'done',
                'log',
                'testStart',
                'testDone',
                'moduleStart',
                'moduleDone'
            ];
        function registerLoggingCallback(key) {
            var loggingCallback = function loggingCallback(callback) {
                if (objectType(callback) !== 'function') {
                    throw new Error('QUnit logging methods require a callback function as their first parameters.');
                }
                config.callbacks[key].push(callback);
            };
            return loggingCallback;
        }
        for (i = 0, l = callbackNames.length; i < l; i++) {
            key = callbackNames[i];
            if (objectType(config.callbacks[key]) === 'undefined') {
                config.callbacks[key] = [];
            }
            obj[key] = registerLoggingCallback(key);
        }
    }
    function runLoggingCallbacks(key, args) {
        var i, l, callbacks;
        callbacks = config.callbacks[key];
        for (i = 0, l = callbacks.length; i < l; i++) {
            callbacks[i](args);
        }
    }
    var fileName = (sourceFromStacktrace(0) || '').replace(/(:\d+)+\)?/, '').replace(/.+\//, '');
    function extractStacktrace(e, offset) {
        offset = offset === undefined ? 4 : offset;
        var stack, include, i;
        if (e && e.stack) {
            stack = e.stack.split('\n');
            if (/^error$/i.test(stack[0])) {
                stack.shift();
            }
            if (fileName) {
                include = [];
                for (i = offset; i < stack.length; i++) {
                    if (stack[i].indexOf(fileName) !== -1) {
                        break;
                    }
                    include.push(stack[i]);
                }
                if (include.length) {
                    return include.join('\n');
                }
            }
            return stack[offset];
        }
    }
    function sourceFromStacktrace(offset) {
        var error = new Error();
        if (!error.stack) {
            try {
                throw error;
            } catch (err) {
                error = err;
            }
        }
        return extractStacktrace(error, offset);
    }
    var priorityCount = 0;
    var unitSampler = void 0;
    function advance() {
        var start = now();
        config.depth = (config.depth || 0) + 1;
        while (config.queue.length && !config.blocking) {
            var elapsedTime = now() - start;
            if (!defined.setTimeout || config.updateRate <= 0 || elapsedTime < config.updateRate) {
                if (priorityCount > 0) {
                    priorityCount--;
                }
                config.queue.shift()();
            } else {
                setTimeout(advance, 13);
                break;
            }
        }
        config.depth--;
        if (!config.blocking && !config.queue.length && config.depth === 0) {
            done();
        }
    }
    function addToQueueImmediate(callback) {
        if (objectType(callback) === 'array') {
            while (callback.length) {
                addToQueueImmediate(callback.pop());
            }
            return;
        }
        config.queue.unshift(callback);
        priorityCount++;
    }
    function addToQueue(callback, prioritize, seed) {
        if (prioritize) {
            config.queue.splice(priorityCount++, 0, callback);
        } else if (seed) {
            if (!unitSampler) {
                unitSampler = unitSamplerGenerator(seed);
            }
            var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));
            config.queue.splice(priorityCount + index, 0, callback);
        } else {
            config.queue.push(callback);
        }
    }
    function unitSamplerGenerator(seed) {
        var sample = parseInt(generateHash(seed), 16) || -1;
        return function () {
            sample ^= sample << 13;
            sample ^= sample >>> 17;
            sample ^= sample << 5;
            if (sample < 0) {
                sample += 4294967296;
            }
            return sample / 4294967296;
        };
    }
    function done() {
        var storage = config.storage;
        ProcessingQueue.finished = true;
        var runtime = now() - config.started;
        var passed = config.stats.all - config.stats.bad;
        emit('runEnd', globalSuite.end(true));
        runLoggingCallbacks('done', {
            passed: passed,
            failed: config.stats.bad,
            total: config.stats.all,
            runtime: runtime
        });
        if (storage && config.stats.bad === 0) {
            for (var i = storage.length - 1; i >= 0; i--) {
                var key = storage.key(i);
                if (key.indexOf('qunit-test-') === 0) {
                    storage.removeItem(key);
                }
            }
        }
    }
    var ProcessingQueue = {
        finished: false,
        add: addToQueue,
        addImmediate: addToQueueImmediate,
        advance: advance
    };
    var TestReport = function () {
        function TestReport(name, suite, options) {
            classCallCheck(this, TestReport);
            this.name = name;
            this.suiteName = suite.name;
            this.fullName = suite.fullName.concat(name);
            this.runtime = 0;
            this.assertions = [];
            this.skipped = !!options.skip;
            this.todo = !!options.todo;
            this.valid = options.valid;
            this._startTime = 0;
            this._endTime = 0;
            suite.pushTest(this);
        }
        createClass(TestReport, [
            {
                key: 'start',
                value: function start(recordTime) {
                    if (recordTime) {
                        this._startTime = Date.now();
                    }
                    return {
                        name: this.name,
                        suiteName: this.suiteName,
                        fullName: this.fullName.slice()
                    };
                }
            },
            {
                key: 'end',
                value: function end(recordTime) {
                    if (recordTime) {
                        this._endTime = Date.now();
                    }
                    return extend(this.start(), {
                        runtime: this.getRuntime(),
                        status: this.getStatus(),
                        errors: this.getFailedAssertions(),
                        assertions: this.getAssertions()
                    });
                }
            },
            {
                key: 'pushAssertion',
                value: function pushAssertion(assertion) {
                    this.assertions.push(assertion);
                }
            },
            {
                key: 'getRuntime',
                value: function getRuntime() {
                    return this._endTime - this._startTime;
                }
            },
            {
                key: 'getStatus',
                value: function getStatus() {
                    if (this.skipped) {
                        return 'skipped';
                    }
                    var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;
                    if (!testPassed) {
                        return 'failed';
                    } else if (this.todo) {
                        return 'todo';
                    } else {
                        return 'passed';
                    }
                }
            },
            {
                key: 'getFailedAssertions',
                value: function getFailedAssertions() {
                    return this.assertions.filter(function (assertion) {
                        return !assertion.passed;
                    });
                }
            },
            {
                key: 'getAssertions',
                value: function getAssertions() {
                    return this.assertions.slice();
                }
            },
            {
                key: 'slimAssertions',
                value: function slimAssertions() {
                    this.assertions = this.assertions.map(function (assertion) {
                        delete assertion.actual;
                        delete assertion.expected;
                        return assertion;
                    });
                }
            }
        ]);
        return TestReport;
    }();
    var focused$1 = false;
    function Test(settings) {
        var i, l;
        ++Test.count;
        this.expected = null;
        this.assertions = [];
        this.semaphore = 0;
        this.module = config.currentModule;
        this.stack = sourceFromStacktrace(3);
        this.steps = [];
        this.timeout = undefined;
        if (this.module.skip) {
            settings.skip = true;
            settings.todo = false;
        } else if (this.module.todo && !settings.skip) {
            settings.todo = true;
        }
        extend(this, settings);
        this.testReport = new TestReport(settings.testName, this.module.suiteReport, {
            todo: settings.todo,
            skip: settings.skip,
            valid: this.valid()
        });
        for (i = 0, l = this.module.tests; i < l.length; i++) {
            if (this.module.tests[i].name === this.testName) {
                this.testName += ' ';
            }
        }
        this.testId = generateHash(this.module.name, this.testName);
        this.module.tests.push({
            name: this.testName,
            testId: this.testId,
            skip: !!settings.skip
        });
        if (settings.skip) {
            this.callback = function () {
            };
            this.async = false;
            this.expected = 0;
        } else {
            if (typeof this.callback !== 'function') {
                var method = this.todo ? 'todo' : 'test';
                throw new TypeError('You must provide a function as a test callback to QUnit.' + method + '("' + settings.testName + '")');
            }
            this.assert = new Assert(this);
        }
    }
    Test.count = 0;
    function getNotStartedModules(startModule) {
        var module = startModule, modules = [];
        while (module && module.testsRun === 0) {
            modules.push(module);
            module = module.parentModule;
        }
        return modules;
    }
    Test.prototype = {
        before: function before() {
            var i, startModule, module = this.module, notStartedModules = getNotStartedModules(module);
            for (i = notStartedModules.length - 1; i >= 0; i--) {
                startModule = notStartedModules[i];
                startModule.stats = {
                    all: 0,
                    bad: 0,
                    started: now()
                };
                emit('suiteStart', startModule.suiteReport.start(true));
                runLoggingCallbacks('moduleStart', {
                    name: startModule.name,
                    tests: startModule.tests
                });
            }
            config.current = this;
            this.testEnvironment = extend({}, module.testEnvironment);
            this.started = now();
            emit('testStart', this.testReport.start(true));
            runLoggingCallbacks('testStart', {
                name: this.testName,
                module: module.name,
                testId: this.testId,
                previousFailure: this.previousFailure
            });
            if (!config.pollution) {
                saveGlobal();
            }
        },
        run: function run() {
            var promise;
            config.current = this;
            this.callbackStarted = now();
            if (config.notrycatch) {
                runTest(this);
                return;
            }
            try {
                runTest(this);
            } catch (e) {
                this.pushFailure('Died on test #' + (this.assertions.length + 1) + ' ' + this.stack + ': ' + (e.message || e), extractStacktrace(e, 0));
                saveGlobal();
                if (config.blocking) {
                    internalRecover(this);
                }
            }
            function runTest(test) {
                promise = test.callback.call(test.testEnvironment, test.assert);
                test.resolvePromise(promise);
                if (test.timeout === 0 && test.semaphore !== 0) {
                    pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.', sourceFromStacktrace(2));
                }
            }
        },
        after: function after() {
            checkPollution();
        },
        queueHook: function queueHook(hook, hookName, hookOwner) {
            var _this = this;
            var callHook = function callHook() {
                var promise = hook.call(_this.testEnvironment, _this.assert);
                _this.resolvePromise(promise, hookName);
            };
            var runHook = function runHook() {
                if (hookName === 'before') {
                    if (hookOwner.unskippedTestsRun !== 0) {
                        return;
                    }
                    _this.preserveEnvironment = true;
                }
                if (hookName === 'after' && hookOwner.unskippedTestsRun !== numberOfUnskippedTests(hookOwner) - 1 && config.queue.length > 2) {
                    return;
                }
                config.current = _this;
                if (config.notrycatch) {
                    callHook();
                    return;
                }
                try {
                    callHook();
                } catch (error) {
                    _this.pushFailure(hookName + ' failed on ' + _this.testName + ': ' + (error.message || error), extractStacktrace(error, 0));
                }
            };
            return runHook;
        },
        hooks: function hooks(handler) {
            var hooks = [];
            function processHooks(test, module) {
                if (module.parentModule) {
                    processHooks(test, module.parentModule);
                }
                if (module.hooks[handler].length) {
                    for (var i = 0; i < module.hooks[handler].length; i++) {
                        hooks.push(test.queueHook(module.hooks[handler][i], handler, module));
                    }
                }
            }
            if (!this.skip) {
                processHooks(this, this.module);
            }
            return hooks;
        },
        finish: function finish() {
            config.current = this;
            if (config.requireExpects && this.expected === null) {
                this.pushFailure('Expected number of assertions to be defined, but expect() was ' + 'not called.', this.stack);
            } else if (this.expected !== null && this.expected !== this.assertions.length) {
                this.pushFailure('Expected ' + this.expected + ' assertions, but ' + this.assertions.length + ' were run', this.stack);
            } else if (this.expected === null && !this.assertions.length) {
                this.pushFailure('Expected at least one assertion, but none were run - call ' + 'expect(0) to accept zero assertions.', this.stack);
            }
            var i, module = this.module, moduleName = module.name, testName = this.testName, skipped = !!this.skip, todo = !!this.todo, bad = 0, storage = config.storage;
            this.runtime = now() - this.started;
            config.stats.all += this.assertions.length;
            module.stats.all += this.assertions.length;
            for (i = 0; i < this.assertions.length; i++) {
                if (!this.assertions[i].result) {
                    bad++;
                    config.stats.bad++;
                    module.stats.bad++;
                }
            }
            notifyTestsRan(module, skipped);
            if (storage) {
                if (bad) {
                    storage.setItem('qunit-test-' + moduleName + '-' + testName, bad);
                } else {
                    storage.removeItem('qunit-test-' + moduleName + '-' + testName);
                }
            }
            emit('testEnd', this.testReport.end(true));
            this.testReport.slimAssertions();
            runLoggingCallbacks('testDone', {
                name: testName,
                module: moduleName,
                skipped: skipped,
                todo: todo,
                failed: bad,
                passed: this.assertions.length - bad,
                total: this.assertions.length,
                runtime: skipped ? 0 : this.runtime,
                assertions: this.assertions,
                testId: this.testId,
                source: this.stack
            });
            if (module.testsRun === numberOfTests(module)) {
                logSuiteEnd(module);
                var parent = module.parentModule;
                while (parent && parent.testsRun === numberOfTests(parent)) {
                    logSuiteEnd(parent);
                    parent = parent.parentModule;
                }
            }
            config.current = undefined;
            function logSuiteEnd(module) {
                emit('suiteEnd', module.suiteReport.end(true));
                runLoggingCallbacks('moduleDone', {
                    name: module.name,
                    tests: module.tests,
                    failed: module.stats.bad,
                    passed: module.stats.all - module.stats.bad,
                    total: module.stats.all,
                    runtime: now() - module.stats.started
                });
            }
        },
        preserveTestEnvironment: function preserveTestEnvironment() {
            if (this.preserveEnvironment) {
                this.module.testEnvironment = this.testEnvironment;
                this.testEnvironment = extend({}, this.module.testEnvironment);
            }
        },
        queue: function queue() {
            var test = this;
            if (!this.valid()) {
                return;
            }
            function runTest() {
                ProcessingQueue.addImmediate([
                    function () {
                        test.before();
                    },
                    test.hooks('before'),
                    function () {
                        test.preserveTestEnvironment();
                    },
                    test.hooks('beforeEach'),
                    function () {
                        test.run();
                    },
                    test.hooks('afterEach').reverse(),
                    test.hooks('after').reverse(),
                    function () {
                        test.after();
                    },
                    function () {
                        test.finish();
                    }
                ]);
            }
            var previousFailCount = config.storage && +config.storage.getItem('qunit-test-' + this.module.name + '-' + this.testName);
            var prioritize = config.reorder && !!previousFailCount;
            this.previousFailure = !!previousFailCount;
            ProcessingQueue.add(runTest, prioritize, config.seed);
            if (ProcessingQueue.finished) {
                ProcessingQueue.advance();
            }
        },
        pushResult: function pushResult(resultInfo) {
            if (this !== config.current) {
                throw new Error('Assertion occured after test had finished.');
            }
            var source, details = {
                    module: this.module.name,
                    name: this.testName,
                    result: resultInfo.result,
                    message: resultInfo.message,
                    actual: resultInfo.actual,
                    testId: this.testId,
                    negative: resultInfo.negative || false,
                    runtime: now() - this.started,
                    todo: !!this.todo
                };
            if (hasOwn.call(resultInfo, 'expected')) {
                details.expected = resultInfo.expected;
            }
            if (!resultInfo.result) {
                source = resultInfo.source || sourceFromStacktrace();
                if (source) {
                    details.source = source;
                }
            }
            this.logAssertion(details);
            this.assertions.push({
                result: !!resultInfo.result,
                message: resultInfo.message
            });
        },
        pushFailure: function pushFailure(message, source, actual) {
            if (!(this instanceof Test)) {
                throw new Error('pushFailure() assertion outside test context, was ' + sourceFromStacktrace(2));
            }
            this.pushResult({
                result: false,
                message: message || 'error',
                actual: actual || null,
                source: source
            });
        },
        logAssertion: function logAssertion(details) {
            runLoggingCallbacks('log', details);
            var assertion = {
                passed: details.result,
                actual: details.actual,
                expected: details.expected,
                message: details.message,
                stack: details.source,
                todo: details.todo
            };
            this.testReport.pushAssertion(assertion);
            emit('assertion', assertion);
        },
        resolvePromise: function resolvePromise(promise, phase) {
            var then, resume, message, test = this;
            if (promise != null) {
                then = promise.then;
                if (objectType(then) === 'function') {
                    resume = internalStop(test);
                    then.call(promise, function () {
                        resume();
                    }, function (error) {
                        message = 'Promise rejected ' + (!phase ? 'during' : phase.replace(/Each$/, '')) + ' "' + test.testName + '": ' + (error && error.message || error);
                        test.pushFailure(message, extractStacktrace(error, 0));
                        saveGlobal();
                        resume();
                    });
                }
            }
        },
        valid: function valid() {
            var filter = config.filter, regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec(filter), module = config.module && config.module.toLowerCase(), fullName = this.module.name + ': ' + this.testName;
            function moduleChainNameMatch(testModule) {
                var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;
                if (testModuleName === module) {
                    return true;
                } else if (testModule.parentModule) {
                    return moduleChainNameMatch(testModule.parentModule);
                } else {
                    return false;
                }
            }
            function moduleChainIdMatch(testModule) {
                return inArray(testModule.moduleId, config.moduleId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule);
            }
            if (this.callback && this.callback.validTest) {
                return true;
            }
            if (config.moduleId && config.moduleId.length > 0 && !moduleChainIdMatch(this.module)) {
                return false;
            }
            if (config.testId && config.testId.length > 0 && !inArray(this.testId, config.testId)) {
                return false;
            }
            if (module && !moduleChainNameMatch(this.module)) {
                return false;
            }
            if (!filter) {
                return true;
            }
            return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);
        },
        regexFilter: function regexFilter(exclude, pattern, flags, fullName) {
            var regex = new RegExp(pattern, flags);
            var match = regex.test(fullName);
            return match !== exclude;
        },
        stringFilter: function stringFilter(filter, fullName) {
            filter = filter.toLowerCase();
            fullName = fullName.toLowerCase();
            var include = filter.charAt(0) !== '!';
            if (!include) {
                filter = filter.slice(1);
            }
            if (fullName.indexOf(filter) !== -1) {
                return include;
            }
            return !include;
        }
    };
    function pushFailure() {
        if (!config.current) {
            throw new Error('pushFailure() assertion outside test context, in ' + sourceFromStacktrace(2));
        }
        var currentTest = config.current;
        return currentTest.pushFailure.apply(currentTest, arguments);
    }
    function saveGlobal() {
        config.pollution = [];
        if (config.noglobals) {
            for (var key in global$1) {
                if (hasOwn.call(global$1, key)) {
                    if (/^qunit-test-output/.test(key)) {
                        continue;
                    }
                    config.pollution.push(key);
                }
            }
        }
    }
    function checkPollution() {
        var newGlobals, deletedGlobals, old = config.pollution;
        saveGlobal();
        newGlobals = diff(config.pollution, old);
        if (newGlobals.length > 0) {
            pushFailure('Introduced global variable(s): ' + newGlobals.join(', '));
        }
        deletedGlobals = diff(old, config.pollution);
        if (deletedGlobals.length > 0) {
            pushFailure('Deleted global variable(s): ' + deletedGlobals.join(', '));
        }
    }
    function test(testName, callback) {
        if (focused$1) {
            return;
        }
        var newTest = new Test({
            testName: testName,
            callback: callback
        });
        newTest.queue();
    }
    function todo(testName, callback) {
        if (focused$1) {
            return;
        }
        var newTest = new Test({
            testName: testName,
            callback: callback,
            todo: true
        });
        newTest.queue();
    }
    function skip(testName) {
        if (focused$1) {
            return;
        }
        var test = new Test({
            testName: testName,
            skip: true
        });
        test.queue();
    }
    function only(testName, callback) {
        if (focused$1) {
            return;
        }
        config.queue.length = 0;
        focused$1 = true;
        var newTest = new Test({
            testName: testName,
            callback: callback
        });
        newTest.queue();
    }
    function internalStop(test) {
        test.semaphore += 1;
        config.blocking = true;
        if (defined.setTimeout) {
            var timeoutDuration = void 0;
            if (typeof test.timeout === 'number') {
                timeoutDuration = test.timeout;
            } else if (typeof config.testTimeout === 'number') {
                timeoutDuration = config.testTimeout;
            }
            if (typeof timeoutDuration === 'number' && timeoutDuration > 0) {
                clearTimeout(config.timeout);
                config.timeout = setTimeout(function () {
                    pushFailure('Test took longer than ' + timeoutDuration + 'ms; test timed out.', sourceFromStacktrace(2));
                    internalRecover(test);
                }, timeoutDuration);
            }
        }
        var released = false;
        return function resume() {
            if (released) {
                return;
            }
            released = true;
            test.semaphore -= 1;
            internalStart(test);
        };
    }
    function internalRecover(test) {
        test.semaphore = 0;
        internalStart(test);
    }
    function internalStart(test) {
        if (isNaN(test.semaphore)) {
            test.semaphore = 0;
            pushFailure('Invalid value on test.semaphore', sourceFromStacktrace(2));
            return;
        }
        if (test.semaphore > 0) {
            return;
        }
        if (test.semaphore < 0) {
            test.semaphore = 0;
            pushFailure('Tried to restart test while already started (test\'s semaphore was 0 already)', sourceFromStacktrace(2));
            return;
        }
        if (defined.setTimeout) {
            if (config.timeout) {
                clearTimeout(config.timeout);
            }
            config.timeout = setTimeout(function () {
                if (test.semaphore > 0) {
                    return;
                }
                if (config.timeout) {
                    clearTimeout(config.timeout);
                }
                begin();
            }, 13);
        } else {
            begin();
        }
    }
    function collectTests(module) {
        var tests = [].concat(module.tests);
        var modules = [].concat(toConsumableArray(module.childModules));
        while (modules.length) {
            var nextModule = modules.shift();
            tests.push.apply(tests, nextModule.tests);
            modules.push.apply(modules, toConsumableArray(nextModule.childModules));
        }
        return tests;
    }
    function numberOfTests(module) {
        return collectTests(module).length;
    }
    function numberOfUnskippedTests(module) {
        return collectTests(module).filter(function (test) {
            return !test.skip;
        }).length;
    }
    function notifyTestsRan(module, skipped) {
        module.testsRun++;
        if (!skipped) {
            module.unskippedTestsRun++;
        }
        while (module = module.parentModule) {
            module.testsRun++;
            if (!skipped) {
                module.unskippedTestsRun++;
            }
        }
    }
    function consoleProxy(method) {
        return function () {
            if (console) {
                console[method].apply(console, arguments);
            }
        };
    }
    var Logger = { warn: consoleProxy('warn') };
    var Assert = function () {
        function Assert(testContext) {
            classCallCheck(this, Assert);
            this.test = testContext;
        }
        createClass(Assert, [
            {
                key: 'timeout',
                value: function timeout(duration) {
                    if (typeof duration !== 'number') {
                        throw new Error('You must pass a number as the duration to assert.timeout');
                    }
                    this.test.timeout = duration;
                }
            },
            {
                key: 'step',
                value: function step(message) {
                    var result = !!message;
                    this.test.steps.push(message);
                    return this.pushResult({
                        result: result,
                        message: message || 'You must provide a message to assert.step'
                    });
                }
            },
            {
                key: 'verifySteps',
                value: function verifySteps(steps, message) {
                    this.deepEqual(this.test.steps, steps, message);
                }
            },
            {
                key: 'expect',
                value: function expect(asserts) {
                    if (arguments.length === 1) {
                        this.test.expected = asserts;
                    } else {
                        return this.test.expected;
                    }
                }
            },
            {
                key: 'async',
                value: function async(count) {
                    var test$$1 = this.test;
                    var popped = false, acceptCallCount = count;
                    if (typeof acceptCallCount === 'undefined') {
                        acceptCallCount = 1;
                    }
                    var resume = internalStop(test$$1);
                    return function done() {
                        if (config.current !== test$$1) {
                            throw Error('assert.async callback called after test finished.');
                        }
                        if (popped) {
                            test$$1.pushFailure('Too many calls to the `assert.async` callback', sourceFromStacktrace(2));
                            return;
                        }
                        acceptCallCount -= 1;
                        if (acceptCallCount > 0) {
                            return;
                        }
                        popped = true;
                        resume();
                    };
                }
            },
            {
                key: 'push',
                value: function push(result, actual, expected, message, negative) {
                    Logger.warn('assert.push is deprecated and will be removed in QUnit 3.0.' + ' Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).');
                    var currentAssert = this instanceof Assert ? this : config.current.assert;
                    return currentAssert.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: negative
                    });
                }
            },
            {
                key: 'pushResult',
                value: function pushResult(resultInfo) {
                    var assert = this;
                    var currentTest = assert instanceof Assert && assert.test || config.current;
                    if (!currentTest) {
                        throw new Error('assertion outside test context, in ' + sourceFromStacktrace(2));
                    }
                    if (!(assert instanceof Assert)) {
                        assert = currentTest.assert;
                    }
                    return assert.test.pushResult(resultInfo);
                }
            },
            {
                key: 'ok',
                value: function ok(result, message) {
                    if (!message) {
                        message = result ? 'okay' : 'failed, expected argument to be truthy, was: ' + dump.parse(result);
                    }
                    this.pushResult({
                        result: !!result,
                        actual: result,
                        expected: true,
                        message: message
                    });
                }
            },
            {
                key: 'notOk',
                value: function notOk(result, message) {
                    if (!message) {
                        message = !result ? 'okay' : 'failed, expected argument to be falsy, was: ' + dump.parse(result);
                    }
                    this.pushResult({
                        result: !result,
                        actual: result,
                        expected: false,
                        message: message
                    });
                }
            },
            {
                key: 'equal',
                value: function equal(actual, expected, message) {
                    var result = expected == actual;
                    this.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notEqual',
                value: function notEqual(actual, expected, message) {
                    var result = expected != actual;
                    this.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'propEqual',
                value: function propEqual(actual, expected, message) {
                    actual = objectValues(actual);
                    expected = objectValues(expected);
                    this.pushResult({
                        result: equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notPropEqual',
                value: function notPropEqual(actual, expected, message) {
                    actual = objectValues(actual);
                    expected = objectValues(expected);
                    this.pushResult({
                        result: !equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'deepEqual',
                value: function deepEqual(actual, expected, message) {
                    this.pushResult({
                        result: equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notDeepEqual',
                value: function notDeepEqual(actual, expected, message) {
                    this.pushResult({
                        result: !equiv(actual, expected),
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'strictEqual',
                value: function strictEqual(actual, expected, message) {
                    this.pushResult({
                        result: expected === actual,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            },
            {
                key: 'notStrictEqual',
                value: function notStrictEqual(actual, expected, message) {
                    this.pushResult({
                        result: expected !== actual,
                        actual: actual,
                        expected: expected,
                        message: message,
                        negative: true
                    });
                }
            },
            {
                key: 'throws',
                value: function throws(block, expected, message) {
                    var actual = void 0, result = false;
                    var currentTest = this instanceof Assert && this.test || config.current;
                    if (objectType(expected) === 'string') {
                        if (message == null) {
                            message = expected;
                            expected = null;
                        } else {
                            throw new Error('throws/raises does not accept a string value for the expected argument.\n' + 'Use a non-string object value (e.g. regExp) instead if it\'s necessary.');
                        }
                    }
                    currentTest.ignoreGlobalErrors = true;
                    try {
                        block.call(currentTest.testEnvironment);
                    } catch (e) {
                        actual = e;
                    }
                    currentTest.ignoreGlobalErrors = false;
                    if (actual) {
                        var expectedType = objectType(expected);
                        if (!expected) {
                            result = true;
                            expected = null;
                        } else if (expectedType === 'regexp') {
                            result = expected.test(errorString(actual));
                        } else if (expectedType === 'function' && actual instanceof expected) {
                            result = true;
                        } else if (expectedType === 'object') {
                            result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;
                        } else if (expectedType === 'function' && expected.call({}, actual) === true) {
                            expected = null;
                            result = true;
                        }
                    }
                    currentTest.assert.pushResult({
                        result: result,
                        actual: actual,
                        expected: expected,
                        message: message
                    });
                }
            }
        ]);
        return Assert;
    }();
    Assert.prototype.raises = Assert.prototype['throws'];
    function errorString(error) {
        var resultErrorString = error.toString();
        if (resultErrorString.substring(0, 7) === '[object') {
            var name = error.name ? error.name.toString() : 'Error';
            var message = error.message ? error.message.toString() : '';
            if (name && message) {
                return name + ': ' + message;
            } else if (name) {
                return name;
            } else if (message) {
                return message;
            } else {
                return 'Error';
            }
        } else {
            return resultErrorString;
        }
    }
    function exportQUnit(QUnit) {
        if (defined.document) {
            if (window.QUnit && window.QUnit.version) {
                throw new Error('QUnit has already been defined.');
            }
            window.QUnit = QUnit;
        }
        if (typeof module !== 'undefined' && module && module.exports) {
            module.exports = QUnit;
            module.exports.QUnit = QUnit;
        }
        if (typeof exports !== 'undefined' && exports) {
            exports.QUnit = QUnit;
        }
        if (typeof define === 'function' && define.amd) {
            define('qunitjs@2.4.1#qunit/qunit', function () {
                return QUnit;
            });
            QUnit.config.autostart = false;
        }
        if (self$1 && self$1.WorkerGlobalScope && self$1 instanceof self$1.WorkerGlobalScope) {
            self$1.QUnit = QUnit;
        }
    }
    var SuiteReport = function () {
        function SuiteReport(name, parentSuite) {
            classCallCheck(this, SuiteReport);
            this.name = name;
            this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];
            this.tests = [];
            this.childSuites = [];
            if (parentSuite) {
                parentSuite.pushChildSuite(this);
            }
        }
        createClass(SuiteReport, [
            {
                key: 'start',
                value: function start(recordTime) {
                    if (recordTime) {
                        this._startTime = Date.now();
                    }
                    return {
                        name: this.name,
                        fullName: this.fullName.slice(),
                        tests: this.tests.map(function (test) {
                            return test.start();
                        }),
                        childSuites: this.childSuites.map(function (suite) {
                            return suite.start();
                        }),
                        testCounts: { total: this.getTestCounts().total }
                    };
                }
            },
            {
                key: 'end',
                value: function end(recordTime) {
                    if (recordTime) {
                        this._endTime = Date.now();
                    }
                    return {
                        name: this.name,
                        fullName: this.fullName.slice(),
                        tests: this.tests.map(function (test) {
                            return test.end();
                        }),
                        childSuites: this.childSuites.map(function (suite) {
                            return suite.end();
                        }),
                        testCounts: this.getTestCounts(),
                        runtime: this.getRuntime(),
                        status: this.getStatus()
                    };
                }
            },
            {
                key: 'pushChildSuite',
                value: function pushChildSuite(suite) {
                    this.childSuites.push(suite);
                }
            },
            {
                key: 'pushTest',
                value: function pushTest(test) {
                    this.tests.push(test);
                }
            },
            {
                key: 'getRuntime',
                value: function getRuntime() {
                    return this._endTime - this._startTime;
                }
            },
            {
                key: 'getTestCounts',
                value: function getTestCounts() {
                    var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                        passed: 0,
                        failed: 0,
                        skipped: 0,
                        todo: 0,
                        total: 0
                    };
                    counts = this.tests.reduce(function (counts, test) {
                        if (test.valid) {
                            counts[test.getStatus()]++;
                            counts.total++;
                        }
                        return counts;
                    }, counts);
                    return this.childSuites.reduce(function (counts, suite) {
                        return suite.getTestCounts(counts);
                    }, counts);
                }
            },
            {
                key: 'getStatus',
                value: function getStatus() {
                    var _getTestCounts = this.getTestCounts(), total = _getTestCounts.total, failed = _getTestCounts.failed, skipped = _getTestCounts.skipped, todo = _getTestCounts.todo;
                    if (failed) {
                        return 'failed';
                    } else {
                        if (skipped === total) {
                            return 'skipped';
                        } else if (todo === total) {
                            return 'todo';
                        } else {
                            return 'passed';
                        }
                    }
                }
            }
        ]);
        return SuiteReport;
    }();
    function onError(error) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }
        if (config.current) {
            if (config.current.ignoreGlobalErrors) {
                return true;
            }
            pushFailure.apply(undefined, [
                error.message,
                error.fileName + ':' + error.lineNumber
            ].concat(args));
        } else {
            test('global failure', extend(function () {
                pushFailure.apply(undefined, [
                    error.message,
                    error.fileName + ':' + error.lineNumber
                ].concat(args));
            }, { validTest: true }));
        }
        return false;
    }
    var focused = false;
    var QUnit = {};
    var globalSuite = new SuiteReport();
    config.currentModule.suiteReport = globalSuite;
    var moduleStack = [];
    var globalStartCalled = false;
    var runStarted = false;
    QUnit.isLocal = !(defined.document && window.location.protocol !== 'file:');
    QUnit.version = '2.4.1';
    function createModule(name, testEnvironment, modifiers) {
        var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;
        var moduleName = parentModule !== null ? [
            parentModule.name,
            name
        ].join(' > ') : name;
        var parentSuite = parentModule ? parentModule.suiteReport : globalSuite;
        var skip$$1 = parentModule !== null && parentModule.skip || modifiers.skip;
        var todo$$1 = parentModule !== null && parentModule.todo || modifiers.todo;
        var module = {
            name: moduleName,
            parentModule: parentModule,
            tests: [],
            moduleId: generateHash(moduleName),
            testsRun: 0,
            unskippedTestsRun: 0,
            childModules: [],
            suiteReport: new SuiteReport(name, parentSuite),
            skip: skip$$1,
            todo: skip$$1 ? false : todo$$1
        };
        var env = {};
        if (parentModule) {
            parentModule.childModules.push(module);
            extend(env, parentModule.testEnvironment);
        }
        extend(env, testEnvironment);
        module.testEnvironment = env;
        config.modules.push(module);
        return module;
    }
    function processModule(name, options, executeNow) {
        var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var module = createModule(name, options, modifiers);
        var testEnvironment = module.testEnvironment;
        var hooks = module.hooks = {};
        setHookFromEnvironment(hooks, testEnvironment, 'before');
        setHookFromEnvironment(hooks, testEnvironment, 'beforeEach');
        setHookFromEnvironment(hooks, testEnvironment, 'afterEach');
        setHookFromEnvironment(hooks, testEnvironment, 'after');
        function setHookFromEnvironment(hooks, environment, name) {
            var potentialHook = environment[name];
            hooks[name] = typeof potentialHook === 'function' ? [potentialHook] : [];
            delete environment[name];
        }
        var moduleFns = {
            before: setHookFunction(module, 'before'),
            beforeEach: setHookFunction(module, 'beforeEach'),
            afterEach: setHookFunction(module, 'afterEach'),
            after: setHookFunction(module, 'after')
        };
        var currentModule = config.currentModule;
        if (objectType(executeNow) === 'function') {
            moduleStack.push(module);
            config.currentModule = module;
            executeNow.call(module.testEnvironment, moduleFns);
            moduleStack.pop();
            module = module.parentModule || currentModule;
        }
        config.currentModule = module;
    }
    function module$1(name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow);
    }
    module$1.only = function () {
        if (focused) {
            return;
        }
        config.modules.length = 0;
        config.queue.length = 0;
        module$1.apply(undefined, arguments);
        focused = true;
    };
    module$1.skip = function (name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow, { skip: true });
    };
    module$1.todo = function (name, options, executeNow) {
        if (focused) {
            return;
        }
        if (arguments.length === 2) {
            if (objectType(options) === 'function') {
                executeNow = options;
                options = undefined;
            }
        }
        processModule(name, options, executeNow, { todo: true });
    };
    extend(QUnit, {
        on: on,
        module: module$1,
        test: test,
        todo: todo,
        skip: skip,
        only: only,
        start: function start(count) {
            var globalStartAlreadyCalled = globalStartCalled;
            if (!config.current) {
                globalStartCalled = true;
                if (runStarted) {
                    throw new Error('Called start() while test already started running');
                } else if (globalStartAlreadyCalled || count > 1) {
                    throw new Error('Called start() outside of a test context too many times');
                } else if (config.autostart) {
                    throw new Error('Called start() outside of a test context when ' + 'QUnit.config.autostart was true');
                } else if (!config.pageLoaded) {
                    config.autostart = true;
                    if (!defined.document) {
                        QUnit.load();
                    }
                    return;
                }
            } else {
                throw new Error('QUnit.start cannot be called inside a test context.');
            }
            scheduleBegin();
        },
        config: config,
        is: is,
        objectType: objectType,
        extend: extend,
        load: function load() {
            config.pageLoaded = true;
            extend(config, {
                stats: {
                    all: 0,
                    bad: 0
                },
                started: 0,
                updateRate: 1000,
                autostart: true,
                filter: ''
            }, true);
            if (!runStarted) {
                config.blocking = false;
                if (config.autostart) {
                    scheduleBegin();
                }
            }
        },
        stack: function stack(offset) {
            offset = (offset || 0) + 2;
            return sourceFromStacktrace(offset);
        },
        onError: onError
    });
    QUnit.pushFailure = pushFailure;
    QUnit.assert = Assert.prototype;
    QUnit.equiv = equiv;
    QUnit.dump = dump;
    registerLoggingCallbacks(QUnit);
    function scheduleBegin() {
        runStarted = true;
        if (defined.setTimeout) {
            setTimeout(function () {
                begin();
            }, 13);
        } else {
            begin();
        }
    }
    function begin() {
        var i, l, modulesLog = [];
        if (!config.started) {
            config.started = now();
            if (config.modules[0].name === '' && config.modules[0].tests.length === 0) {
                config.modules.shift();
            }
            for (i = 0, l = config.modules.length; i < l; i++) {
                modulesLog.push({
                    name: config.modules[i].name,
                    tests: config.modules[i].tests
                });
            }
            emit('runStart', globalSuite.start(true));
            runLoggingCallbacks('begin', {
                totalTests: Test.count,
                modules: modulesLog
            });
        }
        config.blocking = false;
        ProcessingQueue.advance();
    }
    function setHookFunction(module, hookName) {
        return function setHook(callback) {
            module.hooks[hookName].push(callback);
        };
    }
    exportQUnit(QUnit);
    (function () {
        if (typeof window === 'undefined' || typeof document === 'undefined') {
            return;
        }
        var config = QUnit.config, hasOwn = Object.prototype.hasOwnProperty;
        function storeFixture() {
            if (hasOwn.call(config, 'fixture')) {
                return;
            }
            var fixture = document.getElementById('qunit-fixture');
            if (fixture) {
                config.fixture = fixture.innerHTML;
            }
        }
        QUnit.begin(storeFixture);
        function resetFixture() {
            if (config.fixture == null) {
                return;
            }
            var fixture = document.getElementById('qunit-fixture');
            if (fixture) {
                fixture.innerHTML = config.fixture;
            }
        }
        QUnit.testStart(resetFixture);
    }());
    (function () {
        var location = typeof window !== 'undefined' && window.location;
        if (!location) {
            return;
        }
        var urlParams = getUrlParams();
        QUnit.urlParams = urlParams;
        QUnit.config.moduleId = [].concat(urlParams.moduleId || []);
        QUnit.config.testId = [].concat(urlParams.testId || []);
        QUnit.config.module = urlParams.module;
        QUnit.config.filter = urlParams.filter;
        if (urlParams.seed === true) {
            QUnit.config.seed = Math.random().toString(36).slice(2);
        } else if (urlParams.seed) {
            QUnit.config.seed = urlParams.seed;
        }
        QUnit.config.urlConfig.push({
            id: 'hidepassed',
            label: 'Hide passed tests',
            tooltip: 'Only show tests and assertions that fail. Stored as query-strings.'
        }, {
            id: 'noglobals',
            label: 'Check for Globals',
            tooltip: 'Enabling this will test if any test introduces new properties on the ' + 'global object (`window` in Browsers). Stored as query-strings.'
        }, {
            id: 'notrycatch',
            label: 'No try-catch',
            tooltip: 'Enabling this will run tests outside of a try-catch block. Makes debugging ' + 'exceptions in IE reasonable. Stored as query-strings.'
        });
        QUnit.begin(function () {
            var i, option, urlConfig = QUnit.config.urlConfig;
            for (i = 0; i < urlConfig.length; i++) {
                option = QUnit.config.urlConfig[i];
                if (typeof option !== 'string') {
                    option = option.id;
                }
                if (QUnit.config[option] === undefined) {
                    QUnit.config[option] = urlParams[option];
                }
            }
        });
        function getUrlParams() {
            var i, param, name, value;
            var urlParams = Object.create(null);
            var params = location.search.slice(1).split('&');
            var length = params.length;
            for (i = 0; i < length; i++) {
                if (params[i]) {
                    param = params[i].split('=');
                    name = decodeQueryParam(param[0]);
                    value = param.length === 1 || decodeQueryParam(param.slice(1).join('='));
                    if (name in urlParams) {
                        urlParams[name] = [].concat(urlParams[name], value);
                    } else {
                        urlParams[name] = value;
                    }
                }
            }
            return urlParams;
        }
        function decodeQueryParam(param) {
            return decodeURIComponent(param.replace(/\+/g, '%20'));
        }
    }());
    var stats = {
        passedTests: 0,
        failedTests: 0,
        skippedTests: 0,
        todoTests: 0
    };
    function escapeText(s) {
        if (!s) {
            return '';
        }
        s = s + '';
        return s.replace(/['"<>&]/g, function (s) {
            switch (s) {
            case '\'':
                return '&#039;';
            case '"':
                return '&quot;';
            case '<':
                return '&lt;';
            case '>':
                return '&gt;';
            case '&':
                return '&amp;';
            }
        });
    }
    (function () {
        if (typeof window === 'undefined' || !window.document) {
            return;
        }
        var config = QUnit.config, document$$1 = window.document, collapseNext = false, hasOwn = Object.prototype.hasOwnProperty, unfilteredUrl = setUrl({
                filter: undefined,
                module: undefined,
                moduleId: undefined,
                testId: undefined
            }), modulesList = [];
        function addEvent(elem, type, fn) {
            elem.addEventListener(type, fn, false);
        }
        function removeEvent(elem, type, fn) {
            elem.removeEventListener(type, fn, false);
        }
        function addEvents(elems, type, fn) {
            var i = elems.length;
            while (i--) {
                addEvent(elems[i], type, fn);
            }
        }
        function hasClass(elem, name) {
            return (' ' + elem.className + ' ').indexOf(' ' + name + ' ') >= 0;
        }
        function addClass(elem, name) {
            if (!hasClass(elem, name)) {
                elem.className += (elem.className ? ' ' : '') + name;
            }
        }
        function toggleClass(elem, name, force) {
            if (force || typeof force === 'undefined' && !hasClass(elem, name)) {
                addClass(elem, name);
            } else {
                removeClass(elem, name);
            }
        }
        function removeClass(elem, name) {
            var set = ' ' + elem.className + ' ';
            while (set.indexOf(' ' + name + ' ') >= 0) {
                set = set.replace(' ' + name + ' ', ' ');
            }
            elem.className = typeof set.trim === 'function' ? set.trim() : set.replace(/^\s+|\s+$/g, '');
        }
        function id(name) {
            return document$$1.getElementById && document$$1.getElementById(name);
        }
        function abortTests() {
            var abortButton = id('qunit-abort-tests-button');
            if (abortButton) {
                abortButton.disabled = true;
                abortButton.innerHTML = 'Aborting...';
            }
            QUnit.config.queue.length = 0;
            return false;
        }
        function interceptNavigation(ev) {
            applyUrlParams();
            if (ev && ev.preventDefault) {
                ev.preventDefault();
            }
            return false;
        }
        function getUrlConfigHtml() {
            var i, j, val, escaped, escapedTooltip, selection = false, urlConfig = config.urlConfig, urlConfigHtml = '';
            for (i = 0; i < urlConfig.length; i++) {
                val = config.urlConfig[i];
                if (typeof val === 'string') {
                    val = {
                        id: val,
                        label: val
                    };
                }
                escaped = escapeText(val.id);
                escapedTooltip = escapeText(val.tooltip);
                if (!val.value || typeof val.value === 'string') {
                    urlConfigHtml += '<label for=\'qunit-urlconfig-' + escaped + '\' title=\'' + escapedTooltip + '\'><input id=\'qunit-urlconfig-' + escaped + '\' name=\'' + escaped + '\' type=\'checkbox\'' + (val.value ? ' value=\'' + escapeText(val.value) + '\'' : '') + (config[val.id] ? ' checked=\'checked\'' : '') + ' title=\'' + escapedTooltip + '\' />' + escapeText(val.label) + '</label>';
                } else {
                    urlConfigHtml += '<label for=\'qunit-urlconfig-' + escaped + '\' title=\'' + escapedTooltip + '\'>' + val.label + ': </label><select id=\'qunit-urlconfig-' + escaped + '\' name=\'' + escaped + '\' title=\'' + escapedTooltip + '\'><option></option>';
                    if (QUnit.is('array', val.value)) {
                        for (j = 0; j < val.value.length; j++) {
                            escaped = escapeText(val.value[j]);
                            urlConfigHtml += '<option value=\'' + escaped + '\'' + (config[val.id] === val.value[j] ? (selection = true) && ' selected=\'selected\'' : '') + '>' + escaped + '</option>';
                        }
                    } else {
                        for (j in val.value) {
                            if (hasOwn.call(val.value, j)) {
                                urlConfigHtml += '<option value=\'' + escapeText(j) + '\'' + (config[val.id] === j ? (selection = true) && ' selected=\'selected\'' : '') + '>' + escapeText(val.value[j]) + '</option>';
                            }
                        }
                    }
                    if (config[val.id] && !selection) {
                        escaped = escapeText(config[val.id]);
                        urlConfigHtml += '<option value=\'' + escaped + '\' selected=\'selected\' disabled=\'disabled\'>' + escaped + '</option>';
                    }
                    urlConfigHtml += '</select>';
                }
            }
            return urlConfigHtml;
        }
        function toolbarChanged() {
            var updatedUrl, value, tests, field = this, params = {};
            if ('selectedIndex' in field) {
                value = field.options[field.selectedIndex].value || undefined;
            } else {
                value = field.checked ? field.defaultValue || true : undefined;
            }
            params[field.name] = value;
            updatedUrl = setUrl(params);
            if ('hidepassed' === field.name && 'replaceState' in window.history) {
                QUnit.urlParams[field.name] = value;
                config[field.name] = value || false;
                tests = id('qunit-tests');
                if (tests) {
                    toggleClass(tests, 'hidepass', value || false);
                }
                window.history.replaceState(null, '', updatedUrl);
            } else {
                window.location = updatedUrl;
            }
        }
        function setUrl(params) {
            var key, arrValue, i, querystring = '?', location = window.location;
            params = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);
            for (key in params) {
                if (hasOwn.call(params, key) && params[key] !== undefined) {
                    arrValue = [].concat(params[key]);
                    for (i = 0; i < arrValue.length; i++) {
                        querystring += encodeURIComponent(key);
                        if (arrValue[i] !== true) {
                            querystring += '=' + encodeURIComponent(arrValue[i]);
                        }
                        querystring += '&';
                    }
                }
            }
            return location.protocol + '//' + location.host + location.pathname + querystring.slice(0, -1);
        }
        function applyUrlParams() {
            var i, selectedModules = [], modulesList = id('qunit-modulefilter-dropdown-list').getElementsByTagName('input'), filter = id('qunit-filter-input').value;
            for (i = 0; i < modulesList.length; i++) {
                if (modulesList[i].checked) {
                    selectedModules.push(modulesList[i].value);
                }
            }
            window.location = setUrl({
                filter: filter === '' ? undefined : filter,
                moduleId: selectedModules.length === 0 ? undefined : selectedModules,
                module: undefined,
                testId: undefined
            });
        }
        function toolbarUrlConfigContainer() {
            var urlConfigContainer = document$$1.createElement('span');
            urlConfigContainer.innerHTML = getUrlConfigHtml();
            addClass(urlConfigContainer, 'qunit-url-config');
            addEvents(urlConfigContainer.getElementsByTagName('input'), 'change', toolbarChanged);
            addEvents(urlConfigContainer.getElementsByTagName('select'), 'change', toolbarChanged);
            return urlConfigContainer;
        }
        function abortTestsButton() {
            var button = document$$1.createElement('button');
            button.id = 'qunit-abort-tests-button';
            button.innerHTML = 'Abort';
            addEvent(button, 'click', abortTests);
            return button;
        }
        function toolbarLooseFilter() {
            var filter = document$$1.createElement('form'), label = document$$1.createElement('label'), input = document$$1.createElement('input'), button = document$$1.createElement('button');
            addClass(filter, 'qunit-filter');
            label.innerHTML = 'Filter: ';
            input.type = 'text';
            input.value = config.filter || '';
            input.name = 'filter';
            input.id = 'qunit-filter-input';
            button.innerHTML = 'Go';
            label.appendChild(input);
            filter.appendChild(label);
            filter.appendChild(document$$1.createTextNode(' '));
            filter.appendChild(button);
            addEvent(filter, 'submit', interceptNavigation);
            return filter;
        }
        function moduleListHtml() {
            var i, checked, html = '';
            for (i = 0; i < config.modules.length; i++) {
                if (config.modules[i].name !== '') {
                    checked = config.moduleId.indexOf(config.modules[i].moduleId) > -1;
                    html += '<li><label class=\'clickable' + (checked ? ' checked' : '') + '\'><input type=\'checkbox\' ' + 'value=\'' + config.modules[i].moduleId + '\'' + (checked ? ' checked=\'checked\'' : '') + ' />' + escapeText(config.modules[i].name) + '</label></li>';
                }
            }
            return html;
        }
        function toolbarModuleFilter() {
            var allCheckbox, commit, reset, moduleFilter = document$$1.createElement('form'), label = document$$1.createElement('label'), moduleSearch = document$$1.createElement('input'), dropDown = document$$1.createElement('div'), actions = document$$1.createElement('span'), dropDownList = document$$1.createElement('ul'), dirty = false;
            moduleSearch.id = 'qunit-modulefilter-search';
            addEvent(moduleSearch, 'input', searchInput);
            addEvent(moduleSearch, 'input', searchFocus);
            addEvent(moduleSearch, 'focus', searchFocus);
            addEvent(moduleSearch, 'click', searchFocus);
            label.id = 'qunit-modulefilter-search-container';
            label.innerHTML = 'Module: ';
            label.appendChild(moduleSearch);
            actions.id = 'qunit-modulefilter-actions';
            actions.innerHTML = '<button style=\'display:none\'>Apply</button>' + '<button type=\'reset\' style=\'display:none\'>Reset</button>' + '<label class=\'clickable' + (config.moduleId.length ? '' : ' checked') + '\'><input type=\'checkbox\'' + (config.moduleId.length ? '' : ' checked=\'checked\'') + '>All modules</label>';
            allCheckbox = actions.lastChild.firstChild;
            commit = actions.firstChild;
            reset = commit.nextSibling;
            addEvent(commit, 'click', applyUrlParams);
            dropDownList.id = 'qunit-modulefilter-dropdown-list';
            dropDownList.innerHTML = moduleListHtml();
            dropDown.id = 'qunit-modulefilter-dropdown';
            dropDown.style.display = 'none';
            dropDown.appendChild(actions);
            dropDown.appendChild(dropDownList);
            addEvent(dropDown, 'change', selectionChange);
            selectionChange();
            moduleFilter.id = 'qunit-modulefilter';
            moduleFilter.appendChild(label);
            moduleFilter.appendChild(dropDown);
            addEvent(moduleFilter, 'submit', interceptNavigation);
            addEvent(moduleFilter, 'reset', function () {
                window.setTimeout(selectionChange);
            });
            function searchFocus() {
                if (dropDown.style.display !== 'none') {
                    return;
                }
                dropDown.style.display = 'block';
                addEvent(document$$1, 'click', hideHandler);
                addEvent(document$$1, 'keydown', hideHandler);
                function hideHandler(e) {
                    var inContainer = moduleFilter.contains(e.target);
                    if (e.keyCode === 27 || !inContainer) {
                        if (e.keyCode === 27 && inContainer) {
                            moduleSearch.focus();
                        }
                        dropDown.style.display = 'none';
                        removeEvent(document$$1, 'click', hideHandler);
                        removeEvent(document$$1, 'keydown', hideHandler);
                        moduleSearch.value = '';
                        searchInput();
                    }
                }
            }
            function searchInput() {
                var i, item, searchText = moduleSearch.value.toLowerCase(), listItems = dropDownList.children;
                for (i = 0; i < listItems.length; i++) {
                    item = listItems[i];
                    if (!searchText || item.textContent.toLowerCase().indexOf(searchText) > -1) {
                        item.style.display = '';
                    } else {
                        item.style.display = 'none';
                    }
                }
            }
            function selectionChange(evt) {
                var i, item, checkbox = evt && evt.target || allCheckbox, modulesList = dropDownList.getElementsByTagName('input'), selectedNames = [];
                toggleClass(checkbox.parentNode, 'checked', checkbox.checked);
                dirty = false;
                if (checkbox.checked && checkbox !== allCheckbox) {
                    allCheckbox.checked = false;
                    removeClass(allCheckbox.parentNode, 'checked');
                }
                for (i = 0; i < modulesList.length; i++) {
                    item = modulesList[i];
                    if (!evt) {
                        toggleClass(item.parentNode, 'checked', item.checked);
                    } else if (checkbox === allCheckbox && checkbox.checked) {
                        item.checked = false;
                        removeClass(item.parentNode, 'checked');
                    }
                    dirty = dirty || item.checked !== item.defaultChecked;
                    if (item.checked) {
                        selectedNames.push(item.parentNode.textContent);
                    }
                }
                commit.style.display = reset.style.display = dirty ? '' : 'none';
                moduleSearch.placeholder = selectedNames.join(', ') || allCheckbox.parentNode.textContent;
                moduleSearch.title = 'Type to filter list. Current selection:\n' + (selectedNames.join('\n') || allCheckbox.parentNode.textContent);
            }
            return moduleFilter;
        }
        function appendToolbar() {
            var toolbar = id('qunit-testrunner-toolbar');
            if (toolbar) {
                toolbar.appendChild(toolbarUrlConfigContainer());
                toolbar.appendChild(toolbarModuleFilter());
                toolbar.appendChild(toolbarLooseFilter());
                toolbar.appendChild(document$$1.createElement('div')).className = 'clearfix';
            }
        }
        function appendHeader() {
            var header = id('qunit-header');
            if (header) {
                header.innerHTML = '<a href=\'' + escapeText(unfilteredUrl) + '\'>' + header.innerHTML + '</a> ';
            }
        }
        function appendBanner() {
            var banner = id('qunit-banner');
            if (banner) {
                banner.className = '';
            }
        }
        function appendTestResults() {
            var tests = id('qunit-tests'), result = id('qunit-testresult'), controls;
            if (result) {
                result.parentNode.removeChild(result);
            }
            if (tests) {
                tests.innerHTML = '';
                result = document$$1.createElement('p');
                result.id = 'qunit-testresult';
                result.className = 'result';
                tests.parentNode.insertBefore(result, tests);
                result.innerHTML = '<div id="qunit-testresult-display">Running...<br />&#160;</div>' + '<div id="qunit-testresult-controls"></div>' + '<div class="clearfix"></div>';
                controls = id('qunit-testresult-controls');
            }
            if (controls) {
                controls.appendChild(abortTestsButton());
            }
        }
        function appendFilteredTest() {
            var testId = QUnit.config.testId;
            if (!testId || testId.length <= 0) {
                return '';
            }
            return '<div id=\'qunit-filteredTest\'>Rerunning selected tests: ' + escapeText(testId.join(', ')) + ' <a id=\'qunit-clearFilter\' href=\'' + escapeText(unfilteredUrl) + '\'>Run all tests</a></div>';
        }
        function appendUserAgent() {
            var userAgent = id('qunit-userAgent');
            if (userAgent) {
                userAgent.innerHTML = '';
                userAgent.appendChild(document$$1.createTextNode('QUnit ' + QUnit.version + '; ' + navigator.userAgent));
            }
        }
        function appendInterface() {
            var qunit = id('qunit');
            if (qunit) {
                qunit.innerHTML = '<h1 id=\'qunit-header\'>' + escapeText(document$$1.title) + '</h1>' + '<h2 id=\'qunit-banner\'></h2>' + '<div id=\'qunit-testrunner-toolbar\'></div>' + appendFilteredTest() + '<h2 id=\'qunit-userAgent\'></h2>' + '<ol id=\'qunit-tests\'></ol>';
            }
            appendHeader();
            appendBanner();
            appendTestResults();
            appendUserAgent();
            appendToolbar();
        }
        function appendTestsList(modules) {
            var i, l, x, z, test, moduleObj;
            for (i = 0, l = modules.length; i < l; i++) {
                moduleObj = modules[i];
                for (x = 0, z = moduleObj.tests.length; x < z; x++) {
                    test = moduleObj.tests[x];
                    appendTest(test.name, test.testId, moduleObj.name);
                }
            }
        }
        function appendTest(name, testId, moduleName) {
            var title, rerunTrigger, testBlock, assertList, tests = id('qunit-tests');
            if (!tests) {
                return;
            }
            title = document$$1.createElement('strong');
            title.innerHTML = getNameHtml(name, moduleName);
            rerunTrigger = document$$1.createElement('a');
            rerunTrigger.innerHTML = 'Rerun';
            rerunTrigger.href = setUrl({ testId: testId });
            testBlock = document$$1.createElement('li');
            testBlock.appendChild(title);
            testBlock.appendChild(rerunTrigger);
            testBlock.id = 'qunit-test-output-' + testId;
            assertList = document$$1.createElement('ol');
            assertList.className = 'qunit-assert-list';
            testBlock.appendChild(assertList);
            tests.appendChild(testBlock);
        }
        QUnit.begin(function (details) {
            var i, moduleObj, tests;
            for (i = 0; i < details.modules.length; i++) {
                moduleObj = details.modules[i];
                if (moduleObj.name) {
                    modulesList.push(moduleObj.name);
                }
            }
            modulesList.sort(function (a, b) {
                return a.localeCompare(b);
            });
            appendInterface();
            appendTestsList(details.modules);
            tests = id('qunit-tests');
            if (tests && config.hidepassed) {
                addClass(tests, 'hidepass');
            }
        });
        QUnit.done(function (details) {
            var banner = id('qunit-banner'), tests = id('qunit-tests'), abortButton = id('qunit-abort-tests-button'), totalTests = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests, html = [
                    totalTests,
                    ' tests completed in ',
                    details.runtime,
                    ' milliseconds, with ',
                    stats.failedTests,
                    ' failed, ',
                    stats.skippedTests,
                    ' skipped, and ',
                    stats.todoTests,
                    ' todo.<br />',
                    '<span class=\'passed\'>',
                    details.passed,
                    '</span> assertions of <span class=\'total\'>',
                    details.total,
                    '</span> passed, <span class=\'failed\'>',
                    details.failed,
                    '</span> failed.'
                ].join(''), test, assertLi, assertList;
            if (abortButton && abortButton.disabled) {
                html = 'Tests aborted after ' + details.runtime + ' milliseconds.';
                for (var i = 0; i < tests.children.length; i++) {
                    test = tests.children[i];
                    if (test.className === '' || test.className === 'running') {
                        test.className = 'aborted';
                        assertList = test.getElementsByTagName('ol')[0];
                        assertLi = document$$1.createElement('li');
                        assertLi.className = 'fail';
                        assertLi.innerHTML = 'Test aborted.';
                        assertList.appendChild(assertLi);
                    }
                }
            }
            if (banner && (!abortButton || abortButton.disabled === false)) {
                banner.className = stats.failedTests ? 'qunit-fail' : 'qunit-pass';
            }
            if (abortButton) {
                abortButton.parentNode.removeChild(abortButton);
            }
            if (tests) {
                id('qunit-testresult-display').innerHTML = html;
            }
            if (config.altertitle && document$$1.title) {
                document$$1.title = [
                    stats.failedTests ? '\u2716' : '\u2714',
                    document$$1.title.replace(/^[\u2714\u2716] /i, '')
                ].join(' ');
            }
            if (config.scrolltop && window.scrollTo) {
                window.scrollTo(0, 0);
            }
        });
        function getNameHtml(name, module) {
            var nameHtml = '';
            if (module) {
                nameHtml = '<span class=\'module-name\'>' + escapeText(module) + '</span>: ';
            }
            nameHtml += '<span class=\'test-name\'>' + escapeText(name) + '</span>';
            return nameHtml;
        }
        QUnit.testStart(function (details) {
            var running, testBlock, bad;
            testBlock = id('qunit-test-output-' + details.testId);
            if (testBlock) {
                testBlock.className = 'running';
            } else {
                appendTest(details.name, details.testId, details.module);
            }
            running = id('qunit-testresult-display');
            if (running) {
                bad = QUnit.config.reorder && details.previousFailure;
                running.innerHTML = [
                    bad ? 'Rerunning previously failed test: <br />' : 'Running: <br />',
                    getNameHtml(details.name, details.module)
                ].join('');
            }
        });
        function stripHtml(string) {
            return string.replace(/<\/?[^>]+(>|$)/g, '').replace(/\&quot;/g, '').replace(/\s+/g, '');
        }
        QUnit.log(function (details) {
            var assertList, assertLi, message, expected, actual, diff, showDiff = false, testItem = id('qunit-test-output-' + details.testId);
            if (!testItem) {
                return;
            }
            message = escapeText(details.message) || (details.result ? 'okay' : 'failed');
            message = '<span class=\'test-message\'>' + message + '</span>';
            message += '<span class=\'runtime\'>@ ' + details.runtime + ' ms</span>';
            if (!details.result && hasOwn.call(details, 'expected')) {
                if (details.negative) {
                    expected = 'NOT ' + QUnit.dump.parse(details.expected);
                } else {
                    expected = QUnit.dump.parse(details.expected);
                }
                actual = QUnit.dump.parse(details.actual);
                message += '<table><tr class=\'test-expected\'><th>Expected: </th><td><pre>' + escapeText(expected) + '</pre></td></tr>';
                if (actual !== expected) {
                    message += '<tr class=\'test-actual\'><th>Result: </th><td><pre>' + escapeText(actual) + '</pre></td></tr>';
                    if (typeof details.actual === 'number' && typeof details.expected === 'number') {
                        if (!isNaN(details.actual) && !isNaN(details.expected)) {
                            showDiff = true;
                            diff = details.actual - details.expected;
                            diff = (diff > 0 ? '+' : '') + diff;
                        }
                    } else if (typeof details.actual !== 'boolean' && typeof details.expected !== 'boolean') {
                        diff = QUnit.diff(expected, actual);
                        showDiff = stripHtml(diff).length !== stripHtml(expected).length + stripHtml(actual).length;
                    }
                    if (showDiff) {
                        message += '<tr class=\'test-diff\'><th>Diff: </th><td><pre>' + diff + '</pre></td></tr>';
                    }
                } else if (expected.indexOf('[object Array]') !== -1 || expected.indexOf('[object Object]') !== -1) {
                    message += '<tr class=\'test-message\'><th>Message: </th><td>' + 'Diff suppressed as the depth of object is more than current max depth (' + QUnit.config.maxDepth + ').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to ' + ' run with a higher max depth or <a href=\'' + escapeText(setUrl({ maxDepth: -1 })) + '\'>' + 'Rerun</a> without max depth.</p></td></tr>';
                } else {
                    message += '<tr class=\'test-message\'><th>Message: </th><td>' + 'Diff suppressed as the expected and actual results have an equivalent' + ' serialization</td></tr>';
                }
                if (details.source) {
                    message += '<tr class=\'test-source\'><th>Source: </th><td><pre>' + escapeText(details.source) + '</pre></td></tr>';
                }
                message += '</table>';
            } else if (!details.result && details.source) {
                message += '<table>' + '<tr class=\'test-source\'><th>Source: </th><td><pre>' + escapeText(details.source) + '</pre></td></tr>' + '</table>';
            }
            assertList = testItem.getElementsByTagName('ol')[0];
            assertLi = document$$1.createElement('li');
            assertLi.className = details.result ? 'pass' : 'fail';
            assertLi.innerHTML = message;
            assertList.appendChild(assertLi);
        });
        QUnit.testDone(function (details) {
            var testTitle, time, testItem, assertList, good, bad, testCounts, skipped, sourceName, tests = id('qunit-tests');
            if (!tests) {
                return;
            }
            testItem = id('qunit-test-output-' + details.testId);
            assertList = testItem.getElementsByTagName('ol')[0];
            good = details.passed;
            bad = details.failed;
            var testPassed = details.failed > 0 ? details.todo : !details.todo;
            if (testPassed) {
                addClass(assertList, 'qunit-collapsed');
            } else if (config.collapse) {
                if (!collapseNext) {
                    collapseNext = true;
                } else {
                    addClass(assertList, 'qunit-collapsed');
                }
            }
            testTitle = testItem.firstChild;
            testCounts = bad ? '<b class=\'failed\'>' + bad + '</b>, ' + '<b class=\'passed\'>' + good + '</b>, ' : '';
            testTitle.innerHTML += ' <b class=\'counts\'>(' + testCounts + details.assertions.length + ')</b>';
            if (details.skipped) {
                stats.skippedTests++;
                testItem.className = 'skipped';
                skipped = document$$1.createElement('em');
                skipped.className = 'qunit-skipped-label';
                skipped.innerHTML = 'skipped';
                testItem.insertBefore(skipped, testTitle);
            } else {
                addEvent(testTitle, 'click', function () {
                    toggleClass(assertList, 'qunit-collapsed');
                });
                testItem.className = testPassed ? 'pass' : 'fail';
                if (details.todo) {
                    var todoLabel = document$$1.createElement('em');
                    todoLabel.className = 'qunit-todo-label';
                    todoLabel.innerHTML = 'todo';
                    testItem.className += ' todo';
                    testItem.insertBefore(todoLabel, testTitle);
                }
                time = document$$1.createElement('span');
                time.className = 'runtime';
                time.innerHTML = details.runtime + ' ms';
                testItem.insertBefore(time, assertList);
                if (!testPassed) {
                    stats.failedTests++;
                } else if (details.todo) {
                    stats.todoTests++;
                } else {
                    stats.passedTests++;
                }
            }
            if (details.source) {
                sourceName = document$$1.createElement('p');
                sourceName.innerHTML = '<strong>Source: </strong>' + details.source;
                addClass(sourceName, 'qunit-source');
                if (testPassed) {
                    addClass(sourceName, 'qunit-collapsed');
                }
                addEvent(testTitle, 'click', function () {
                    toggleClass(sourceName, 'qunit-collapsed');
                });
                testItem.appendChild(sourceName);
            }
        });
        var notPhantom = function (p) {
            return !(p && p.version && p.version.major > 0);
        }(window.phantom);
        if (notPhantom && document$$1.readyState === 'complete') {
            QUnit.load();
        } else {
            addEvent(window, 'load', QUnit.load);
        }
        var originalWindowOnError = window.onerror;
        window.onerror = function (message, fileName, lineNumber) {
            var ret = false;
            if (originalWindowOnError) {
                for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
                    args[_key - 3] = arguments[_key];
                }
                ret = originalWindowOnError.call.apply(originalWindowOnError, [
                    this,
                    message,
                    fileName,
                    lineNumber
                ].concat(args));
            }
            if (ret !== true) {
                var error = {
                    message: message,
                    fileName: fileName,
                    lineNumber: lineNumber
                };
                ret = QUnit.onError(error);
            }
            return ret;
        };
    }());
    QUnit.diff = function () {
        function DiffMatchPatch() {
        }
        var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
        DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {
            var deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;
            deadline = new Date().getTime() + 1000;
            if (text1 === null || text2 === null) {
                throw new Error('Null input. (DiffMain)');
            }
            if (text1 === text2) {
                if (text1) {
                    return [[
                            DIFF_EQUAL,
                            text1
                        ]];
                }
                return [];
            }
            if (typeof optChecklines === 'undefined') {
                optChecklines = true;
            }
            checklines = optChecklines;
            commonlength = this.diffCommonPrefix(text1, text2);
            commonprefix = text1.substring(0, commonlength);
            text1 = text1.substring(commonlength);
            text2 = text2.substring(commonlength);
            commonlength = this.diffCommonSuffix(text1, text2);
            commonsuffix = text1.substring(text1.length - commonlength);
            text1 = text1.substring(0, text1.length - commonlength);
            text2 = text2.substring(0, text2.length - commonlength);
            diffs = this.diffCompute(text1, text2, checklines, deadline);
            if (commonprefix) {
                diffs.unshift([
                    DIFF_EQUAL,
                    commonprefix
                ]);
            }
            if (commonsuffix) {
                diffs.push([
                    DIFF_EQUAL,
                    commonsuffix
                ]);
            }
            this.diffCleanupMerge(diffs);
            return diffs;
        };
        DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {
            var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;
            changes = false;
            equalities = [];
            equalitiesLength = 0;
            lastequality = null;
            pointer = 0;
            preIns = false;
            preDel = false;
            postIns = false;
            postDel = false;
            while (pointer < diffs.length) {
                if (diffs[pointer][0] === DIFF_EQUAL) {
                    if (diffs[pointer][1].length < 4 && (postIns || postDel)) {
                        equalities[equalitiesLength++] = pointer;
                        preIns = postIns;
                        preDel = postDel;
                        lastequality = diffs[pointer][1];
                    } else {
                        equalitiesLength = 0;
                        lastequality = null;
                    }
                    postIns = postDel = false;
                } else {
                    if (diffs[pointer][0] === DIFF_DELETE) {
                        postDel = true;
                    } else {
                        postIns = true;
                    }
                    if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {
                        diffs.splice(equalities[equalitiesLength - 1], 0, [
                            DIFF_DELETE,
                            lastequality
                        ]);
                        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                        equalitiesLength--;
                        lastequality = null;
                        if (preIns && preDel) {
                            postIns = postDel = true;
                            equalitiesLength = 0;
                        } else {
                            equalitiesLength--;
                            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                            postIns = postDel = false;
                        }
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
        };
        DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {
            var op, data, x, html = [];
            for (x = 0; x < diffs.length; x++) {
                op = diffs[x][0];
                data = diffs[x][1];
                switch (op) {
                case DIFF_INSERT:
                    html[x] = '<ins>' + escapeText(data) + '</ins>';
                    break;
                case DIFF_DELETE:
                    html[x] = '<del>' + escapeText(data) + '</del>';
                    break;
                case DIFF_EQUAL:
                    html[x] = '<span>' + escapeText(data) + '</span>';
                    break;
                }
            }
            return html.join('');
        };
        DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {
            var pointermid, pointermax, pointermin, pointerstart;
            if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
                return 0;
            }
            pointermin = 0;
            pointermax = Math.min(text1.length, text2.length);
            pointermid = pointermax;
            pointerstart = 0;
            while (pointermin < pointermid) {
                if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
                    pointermin = pointermid;
                    pointerstart = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
        };
        DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {
            var pointermid, pointermax, pointermin, pointerend;
            if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
                return 0;
            }
            pointermin = 0;
            pointermax = Math.min(text1.length, text2.length);
            pointermid = pointermax;
            pointerend = 0;
            while (pointermin < pointermid) {
                if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
                    pointermin = pointermid;
                    pointerend = pointermin;
                } else {
                    pointermax = pointermid;
                }
                pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
            }
            return pointermid;
        };
        DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {
            var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;
            if (!text1) {
                return [[
                        DIFF_INSERT,
                        text2
                    ]];
            }
            if (!text2) {
                return [[
                        DIFF_DELETE,
                        text1
                    ]];
            }
            longtext = text1.length > text2.length ? text1 : text2;
            shorttext = text1.length > text2.length ? text2 : text1;
            i = longtext.indexOf(shorttext);
            if (i !== -1) {
                diffs = [
                    [
                        DIFF_INSERT,
                        longtext.substring(0, i)
                    ],
                    [
                        DIFF_EQUAL,
                        shorttext
                    ],
                    [
                        DIFF_INSERT,
                        longtext.substring(i + shorttext.length)
                    ]
                ];
                if (text1.length > text2.length) {
                    diffs[0][0] = diffs[2][0] = DIFF_DELETE;
                }
                return diffs;
            }
            if (shorttext.length === 1) {
                return [
                    [
                        DIFF_DELETE,
                        text1
                    ],
                    [
                        DIFF_INSERT,
                        text2
                    ]
                ];
            }
            hm = this.diffHalfMatch(text1, text2);
            if (hm) {
                text1A = hm[0];
                text1B = hm[1];
                text2A = hm[2];
                text2B = hm[3];
                midCommon = hm[4];
                diffsA = this.DiffMain(text1A, text2A, checklines, deadline);
                diffsB = this.DiffMain(text1B, text2B, checklines, deadline);
                return diffsA.concat([[
                        DIFF_EQUAL,
                        midCommon
                    ]], diffsB);
            }
            if (checklines && text1.length > 100 && text2.length > 100) {
                return this.diffLineMode(text1, text2, deadline);
            }
            return this.diffBisect(text1, text2, deadline);
        };
        DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {
            var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;
            longtext = text1.length > text2.length ? text1 : text2;
            shorttext = text1.length > text2.length ? text2 : text1;
            if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
                return null;
            }
            dmp = this;
            function diffHalfMatchI(longtext, shorttext, i) {
                var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;
                seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
                j = -1;
                bestCommon = '';
                while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
                    prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));
                    suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
                    if (bestCommon.length < suffixLength + prefixLength) {
                        bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                        bestLongtextA = longtext.substring(0, i - suffixLength);
                        bestLongtextB = longtext.substring(i + prefixLength);
                        bestShorttextA = shorttext.substring(0, j - suffixLength);
                        bestShorttextB = shorttext.substring(j + prefixLength);
                    }
                }
                if (bestCommon.length * 2 >= longtext.length) {
                    return [
                        bestLongtextA,
                        bestLongtextB,
                        bestShorttextA,
                        bestShorttextB,
                        bestCommon
                    ];
                } else {
                    return null;
                }
            }
            hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
            hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
            if (!hm1 && !hm2) {
                return null;
            } else if (!hm2) {
                hm = hm1;
            } else if (!hm1) {
                hm = hm2;
            } else {
                hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
            }
            if (text1.length > text2.length) {
                text1A = hm[0];
                text1B = hm[1];
                text2A = hm[2];
                text2B = hm[3];
            } else {
                text2A = hm[0];
                text2B = hm[1];
                text1A = hm[2];
                text1B = hm[3];
            }
            midCommon = hm[4];
            return [
                text1A,
                text1B,
                text2A,
                text2B,
                midCommon
            ];
        };
        DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {
            var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;
            a = this.diffLinesToChars(text1, text2);
            text1 = a.chars1;
            text2 = a.chars2;
            linearray = a.lineArray;
            diffs = this.DiffMain(text1, text2, false, deadline);
            this.diffCharsToLines(diffs, linearray);
            this.diffCleanupSemantic(diffs);
            diffs.push([
                DIFF_EQUAL,
                ''
            ]);
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = '';
            textInsert = '';
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    countInsert++;
                    textInsert += diffs[pointer][1];
                    break;
                case DIFF_DELETE:
                    countDelete++;
                    textDelete += diffs[pointer][1];
                    break;
                case DIFF_EQUAL:
                    if (countDelete >= 1 && countInsert >= 1) {
                        diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
                        pointer = pointer - countDelete - countInsert;
                        a = this.DiffMain(textDelete, textInsert, false, deadline);
                        for (j = a.length - 1; j >= 0; j--) {
                            diffs.splice(pointer, 0, a[j]);
                        }
                        pointer = pointer + a.length;
                    }
                    countInsert = 0;
                    countDelete = 0;
                    textDelete = '';
                    textInsert = '';
                    break;
                }
                pointer++;
            }
            diffs.pop();
            return diffs;
        };
        DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {
            var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;
            text1Length = text1.length;
            text2Length = text2.length;
            maxD = Math.ceil((text1Length + text2Length) / 2);
            vOffset = maxD;
            vLength = 2 * maxD;
            v1 = new Array(vLength);
            v2 = new Array(vLength);
            for (x = 0; x < vLength; x++) {
                v1[x] = -1;
                v2[x] = -1;
            }
            v1[vOffset + 1] = 0;
            v2[vOffset + 1] = 0;
            delta = text1Length - text2Length;
            front = delta % 2 !== 0;
            k1start = 0;
            k1end = 0;
            k2start = 0;
            k2end = 0;
            for (d = 0; d < maxD; d++) {
                if (new Date().getTime() > deadline) {
                    break;
                }
                for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
                    k1Offset = vOffset + k1;
                    if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
                        x1 = v1[k1Offset + 1];
                    } else {
                        x1 = v1[k1Offset - 1] + 1;
                    }
                    y1 = x1 - k1;
                    while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
                        x1++;
                        y1++;
                    }
                    v1[k1Offset] = x1;
                    if (x1 > text1Length) {
                        k1end += 2;
                    } else if (y1 > text2Length) {
                        k1start += 2;
                    } else if (front) {
                        k2Offset = vOffset + delta - k1;
                        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
                            x2 = text1Length - v2[k2Offset];
                            if (x1 >= x2) {
                                return this.diffBisectSplit(text1, text2, x1, y1, deadline);
                            }
                        }
                    }
                }
                for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
                    k2Offset = vOffset + k2;
                    if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
                        x2 = v2[k2Offset + 1];
                    } else {
                        x2 = v2[k2Offset - 1] + 1;
                    }
                    y2 = x2 - k2;
                    while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
                        x2++;
                        y2++;
                    }
                    v2[k2Offset] = x2;
                    if (x2 > text1Length) {
                        k2end += 2;
                    } else if (y2 > text2Length) {
                        k2start += 2;
                    } else if (!front) {
                        k1Offset = vOffset + delta - k2;
                        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
                            x1 = v1[k1Offset];
                            y1 = vOffset + x1 - k1Offset;
                            x2 = text1Length - x2;
                            if (x1 >= x2) {
                                return this.diffBisectSplit(text1, text2, x1, y1, deadline);
                            }
                        }
                    }
                }
            }
            return [
                [
                    DIFF_DELETE,
                    text1
                ],
                [
                    DIFF_INSERT,
                    text2
                ]
            ];
        };
        DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {
            var text1a, text1b, text2a, text2b, diffs, diffsb;
            text1a = text1.substring(0, x);
            text2a = text2.substring(0, y);
            text1b = text1.substring(x);
            text2b = text2.substring(y);
            diffs = this.DiffMain(text1a, text2a, false, deadline);
            diffsb = this.DiffMain(text1b, text2b, false, deadline);
            return diffs.concat(diffsb);
        };
        DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {
            var changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
            changes = false;
            equalities = [];
            equalitiesLength = 0;
            lastequality = null;
            pointer = 0;
            lengthInsertions1 = 0;
            lengthDeletions1 = 0;
            lengthInsertions2 = 0;
            lengthDeletions2 = 0;
            while (pointer < diffs.length) {
                if (diffs[pointer][0] === DIFF_EQUAL) {
                    equalities[equalitiesLength++] = pointer;
                    lengthInsertions1 = lengthInsertions2;
                    lengthDeletions1 = lengthDeletions2;
                    lengthInsertions2 = 0;
                    lengthDeletions2 = 0;
                    lastequality = diffs[pointer][1];
                } else {
                    if (diffs[pointer][0] === DIFF_INSERT) {
                        lengthInsertions2 += diffs[pointer][1].length;
                    } else {
                        lengthDeletions2 += diffs[pointer][1].length;
                    }
                    if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {
                        diffs.splice(equalities[equalitiesLength - 1], 0, [
                            DIFF_DELETE,
                            lastequality
                        ]);
                        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                        equalitiesLength--;
                        equalitiesLength--;
                        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                        lengthInsertions1 = 0;
                        lengthDeletions1 = 0;
                        lengthInsertions2 = 0;
                        lengthDeletions2 = 0;
                        lastequality = null;
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
            pointer = 1;
            while (pointer < diffs.length) {
                if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
                    deletion = diffs[pointer - 1][1];
                    insertion = diffs[pointer][1];
                    overlapLength1 = this.diffCommonOverlap(deletion, insertion);
                    overlapLength2 = this.diffCommonOverlap(insertion, deletion);
                    if (overlapLength1 >= overlapLength2) {
                        if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [
                                DIFF_EQUAL,
                                insertion.substring(0, overlapLength1)
                            ]);
                            diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
                            diffs[pointer + 1][1] = insertion.substring(overlapLength1);
                            pointer++;
                        }
                    } else {
                        if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {
                            diffs.splice(pointer, 0, [
                                DIFF_EQUAL,
                                deletion.substring(0, overlapLength2)
                            ]);
                            diffs[pointer - 1][0] = DIFF_INSERT;
                            diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
                            diffs[pointer + 1][0] = DIFF_DELETE;
                            diffs[pointer + 1][1] = deletion.substring(overlapLength2);
                            pointer++;
                        }
                    }
                    pointer++;
                }
                pointer++;
            }
        };
        DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {
            var text1Length, text2Length, textLength, best, length, pattern, found;
            text1Length = text1.length;
            text2Length = text2.length;
            if (text1Length === 0 || text2Length === 0) {
                return 0;
            }
            if (text1Length > text2Length) {
                text1 = text1.substring(text1Length - text2Length);
            } else if (text1Length < text2Length) {
                text2 = text2.substring(0, text1Length);
            }
            textLength = Math.min(text1Length, text2Length);
            if (text1 === text2) {
                return textLength;
            }
            best = 0;
            length = 1;
            while (true) {
                pattern = text1.substring(textLength - length);
                found = text2.indexOf(pattern);
                if (found === -1) {
                    return best;
                }
                length += found;
                if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {
                    best = length;
                    length++;
                }
            }
        };
        DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {
            var lineArray, lineHash, chars1, chars2;
            lineArray = [];
            lineHash = {};
            lineArray[0] = '';
            function diffLinesToCharsMunge(text) {
                var chars, lineStart, lineEnd, lineArrayLength, line;
                chars = '';
                lineStart = 0;
                lineEnd = -1;
                lineArrayLength = lineArray.length;
                while (lineEnd < text.length - 1) {
                    lineEnd = text.indexOf('\n', lineStart);
                    if (lineEnd === -1) {
                        lineEnd = text.length - 1;
                    }
                    line = text.substring(lineStart, lineEnd + 1);
                    lineStart = lineEnd + 1;
                    var lineHashExists = lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined;
                    if (lineHashExists) {
                        chars += String.fromCharCode(lineHash[line]);
                    } else {
                        chars += String.fromCharCode(lineArrayLength);
                        lineHash[line] = lineArrayLength;
                        lineArray[lineArrayLength++] = line;
                    }
                }
                return chars;
            }
            chars1 = diffLinesToCharsMunge(text1);
            chars2 = diffLinesToCharsMunge(text2);
            return {
                chars1: chars1,
                chars2: chars2,
                lineArray: lineArray
            };
        };
        DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {
            var x, chars, text, y;
            for (x = 0; x < diffs.length; x++) {
                chars = diffs[x][1];
                text = [];
                for (y = 0; y < chars.length; y++) {
                    text[y] = lineArray[chars.charCodeAt(y)];
                }
                diffs[x][1] = text.join('');
            }
        };
        DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {
            var pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;
            diffs.push([
                DIFF_EQUAL,
                ''
            ]);
            pointer = 0;
            countDelete = 0;
            countInsert = 0;
            textDelete = '';
            textInsert = '';
            while (pointer < diffs.length) {
                switch (diffs[pointer][0]) {
                case DIFF_INSERT:
                    countInsert++;
                    textInsert += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_DELETE:
                    countDelete++;
                    textDelete += diffs[pointer][1];
                    pointer++;
                    break;
                case DIFF_EQUAL:
                    if (countDelete + countInsert > 1) {
                        if (countDelete !== 0 && countInsert !== 0) {
                            commonlength = this.diffCommonPrefix(textInsert, textDelete);
                            if (commonlength !== 0) {
                                if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
                                    diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
                                } else {
                                    diffs.splice(0, 0, [
                                        DIFF_EQUAL,
                                        textInsert.substring(0, commonlength)
                                    ]);
                                    pointer++;
                                }
                                textInsert = textInsert.substring(commonlength);
                                textDelete = textDelete.substring(commonlength);
                            }
                            commonlength = this.diffCommonSuffix(textInsert, textDelete);
                            if (commonlength !== 0) {
                                diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
                                textInsert = textInsert.substring(0, textInsert.length - commonlength);
                                textDelete = textDelete.substring(0, textDelete.length - commonlength);
                            }
                        }
                        if (countDelete === 0) {
                            diffs.splice(pointer - countInsert, countDelete + countInsert, [
                                DIFF_INSERT,
                                textInsert
                            ]);
                        } else if (countInsert === 0) {
                            diffs.splice(pointer - countDelete, countDelete + countInsert, [
                                DIFF_DELETE,
                                textDelete
                            ]);
                        } else {
                            diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [
                                DIFF_DELETE,
                                textDelete
                            ], [
                                DIFF_INSERT,
                                textInsert
                            ]);
                        }
                        pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;
                    } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                        diffs[pointer - 1][1] += diffs[pointer][1];
                        diffs.splice(pointer, 1);
                    } else {
                        pointer++;
                    }
                    countInsert = 0;
                    countDelete = 0;
                    textDelete = '';
                    textInsert = '';
                    break;
                }
            }
            if (diffs[diffs.length - 1][1] === '') {
                diffs.pop();
            }
            changes = false;
            pointer = 1;
            while (pointer < diffs.length - 1) {
                if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
                    diffPointer = diffs[pointer][1];
                    position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);
                    if (position === diffs[pointer - 1][1]) {
                        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
                        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                        diffs.splice(pointer - 1, 1);
                        changes = true;
                    } else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
                        diffs[pointer - 1][1] += diffs[pointer + 1][1];
                        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
                        diffs.splice(pointer + 1, 1);
                        changes = true;
                    }
                }
                pointer++;
            }
            if (changes) {
                this.diffCleanupMerge(diffs);
            }
        };
        return function (o, n) {
            var diff, output, text;
            diff = new DiffMatchPatch();
            output = diff.DiffMain(o, n);
            diff.diffCleanupEfficiency(output);
            text = diff.diffPrettyHtml(output);
            return text;
        };
    }();
}(function () {
    return this;
}()));
/*can-util@3.14.0#test/qunit*/
define('can-util@3.14.0#test/qunit', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isQunit = testType === 'qunit';
    if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-util@3.14.0#js/assign-non-enumerable/assign-non-enumerable-test*/
define('can-util@3.14.0#js/assign-non-enumerable/assign-non-enumerable-test', [
    'require',
    'exports',
    'module',
    './assign-non-enumerable',
    '../../test/qunit'
], function (require, exports, module) {
    var assignNonEnumerable = require('./assign-non-enumerable');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/assign-non-enumerable');
    QUnit.test('Assign all properties to an object', function (assert) {
        var a = { a: 1 };
        var b = {
            b: 3,
            c: 2
        };
        var actual = assignNonEnumerable(a, b);
        assert.equal(a, actual);
        for (var prop in a) {
            if (prop !== 'a') {
                assert.ok(false, 'we got a prop of ' + prop);
            }
        }
        assert.equal(actual.b, 3);
        assert.equal(actual.c, 2);
        actual.b = 'B';
        assert.equal(actual.b, 'B');
    });
});
/*can-util@3.14.0#js/base-url/base-url-test*/
define('can-util@3.14.0#js/base-url/base-url-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './base-url',
    'can-globals/global/global',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var QUnit = require('../../test/qunit');
        var getBaseUrl = require('./base-url');
        var getGlobal = require('can-globals/global/global');
        var getDomDocument = require('can-globals/document/document');
        QUnit.module('can-util/js/base-url');
        QUnit.test('basics', function (assert) {
            var global = getGlobal(), domDocument = getDomDocument();
            if (domDocument && 'baseURI' in domDocument) {
                assert.ok(getBaseUrl() === global.document.baseURI, getBaseUrl());
            } else if (global.location) {
                assert.ok(getBaseUrl() === global.location.href.substr(0, global.location.href.lastIndexOf('/')), getBaseUrl());
            } else if (typeof process !== 'undefined') {
                assert.ok(getBaseUrl() === process.cwd(), getBaseUrl());
            }
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/deep-assign/deep-assign-test*/
define('can-util@3.14.0#js/deep-assign/deep-assign-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './deep-assign'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var deepAssign = require('./deep-assign');
    QUnit.module('can-util/js/deep-assign');
    QUnit.test('basics', function (assert) {
        var original = { nested: { foo: 'bar' } };
        var res = deepAssign(true, {}, original);
        assert.deepEqual(res, { nested: { foo: 'bar' } }, 'they look the same');
        assert.ok(res.nested !== original.nested, 'different objects');
    });
});
/*can-util@3.14.0#js/defaults/defaults-test*/
define('can-util@3.14.0#js/defaults/defaults-test', [
    'require',
    'exports',
    'module',
    './defaults',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var defaults = require('./defaults');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/defaults');
    QUnit.test('Assigns props from sources to object if they are undefined in object', function (assert) {
        var a = {
            a: 1,
            b: 2,
            c: 3
        };
        var b = {
            a: 2,
            b: 3,
            d: 4
        };
        var c = {
            d: 5,
            e: 5
        };
        var expected = {
            a: 1,
            b: 2,
            c: 3,
            d: 4,
            e: 5
        };
        var actual = defaults(a, b, c);
        for (var prop in actual) {
            assert.equal(expected[prop], actual[prop]);
        }
    });
});
/*can-util@3.14.0#js/diff/diff-test*/
define('can-util@3.14.0#js/diff/diff-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './diff'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diff = require('./diff');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function (assert) {
        var patches = diff([], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [], 'no changes');
        patches = diff([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diff([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diff([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        assert.deepEqual(patches, [
            {
                index: 2,
                insert: [],
                deleteCount: 1
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ]);
        patches = diff([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        assert.deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        assert.deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 1.5 },
            { id: 3 }
        ], function (a, b) {
            return a.id === b.id;
        });
        assert.deepEqual(patches, [{
                index: 1,
                deleteCount: 1,
                insert: [
                    { id: 1.5 },
                    { id: 3 }
                ]
            }], 'identity works');
        patches = diff([
            { id: 1 },
            { id: 2 }
        ], [
            { id: 1 },
            { id: 3 },
            { id: 2 }
        ], function (a, b) {
            return a.id === b.id;
        });
        assert.deepEqual(patches, [{
                index: 1,
                deleteCount: 0,
                insert: [{ id: 3 }]
            }], 'identity for a single middle insertion');
    });
});
/*can-util@3.14.0#js/diff-array/diff-array*/
define('can-util@3.14.0#js/diff-array/diff-array', [
    'require',
    'exports',
    'module',
    '../diff/diff'
], function (require, exports, module) {
    'use strict';
    var diff = require('../diff/diff');
    module.exports = exports = diff;
});
/*can-util@3.14.0#js/diff-array/diff-array-test*/
define('can-util@3.14.0#js/diff-array/diff-array-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './diff-array'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diffArray = require('./diff-array');
    QUnit.module('can-util/js/diff-array');
    QUnit.test('basics', function (assert) {
        var patches = diffArray([], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [{
                index: 0,
                deleteCount: 0,
                insert: [
                    1,
                    2,
                    3
                ]
            }], 'insert many at end');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3
        ]);
        assert.deepEqual(patches, [], 'no changes');
        patches = diffArray([
            1,
            2,
            3
        ], [
            1,
            2,
            3,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 3,
                deleteCount: 0,
                insert: [4]
            }], 'add one at the end');
        patches = diffArray([
            1,
            2,
            3,
            4
        ], [
            1,
            2,
            4
        ]);
        assert.deepEqual(patches, [{
                index: 2,
                deleteCount: 1,
                insert: []
            }], 'remove one in the middle');
        patches = diffArray([
            'a',
            'b',
            'z',
            'f',
            'x'
        ], [
            'a',
            'b',
            'f',
            'w',
            'z'
        ]);
        assert.deepEqual(patches, [
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: [
                    'w',
                    'z'
                ]
            }
        ], 'can delete one');
        patches = diffArray([
            'a',
            'b',
            'b'
        ], [
            'c',
            'a',
            'b'
        ]);
        assert.deepEqual(patches, [
            {
                index: 0,
                insert: ['c'],
                deleteCount: 0
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
        patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e',
            'f',
            'g'
        ], [
            'a',
            'c',
            'e',
            'g'
        ]);
        assert.deepEqual(patches, [
            {
                index: 1,
                insert: [],
                deleteCount: 1
            },
            {
                index: 2,
                deleteCount: 1,
                insert: []
            },
            {
                index: 3,
                deleteCount: 1,
                insert: []
            }
        ]);
    });
    QUnit.test('handle swaps at the end (#193)', function (assert) {
        var patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e'
        ], [
            'a',
            'x',
            'y',
            'z',
            'e'
        ]);
        assert.deepEqual(patches, [{
                index: 1,
                deleteCount: 3,
                insert: [
                    'x',
                    'y',
                    'z'
                ]
            }], 'handle reverse patch');
    });
    QUnit.test('handle swaps at the end after a delete (#193)', function (assert) {
        var patches = diffArray([
            'a',
            'b',
            'c',
            'd',
            'e'
        ], [
            'a',
            'x',
            'b',
            'y',
            'z',
            'e'
        ]);
        assert.deepEqual(patches, [
            {
                index: 1,
                deleteCount: 0,
                insert: ['x']
            },
            {
                index: 3,
                deleteCount: 2,
                insert: [
                    'y',
                    'z'
                ]
            }
        ], 'handle reverse patch');
    });
});
/*can-util@3.14.0#js/diff-object/diff-object*/
define('can-util@3.14.0#js/diff-object/diff-object', [
    'require',
    'exports',
    'module',
    'can-assign'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-assign');
    module.exports = exports = function (oldObject, newObject) {
        var oldObjectClone, patches = [];
        oldObjectClone = assign({}, oldObject);
        for (var newProp in newObject) {
            if (!oldObject || !oldObject.hasOwnProperty(newProp)) {
                patches.push({
                    property: newProp,
                    type: 'add',
                    value: newObject[newProp]
                });
            } else if (newObject[newProp] !== oldObject[newProp]) {
                patches.push({
                    property: newProp,
                    type: 'set',
                    value: newObject[newProp]
                });
            }
            delete oldObjectClone[newProp];
        }
        for (var oldProp in oldObjectClone) {
            patches.push({
                property: oldProp,
                type: 'remove'
            });
        }
        return patches;
    };
});
/*can-util@3.14.0#js/diff-object/diff-object-test*/
define('can-util@3.14.0#js/diff-object/diff-object-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './diff-object'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var diffObject = require('./diff-object');
    QUnit.module('can-util/js/diff');
    QUnit.test('basics', function (assert) {
        var patches = diffObject({}, { a: 'foo' });
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property');
        patches = diffObject(null, { a: 'foo' });
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'add',
                value: 'foo'
            }], 'add property - oldObject null');
        patches = diffObject({ a: 'foo' }, { a: 'bar' });
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'set',
                value: 'bar'
            }], 'change property');
        patches = diffObject({ a: 'foo' }, {});
        assert.deepEqual(patches, [{
                property: 'a',
                type: 'remove'
            }], 'remove property');
        patches = diffObject({
            a: 'foo',
            b: 'baz'
        }, {
            a: 'bar',
            c: 'quz'
        });
        assert.deepEqual(patches, [
            {
                property: 'a',
                type: 'set',
                value: 'bar'
            },
            {
                property: 'c',
                type: 'add',
                value: 'quz'
            },
            {
                property: 'b',
                type: 'remove'
            }
        ], 'add, set, and remove');
    });
    QUnit.test('mutation test', function (assert) {
        var oldObject = {
            a: 'foo',
            b: 'baz'
        };
        var newObject = {
            a: 'bar',
            c: 'quz'
        };
        diffObject(oldObject, newObject);
        assert.deepEqual(oldObject, {
            a: 'foo',
            b: 'baz'
        }, 'should not mutate old object');
        assert.deepEqual(newObject, {
            a: 'bar',
            c: 'quz'
        }, 'should not mutate new object');
    });
});
/*can-util@3.14.0#js/each/each-test*/
define('can-util@3.14.0#js/each/each-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './each',
    'can-symbol'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var each = require('./each');
    var canSymbol = require('can-symbol');
    QUnit.module('can-util/js/each');
    QUnit.test('iOS 8 64-bit JIT object length bug', function (assert) {
        assert.expect(4);
        var i;
        for (i = 0; i < 1000; i++) {
            each([]);
        }
        i = 0;
        each({
            1: '1',
            2: '2',
            3: '3'
        }, function (index) {
            assert.equal(++i, index, 'Iterate over object');
        });
        assert.equal(i, 3, 'Last index should be the length of the array');
    });
    QUnit.test('#1989 - isArrayLike needs to check for object type', function (assert) {
        try {
            each(true, function (index) {
            });
            assert.ok(true, 'each on true worked');
        } catch (e) {
            assert.ok(false, 'Should not fail');
        }
    });
    QUnit.test('objects that implement iterators work', function (assert) {
        var Ctr = function () {
        };
        Ctr.prototype[canSymbol.iterator || canSymbol.for('iterator')] = function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: [
                            'a',
                            'b'
                        ],
                        done: false
                    };
                }
            };
        };
        var obj = new Ctr();
        each(obj, function (value, key) {
            assert.equal(key, 'a');
            assert.equal(value, 'b');
        });
    });
});
/*can-util@3.14.0#js/get/get-test*/
define('can-util@3.14.0#js/get/get-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './get'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var get = require('./get');
    QUnit.module('can-util/js/get');
    QUnit.test('get Single root', function (assert) {
        var root, result;
        root = { foo: 'bar' };
        result = get(root, 'foo');
        assert.equal(result, 'bar', 'got \'bar\'');
        result = get(root, 'baz');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get Deep objects', function (assert) {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = get(root, 'foo.bar');
        assert.equal(result, 'baz', 'got \'baz\'');
        result = get(root, 'foo.world');
        assert.equal(result, undefined, 'got \'undefined\'');
        result = get(root, 'baz.world');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get with numeric index', function (assert) {
        var list = [
                1,
                2,
                3
            ], result0 = get(list, 0);
        assert.equal(result0, 1, 'got the 1st element of the list');
        var result1 = get(list, 1);
        assert.equal(result1, 2, 'got the 2nd element of the list');
    });
});
/*can-util@3.14.0#js/is-node/is-node*/
define('can-util@3.14.0#js/is-node/is-node', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        module.exports = namespace.isNode = function () {
            return typeof process === 'object' && {}.toString.call(process) === '[object process]';
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/import/import-test*/
define('can-util@3.14.0#js/import/import-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './import',
    '../is-node/is-node'
], function (require, exports, module) {
    (function (global, __dirname, require, exports, module) {
        'use strict';
        var QUnit = require('../../test/qunit');
        var load = require('./import');
        var isNode = require('../is-node/is-node')();
        if (!isNode) {
            QUnit.module('can-util/js/import');
            if (__dirname !== '/') {
                QUnit.test('basic can-import works', function (assert) {
                    return load('can-util/js/import/testmodule', __dirname).then(function (data) {
                        assert.equal(data, 'Hello world');
                    }).then(null, function (err) {
                        assert.ok(false, err);
                    });
                });
            }
        } else {
            QUnit.module('can-util/js/import - Node', {
                before: function () {
                    this.oldSystem = global.System;
                    global.System = {
                        'import': function (name) {
                            name = name.replace('can-util', '');
                            return new Promise(function (resolve, reject) {
                                try {
                                    var mod = require(process.cwd() + name);
                                    resolve(mod);
                                } catch (err) {
                                    reject(err);
                                }
                            });
                        }
                    };
                },
                after: function () {
                    global.System = this.oldSystem;
                }
            });
            QUnit.test('basic can-import works', function (assert) {
                return load('can-util/js/import/testmodule', __dirname).then(function (data) {
                    assert.equal(data, 'Hello world');
                }).then(null, function (err) {
                    assert.ok(false, err);
                });
            });
        }
    }(function () {
        return this;
    }(), '/', require, exports, module));
});
/*can-util@3.14.0#js/is-array-like/is-array-like-test*/
define('can-util@3.14.0#js/is-array-like/is-array-like-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-array-like'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isArrayLike = require('./is-array-like');
    QUnit.module('can-util/js/is-array-like');
    QUnit.test('basics', function (assert) {
        assert.ok(isArrayLike({
            0: 1,
            length: 1
        }));
    });
    QUnit.test('string', function (assert) {
        assert.ok(isArrayLike('yes'));
    });
    QUnit.test('Object with a .length property', function (assert) {
        var obj = { length: 0 };
        assert.ok(isArrayLike(obj));
    });
    QUnit.test('function should be false', function (assert) {
        var func = function () {
        };
        assert.ok(!isArrayLike(func));
    });
    QUnit.test('0 should be false', function (assert) {
        assert.ok(!isArrayLike(0));
    });
});
/*can-util@3.14.0#js/is-container/is-container-test*/
define('can-util@3.14.0#js/is-container/is-container-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-container'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isContainer = require('./is-container');
    QUnit.module('can-util/js/is-container');
    QUnit.test('object', function (assert) {
        assert.ok(isContainer({ 'a': 1 }));
    });
    QUnit.test('function', function (assert) {
        var sum = function (num1, num2) {
            return num1 + num2;
        };
        assert.ok(isContainer(sum));
    });
    QUnit.test('NaN and undefined is not a container', function (assert) {
        assert.ok(!isContainer(NaN));
        assert.ok(!isContainer());
    });
});
/*can-util@3.14.0#js/is-empty-object/is-empty-object-test*/
define('can-util@3.14.0#js/is-empty-object/is-empty-object-test', [
    'require',
    'exports',
    'module',
    './is-empty-object',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var isEmptyObject = require('./is-empty-object');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/is-empty-object/is-empty-object');
    QUnit.test('Returns true for plain objects', function (assert) {
        assert.ok(isEmptyObject({}), '{} is true');
        assert.ok(isEmptyObject(new Object()), 'new Object is true');
    });
    QUnit.test('Plain objects with properties are false', function (assert) {
        assert.equal(isEmptyObject({ a: 1 }), false, 'not empty');
    });
    QUnit.test('Returns true for custom objects with no props', function (assert) {
        var Thing = function () {
        };
        assert.equal(isEmptyObject(new Thing()), true, 'is empty');
        var thing2 = new Thing();
        thing2.foo = 'bar';
        assert.equal(isEmptyObject(thing2), false, 'not empty');
    });
});
/*can-util@3.14.0#js/is-function/is-function-test*/
define('can-util@3.14.0#js/is-function/is-function-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-function'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isFunction = require('./is-function');
    QUnit.module('can-util/js/is-function');
    QUnit.test('basics', function (assert) {
        assert.ok(isFunction(function () {
        }));
    });
});
/*can-util@3.14.0#js/is-node/is-node-test*/
define('can-util@3.14.0#js/is-node/is-node-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-node'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isNode = require('./is-node');
    QUnit.module('can-util/js/is-node');
    QUnit.test('basics', function (assert) {
        assert.equal(typeof isNode(), 'boolean');
    });
});
/*can-util@3.14.0#js/is-plain-object/is-plain-object-test*/
define('can-util@3.14.0#js/is-plain-object/is-plain-object-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-plain-object'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPlainObject = require('./is-plain-object');
    QUnit.module('can-util/js/is-plain-object');
    QUnit.test('basics', function (assert) {
        assert.ok(isPlainObject({ foo: 'bar' }));
    });
    QUnit.test('objects with prototypes', function (assert) {
        var Ctr = function () {
        };
        var obj = new Ctr();
        assert.equal(isPlainObject(obj), false, 'not a plain object');
    });
    QUnit.test('new Object', function (assert) {
        var obj;
        obj = new Object();
        assert.equal(isPlainObject(obj), true, 'using new Object gives you a plain object');
    });
    QUnit.test('Booleans', function (assert) {
        assert.equal(isPlainObject(true), false, 'Boolean value true is false');
        assert.equal(isPlainObject(Boolean(true)), false, 'Boolean constructor');
    });
    QUnit.test('Numbers', function (assert) {
        assert.equal(isPlainObject(15.66), false, 'number is not a plain object');
        assert.equal(isPlainObject(parseInt(13)), false, 'integer is not a plain object');
    });
    QUnit.test('NaN', function (assert) {
        assert.equal(isPlainObject(NaN), false, 'NaN is not a plain object');
    });
});
/*can-util@3.14.0#js/is-promise-like/is-promise-like-test*/
define('can-util@3.14.0#js/is-promise-like/is-promise-like-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-promise-like'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPromise = require('./is-promise-like');
    QUnit.module('can-util/js/is-promise-like');
    QUnit.test('basics', function (assert) {
        assert.ok(isPromise({
            then: function () {
            }
        }));
    });
});
/*can-util@3.14.0#js/make-promise/make-promise*/
define('can-util@3.14.0#js/make-promise/make-promise', [
    'require',
    'exports',
    'module',
    '../is-promise-like/is-promise-like',
    '../is-promise/is-promise'
], function (require, exports, module) {
    'use strict';
    var isPromiseLike = require('../is-promise-like/is-promise-like');
    var isPromise = require('../is-promise/is-promise');
    module.exports = function (obj) {
        if (isPromiseLike(obj) && !isPromise(obj)) {
            return new Promise(function (resolve, reject) {
                obj.then(resolve, reject);
            });
        } else {
            return obj;
        }
    };
});
/*can-util@3.14.0#js/make-promise/make-promise-test*/
define('can-util@3.14.0#js/make-promise/make-promise-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    '../is-promise/is-promise',
    './make-promise'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isPromise = require('../is-promise/is-promise');
    var makePromise = require('./make-promise');
    QUnit.module('can-util/js/make-promise');
    QUnit.test('basics', function (assert) {
        var obj = {
            fail: function () {
            },
            then: function () {
            }
        };
        var promise = makePromise(obj);
        assert.ok(isPromise(promise));
        obj = {
            catch: function () {
            },
            then: function () {
            }
        };
        promise = makePromise(obj);
        assert.ok(isPromise(promise));
    });
});
/*can-util@3.14.0#js/omit/omit*/
define('can-util@3.14.0#js/omit/omit', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var namespace = require('can-namespace');
    module.exports = namespace.omit = function (source, propsToOmit) {
        var result = {};
        for (var prop in source) {
            if (propsToOmit.indexOf(prop) < 0) {
                result[prop] = source[prop];
            }
        }
        return result;
    };
});
/*can-util@3.14.0#js/omit/omit-test*/
define('can-util@3.14.0#js/omit/omit-test', [
    'require',
    'exports',
    'module',
    './omit',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var omit = require('./omit');
    var QUnit = require('../../test/qunit');
    QUnit.module('can-util/js/omit');
    QUnit.test('Omit properties from an object', function (assert) {
        var source = {
            a: 1,
            b: 2,
            c: 3,
            d: 4
        };
        var propsToOmit = [
            'b',
            'd'
        ];
        var expected = {
            a: 1,
            c: 3
        };
        var actual = omit(source, propsToOmit);
        assert.deepEqual(expected, actual);
    });
});
/*can-util@3.14.0#js/is-web-worker/is-web-worker*/
define('can-util@3.14.0#js/is-web-worker/is-web-worker', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        module.exports = namespace.isWebWorker = function () {
            return typeof WorkerGlobalScope !== 'undefined' && this instanceof WorkerGlobalScope;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#js/is-web-worker/is-web-worker-test*/
define('can-util@3.14.0#js/is-web-worker/is-web-worker-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './is-web-worker'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var isWebWorker = require('./is-web-worker');
    QUnit.module('can-util/js/is-web-worker');
    QUnit.test('basics', function (assert) {
        assert.equal(typeof isWebWorker(), 'boolean');
    });
});
/*can-util@3.14.0#js/join-uris/join-uris-test*/
define('can-util@3.14.0#js/join-uris/join-uris-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './join-uris'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var joinURIs = require('./join-uris');
    QUnit.module('can-util/js/join-uris');
    QUnit.test('basics', function (assert) {
        assert.deepEqual(joinURIs('foo/bar/car.html', '../zed.html'), 'foo/zed.html');
    });
});
/*can-util@3.14.0#js/last/last-test*/
define('can-util@3.14.0#js/last/last-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './last'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var last = require('./last');
    QUnit.module('can-util/js/last');
    QUnit.test('basics', function (assert) {
        assert.equal(last([
            'a',
            'b'
        ]), 'b');
    });
});
/*can-util@3.14.0#js/make-array/make-array-test*/
define('can-util@3.14.0#js/make-array/make-array-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './make-array'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var makeArray = require('./make-array');
    QUnit.module('can-util/js/make-array');
    QUnit.test('basics', function (assert) {
        var res = makeArray({
            0: 'a',
            length: 1
        });
        assert.deepEqual(res, ['a']);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with Object', function (assert) {
        var res = makeArray({
            abc: 'xyz',
            bar: 'foo'
        });
        assert.deepEqual(res, [{
                abc: 'xyz',
                bar: 'foo'
            }]);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with number', function (assert) {
        var res = makeArray(1);
        assert.deepEqual(res, [1]);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with zero', function (assert) {
        var res = makeArray(0);
        assert.deepEqual(res, [0]);
        assert.ok(res instanceof Array);
    });
    QUnit.test('with null', function (assert) {
        var res = makeArray(null);
        assert.deepEqual(res, []);
        assert.ok(res instanceof Array);
    });
});
/*can-util@3.14.0#js/make-map/make-map*/
define('can-util@3.14.0#js/make-map/make-map', [
    'require',
    'exports',
    'module',
    '../each/each'
], function (require, exports, module) {
    'use strict';
    var each = require('../each/each');
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        each(items, function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*can-util@3.14.0#js/make-map/make-map-test*/
define('can-util@3.14.0#js/make-map/make-map-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './make-map'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var makeMap = require('./make-map');
    QUnit.module('can-util/js/make-map');
    QUnit.test('basics', function (assert) {
        var res = makeMap('a,b,c');
        assert.deepEqual(res, {
            a: true,
            b: true,
            c: true
        });
        assert.ok(res instanceof Object);
    });
});
/*can-util@3.14.0#js/set-not-enumerable/set-not-enumerable-test*/
define('can-util@3.14.0#js/set-not-enumerable/set-not-enumerable-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './set-not-enumerable'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var setNotEnumerable = require('./set-not-enumerable');
    QUnit.module('can-util/js/set-not-enumerable');
    QUnit.test('basics', function (assert) {
        assert.expect(0);
        var obj = {};
        setNotEnumerable(obj, 'prop', 'val');
        for (var prop in obj) {
            assert.ok(false, prop);
        }
    });
});
/*can-util@3.14.0#js/single-reference/single-reference-test*/
define('can-util@3.14.0#js/single-reference/single-reference-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './single-reference'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var singleReference = require('./single-reference');
    QUnit.module('can-util/js/single-reference');
    QUnit.test('basics', function (assert) {
        var obj = {};
        singleReference.set(obj, 'pet', 'dog');
        var retrieved = singleReference.getAndDelete(obj, 'pet');
        assert.equal(retrieved, 'dog', 'sets and retrieves successfully');
        assert.equal(Object.keys(obj).length, 0, 'also deletes when retrieved');
    });
});
/*can-util@3.14.0#js/string/string-test*/
define('can-util@3.14.0#js/string/string-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './string',
    '../get/get'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var string = require('./string');
    var get = require('../get/get');
    QUnit.module('can-util/js/string');
    QUnit.test('string.sub', function (assert) {
        assert.equal(string.sub('a{b}', { b: 'c' }), 'ac');
        var foo = { b: 'c' };
        assert.equal(string.sub('a{b}', foo, true), 'ac');
        assert.ok(!foo.b, 'b\'s value was removed');
    });
    QUnit.test('string.sub with undefined values', function (assert) {
        var subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' });
        assert.deepEqual(subbed, null, 'Rendering with undefined values should return null');
        subbed = string.sub('test{exists} plus{noexists}', { exists: 'test' }, true);
        assert.deepEqual(subbed, null, 'Rendering with undefined values should return null even when remove param is true');
    });
    QUnit.test('string.sub with null values', function (assert) {
        var subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        });
        assert.deepEqual(subbed, null, 'Rendering with null values should return null');
        subbed = string.sub('test{exists} plus{noexists}', {
            exists: 'test',
            noexists: null
        }, true);
        assert.deepEqual(subbed, null, 'Rendering with null values should return null even when remove param is true');
    });
    QUnit.test('string.sub double', function (assert) {
        assert.equal(string.sub('{b} {d}', {
            b: 'c',
            d: 'e'
        }), 'c e');
    });
    QUnit.test('String.underscore', function (assert) {
        assert.equal(string.underscore('Foo.Bar.ZarDar'), 'foo.bar.zar_dar');
    });
    QUnit.test('string.sub remove', function (assert) {
        var obj = { a: 'a' };
        assert.equal(string.sub('{a}', obj, false), 'a');
        assert.deepEqual(obj, { a: 'a' });
        assert.equal(string.sub('{a}', obj, true), 'a');
        assert.deepEqual(obj, {});
    });
    QUnit.test('get Single root', function (assert) {
        var root, result;
        root = { foo: 'bar' };
        result = get(root, 'foo');
        assert.equal(result, 'bar', 'got \'bar\'');
        result = get(root, 'baz');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('get Multiple root', function (assert) {
        var root1, root2, roots, result;
        root1 = { a: 1 };
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = get(roots, '0.a');
        assert.equal(result, 1, 'got \'1\'');
        result = get(roots, '1.b');
        assert.equal(result, 2, 'got \'2\'');
        result = get(roots, 'c');
        assert.equal(result, undefined, 'got \'undefined\'');
        root1 = undefined;
        root2 = { b: 2 };
        roots = [
            root1,
            root2
        ];
        result = get(roots, '1.b');
        assert.equal(result, 2, 'got \'2\'');
    });
    QUnit.test('get Deep objects', function (assert) {
        var root, result;
        root = { foo: { bar: 'baz' } };
        result = get(root, 'foo.bar');
        assert.equal(result, 'baz', 'got \'baz\'');
        result = get(root, 'foo.world');
        assert.equal(result, undefined, 'got \'undefined\'');
    });
    QUnit.test('string.esc', function (assert) {
        var text = string.esc(0);
        assert.equal(text, '0', '0 value properly rendered');
        text = string.esc(null);
        assert.deepEqual(text, '', 'null value returns empty string');
        text = string.esc();
        assert.deepEqual(text, '', 'undefined returns empty string');
        text = string.esc(NaN);
        assert.deepEqual(text, '', 'NaN returns empty string');
        text = string.esc('<div>&nbsp;</div>');
        assert.equal(text, '&lt;div&gt;&amp;nbsp;&lt;/div&gt;', 'HTML escaped properly');
    });
    QUnit.test('string.camelize', function (assert) {
        var text = string.camelize(0);
        assert.equal(text, '0', '0 value properly rendered');
        text = string.camelize(null);
        assert.equal(text, '', 'null value returns empty string');
        text = string.camelize();
        assert.equal(text, '', 'undefined returns empty string');
        text = string.camelize(NaN);
        assert.equal(text, '', 'NaN returns empty string');
        text = string.camelize('-moz-index');
        assert.equal(text, 'MozIndex');
        text = string.camelize('foo-bar');
        assert.equal(text, 'fooBar');
    });
    QUnit.test('string.hyphenate', function (assert) {
        var text = string.hyphenate(0);
        assert.equal(text, '0', '0 value properly rendered');
        text = string.hyphenate(null);
        assert.equal(text, '', 'null value returns empty string');
        text = string.hyphenate();
        assert.equal(text, '', 'undefined returns empty string');
        text = string.hyphenate(NaN);
        assert.equal(text, '', 'NaN returns empty string');
        text = string.hyphenate('ABC');
        assert.equal(text, 'ABC');
        text = string.hyphenate('dataNode');
        assert.equal(text, 'data-node');
    });
    QUnit.test('string.replaceWith should substitute paths with replacer values', function (assert) {
        assert.expect(5);
        var str = 'I like {food} and {hobbies.favorite}';
        var data = {
            food: 'cake',
            hobbies: { favorite: 'writing unit tests' }
        };
        var callCount = 0;
        var replacer = function (key, value) {
            callCount++;
            if (callCount === 1) {
                assert.equal(key, 'food');
                assert.equal(value, 'cake');
            }
            if (callCount === 2) {
                assert.equal(key, 'hobbies.favorite');
                assert.equal(value, 'writing unit tests');
            }
            return value;
        };
        assert.equal(string.replaceWith(str, data, replacer), 'I like cake and writing unit tests');
    });
});
/*can-util@3.14.0#js/string-to-any/string-to-any-test*/
define('can-util@3.14.0#js/string-to-any/string-to-any-test', [
    'require',
    'exports',
    'module',
    '../../test/qunit',
    './string-to-any',
    '../each/each'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('../../test/qunit');
    var stringToAny = require('./string-to-any');
    var each = require('../each/each');
    QUnit.module('can-util/js/string-to-any');
    QUnit.test('works with primitive types', function (assert) {
        var fixture = {
            'foo': 'foo',
            '33': 33,
            'true': true,
            'false': false,
            'undefined': undefined,
            'null': null,
            'Infinity': Infinity
        };
        each(fixture, function (value, key) {
            assert.ok(stringToAny(key) === value, 'Correctly converted type: ' + key);
        });
        assert.ok(isNaN(stringToAny('NaN')), 'Correclty converted type: NaN');
    });
});
/*can-util@3.14.0#js/tests*/
define('can-util@3.14.0#js/tests', [
    'require',
    'exports',
    'module',
    './assign-non-enumerable/assign-non-enumerable-test',
    './base-url/base-url-test',
    './deep-assign/deep-assign-test',
    './defaults/defaults-test',
    './diff/diff-test',
    './diff-array/diff-array-test',
    './diff-object/diff-object-test',
    './each/each-test',
    './get/get-test',
    './import/import-test',
    './is-array-like/is-array-like-test',
    './is-container/is-container-test',
    './is-empty-object/is-empty-object-test',
    './is-function/is-function-test',
    './is-node/is-node-test',
    './is-plain-object/is-plain-object-test',
    './is-promise-like/is-promise-like-test',
    './make-promise/make-promise-test',
    './omit/omit-test',
    './is-web-worker/is-web-worker-test',
    './join-uris/join-uris-test',
    './last/last-test',
    './make-array/make-array-test',
    './make-map/make-map-test',
    './set-not-enumerable/set-not-enumerable-test',
    './single-reference/single-reference-test',
    './string/string-test',
    './string-to-any/string-to-any-test'
], function (require, exports, module) {
    'use strict';
    require('./assign-non-enumerable/assign-non-enumerable-test');
    require('./base-url/base-url-test');
    require('./deep-assign/deep-assign-test');
    require('./defaults/defaults-test');
    require('./diff/diff-test');
    require('./diff-array/diff-array-test');
    require('./diff-object/diff-object-test');
    require('./each/each-test');
    require('./get/get-test');
    require('./import/import-test');
    require('./is-array-like/is-array-like-test');
    require('./is-container/is-container-test');
    require('./is-empty-object/is-empty-object-test');
    require('./is-function/is-function-test');
    require('./is-node/is-node-test');
    require('./is-plain-object/is-plain-object-test');
    require('./is-promise-like/is-promise-like-test');
    require('./make-promise/make-promise-test');
    require('./omit/omit-test');
    require('./is-web-worker/is-web-worker-test');
    require('./join-uris/join-uris-test');
    require('./last/last-test');
    require('./make-array/make-array-test');
    require('./make-map/make-map-test');
    require('./set-not-enumerable/set-not-enumerable-test');
    require('./single-reference/single-reference-test');
    require('./string/string-test');
    require('./string-to-any/string-to-any-test');
});
/*can-util@3.14.0#test/helpers*/
define('can-util@3.14.0#test/helpers', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var getGlobal = require('can-globals/global/global');
        function isProduction() {
            var root = getGlobal();
            if (root.System) {
                return root.System.env.indexOf('production') !== -1;
            }
            if (root.process) {
                var nodeEnv = root.process.env.NODE_ENV;
                return nodeEnv === 'production' || nodeEnv === 'window-production';
            }
            return false;
        }
        function isServer() {
            var root = getGlobal();
            var testType = root.process && root.process.env.TEST;
            return testType === 'qunit';
        }
        module.exports = {
            isProduction: isProduction,
            isServer: isServer
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/attr/attr-test*/
define('can-util@3.14.0#dom/attr/attr-test', [
    'require',
    'exports',
    'module',
    '../attr/attr',
    '../events/events',
    '../data/data',
    '../dispatch/dispatch',
    '../mutate/mutate',
    'can-globals/mutation-observer/mutation-observer',
    'can-types',
    '../../test/helpers',
    '../../test/qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var domAttr = require('../attr/attr');
        var domEvents = require('../events/events');
        var domData = require('../data/data');
        var domDispatch = require('../dispatch/dispatch');
        var mutate = require('../mutate/mutate');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var types = require('can-types');
        var helpers = require('../../test/helpers');
        var isServer = helpers.isServer;
        var unit = require('../../test/qunit');
        unit.skipOnServer = unit.test;
        if (isServer) {
            unit.skipOnServer = unit.skip;
        }
        unit.module('can-util/dom/attr');
        unit.test('attributes event', function (assert) {
            var done = assert.async();
            var div = document.createElement('div');
            var attrHandler1 = function (ev) {
                assert.equal(ev.attributeName, 'foo', 'attribute name is correct');
                assert.equal(ev.target, div, 'target');
                assert.equal(ev.oldValue, null, 'oldValue');
                assert.equal(div.getAttribute(ev.attributeName), 'bar');
                domEvents.removeEventListener.call(div, 'attributes', attrHandler1);
            };
            domEvents.addEventListener.call(div, 'attributes', attrHandler1);
            domAttr.set(div, 'foo', 'bar');
            setTimeout(function () {
                var attrHandler = function (ev) {
                    assert.ok(true, 'removed event handler should be called');
                    assert.equal(ev.attributeName, 'foo', 'attribute name is correct');
                    assert.equal(ev.target, div, 'target');
                    assert.equal(ev.oldValue, 'bar', 'oldValue should be \'bar\'');
                    assert.equal(div.getAttribute(ev.attributeName), null, 'value of the attribute should be null after the remove.');
                    domEvents.removeEventListener.call(div, 'attributes', attrHandler);
                    done();
                };
                domEvents.addEventListener.call(div, 'attributes', attrHandler);
                domAttr.remove(div, 'foo');
            }, 50);
        });
        unit.test('attr events without MUTATION_OBSERVER', function (assert) {
            assert.expect(9);
            var done = assert.async();
            var MO = getMutationObserver();
            getMutationObserver(null);
            var div = document.createElement('div');
            var attrHandler1 = function (ev) {
                assert.equal(ev.attributeName, 'foo', 'attribute name is correct');
                assert.equal(ev.target, div, 'target');
                assert.equal(ev.oldValue, null, 'oldValue');
                assert.equal(div.getAttribute(ev.attributeName), 'bar');
                domEvents.removeEventListener.call(div, 'attributes', attrHandler1);
            };
            domEvents.addEventListener.call(div, 'attributes', attrHandler1);
            domAttr.set(div, 'foo', 'bar');
            setTimeout(function () {
                var attrHandler = function (ev) {
                    assert.ok(true, 'removed event handler should be called');
                    assert.equal(ev.attributeName, 'foo', 'attribute name is correct');
                    assert.equal(ev.target, div, 'target');
                    assert.equal(ev.oldValue, 'bar', 'oldValue should be \'bar\'');
                    assert.equal(div.getAttribute(ev.attributeName), null, 'value of the attribute should be null after the remove.');
                    domEvents.removeEventListener.call(div, 'attributes', attrHandler);
                    getMutationObserver(MO);
                    done();
                };
                domEvents.addEventListener.call(div, 'attributes', attrHandler);
                domAttr.remove(div, 'foo');
            }, 50);
        });
        unit.test('attr.set CHECKED attribute works', function (assert) {
            var input = document.createElement('input');
            input.type = 'checkbox';
            document.getElementById('qunit-fixture').appendChild(input);
            domAttr.set(input, 'CHECKED');
            assert.equal(input.checked, true);
            input.checked = false;
            domAttr.set(input, 'CHECKED');
            assert.equal(input.checked, true);
            document.getElementById('qunit-fixture').removeChild(input);
        });
        if (!isServer()) {
            unit.test('Map special attributes', function (assert) {
                var div = document.createElement('label');
                document.getElementById('qunit-fixture').appendChild(div);
                domAttr.set(div, 'for', 'my-for');
                assert.equal(div.htmlFor, 'my-for', 'Map for to htmlFor');
                if ('innerText' in div) {
                    domAttr.set(div, 'innertext', 'my-inner-text');
                    assert.equal(div.innerText, 'my-inner-text', 'Map innertext to innerText');
                }
                domAttr.set(div, 'textcontent', 'my-content');
                assert.equal(div.textContent, 'my-content', 'Map textcontent to textContent');
                document.getElementById('qunit-fixture').removeChild(div);
                div = document.createElement('input');
                div.type = 'text';
                document.getElementById('qunit-fixture').appendChild(div);
                domAttr.set(div, 'readonly');
                assert.equal(div.readOnly, true, 'Map readonly to readOnly');
                domAttr.set(div, 'readonly', false);
                assert.equal(div.readOnly, false, 'not readonly');
                domAttr.set(div, 'readonly', '');
                assert.equal(div.readOnly, true, 'readonly again');
                document.getElementById('qunit-fixture').removeChild(div);
            });
        }
        var supportsCreateElementNs = !isServer();
        if (supportsCreateElementNs) {
            unit.test('set class attribute via className or setAttribute for svg (#2015)', function (assert) {
                var div = document.createElement('div');
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                var obj = {
                    toString: function () {
                        return 'my-class';
                    }
                };
                domAttr.set(div, 'class', 'my-class');
                assert.equal(div.getAttribute('class'), 'my-class', 'class mapped to className');
                domAttr.set(div, 'class', undefined);
                assert.equal(div.getAttribute('class'), '', 'an undefined className is an empty string');
                domAttr.set(div, 'class', obj);
                assert.equal(div.getAttribute('class'), 'my-class', 'you can pass an object to className');
                domAttr.set(svg, 'class', 'my-class');
                assert.equal(svg.getAttribute('class'), 'my-class', 'svg class was set as an attribute');
                domAttr.set(svg, 'class', undefined);
                assert.equal(svg.getAttribute('class'), '', 'an undefined svg class is an empty string');
                domAttr.set(svg, 'class', obj);
                assert.equal(svg.getAttribute('class'), 'my-class', 'you can pass an object to svg class');
            });
            unit.test('set xlink:href attribute via setAttributeNS for svg-use (#2384)', function (assert) {
                var use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
                domAttr.set(use, 'xlink:href', 'svgUri');
                assert.equal(use.getAttributeNS('http://www.w3.org/1999/xlink', 'href'), 'svgUri', 'svg-use xlink:href was set with setAttributeNS');
            });
        }
        unit.test('attr.special addEventListener allows custom binding', function (assert) {
            var trigger;
            domAttr.special.foo = {
                addEventListener: function (eventName, handler) {
                    trigger = function () {
                        handler();
                    };
                    return function () {
                        trigger = function () {
                        };
                    };
                },
                set: function (val) {
                    this.foo = val;
                    trigger();
                }
            };
            var div = document.createElement('div');
            var times = 0;
            var handler = function () {
                times++;
                assert.equal(times, 1, 'addEventListener called');
            };
            domEvents.addEventListener.call(div, 'foo', handler);
            domAttr.set(div, 'foo', 'bar');
            domEvents.removeEventListener.call(div, 'foo', handler);
            domAttr.set(div, 'foo', 'baz');
            delete domAttr.special.foo;
        });
        unit.test('\'selected\' is bindable on an <option>', function (assert) {
            var select = document.createElement('select');
            var option1 = document.createElement('option');
            option1.value = 'one';
            var option2 = document.createElement('option');
            option2.value = 'two';
            select.appendChild(option1);
            select.appendChild(option2);
            domEvents.addEventListener.call(option2, 'selected', function () {
                assert.ok(true, 'selected was called on the option');
            });
            option2.selected = true;
            domDispatch.call(select, 'change');
            assert.equal(domAttr.get(option1, 'selected'), false, 'option1 is not selected');
            assert.equal(domAttr.get(option2, 'selected'), true, 'option2 is selected');
        });
        if (!isServer()) {
            unit.test('get, set, and addEventListener on values', function (assert) {
                var select = document.createElement('select');
                select.multiple = true;
                var option1 = document.createElement('option');
                option1.value = 'one';
                var option2 = document.createElement('option');
                option2.value = 'two';
                select.appendChild(option1);
                select.appendChild(option2);
                var valuesCount = 0;
                domEvents.addEventListener.call(select, 'values', function () {
                    valuesCount++;
                });
                assert.deepEqual(domAttr.get(select, 'values'), [], 'None selected to start');
                option1.selected = true;
                domDispatch.call(select, 'change');
                assert.equal(valuesCount, 1, 'values event');
                assert.deepEqual(domAttr.get(select, 'values'), ['one'], 'First option is in values');
                option2.selected = true;
                domDispatch.call(select, 'change');
                assert.equal(valuesCount, 2, 'values event');
                assert.deepEqual(domAttr.get(select, 'values'), [
                    'one',
                    'two'
                ], 'both selected');
                option1.selected = option2.selected = false;
                domDispatch.call(select, 'change');
                assert.equal(valuesCount, 3, 'values event');
                assert.deepEqual(domAttr.get(select, 'values'), [], 'none selected');
                domAttr.set(select, 'values', ['two']);
                assert.equal(option1.selected, false, 'option1 not selected');
                assert.equal(option2.selected, true, 'option2 selected');
                assert.deepEqual(domAttr.get(select, 'values'), ['two'], 'two is only selected');
            });
        }
        unit.test('get, set, and addEventListener on innerHTML', function (assert) {
            var div = document.createElement('div');
            div.appendChild(document.createElement('span'));
            var count = 0;
            domEvents.addEventListener.call(div, 'innerHTML', function () {
                count++;
            });
            assert.equal(domAttr.get(div, 'innerHTML'), '<span></span>', 'got innerhtml');
            domAttr.set(div, 'innerHTML', '<p>hello</p>');
            domDispatch.call(div, 'change');
            assert.equal(count, 1, 'innerHTML event');
            assert.equal(domAttr.get(div, 'innerHTML'), '<p>hello</p>', 'got innerhtml');
        });
        unit.test('get, set on \'value\'', function (assert) {
            var input = document.createElement('input');
            input.value = 'foo';
            assert.equal(domAttr.get(input, 'value'), 'foo', 'got the value');
            domAttr.set(input, 'value', 'bar');
            assert.equal(domAttr.get(input, 'value'), 'bar', 'got the value');
            input.value = '';
            assert.equal(domAttr.get(input, 'value'), '', 'value is an empty string');
        });
        unit.test('get/sets the checkedness of a checkbox', function (assert) {
            var input = document.createElement('input');
            input.type = 'checkbox';
            assert.equal(domAttr.get(input, 'checked'), false, 'not checked');
            domAttr.set(input, 'checked', true);
            assert.equal(domAttr.get(input, 'checked'), true, 'now it is true');
            domAttr.set(input, 'checked', false);
            assert.equal(domAttr.get(input, 'checked'), false, 'now it is false');
            domAttr.set(input, 'checked');
            assert.equal(domAttr.get(input, 'checked'), true, 'now it is true');
            domAttr.set(input, 'checked', 0);
            assert.equal(domAttr.get(input, 'checked'), false, 'now it is false');
            domAttr.set(input, 'checked', '');
            assert.equal(domAttr.get(input, 'checked'), true, 'now it is true');
        });
        if (!isServer()) {
            unit.test('For inputs checked is set as an attribute', function (assert) {
                var input = document.createElement('input');
                input.type = 'checkbox';
                domAttr.set(input, 'checked', '');
                assert.equal(input.checked, true, 'checked is true');
                assert.equal(input.getAttribute('checked'), undefined, 'no checked attr');
                var customEl = document.createElement('custom-element');
                domAttr.set(customEl, 'checked', '');
                assert.ok(customEl.hasAttribute('checked'), 'has checked attr');
                assert.equal(customEl.getAttribute('checked'), '', 'attr is an empty string');
                assert.equal(domAttr.get(customEl, 'checked'), '', 'attr from get');
            });
            unit.test('attr.special.value, fallback to the attribute', function (assert) {
                var customEl = document.createElement('custom-element');
                customEl.setAttribute('value', 'foo');
                assert.equal(domAttr.get(customEl, 'value'), 'foo', 'value is foo');
            });
            unit.test('Setting a select\'s value updates child\'s selectedness', function (assert) {
                var select = document.createElement('select');
                var option1 = document.createElement('option');
                option1.value = 'one';
                option1.selected = true;
                var option2 = document.createElement('option');
                option2.value = 'two';
                select.appendChild(option1);
                select.appendChild(option2);
                assert.equal(domAttr.get(select, 'value'), 'one', 'initial value');
                domAttr.set(select, 'value', 'two');
                assert.equal(option1.selected, false, 'not selected');
                assert.equal(option2.selected, true, 'now it is selected');
            });
        }
        unit.test('Removing an option causes the select\'s value to be re-evaluated', function (assert) {
            var done = assert.async();
            var select = document.createElement('select');
            var option1 = document.createElement('option');
            option1.value = 'one';
            var option2 = document.createElement('option');
            option2.value = 'two';
            select.appendChild(option1);
            select.appendChild(option2);
            domAttr.set(select, 'value', 'one');
            assert.equal(option1.selected, true, 'selected');
            assert.equal(domAttr.get(select, 'value'), 'one', 'got the value');
            domEvents.addEventListener.call(select, 'change', function () {
                assert.equal(domAttr.get(select, 'value'), undefined, 'no value now');
                done();
            });
            select.removeChild(option1);
            if (!getMutationObserver()) {
                var data = domData.get.call(select, 'canBindingCallback');
                data.onMutation();
            }
        });
        if (!isServer()) {
            unit.test('Multiselect values is updated on any children added/removed', function (assert) {
                var done = assert.async();
                var select = document.createElement('select');
                select.multiple = true;
                var option1 = document.createElement('option');
                option1.value = 'one';
                var option2 = document.createElement('option');
                option2.value = 'two';
                var option3 = document.createElement('option');
                option3.value = 'three';
                option3.selected = true;
                select.appendChild(option1);
                select.appendChild(option2);
                select.appendChild(option3);
                domAttr.set(select, 'values', [
                    'one',
                    'three'
                ]);
                assert.deepEqual(domAttr.get(select, 'values'), [
                    'one',
                    'three'
                ], 'initial value is right');
                domEvents.addEventListener.call(select, 'values', function () {
                    assert.deepEqual(domAttr.get(select, 'values'), ['three'], 'new val is right');
                    done();
                });
                select.removeChild(option1);
                if (!getMutationObserver()) {
                    var data = domData.get.call(select, 'canBindingCallback');
                    data.onMutation();
                }
            });
        }
        if (!isServer()) {
            unit.test('Select options within optgroups should be set via `value` properly', function (assert) {
                function tag(tag, value) {
                    var el = document.createElement(tag);
                    if (value) {
                        el.value = value;
                    }
                    return el;
                }
                var select = tag('select');
                var optgroup1 = tag('optgroup');
                var option11 = tag('option', 'list1-item1');
                option11.selected = true;
                var option12 = tag('option', 'list1-item2');
                var optgroup2 = tag('optgroup');
                var option21 = tag('option', 'list2-item1');
                var option22 = tag('option', 'list2-item2');
                select.appendChild(optgroup1);
                select.appendChild(optgroup2);
                optgroup1.appendChild(option11);
                optgroup1.appendChild(option12);
                optgroup2.appendChild(option21);
                optgroup2.appendChild(option22);
                assert.equal(domAttr.get(select, 'value'), 'list1-item1', 'initial value');
                domAttr.set(select, 'value', 'list2-item2');
                assert.equal(domAttr.get(select, 'value'), 'list2-item2', 'updated value');
                assert.equal(option11.selected, false, 'initial option is not selected');
                assert.equal(option22.selected, true, 'second option is selected');
            });
            unit.test('Select options within optgroups should be set via `values` properly', function (assert) {
                function tag(tag, value) {
                    var el = document.createElement(tag);
                    if (value) {
                        el.value = value;
                    }
                    return el;
                }
                var select = tag('select');
                select.multiple = true;
                var optgroup1 = tag('optgroup');
                var option11 = tag('option', 'list1-item1');
                option11.selected = true;
                var option12 = tag('option', 'list1-item2');
                var optgroup2 = tag('optgroup');
                var option21 = tag('option', 'list2-item1');
                var option22 = tag('option', 'list2-item2');
                select.appendChild(optgroup1);
                select.appendChild(optgroup2);
                optgroup1.appendChild(option11);
                optgroup1.appendChild(option12);
                optgroup2.appendChild(option21);
                optgroup2.appendChild(option22);
                assert.deepEqual(domAttr.get(select, 'values'), ['list1-item1'], 'initial value');
                domAttr.set(select, 'values', [
                    'list1-item2',
                    'list2-item2'
                ]);
                assert.deepEqual(domAttr.get(select, 'values'), [
                    'list1-item2',
                    'list2-item2'
                ], 'updated value');
                assert.equal(option11.selected, false, 'initial option is not selected');
                assert.equal(option12.selected, true, 'second option is selected');
                assert.equal(option22.selected, true, 'third option is selected');
            });
            unit.test('Setting a value that will be appended later', function (assert) {
                var done = assert.async();
                var select = document.createElement('select');
                var option1 = document.createElement('option');
                option1.value = 'one';
                domAttr.set(select, 'value', 'two');
                var option2 = document.createElement('option');
                option2.value = 'two';
                domEvents.addEventListener.call(select, 'change', function () {
                    assert.equal(domAttr.get(select, 'value'), 'two', 'option2 is selected');
                    done();
                });
                select.appendChild(option2);
                if (!getMutationObserver()) {
                    var data = domData.get.call(select, 'canBindingCallback');
                    data.onMutation();
                }
            });
        }
        unit.test('Calling remove on checked sets it to false', function (assert) {
            var input = document.createElement('input');
            input.type = 'checkbox';
            domAttr.set(input, 'checked');
            assert.equal(input.checked, true, 'it is checked');
            domAttr.remove(input, 'checked');
            assert.equal(input.checked, false, 'not checked');
        });
        unit.test('Boolean attrs that don\'t support a prop sets the attribute', function (assert) {
            var div = document.createElement('div');
            domAttr.set(div, 'disabled');
            assert.equal(domAttr.get(div, 'disabled'), '', 'empty string');
        });
        unit.test('Setting a non-string value on a select correctly selects the child', function (assert) {
            var select = document.createElement('select');
            var option1 = document.createElement('option');
            option1.value = '1';
            var option2 = document.createElement('option');
            option2.value = '2';
            select.appendChild(option1);
            select.appendChild(option2);
            domAttr.set(select, 'value', 2);
            assert.equal(option2.selected, true, 'second one is selected');
        });
        unit.test('Setting null doesn\'t select the default value on a select', function (assert) {
            var select = document.createElement('select');
            var option1 = document.createElement('option');
            option1.value = '';
            var option2 = document.createElement('option');
            option2.value = 'two';
            select.appendChild(option1);
            select.appendChild(option2);
            domAttr.set(select, 'value', null);
            assert.equal(option1.selected, false, 'option1 not selected');
            assert.equal(option2.selected, false, 'option2 not selected');
            assert.equal(select.selectedIndex, -1, 'no selected index, wha-wha');
        });
        unit.test('setting .value on an input to undefined or null makes value empty (#83)', function (assert) {
            var input = document.createElement('input');
            input.value = 'something';
            domAttr.set(input, 'value', null);
            assert.equal(input.value, '', 'null');
            domAttr.set(input, 'value', undefined);
            assert.equal(input.value, '', 'undefined');
        });
        unit.test('setting .value on a textarea to undefined or null makes value empty', function (assert) {
            var textarea = document.createElement('textarea');
            textarea.value = 'something';
            domAttr.set(textarea, 'value', null);
            assert.equal(textarea.value, '', 'null');
            domAttr.set(textarea, 'value', undefined);
            assert.equal(textarea.value, '', 'undefined');
        });
        if (!isServer()) {
            unit.test('attr.special.focused calls after previous events', function (assert) {
                var oldQueue = types.queueTask;
                types.queueTask = function (task) {
                    setTimeout(function () {
                        task[0].apply(task[1], task[2]);
                    }, 5);
                };
                var input = document.createElement('input');
                input.type = 'text';
                var ta = document.getElementById('qunit-fixture');
                ta.appendChild(input);
                var done = assert.async();
                domAttr.set(input, 'focused', true);
                setTimeout(function () {
                    assert.equal(domAttr.get(input, 'focused'), true, 'it is now focused');
                    types.queueTask = oldQueue;
                    done();
                }, 10);
                assert.equal(domAttr.get(input, 'focused'), false, 'not focused yet');
            });
            unit.test('attr.special.focused binds on inserted if element is detached', function (assert) {
                assert.expect(2);
                var input = document.createElement('input');
                input.type = 'text';
                var ta = document.getElementById('qunit-fixture');
                var done = assert.async();
                domAttr.set(input, 'focused', true);
                assert.equal(domAttr.get(input, 'focused'), false, 'not focused yet');
                domEvents.addEventListener.call(input, 'inserted', function () {
                    assert.equal(domAttr.get(input, 'focused'), true, 'it is now focused');
                    done();
                });
                mutate.appendChild.call(ta, input);
            });
        }
        unit.test('handles removing multiple event handlers', function (assert) {
            var handler1 = function () {
            };
            var handler2 = function () {
            };
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'attributes', handler1, false);
            domEvents.addEventListener.call(div, 'attributes', handler2, false);
            domEvents.removeEventListener.call(div, 'attributes', handler1);
            domEvents.removeEventListener.call(div, 'attributes', handler2);
            assert.ok(true, 'should not throw');
        });
        unit.test('handles removing multiple event handlers without MUTATION_OBSERVER', function (assert) {
            var MO = getMutationObserver();
            getMutationObserver(null);
            var handler1 = function () {
            };
            var handler2 = function () {
            };
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'attributes', handler1, false);
            domEvents.addEventListener.call(div, 'attributes', handler2, false);
            domEvents.removeEventListener.call(div, 'attributes', handler1);
            domEvents.removeEventListener.call(div, 'attributes', handler2);
            assert.ok(true, 'should not throw');
            getMutationObserver(MO);
        });
        unit.skipOnServer('get, set, and addEventListener on focused', function (assert) {
            var done = assert.async();
            var input = document.createElement('input');
            var ta = document.getElementById('qunit-fixture');
            var test;
            var focusedCount = 0;
            ta.appendChild(input);
            var tests = [
                {
                    action: function () {
                        assert.equal(domAttr.get(input, 'focused'), false, 'get not focused');
                        domAttr.set(input, 'focused', true);
                        if (!document.hasFocus()) {
                            domDispatch.call(input, 'focus');
                        }
                    },
                    test: function () {
                        assert.equal(focusedCount, 1, 'focused event');
                        assert.equal(domAttr.get(input, 'focused'), true, 'get focused');
                    }
                },
                {
                    action: function () {
                        domAttr.set(input, 'focused', false);
                        if (!document.hasFocus()) {
                            domDispatch.call(input, 'blur');
                        }
                    },
                    test: function () {
                        assert.equal(focusedCount, 2, 'focused event');
                        assert.equal(domAttr.get(input, 'focused'), false, 'get not focused after blur');
                    }
                }
            ];
            function next() {
                test = tests.shift();
                if (!test) {
                    done();
                    return;
                }
                test.action();
            }
            assert.ok(domAttr.special.focused.addEventListener, 'addEventListener implemented');
            domEvents.addEventListener.call(input, 'focused', function () {
                focusedCount++;
                test.test();
                setTimeout(next, 50);
            });
            next();
        });
        unit.test('Binding to selected updates the selectedness of options', function (assert) {
            assert.expect(3);
            var select = document.createElement('select');
            var option1 = document.createElement('option');
            option1.selected = false;
            option1.value = 'one';
            select.appendChild(option1);
            var option2 = document.createElement('option');
            option2.value = 'two';
            select.appendChild(option2);
            domEvents.addEventListener.call(option1, 'selected', function () {
                assert.ok(true, 'this was called');
            });
            domAttr.set(option1, 'selected', true);
            option2.selected = true;
            domDispatch.call(select, 'change');
            assert.equal(option2.selected, true);
            assert.equal(option1.selected, false);
        });
        unit.test('Select\'s value is preserved when inserted into the document', function (assert) {
            var done = assert.async();
            var select = document.createElement('select');
            var option1 = document.createElement('option');
            option1.value = 'one';
            select.appendChild(option1);
            domAttr.set(select, 'value', null);
            assert.equal(select.selectedIndex, -1, 'was set to -1');
            var ta = document.getElementById('qunit-fixture');
            mutate.appendChild.call(ta, select);
            setTimeout(function () {
                assert.equal(select.selectedIndex, -1, 'still is -1');
                done();
            }, 50);
        });
        unit.test('multi-select does not dispatch a values change event if its selected options are unchanged (#105)', function (assert) {
            var done = assert.async();
            var div = document.createElement('div');
            div.innerHTML = '<select multiple><option selected>2</option><option selected>1</option><option>3</option></select>';
            var select = div.firstChild;
            document.body.appendChild(div);
            var valuesChanges = 0;
            domEvents.addEventListener.call(select, 'values', function () {
                valuesChanges++;
            });
            domAttr.set(select, 'values', [
                '1',
                '2'
            ]);
            select.innerHTML = '<option selected>1</option><option selected>2</option><option>3</option>';
            setTimeout(function () {
                assert.strictEqual(valuesChanges, 0, 'we do not dispatch a change event');
                document.body.removeChild(div);
                done();
            }, 50);
        });
        unit.test('setting checked to undefined should result in false for checkboxes (#184)', function (assert) {
            var input = document.createElement('input');
            input.type = 'checkbox';
            domAttr.set(input, 'checked', undefined);
            assert.equal(input.checked, false, 'Should set checked to false');
            domAttr.set(input, 'checked', true);
            assert.equal(input.checked, true, 'Should become true');
            domAttr.set(input, 'checked', undefined);
            assert.equal(input.checked, false, 'Should become false again');
        });
        unit.test('set attribute with namespaces (#309)', function (assert) {
            var div = document.createElement('div');
            domAttr.set(div, 'foo:bar', 'value');
            assert.equal(domAttr.get(div, 'foo:bar'), 'value');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/data/data-test*/
define('can-util@3.14.0#dom/data/data-test', [
    'require',
    'exports',
    'module',
    './data',
    'can-dom-data-state',
    '../../js/diff-object/diff-object',
    'can-globals/document/document',
    '../mutate/mutate',
    '../mutation-observer/document/document',
    '../../test/qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var domData = require('./data');
        var domDataState = require('can-dom-data-state');
        var diff = require('../../js/diff-object/diff-object');
        var getDocument = require('can-globals/document/document');
        var mutate = require('../mutate/mutate');
        var mutationDocument = require('../mutation-observer/document/document');
        var unit = require('../../test/qunit');
        var document = getDocument();
        unit.module('can-util/dom/data');
        unit.test('domData should be cleaned up if element is removed from DOM', function (assert) {
            var done = assert.async();
            var fixture = document.getElementById('qunit-fixture');
            var origDataKeys = Object.keys(domDataState._data);
            var div = document.createElement('div');
            mutate.appendChild.call(fixture, div);
            domData.set.call(div, 'div-data', { abc: 'def' });
            var newDataKeys = Object.keys(domDataState._data);
            assert.ok(diff(origDataKeys, newDataKeys).length > 0, 'items added to domData._data for div');
            mutate.removeChild.call(fixture, div);
            var checkRemoved = function () {
                if (diff(Object.keys(domDataState._data), origDataKeys).length === 0) {
                    assert.ok(true, 'domData._data returned to initial state');
                    done();
                } else {
                    setTimeout(checkRemoved, 10);
                }
            };
            checkRemoved();
        });
        unit.test('domData should be cleaned up if multiple elements are removed from DOM', function (assert) {
            var done = assert.async();
            var fixture = document.getElementById('qunit-fixture');
            var origDataKeys = Object.keys(domDataState._data);
            var div = document.createElement('div');
            mutate.appendChild.call(fixture, div);
            domData.set.call(div, 'div-data', { abc: 'def' });
            var newDataKeys = Object.keys(domDataState._data);
            assert.ok(diff(origDataKeys, newDataKeys).length > 0, 'items added to domData._data for div');
            var p = document.createElement('p');
            mutate.appendChild.call(fixture, p);
            domData.set.call(p, 'p-data', { ghi: 'jkl' });
            newDataKeys = Object.keys(domDataState._data);
            assert.ok(diff(origDataKeys, newDataKeys).length > 1, 'items added to domData._data for p');
            mutate.removeChild.call(fixture, div);
            mutate.removeChild.call(fixture, p);
            var checkRemoved = function () {
                if (diff(Object.keys(domDataState._data), origDataKeys).length === 0) {
                    assert.ok(true, 'domData._data returned to initial state');
                    done();
                } else {
                    setTimeout(checkRemoved, 10);
                }
            };
            checkRemoved();
        });
        unit.test('domData should be cleaned up if element is removed from DOM after calling setData for two different keys', function (assert) {
            var fixture = document.getElementById('qunit-fixture');
            var done = assert.async();
            var origDataKeys = Object.keys(domDataState._data);
            var div = document.createElement('div');
            mutate.appendChild.call(fixture, div);
            domData.set.call(div, 'div-data', { abc: 'def' });
            domData.set.call(div, 'div-other-data', { ghi: 'jkl' });
            var newDataKeys = Object.keys(domDataState._data);
            assert.ok(diff(origDataKeys, newDataKeys).length > 0, 'items added to domData._data for div');
            mutate.removeChild.call(fixture, div);
            var checkRemoved = function () {
                if (diff(Object.keys(domDataState._data), origDataKeys).length === 0) {
                    assert.ok(true, 'domData._data returned to initial state');
                    done();
                } else {
                    setTimeout(checkRemoved, 10);
                }
            };
            checkRemoved();
        });
        unit.test('domData should be cleaned up if element is removed from DOM after calling setData twice for the same key', function (assert) {
            var fixture = document.getElementById('qunit-fixture');
            var done = assert.async();
            var origDataKeys = Object.keys(domDataState._data);
            var div = document.createElement('div');
            mutate.appendChild.call(fixture, div);
            domData.set.call(div, 'div-data', { abc: 'def' });
            domData.set.call(div, 'div-data', { ghi: 'jkl' });
            var newDataKeys = Object.keys(domDataState._data);
            assert.ok(diff(origDataKeys, newDataKeys).length > 0, 'items added to domData._data for div');
            mutate.removeChild.call(fixture, div);
            var checkRemoved = function () {
                if (diff(Object.keys(domDataState._data), origDataKeys).length === 0) {
                    assert.ok(true, 'domData._data returned to initial state');
                    done();
                } else {
                    setTimeout(checkRemoved, 10);
                }
            };
            checkRemoved();
        });
        if (typeof MutationObserver !== 'undefined') {
            unit.test('domData should count active elements', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                var fixture = document.getElementById('qunit-fixture');
                var startingCount = domData._getElementSetCount();
                mutate.appendChild.call(fixture, div);
                domData.set.call(div, 'foo', 'bar');
                domData.set.call(div, 'foo', 'baz');
                assert.equal(domData.get.call(div, 'foo'), 'baz', 'foo was set');
                assert.equal(domData._getElementSetCount(), startingCount + 1, '_getElementSetCount() incremented');
                mutate.removeChild.call(fixture, div);
                mutationDocument.onAfterRemovedNodes(function handler() {
                    mutationDocument.offAfterRemovedNodes(handler);
                    setTimeout(function () {
                        assert.equal(domData._getElementSetCount(), startingCount, '_getElementSetCount() decremented');
                        assert.equal(domData.get.call(div, 'foo'), undefined, 'foo was deleted');
                        done();
                    }, 0);
                });
            });
            unit.test('domData should not decrement when removing a deleted element', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                var fixture = document.getElementById('qunit-fixture');
                var startingCount = domData._getElementSetCount();
                mutate.appendChild.call(fixture, div);
                domData.set.call(div, 'foo', 'bar');
                domData.delete.call(div);
                mutate.removeChild.call(fixture, div);
                mutationDocument.onAfterRemovedNodes(function handler() {
                    assert.equal(domData._getElementSetCount(), startingCount);
                    mutationDocument.offAfterRemovedNodes(handler);
                    done();
                });
            });
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/dispatch/dispatch-test*/
define('can-util@3.14.0#dom/dispatch/dispatch-test', [
    'require',
    'exports',
    'module',
    './dispatch',
    '../events/events',
    '../../test/qunit'
], function (require, exports, module) {
    'use strict';
    var domDispatch = require('./dispatch');
    var domEvents = require('../events/events');
    var unit = require('../../test/qunit');
    unit.module('can-util/dom/dispatch');
    unit.test('basic synthetic events', function (assert) {
        var div = document.createElement('div');
        domEvents.addEventListener.call(div, 'foo', function () {
            assert.ok(true, 'called back');
        });
        domDispatch.call(div, 'foo');
    });
    unit.test('more complex synthetic events', function (assert) {
        var div = document.createElement('div');
        var arr = [];
        domEvents.addEventListener.call(div, 'attributes', function (ev) {
            assert.ok(true, 'called back');
            assert.equal(ev.something, arr, 'got data');
        });
        domDispatch.call(div, {
            type: 'attributes',
            something: arr
        }, ['a']);
    });
});
/*can-util@3.14.0#dom/events/enter/enter*/
define('can-util@3.14.0#dom/events/enter/enter', [
    'require',
    'exports',
    'module',
    '../events',
    'can-log/dev/dev',
    'can-event-dom-enter/compat'
], function (require, exports, module) {
    'use strict';
    var events = require('../events');
    var canDev = require('can-log/dev/dev');
    var addEnter = require('can-event-dom-enter/compat');
    addEnter(events);
});
/*can-util@3.14.0#dom/events/delegate/delegate-test*/
define('can-util@3.14.0#dom/events/delegate/delegate-test', [
    'require',
    'exports',
    'module',
    '../events',
    '../../data/data',
    '../../fragment/fragment',
    '../../dispatch/dispatch',
    '../inserted/inserted',
    './delegate',
    './enter-leave',
    '../enter/enter',
    '../../../test/qunit',
    '../../../test/helpers'
], function (require, exports, module) {
    'use strict';
    var domEvents = require('../events');
    var domData = require('../../data/data');
    var buildFrag = require('../../fragment/fragment');
    var domDispatch = require('../../dispatch/dispatch');
    require('../inserted/inserted');
    require('./delegate');
    require('./enter-leave');
    require('../enter/enter');
    var QUnit = require('../../../test/qunit');
    var isServer = require('../../../test/helpers').isServer;
    var supportsMatchesMethod = !isServer();
    QUnit.module('can-util/dom/events/delegate');
    if (supportsMatchesMethod) {
        test('basics', 2, function () {
            stop();
            var frag = buildFrag('<ul><li><span/></li><li></li></ul>');
            var ul = frag.firstChild;
            var parent = document.getElementById('qunit-fixture');
            parent.appendChild(ul);
            var handler = function (ev) {
                ok(true, 'called');
                domEvents.removeDelegateListener.call(ul, 'click', 'li', handler);
                var dE = domData.get.call(this, 'delegateEvents');
                equal(dE, undefined, 'data removed');
                start();
            };
            domEvents.addDelegateListener.call(ul, 'click', 'li', handler);
            domDispatch.call(ul.firstChild.firstChild, 'click');
        });
        test('can call removeDelegateListener without having previously called addDelegateListener', 1, function () {
            try {
                var ul = document.createElement('ul');
                domEvents.removeDelegateListener.call(ul, 'click', 'li', function () {
                });
                ok(true, 'Calling removeDelegateListener does not throw');
            } catch (er) {
                ok(false, 'Calling removeDelegateListener throws');
            }
        });
        test('focus', 2, function () {
            stop();
            var frag = buildFrag('<div><input type=\'text\'></div>');
            var div = frag.firstChild;
            document.getElementById('qunit-fixture').appendChild(div);
            var handler = function (ev) {
                ok(true, 'called');
                domEvents.removeDelegateListener.call(div, 'focus', 'input', handler);
                var dE = domData.get.call(this, 'delegateEvents');
                equal(dE, undefined, 'data removed');
                start();
            };
            domEvents.addDelegateListener.call(div, 'focus', 'input', handler);
            domDispatch.call(div.firstChild, 'focus', [], false);
        });
        test('blur', 2, function () {
            stop();
            var frag = buildFrag('<div><input type=\'text\'></div>');
            var div = frag.firstChild;
            document.getElementById('qunit-fixture').appendChild(div);
            var handler = function (ev) {
                ok(true, 'called');
                domEvents.removeDelegateListener.call(div, 'blur', 'input', handler);
                var dE = domData.get.call(this, 'delegateEvents');
                equal(dE, undefined, 'data removed');
                start();
            };
            domEvents.addDelegateListener.call(div, 'blur', 'input', handler);
            domDispatch.call(div.firstChild, 'blur', [], false);
        });
        test('mouseenter', 3, function () {
            stop();
            var frag = buildFrag('<div><button></button></div>'), div = frag.firstChild;
            document.getElementById('qunit-fixture').appendChild(div);
            var handler = function (ev) {
                ok(true, 'called');
                equal(ev.type, 'mouseenter', 'event in handler has delegated event type');
                domEvents.removeDelegateListener.call(div, 'mouseenter', 'button', handler);
                var dE = domData.get.call(this, 'delegateEvents');
                equal(dE, undefined, 'data removed');
                start();
            };
            domEvents.addDelegateListener.call(div, 'mouseenter', 'button', handler);
            domDispatch.call(div.firstChild, {
                type: 'mouseover',
                view: window,
                relatedTarget: div
            }, [], true);
        });
        test('delegated custom events', 2, function () {
            stop();
            var frag = buildFrag('<div><input type=\'text\'></div>');
            var div = frag.firstChild;
            document.getElementById('qunit-fixture').appendChild(div);
            var handler = function (ev) {
                ok(true, 'called');
                domEvents.removeDelegateListener.call(div, 'enter', 'input', handler);
                var dE = domData.get.call(this, 'delegateEvents');
                equal(dE, undefined, 'data removed');
                start();
            };
            domEvents.addDelegateListener.call(div, 'enter', 'input', handler);
            domDispatch.call(div.firstChild, {
                type: 'keyup',
                keyCode: 13
            }, [], true);
        });
    }
});
/*can-util@3.14.0#dom/events/inserted/inserted-test*/
define('can-util@3.14.0#dom/events/inserted/inserted-test', [
    'require',
    'exports',
    'module',
    './inserted',
    '../events',
    'can-globals/mutation-observer/mutation-observer',
    '../../mutate/mutate',
    'can-log/dev/dev',
    '../../../test/helpers',
    '../../../test/qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('./inserted');
        var domEvents = require('../events');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var domMutate = require('../../mutate/mutate');
        var dev = require('can-log/dev/dev');
        var isProduction = require('../../../test/helpers').isProduction;
        var unit = require('../../../test/qunit');
        function runTest(name, MUT_OBS) {
            var oldMutObs;
            unit.module(name, {
                setup: function () {
                    oldMutObs = getMutationObserver();
                    getMutationObserver(MUT_OBS);
                },
                teardown: function () {
                    getMutationObserver(oldMutObs);
                }
            });
            unit.test('basic insertion', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                domEvents.addEventListener.call(div, 'inserted', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            });
            if (!isProduction()) {
                unit.test('basic disabled insertion', function (assert) {
                    assert.expect(1);
                    var done = assert.async();
                    var oldlog = dev.warn;
                    dev.warn = function (text) {
                        dev.warn = oldlog;
                        var message = 'can-util/dom/events::dispatch';
                        assert.equal(text.slice(0, message.length), message, 'Got expected warning.');
                        done();
                    };
                    var input = document.createElement('input');
                    input.disabled = true;
                    domEvents.addEventListener.call(input, 'inserted', function () {
                    });
                    domMutate.appendChild.call(document.getElementById('qunit-fixture'), input);
                });
            }
            unit.test('parent then child inserted - appendChild', function (assert) {
                assert.expect(1);
                var done = assert.async();
                var div = document.createElement('div');
                var span = document.createElement('span');
                domEvents.addEventListener.call(span, 'inserted', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
                domMutate.appendChild.call(div, span);
            });
            unit.test('parent then child inserted in callback - appendChild', function (assert) {
                assert.expect(1);
                var done = assert.async();
                var div = document.createElement('div');
                var span = document.createElement('span');
                domEvents.addEventListener.call(div, 'inserted', function () {
                    domMutate.appendChild.call(div, span);
                });
                domEvents.addEventListener.call(span, 'inserted', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            });
        }
        runTest('can-util/dom/events/inserted - MutationObserver', getMutationObserver());
        runTest('can-util/dom/events/inserted - no MutationObserver', null);
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/events/make-mutation-event/make-mutation-event-test*/
define('can-util@3.14.0#dom/events/make-mutation-event/make-mutation-event-test', [
    'require',
    'exports',
    'module',
    '../events',
    '../../data/data',
    'can-globals/mutation-observer/mutation-observer',
    './make-mutation-event',
    '../../../test/qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var events = require('../events');
        var domData = require('../../data/data');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var makeMutationEvent = require('./make-mutation-event');
        var unit = require('../../../test/qunit');
        var SPECIAL = 'makeMutationEventTestEvent';
        if (getMutationObserver()) {
            unit.module('can-util/events/make-mutation-event/make-mutation-event');
            makeMutationEvent(SPECIAL, 'addedNodes');
            unit.test('Doesn\'t add data about DocumentFragments (leak)', function (assert) {
                var frag = document.createDocumentFragment();
                frag.appendChild(document.createElement('div'));
                events.addEventListener.call(frag, SPECIAL, Function.prototype);
                var data = domData.get.call(document.documentElement, SPECIAL + 'Data');
                var map = data.nodeIdsRespondingToInsert;
                assert.equal(map.size, 0, 'No special event data added for a document fragment');
            });
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/events/removed/removed-test*/
define('can-util@3.14.0#dom/events/removed/removed-test', [
    'require',
    'exports',
    'module',
    './removed',
    '../../../js/each/each',
    '../events',
    'can-globals/mutation-observer/mutation-observer',
    '../../mutate/mutate',
    '../../../test/qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        require('./removed');
        var each = require('../../../js/each/each');
        var domEvents = require('../events');
        var getMutationObserver = require('can-globals/mutation-observer/mutation-observer');
        var domMutate = require('../../mutate/mutate');
        var unit = require('../../../test/qunit');
        var events = [];
        var addEvent = function (el, event, handler) {
            domEvents.addEventListener.call(el, event, handler);
            events.push({
                el: el,
                event: event,
                handler: handler
            });
        };
        var removeEvents = function () {
            if (events.length) {
                each(events, function (ev) {
                    domEvents.removeEventListener.call(ev.el, ev.event, ev.handler);
                });
            }
            events = [];
        };
        QUnit.module('can-util/dom/events/removed', { teardown: removeEvents });
        var _MutationObserver = getMutationObserver();
        if (_MutationObserver) {
            unit.test('with mutation observer - basic removal - removeChild', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                domEvents.addEventListener.call(div, 'removed', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                document.getElementById('qunit-fixture').appendChild(div);
                document.getElementById('qunit-fixture').removeChild(div);
            });
            unit.test('with mutation observer - disabled removal - removeChild', function (assert) {
                var done = assert.async();
                var input = document.createElement('removed');
                input.disabled = true;
                domEvents.addEventListener.call(input, 'removed', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                document.getElementById('qunit-fixture').appendChild(input);
                document.getElementById('qunit-fixture').removeChild(input);
            });
            unit.test('with mutation observer - basic removal - replaceChild', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                var div2 = document.createElement('div');
                domEvents.addEventListener.call(div, 'removed', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                document.getElementById('qunit-fixture').appendChild(div);
                document.getElementById('qunit-fixture').replaceChild(div2, div);
            });
            unit.test('with mutation observer - nested removal - removeChild', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                var span = document.createElement('span');
                div.appendChild(span);
                domEvents.addEventListener.call(span, 'removed', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                document.getElementById('qunit-fixture').appendChild(div);
                document.getElementById('qunit-fixture').removeChild(div);
            });
            unit.test('with mutation observer - move', function (assert) {
                var done = assert.async();
                assert.expect(0);
                var div = document.createElement('div');
                var span = document.createElement('span');
                var p = document.createElement('p');
                div.appendChild(span);
                div.appendChild(p);
                domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
                addEvent(p, 'removed', function () {
                    assert.ok(false, 'called removed');
                });
                div.insertBefore(p, span);
                done();
            });
            unit.test('with mutation observer - move and remove (#146)', function (assert) {
                var done = assert.async();
                var fixture = document.getElementById('qunit-fixture');
                var div = document.createElement('div');
                var span = document.createElement('span');
                var p = document.createElement('p');
                div.appendChild(span);
                div.appendChild(p);
                domMutate.appendChild.call(fixture, div);
                var div2 = document.createElement('div');
                domMutate.appendChild.call(fixture, div2);
                addEvent(p, 'removed', function () {
                    assert.ok(false, 'called removed');
                });
                addEvent(div2, 'removed', function () {
                    assert.ok(true, 'div removed');
                    done();
                });
                div.insertBefore(p, span);
                domMutate.removeChild.call(fixture, div2);
            });
            unit.test('with mutation observer - remaining event handlers fire after one is removed (#236)', function (assert) {
                var done = assert.async();
                var div = document.createElement('div');
                domEvents.addEventListener.call(div, 'removed', function () {
                    assert.ok(true, 'called back');
                    done();
                });
                function removeTwo() {
                }
                domEvents.addEventListener.call(div, 'removed', removeTwo);
                domEvents.removeEventListener.call(div, 'removed', removeTwo);
                document.getElementById('qunit-fixture').appendChild(div);
                document.getElementById('qunit-fixture').removeChild(div);
            });
        }
        unit.test('basic removal without mutation observer - removeChild', function (assert) {
            var done = assert.async();
            getMutationObserver(null);
            var div = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                assert.ok(true, 'called back');
                getMutationObserver(_MutationObserver);
                done();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            domMutate.removeChild.call(document.getElementById('qunit-fixture'), div);
        });
        unit.test('disabled removal without mutation observer - removeChild', function (assert) {
            var done = assert.async();
            getMutationObserver(null);
            var input = document.createElement('input');
            input.disabled = true;
            domEvents.addEventListener.call(input, 'removed', function () {
                assert.ok(true, 'called back');
                getMutationObserver(_MutationObserver);
                done();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), input);
            domMutate.removeChild.call(document.getElementById('qunit-fixture'), input);
        });
        unit.test('basic insertion without mutation observer - replaceChild', function (assert) {
            var done = assert.async();
            getMutationObserver(null);
            var div = document.createElement('div');
            var div2 = document.createElement('div');
            domEvents.addEventListener.call(div, 'removed', function () {
                assert.ok(true, 'called back');
                getMutationObserver(_MutationObserver);
                done();
            });
            domMutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            domMutate.replaceChild.call(document.getElementById('qunit-fixture'), div2, div);
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/mutate/mutate-test*/
define('can-util@3.14.0#dom/mutate/mutate-test', [
    'require',
    'exports',
    'module',
    './mutate',
    '../mutation-observer/mutation-observer',
    'can-globals/document/document',
    'can-vdom/make-document/make-document',
    '../../test/qunit'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var mutate = require('./mutate');
        var MUTATION_OBSERVER = require('../mutation-observer/mutation-observer');
        var getDocument = require('can-globals/document/document');
        var makeDocument = require('can-vdom/make-document/make-document');
        var unit = require('../../test/qunit');
        unit.module('can-util/dom/mutate');
        function disableMO() {
            var old = MUTATION_OBSERVER();
            MUTATION_OBSERVER(null);
            return function () {
                MUTATION_OBSERVER(old);
            };
        }
        unit.test('inserting empty frag', function (assert) {
            var done = assert.async();
            var enableMO = disableMO();
            var frag = document.createDocumentFragment();
            mutate.appendChild.call(document.getElementById('qunit-fixture'), frag);
            var div = document.createElement('div');
            div.addEventListener('inserted', function () {
                assert.ok(true, 'called');
                done();
            });
            mutate.appendChild.call(document.getElementById('qunit-fixture'), div);
            enableMO();
        });
        unit.test('removing the body causes removed events', function (assert) {
            var done = assert.async();
            var enableMO = disableMO();
            var oldDoc = getDocument();
            var doc = makeDocument();
            getDocument(doc);
            var div = doc.createElement('div');
            mutate.appendChild.call(doc.body, div);
            div.addEventListener('removed', function () {
                assert.ok(true, 'called');
                enableMO();
                getDocument(oldDoc);
                done();
            });
            mutate.removeChild.call(doc.documentElement, doc.body);
        });
        unit.skip('inserting into a different document fires inserted', function (assert) {
            var done = assert.async();
            var enableMO = disableMO();
            var doc = document.implementation.createHTMLDocument('Demo');
            var oldDoc = getDocument();
            getDocument(doc);
            var div = document.createElement('div');
            div.addEventListener('inserted', function () {
                assert.ok(true, 'called');
                enableMO();
                getDocument(oldDoc);
                done();
            });
            mutate.appendChild.call(doc.body, div);
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-util@3.14.0#dom/matches/matches-test*/
define('can-util@3.14.0#dom/matches/matches-test', [
    'require',
    'exports',
    'module',
    './matches',
    '../../test/qunit',
    '../../test/helpers'
], function (require, exports, module) {
    'use strict';
    var matches = require('./matches');
    var unit = require('../../test/qunit');
    var isServer = require('../../test/helpers').isServer;
    unit.module('can-util/dom/matches');
    var supportsMatchesMethod = !isServer();
    if (supportsMatchesMethod) {
        unit.test('basics', function (assert) {
            var a = document.createElement('a');
            a.id = 'foo';
            document.getElementById('qunit-fixture').appendChild(a);
            assert.ok(matches.call(a, '#foo'), 'matches selector');
        });
    }
    unit.test('returns false for document', function (assert) {
        var res = matches.call(document, 'a');
        assert.equal(res, false, 'document never matches');
    });
});
/*can-util@3.14.0#dom/tests*/
define('can-util@3.14.0#dom/tests', [
    'require',
    'exports',
    'module',
    './attr/attr-test',
    './data/data-test',
    './dispatch/dispatch-test',
    './events/delegate/delegate-test',
    './events/inserted/inserted-test',
    './events/make-mutation-event/make-mutation-event-test',
    './events/removed/removed-test',
    './mutate/mutate-test',
    './matches/matches-test'
], function (require, exports, module) {
    'use strict';
    require('./attr/attr-test');
    require('./data/data-test');
    require('./dispatch/dispatch-test');
    require('./events/delegate/delegate-test');
    require('./events/inserted/inserted-test');
    require('./events/make-mutation-event/make-mutation-event-test');
    require('./events/removed/removed-test');
    require('./mutate/mutate-test');
    require('./matches/matches-test');
});
/*can-util@3.14.0#test/test*/
define('can-util@3.14.0#test/test', [
    'require',
    'exports',
    'module',
    '../js/tests.js',
    '../dom/tests.js'
], function (require, exports, module) {
    require('../js/tests.js');
    require('../dom/tests.js');
});
/*can@3.14.0#util/util_test*/
define('can@3.14.0#util/util_test', [
    'require',
    'exports',
    'module',
    'can-util/test/test'
], function (require, exports, module) {
    require('can-util/test/test');
});
/*can-view-import@3.2.9#can-view-import*/
define('can-view-import@3.2.9#can-view-import', [
    'require',
    'exports',
    'module',
    'can-assign',
    'can-dom-data-state',
    'can-globals/document/document',
    'can-util/dom/child-nodes/child-nodes',
    'can-util/js/import/import',
    'can-util/dom/mutate/mutate',
    'can-view-nodelist',
    'can-view-callbacks',
    'can-event',
    'can-log/',
    'can-log/dev/dev'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var assign = require('can-assign');
        var canData = require('can-dom-data-state');
        var DOCUMENT = require('can-globals/document/document');
        var getChildNodes = require('can-util/dom/child-nodes/child-nodes');
        var importer = require('can-util/js/import/import');
        var mutate = require('can-util/dom/mutate/mutate');
        var nodeLists = require('can-view-nodelist');
        var viewCallbacks = require('can-view-callbacks');
        var tag = viewCallbacks.tag;
        var events = require('can-event');
        var canLog = require('can-log/');
        var dev = require('can-log/dev/dev');
        function processImport(el, tagData) {
            var moduleName = el.getAttribute('from');
            var templateModule = tagData.options.get('helpers.module');
            var parentName = templateModule ? templateModule.id : undefined;
            if (!moduleName) {
                return Promise.reject('No module name provided');
            }
            var importPromise = importer(moduleName, parentName);
            importPromise.catch(function (err) {
                canLog.error(err);
            });
            canData.set.call(el, 'viewModel', importPromise);
            canData.set.call(el, 'scope', importPromise);
            var scope = tagData.scope.add(importPromise, { notContext: true });
            var handOffTag = el.getAttribute('can-tag');
            if (handOffTag) {
                var callback = tag(handOffTag);
                if (!callback || callback === viewCallbacks.defaultCallback) {
                } else {
                    canData.set.call(el, 'preventDataBindings', true);
                    callback(el, assign(tagData, { scope: scope }));
                    canData.set.call(el, 'preventDataBindings', false);
                    canData.set.call(el, 'viewModel', importPromise);
                    canData.set.call(el, 'scope', importPromise);
                }
            } else {
                var frag = tagData.subtemplate ? tagData.subtemplate(scope, tagData.options) : DOCUMENT().createDocumentFragment();
                var nodeList = nodeLists.register([], undefined, tagData.parentNodeList || true);
                nodeList.expression = '<' + this.tagName + '>';
                events.one.call(el, 'removed', function () {
                    nodeLists.unregister(nodeList);
                });
                mutate.appendChild.call(el, frag);
                nodeLists.update(nodeList, getChildNodes(el));
            }
        }
        [
            'can-import',
            'can-dynamic-import'
        ].forEach(function (tagName) {
            tag(tagName, processImport.bind({ tagName: tagName }));
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-view-import@3.2.9#can-view-import_test*/
define('can-view-import@3.2.9#can-view-import_test', [
    'require',
    'exports',
    'module',
    'can-map',
    'can-component',
    'can-stache',
    'can-compute',
    'can-stache/src/intermediate_and_imports',
    'steal-qunit',
    'can-util/js/import/import',
    'can-view-callbacks',
    'can-test-helpers',
    './can-view-import'
], function (require, exports, module) {
    var CanMap = require('can-map');
    var Component = require('can-component');
    var stache = require('can-stache');
    var compute = require('can-compute');
    var getIntermediateAndImports = require('can-stache/src/intermediate_and_imports');
    var QUnit = require('steal-qunit');
    var importer = require('can-util/js/import/import');
    var tag = require('can-view-callbacks').tag;
    var testHelpers = require('can-test-helpers');
    require('./can-view-import');
    if (window.steal) {
        QUnit.module('can/view/import');
        var test = QUnit.test;
        var equal = QUnit.equal;
        test('static imports are imported', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\'/>' + '<hello-world></hello-world>');
            equal(iai.imports.length, 1, 'There is one import');
        });
        test('dynamic imports are not imported', function () {
            var iai = getIntermediateAndImports('{{#if a}}<can-import from=\'can-view-import/test/hello\'>' + '<hello-world></hello-world></can-import>{{/if a}}');
            equal(iai.imports.length, 0, 'There are no imports');
        });
        if (!System.isEnv('production')) {
            asyncTest('dynamic imports will only load when in scope', function () {
                expect(4);
                var iai = getIntermediateAndImports('{{#if a}}<can-import from=\'can-view-import/test/hello\'>' + '{{#eq state \'resolved\'}}<hello-world></hello-world>{{/eq}}</can-import>{{/if a}}');
                var template = stache(iai.intermediate);
                var a = compute(false);
                var res = template({ a: a });
                equal(res.childNodes[0].childNodes.length, 0, 'There are no child nodes immediately');
                a(true);
                importer('can-view-import/test/hello').then(function () {
                    equal(res.childNodes[0].childNodes.length, 1, 'There is now a nested component');
                    equal(res.childNodes[0].childNodes[0].tagName.toUpperCase(), 'HELLO-WORLD', 'imported the tag');
                    equal(res.childNodes[0].childNodes[0].childNodes[0].nodeValue, 'Hello world!', 'text inserted');
                    start();
                });
            });
        }
        test('if a can-tag is present, handed over rendering to that tag', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\' can-tag=\'loading\'/>');
            tag('loading', function (el) {
                var template = stache('it worked');
                el.appendChild(template());
            });
            var template = stache(iai.intermediate);
            var res = template();
            equal(res.childNodes[0].childNodes[0].nodeValue, 'it worked', 'Rendered with the can-tag');
        });
        testHelpers.dev.devOnlyTest('if a can-tag is present, but not registered, should throw error (#2)', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\' can-tag=\'not-exist\'/>');
            var template = stache(iai.intermediate);
            var finishWarningCheck = testHelpers.dev.willError('The tag \'not-exist\' has not been properly registered.', function (message, matched) {
                if (matched) {
                    ok(true, 'Error message properly sent');
                }
            });
            template();
            finishWarningCheck();
        });
        testHelpers.dev.devOnlyTest('if a can-tag is present, but not registered, should throw error (#2)', function () {
            var iai = getIntermediateAndImports('<can-import from=\'can-view-import/test/hello\' can-tag=\'notexist\'/>');
            var template = stache(iai.intermediate);
            var finishWarningCheck = testHelpers.dev.willError('The tag \'notexist\' has not been properly registered.', function (message, matched) {
                if (matched) {
                    ok(true, 'Error message properly sent');
                }
            });
            template();
            finishWarningCheck();
        });
        if (!System.isEnv('production')) {
            asyncTest('can use an import\'s value', function () {
                var template = '<can-import from=\'can-view-import/test/person\' @value:to=\'*person\' />hello {{*person.name}}';
                var iai = getIntermediateAndImports(template);
                var renderer = stache(iai.intermediate);
                var res = renderer(new CanMap());
                importer('can-view-import/test/person').then(function () {
                    equal(res.childNodes[2].nodeValue, 'world', 'Got the person.name from the import');
                    start();
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can import a template and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other.stache!\' @value:to=\'*other\' />{{{*other()}}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can import a template and use it using the > syntax', function () {
                var template = '<can-import from=\'can-view-import/test/other.stache!\' @value:to=\'*other\' />{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('importing a template works with can-tag', function () {
                Component.extend({
                    tag: 'my-waiter',
                    view: stache('{{#isResolved}}' + '<content></content>' + '{{else}}' + '<div class=\'loading\'></div>' + '{{/isResolved}}'),
                    leakScope: true
                });
                var template = '<can-import from=\'can-view-import/test/other.stache\' @value:to=\'*other\' can-tag=\'my-waiter\'>{{{*other()}}}</can-import>';
                var finishWarningCheck = testHelpers.dev.willWarn(/is not in the current scope/, function (message, matched) {
                    QUnit.notOk(matched, 'importPromise throws a false-positive warning (#83)');
                });
                stache.async(template).then(function (renderer) {
                    var frag = renderer(new CanMap());
                    finishWarningCheck();
                    importer('can-view-import/test/other.stache').then(function () {
                        ok(frag.childNodes[0].childNodes.length > 1, 'Something besides a text node is inserted');
                        equal(frag.childNodes[0].childNodes[2].firstChild.nodeValue, 'hi there', 'Partial worked with can-tag');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production')) {
            asyncTest('can dynamically import a template with can-import and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other-dynamic.stache!\' @value:to=\'*other\'/>{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
            asyncTest('can dynamically import a template with can-dynamic-import (self-closing) and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other-dynamic-unary.stache!\' @value:to=\'*other\'/>{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
            asyncTest('can dynamically import a template with can-dynamic-import and use it', function () {
                var template = '<can-import from=\'can-view-import/test/other-dynamic-block.stache!\' @value:to=\'*other\'/>{{> *other}}';
                stache.async(template).then(function (renderer) {
                    var frag = renderer();
                    importer('can-view-import/test/other.stache!').then(function () {
                        equal(frag.childNodes[3].firstChild.nodeValue, 'hi there', 'Partial was renderered right after the can-import');
                        QUnit.start();
                    });
                });
            });
        }
        if (!System.isEnv('production') && typeof console === 'object') {
            asyncTest('loading errors are logged to the console', function () {
                var template = '<can-import from=\'can-view-import/test/error\'>{{foo}}</can-import>';
                var error = console.error;
                console.error = function (type) {
                    console.error = error;
                    QUnit.ok(/ERROR/i.test(type), 'Logged an error that originated from the dynamically imported module');
                    QUnit.start();
                };
                stache.async(template).then(function (renderer) {
                    renderer({});
                });
            });
        }
    }
});
/*can@3.14.0#view/import/import_test*/
define('can@3.14.0#view/import/import_test', [
    'require',
    'exports',
    'module',
    'can-view-import/can-view-import_test'
], function (require, exports, module) {
    require('can-view-import/can-view-import_test');
});
/*can-view-live@3.2.6#test/live-test*/
define('can-view-live@3.2.6#test/live-test', [
    'require',
    'exports',
    'module',
    'can-view-live',
    'can-compute',
    'can-map',
    'can-list',
    'can-view-nodelist',
    'can-event/batch/batch',
    'can-observation',
    'can-util/dom/events/events',
    'can-reflect',
    'steal-qunit',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/dom/mutate/mutate',
    'can-util/dom/attr/attr',
    'can-util/dom/fragment/fragment',
    'can-util/js/make-array/make-array'
], function (require, exports, module) {
    var live = require('can-view-live');
    var compute = require('can-compute');
    var Map = require('can-map');
    var List = require('can-list');
    var nodeLists = require('can-view-nodelist');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var domEvents = require('can-util/dom/events/events');
    var canReflect = require('can-reflect');
    var QUnit = require('steal-qunit');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var domMutate = require('can-util/dom/mutate/mutate');
    var domAttr = require('can-util/dom/attr/attr');
    var fragment = require('can-util/dom/fragment/fragment');
    var makeArray = require('can-util/js/make-array/make-array');
    QUnit.module('can-view-live', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var html = compute(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    var esc = function (str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    };
    test('text', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var text = compute(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.text(span, text, div);
        equal(div.innerHTML, esc('<label>one</label><label>two</label>'));
        items.push('three');
        equal(div.innerHTML, esc('<label>one</label><label>two</label><label>three</label>'));
    });
    test('attributes', function () {
        var div = document.createElement('div');
        var items = new List([
            'class',
            'foo'
        ]);
        var text = compute(function () {
            var html = '';
            if (items.attr(0) && items.attr(1)) {
                html += items.attr(0) + '=\'' + items.attr(1) + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        items.splice(0, 2);
        equal(div.className, '');
        items.push('foo', 'bar');
        equal(div.getAttribute('foo'), 'bar');
    });
    test('attributes - should remove `removed` events listener', function () {
        QUnit.stop();
        var origAddEventListener = domEvents.addEventListener;
        var origRemoveEventListener = domEvents.removeEventListener;
        domEvents.addEventListener = function () {
            QUnit.ok(true, 'addEventListener called');
            origAddEventListener.apply(this, arguments);
            domEvents.addEventListener = origAddEventListener;
        };
        domEvents.removeEventListener = function () {
            QUnit.ok(true, 'addEventListener called');
            origRemoveEventListener.apply(this, arguments);
            domEvents.removeEventListener = origRemoveEventListener;
            QUnit.start();
        };
        var div = document.createElement('div');
        var text = compute('hello');
        domMutate.appendChild.call(this.fixture, div);
        live.attrs(div, text);
        domMutate.removeChild.call(this.fixture, div);
    });
    test('attribute', function () {
        var div = document.createElement('div');
        var firstObject = new Map({});
        var first = compute(function () {
            return firstObject.attr('selected') ? 'selected' : '';
        });
        var secondObject = new Map({});
        var second = compute(function () {
            return secondObject.attr('active') ? 'active' : '';
        });
        var className = compute(function () {
            return 'foo ' + first() + ' ' + second() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstObject.attr('selected', true);
        equal(div.className, 'foo selected  end');
        secondObject.attr('active', true);
        equal(div.className, 'foo selected active end');
        firstObject.attr('selected', false);
        equal(div.className, 'foo  active end');
    });
    test('specialAttribute with new line', function () {
        var div = document.createElement('div');
        var style = compute('width: 50px;\nheight:50px;');
        live.attr(div, 'style', style);
        equal(div.style.height, '50px');
        equal(div.style.width, '50px');
    });
    test('list', function () {
        var div = document.createElement('div'), list = new List([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        list.push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
    });
    test('list within a compute', function () {
        var div = document.createElement('div'), map = new Map({
                animals: [
                    'bear',
                    'turtle'
                ]
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listCompute = compute(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new List([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    test('list with a compute that returns a list', function () {
        var div = document.createElement('div');
        var template = function (num) {
            return '<label>num=</label> <span>' + num + '</span>';
        };
        var arrCompute = compute([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, arrCompute, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        arrCompute([
            0,
            1,
            2
        ]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
    });
    test('text binding is memory safe (#666)', function () {
        nodeLists.nodeMap.clear();
        var div = document.createElement('div'), span = document.createElement('span'), text = compute(function () {
                return 'foo';
            });
        div.appendChild(span);
        domMutate.appendChild.call(this.fixture, div);
        live.text(span, text, div);
        domMutate.removeChild.call(this.fixture, div);
        stop();
        setTimeout(function () {
            ok(!nodeLists.nodeMap.size, 'nothing in nodeMap');
            start();
        }, 100);
    });
    test('html live binding handles getting a function from a compute', 5, function () {
        var handler = function (el) {
            ok(true, 'called handler');
            equal(el.nodeType, 3, 'got a placeholder');
        };
        var div = document.createElement('div'), placeholder = document.createTextNode('');
        div.appendChild(placeholder);
        var count = compute(0);
        var html = compute(function () {
            if (count() === 0) {
                return '<h1>Hello World</h1>';
            } else {
                return handler;
            }
        });
        live.html(placeholder, html, div);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
        count(1);
        equal(div.getElementsByTagName('h1').length, 0, 'got h1');
        count(0);
        equal(div.getElementsByTagName('h1').length, 1, 'got h1');
    });
    test('live.list does not unbind on a list unnecessarily (#1835)', function () {
        expect(0);
        var div = document.createElement('div'), list = new List([
                'sloth',
                'bear'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal + '</span>';
            }, unbind = list.unbind;
        list.unbind = function () {
            ok(false, 'unbind called');
            return unbind.apply(this, arguments);
        };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, list, template, {});
    });
    test('live.list should handle move events', function (assert) {
        var parent = document.createElement('div');
        var child = document.createElement('div');
        parent.appendChild(child);
        var list = new List([
            1,
            2,
            3
        ]);
        var template = function (num) {
            return '<span>' + num + '</span>';
        };
        live.list(child, list, template, {});
        var oldIndex = 0;
        var newIndex = 2;
        var val = list[oldIndex];
        var args = [
            val,
            oldIndex,
            newIndex
        ];
        list.dispatch('move', args);
        assert.ok(true, 'The list should not blow up');
    });
    test('can.live.attr works with non-string attributes (#1790)', function () {
        var el = document.createElement('div'), attrCompute = compute(function () {
                return 2;
            });
        domAttr.set(el, 'value', 1);
        live.attr(el, 'value', attrCompute);
        ok(true, 'No exception thrown.');
    });
    test('list and an falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function (num) {
                return '<p>NOTHING</p>';
            };
        var listCompute = compute([
            0,
            1
        ]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        listCompute([]);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('list and an initial falsey section (#1979)', function () {
        var div = document.createElement('div'), template = function (num) {
                return '<label>num=</label> <span>' + num + '</span>';
            }, falseyTemplate = function (num) {
                return '<p>NOTHING</p>';
            };
        var listCompute = compute([]);
        div.innerHTML = 'my <b>fav</b> nums: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listCompute, template, {}, undefined, undefined, falseyTemplate);
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 0, 'there are 0 spans');
        var ps = div.getElementsByTagName('p');
        equal(ps.length, 1, 'there is 1 p');
        listCompute([2]);
        spans = div.getElementsByTagName('span');
        equal(spans.length, 1, 'there is 1 spans');
        ps = div.getElementsByTagName('p');
        equal(ps.length, 0, 'there is 1 p');
    });
    test('rendered list items should re-render when updated (#2007)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new List(['foo']);
        var renderer = function (item) {
            return '<span>' + item.get() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'foo', 'list item 0 is foo');
        list.push('bar');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'bar', 'list item 1 is bar');
        list.attr(0, 'baz');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'baz', 'list item 0 is baz');
    });
    test('list items should be correct even if renderer flushes batch (#8)', function () {
        var partial = document.createElement('div');
        var placeholderElement = document.createElement('span');
        var list = new List([
            'one',
            'two'
        ]);
        var renderer = function (item) {
            canBatch.flush();
            return '<span>' + item.get() + '</span>';
        };
        partial.appendChild(placeholderElement);
        live.list(placeholderElement, list, renderer, {});
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'one', 'list item 0 is "one"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'two', 'list item 1 is "two"');
        canBatch.start();
        list.splice(0, 0, 'three');
        list.splice(2, 1);
        canBatch.stop();
        equal(partial.getElementsByTagName('span').length, 2, 'should be two items');
        equal(partial.getElementsByTagName('span')[0].firstChild.data, 'three', 'list item 0 is "three"');
        equal(partial.getElementsByTagName('span')[1].firstChild.data, 'one', 'list item 1 is "one"');
    });
    test('changing items in a live.list after it has been unregistered works (#55)', function () {
        var map = new Map({
            show: true,
            list: ['one']
        });
        var htmlNodeList = makeArray(fragment('<div></div>').childNodes);
        nodeLists.register(htmlNodeList, function () {
        }, true);
        var listNodeList = makeArray(fragment('<div></div>').childNodes);
        nodeLists.register(listNodeList, function () {
        }, htmlNodeList, true);
        var listTextNode = document.createTextNode('');
        var listFrag = document.createDocumentFragment();
        listFrag.appendChild(listTextNode);
        var htmlTextNode = document.createTextNode('');
        var div = document.createElement('div');
        div.appendChild(htmlTextNode);
        var listObs = new Observation(function () {
            return map.attr('list');
        });
        var listRenderer = function (item) {
            Observation.temporarilyBind(item);
            return item.get();
        };
        live.list(listTextNode, listObs, listRenderer, map, listTextNode.parentNode, listNodeList);
        var htmlObservation = new Observation(function () {
            return map.attr('show') ? listFrag : undefined;
        });
        live.html(htmlTextNode, htmlObservation, htmlTextNode.parentNode, htmlNodeList);
        canBatch.start();
        map.attr('show', false);
        map.attr('list').replace([
            'two',
            'three'
        ]);
        canBatch.stop();
        ok(true, 'should not throw');
    });
    QUnit.test('Works with Observations - .html', function () {
        var div = document.createElement('div'), span = document.createElement('span');
        div.appendChild(span);
        var items = new List([
            'one',
            'two'
        ]);
        var html = new Observation(function () {
            var html = '';
            items.each(function (item) {
                html += '<label>' + item + '</label>';
            });
            return html;
        });
        live.html(span, html, div);
        equal(div.getElementsByTagName('label').length, 2);
        items.push('three');
        equal(div.getElementsByTagName('label').length, 3);
    });
    QUnit.test('Works with Observations - .list', function () {
        var div = document.createElement('div'), map = new Map({
                animals: [
                    'bear',
                    'turtle'
                ]
            }), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        var listObservation = new Observation(function () {
            return map.attr('animals');
        });
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, listObservation, template, {});
        equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
        div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
        map.attr('animals').push('turtle');
        equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
        equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        map.attr('animals', new List([
            'sloth',
            'bear',
            'turtle'
        ]));
        var spans = div.getElementsByTagName('span');
        equal(spans.length, 3, 'there are 3 spans');
        ok(!div.getElementsByTagName('label')[0].myexpando, 'no expando');
    });
    QUnit.test('Works with Observations - .attrs', function () {
        var div = document.createElement('div');
        var items = new List([
            'class',
            'foo'
        ]);
        var text = new Observation(function () {
            var html = '';
            if (items.attr(0) && items.attr(1)) {
                html += items.attr(0) + '=\'' + items.attr(1) + '\'';
            }
            return html;
        });
        live.attrs(div, text);
        equal(div.className, 'foo');
        items.splice(0, 2);
        equal(div.className, '');
        items.push('foo', 'bar');
        equal(div.getAttribute('foo'), 'bar');
    });
    QUnit.test('Works with Observations - .attr', function () {
        var div = document.createElement('div');
        var firstObject = new Map({});
        var first = compute(function () {
            return firstObject.attr('selected') ? 'selected' : '';
        });
        var secondObject = new Map({});
        var second = compute(function () {
            return secondObject.attr('active') ? 'active' : '';
        });
        var className = new Observation(function () {
            return 'foo ' + first() + ' ' + second() + ' end';
        });
        live.attr(div, 'class', className);
        equal(div.className, 'foo   end');
        firstObject.attr('selected', true);
        equal(div.className, 'foo selected  end');
        secondObject.attr('active', true);
        equal(div.className, 'foo selected active end');
        firstObject.attr('selected', false);
        equal(div.className, 'foo  active end');
    });
    QUnit.test('events are torn down from correct list on change', function () {
        var div = document.createElement('div');
        var list = new List([
            1,
            2,
            3
        ]);
        var filteredList;
        var c = compute(list);
        var template = function (number) {
            return '<label>Odd number=</label> <span>' + number.get() + '</span>';
        };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var el = div.getElementsByTagName('span')[0];
        live.list(el, c, template, {});
        ok(list.__bindEvents.add && list.__bindEvents.add.length > 0, 'Add handler has been added to list');
        c(filteredList = list.filter(function (x) {
            return x % 2;
        }));
        ok(!list.__bindEvents.add || list.__bindEvents.add.length === 0, 'Add handler has been removed from list');
        ok(filteredList.__bindEvents.add && filteredList.__bindEvents.add.length > 0, 'Add handler has been added to filteredList');
    });
    test('no memory leaks with replacements (#93)', function () {
        var div = document.createElement('div'), animals = new List([
                'bear',
                'turtle'
            ]), template = function (animal) {
                return '<label>Animal=</label> <span>' + animal.get() + '</span>';
            };
        div.innerHTML = 'my <b>fav</b> animals: <span></span> !';
        var htmlNodeList = canReflect.toArray(div.childNodes);
        nodeLists.register(htmlNodeList, function () {
        }, true);
        var el = div.getElementsByTagName('span')[0];
        this.fixture.appendChild(div);
        var nodeList = [el];
        nodeLists.register(nodeList, function () {
        }, htmlNodeList);
        live.list(el, animals, template, {}, this.fixture, nodeList);
        QUnit.deepEqual(nodeList.replacements, [], 'no replacements');
        animals.push('foo');
        QUnit.deepEqual(nodeList.replacements, [], 'no replacements');
        animals.shift();
        QUnit.deepEqual(nodeList.replacements, [], 'no replacements');
    });
});
/*can@3.14.0#view/live/live_test*/
define('can@3.14.0#view/live/live_test', [
    'require',
    'exports',
    'module',
    'can-view-live/test/live-test'
], function (require, exports, module) {
    require('can-view-live/test/live-test');
});
/*can-view-model@3.5.2#can-view-model_test*/
define('can-view-model@3.5.2#can-view-model_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-view-model',
    'can-simple-map',
    'can-map',
    'can-define/map/map',
    'can-types'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var viewModel = require('can-view-model');
    var SimpleMap = require('can-simple-map');
    var CanMap = require('can-map');
    var DefineMap = require('can-define/map/map');
    var types = require('can-types');
    QUnit.module('can-view-model');
    QUnit.test('basics', function () {
        var DefaultMap = types.DefaultMap;
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        viewModel(el, 'foo', 'bar');
        QUnit.equal(viewModel(el, 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('a selector can be passed as the first argument (#6)', function () {
        var DefaultMap = types.DefaultMap;
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        el.className = 'the-el';
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel('.the-el', 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('set custom can-simple-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = SimpleMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('set custom can-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = CanMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('set custom can-define-map on element (#5)', function () {
        var vm, elVm;
        var CustomMap = DefineMap.extend({});
        var el = document.createElement('div');
        document.getElementById('qunit-fixture').appendChild(el);
        vm = new CustomMap({ foo: 'bar' });
        elVm = viewModel(el, vm);
        QUnit.equal(viewModel(el, 'foo'), 'bar');
    });
    QUnit.test('Allow passing array like (jQuery) element', function () {
        var DefaultMap = types.DefaultMap;
        var $el = {};
        types.DefaultMap = undefined;
        var el = document.createElement('div');
        el.className = 'the-el';
        $el[0] = el;
        $el.length = 1;
        document.getElementById('qunit-fixture').appendChild(el);
        viewModel($el, 'foo', 'bar');
        QUnit.equal(viewModel('.the-el', 'foo'), 'bar', 'It reads view scope from html element');
        QUnit.equal(viewModel($el, 'foo'), 'bar', 'It reads view scope from array like (jQuery) element');
        QUnit.ok(viewModel(el) instanceof SimpleMap, 'is can-map');
        types.DefaultMap = DefaultMap;
    });
    QUnit.test('elements with length property not treated as arraylikes (#31)', function () {
        var el = document.createElement('select');
        document.getElementById('qunit-fixture').appendChild(el);
        QUnit.equal(el.length, 0, 'Select has length property (0 for empty)');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on empty select');
        var opt = document.createElement('option');
        el.appendChild(opt);
        QUnit.equal(el.length, 1, 'Select has length 1');
        QUnit.deepEqual(viewModel(el).get(), {}, 'viewModel created on non-empty select');
    });
});
/*can-view-model@3.5.2#test/test*/
define('can-view-model@3.5.2#test/test', [
    'require',
    'exports',
    'module',
    '../can-view-model_test'
], function (require, exports, module) {
    require('../can-view-model_test');
});
/*can-view-nodelist@3.1.1#test/can-view-nodelist-test*/
define('can-view-nodelist@3.1.1#test/can-view-nodelist-test', [
    'require',
    'exports',
    'module',
    'can-view-nodelist',
    'can-util/dom/fragment/fragment',
    'can-util/js/make-array/make-array',
    'can-util/dom/frag/frag',
    'steal-qunit'
], function (require, exports, module) {
    var nodeLists = require('can-view-nodelist');
    var fragment = require('can-util/dom/fragment/fragment');
    var makeArray = require('can-util/js/make-array/make-array');
    var frag = require('can-util/dom/frag/frag');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-nodelist');
    test('unregisters child nodeLists', function () {
        expect(3);
        var spansFrag = fragment('<span>1</span><span>2</span>');
        var spansList = makeArray(spansFrag.childNodes);
        nodeLists.register(spansList, function () {
            ok(true, 'unregistered spansList');
        });
        var labelFrag = fragment('<label>l</label>');
        var labelList = makeArray(labelFrag.childNodes);
        nodeLists.register(labelList, function () {
            ok(true, 'unregistered labelList');
        });
        var ifPreHookupFrag = frag([
                '~',
                '',
                '-',
                ''
            ]), ifChildNodes = ifPreHookupFrag.childNodes, ifEls = makeArray(ifChildNodes);
        nodeLists.replace([ifChildNodes[1]], spansFrag);
        nodeLists.replace([ifChildNodes[4]], labelFrag);
        var ifList = makeArray(ifPreHookupFrag.childNodes);
        nodeLists.register(ifList, function () {
            ok(true, 'unregistered ifList');
        });
        deepEqual(ifList, [
            ifEls[0],
            spansList,
            ifEls[2],
            labelList
        ]);
        nodeLists.update(ifList, [document.createTextNode('empty')]);
    });
});
/*can@3.14.0#view/node_lists/node_lists_test*/
define('can@3.14.0#view/node_lists/node_lists_test', [
    'require',
    'exports',
    'module',
    'can-view-nodelist/test/can-view-nodelist-test'
], function (require, exports, module) {
    require('can-view-nodelist/test/can-view-nodelist-test');
});
/*can-view-parser@3.8.3#test/can-view-parser-test*/
define('can-view-parser@3.8.3#test/can-view-parser-test', [
    'require',
    'exports',
    'module',
    'can-view-parser',
    'steal-qunit',
    'can-log/dev/dev',
    'can-attribute-encoder',
    'can-test-helpers'
], function (require, exports, module) {
    var parser = require('can-view-parser');
    var QUnit = require('steal-qunit');
    var canDev = require('can-log/dev/dev');
    var encoder = require('can-attribute-encoder');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can-view-parser');
    var makeChecks = function (tests) {
        var count = 0;
        var makeCheck = function (name) {
            return function () {
                if (count >= tests.length) {
                    ok(false, 'called ' + name + ' with ' + JSON.stringify([].slice.call(arguments)));
                } else {
                    var test = tests[count], args = test[1];
                    equal(name, test[0], 'test ' + count + ' ' + name + '(');
                    for (var i = 0; i < args.length; i++) {
                        equal(arguments[i], args[i], i + 1 + ' arg -> ' + args[i]);
                    }
                    count++;
                }
            };
        };
        return {
            start: makeCheck('start'),
            end: makeCheck('end'),
            close: makeCheck('close'),
            attrStart: makeCheck('attrStart'),
            attrEnd: makeCheck('attrEnd'),
            attrValue: makeCheck('attrValue'),
            chars: makeCheck('chars'),
            comment: makeCheck('comment'),
            special: makeCheck('special'),
            done: makeCheck('done')
        };
    };
    test('html to html', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests));
    });
    test('uppercase html to html', function () {
        var tests = [
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'chars',
                ['sibling']
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<DIV>sibling</DIV><DIV>sibling</DIV>', makeChecks(tests));
    });
    test('camelCase attributes stay untouched (svg) - #22', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'attrStart',
                ['viewBox']
            ],
            [
                'attrValue',
                ['0 0 15 22']
            ],
            [
                'attrEnd',
                ['viewBox']
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg viewBox="0 0 15 22"></svg>', makeChecks(tests));
    });
    test('camelCase tags stay untouched (svg)', function () {
        var tests = [
            [
                'start',
                [
                    'svg',
                    false
                ]
            ],
            [
                'end',
                [
                    'svg',
                    false
                ]
            ],
            [
                'start',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'end',
                [
                    'radialGradient',
                    false
                ]
            ],
            [
                'close',
                ['radialGradient']
            ],
            [
                'close',
                ['svg']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<svg><radialGradient></radialGradient></svg>', makeChecks(tests));
    });
    test('special in an attribute in an in-tag section', function () {
        parser('<div {{#truthy}}foo=\'{{baz}}\'{{/truthy}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#truthy']
            ],
            [
                'attrStart',
                ['foo']
            ],
            [
                'special',
                ['baz']
            ],
            [
                'attrEnd',
                ['foo']
            ],
            [
                'special',
                ['/truthy']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('special with a custom attribute', function () {
        parser('<div {{#attribute}} {{name}}="{{value}}" {{/attribute}}></div>', makeChecks([
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'special',
                ['#attribute']
            ],
            [
                'special',
                ['name']
            ],
            [
                'attrStart',
                ['']
            ],
            [
                'special',
                ['value']
            ],
            [
                'attrEnd',
                ['']
            ],
            [
                'special',
                ['/attribute']
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('single attribute value', function () {
        parser('<input DISABLED/>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['DISABLED']
            ],
            [
                'attrEnd',
                ['DISABLED']
            ],
            [
                'end',
                [
                    'input',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('trailing linebreaks in IE', function () {
        parser('12345{{!\n  This is a\n  multi-line comment...\n}}67890\n', makeChecks([
            [
                'chars',
                ['12345']
            ],
            [
                'special',
                ['!\n  This is a\n  multi-line comment...\n']
            ],
            [
                'chars',
                ['67890\n']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('block are allowed inside anchor tags', function () {
        parser('<a><div></div></a>', makeChecks([
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['a']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('anchors are allowed as children of inline elements - #2169', function () {
        parser('<span><a></a></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'a',
                    false
                ]
            ],
            [
                'end',
                [
                    'a',
                    false
                ]
            ],
            [
                'close',
                ['a']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('inline tags encapsulate inner block elements', function () {
        parser('<span><div></div></span>', makeChecks([
            [
                'start',
                [
                    'span',
                    false
                ]
            ],
            [
                'end',
                [
                    'span',
                    false
                ]
            ],
            [
                'start',
                [
                    'div',
                    false
                ]
            ],
            [
                'end',
                [
                    'div',
                    false
                ]
            ],
            [
                'close',
                ['div']
            ],
            [
                'close',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<em><h1></h1></em>', makeChecks([
            [
                'start',
                [
                    'em',
                    false
                ]
            ],
            [
                'end',
                [
                    'em',
                    false
                ]
            ],
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'close',
                ['em']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('unordered lists will contain their list items', function () {
        parser('<ul><li></li><li></li></ul>', makeChecks([
            [
                'start',
                [
                    'ul',
                    false
                ]
            ],
            [
                'end',
                [
                    'ul',
                    false
                ]
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'start',
                [
                    'li',
                    false
                ]
            ],
            [
                'end',
                [
                    'li',
                    false
                ]
            ],
            [
                'close',
                ['li']
            ],
            [
                'close',
                ['ul']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports single character attributes (#1132)', function () {
        parser('<circle r="25"></circle>', makeChecks([
            [
                'start',
                [
                    'circle',
                    false
                ]
            ],
            [
                'attrStart',
                ['r']
            ],
            [
                'attrValue',
                ['25']
            ],
            [
                'attrEnd',
                ['r']
            ],
            [
                'end',
                [
                    'circle',
                    false
                ]
            ],
            [
                'close',
                ['circle']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('accept custom tag with colon ":" #1108', function () {
        parser('<x:widget/>', makeChecks([
            [
                'start',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'end',
                [
                    'x:widget',
                    true
                ]
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('output json', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1 id=\'foo\' {{#if}}{{.}}{{/if}} class=\'a{{foo}}\'>Hello {{message}}!</h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('less than outside of an element', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                [' < ']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        var intermediate = parser('<h1> < </h1>', makeChecks(tests), true);
        parser(intermediate, makeChecks(tests));
    });
    test('allow () and [] to enclose attributes', function () {
        parser('<p [click]="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                ['[click]']
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                ['[click]']
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click-me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click-me)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click-me)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<p (click_me)="test"></p>', makeChecks([
            [
                'start',
                [
                    'p',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('(click_me)')]
            ],
            [
                'attrValue',
                ['test']
            ],
            [
                'attrEnd',
                [encoder.encode('(click_me)')]
            ],
            [
                'end',
                ['p']
            ],
            [
                'close',
                ['p']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('allow {} to enclose attributes', function () {
        parser.parseAttrs('{a}="b" {{#c}}d{{/c}}', makeChecks([
            [
                'attrStart',
                [encoder.encode('{a}')]
            ],
            [
                'attrValue',
                ['b']
            ],
            [
                'attrEnd',
                [encoder.encode('{a}')]
            ],
            [
                'special',
                ['#c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/c']
            ]
        ]));
    });
    test('tripple curly in attrs', function () {
        parser.parseAttrs('items="{{{ completed }}}"', makeChecks([
            [
                'attrStart',
                ['items']
            ],
            [
                'special',
                ['{ completed ']
            ],
            [
                'attrEnd',
                ['items']
            ]
        ]));
    });
    test('something', function () {
        parser.parseAttrs('c d=\'e\'', makeChecks([
            [
                'attrStart',
                ['c']
            ],
            [
                'attrEnd',
                ['c']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrValue',
                ['e']
            ],
            [
                'attrEnd',
                ['d']
            ]
        ]));
    });
    test('references', function () {
        parser('<year-selector *y />', makeChecks([
            [
                'start',
                [
                    'year-selector',
                    true
                ]
            ],
            [
                'attrStart',
                ['*y']
            ],
            [
                'attrEnd',
                ['*y']
            ],
            [
                'end',
                ['year-selector']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('quotes around attributes and other lazy attribute writing (#2097)', function () {
        parser('<c-d a={z}/>', makeChecks([
            [
                'start',
                [
                    'c-d',
                    true
                ]
            ],
            [
                'attrStart',
                ['a']
            ],
            [
                'attrValue',
                ['{z}']
            ],
            [
                'attrEnd',
                ['a']
            ],
            [
                'end',
                ['c-d']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<span v={{.}}/>', makeChecks([
            [
                'start',
                [
                    'span',
                    true
                ]
            ],
            [
                'attrStart',
                ['v']
            ],
            [
                'special',
                ['.']
            ],
            [
                'attrEnd',
                ['v']
            ],
            [
                'end',
                ['span']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<div {{^f}} d {{/f}}/>', makeChecks([
            [
                'start',
                [
                    'div',
                    true
                ]
            ],
            [
                'special',
                ['^f']
            ],
            [
                'attrStart',
                ['d']
            ],
            [
                'attrEnd',
                ['d']
            ],
            [
                'special',
                ['/f']
            ],
            [
                'end',
                ['div']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('camelCased attributes are converted to spinal-case', function () {
        parser.parseAttrs('({camelCase})=\'assigned\'', makeChecks([
            [
                'attrStart',
                [encoder.encode('({camelCase})')]
            ],
            [
                'attrValue',
                ['assigned']
            ],
            [
                'attrEnd',
                [encoder.encode('({camelCase})')]
            ]
        ]));
    });
    test('elements that have attributes with equal signs and no values are handled appropriately (#17)', function () {
        parser('<input class=\'toggle\' type=\'checkbox\' {($checked)}=\'complete\' ($change)=>', makeChecks([
            [
                'start',
                [
                    'input',
                    true
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['toggle']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'attrStart',
                ['type']
            ],
            [
                'attrValue',
                ['checkbox']
            ],
            [
                'attrEnd',
                ['type']
            ],
            [
                'attrStart',
                [encoder.encode('{($checked)}')]
            ],
            [
                'attrValue',
                ['complete']
            ],
            [
                'attrEnd',
                [encoder.encode('{($checked)}')]
            ],
            [
                'attrStart',
                [encoder.encode('($change)')]
            ],
            [
                'attrEnd',
                [encoder.encode('($change)')]
            ],
            [
                'end',
                ['input']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('supports other delimiters (#31)', function () {
        var checks = makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['id']
            ],
            [
                'attrValue',
                ['foo']
            ],
            [
                'attrEnd',
                ['id']
            ],
            [
                'special',
                ['#if']
            ],
            [
                'special',
                ['.']
            ],
            [
                'special',
                ['/if']
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['Hello ']
            ],
            [
                'special',
                ['message']
            ],
            [
                'chars',
                ['!']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]);
        checks.magicStart = '{';
        checks.magicMatch = /\{([^\}]*)\}/g;
        parser('<h1 id=\'foo\' {#if}{.}{/if} class=\'a{foo}\'>Hello {message}!</h1>', checks);
    });
    test('{{}} in attribute values are handled correctly (#34)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['class']
            ],
            [
                'special',
                ['foo']
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                ['class']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 class=\'{{foo}}a\'></h1>', makeChecks(tests));
    });
    test('> in attribute values are handled correctly', function () {
        parser('<h1 data-content="<b>foo</b>">bar</h1>', makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['data-content']
            ],
            [
                'attrValue',
                ['<b>foo</b>']
            ],
            [
                'attrEnd',
                ['data-content']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['bar']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<h1 data-nothing="" data-something="something" data-content="<b>foo</b>" data-something-after="something-after">bar</h1>', makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['data-nothing']
            ],
            [
                'attrEnd',
                ['data-nothing']
            ],
            [
                'attrStart',
                ['data-something']
            ],
            [
                'attrValue',
                ['something']
            ],
            [
                'attrEnd',
                ['data-something']
            ],
            [
                'attrStart',
                ['data-content']
            ],
            [
                'attrValue',
                ['<b>foo</b>']
            ],
            [
                'attrEnd',
                ['data-content']
            ],
            [
                'attrStart',
                ['data-something-after']
            ],
            [
                'attrValue',
                ['something-after']
            ],
            [
                'attrEnd',
                ['data-something-after']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['bar']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('<h1 data-first="<b>foo</b>" \n data-second="><>>>>><foo>>>/>> \n />"  \n >\nbar</h1>', makeChecks([
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                ['data-first']
            ],
            [
                'attrValue',
                ['<b>foo</b>']
            ],
            [
                'attrEnd',
                ['data-first']
            ],
            [
                'attrStart',
                ['data-second']
            ],
            [
                'attrValue',
                ['><>>>>><foo>>>/>> \n />']
            ],
            [
                'attrEnd',
                ['data-second']
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'chars',
                ['\nbar']
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('tags with data attributes are allowed in comments (#2)', function () {
        parser('{{! foo }}', makeChecks([
            [
                'special',
                ['! foo ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo /> }}', makeChecks([
            [
                'special',
                ['! <foo /> ']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! <foo bar="{bam}" /> }}', makeChecks([
            [
                'special',
                ['! <foo bar="{bam}" /> ']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('multiline special comments (#14)', function () {
        parser('{{! foo !}}', makeChecks([
            [
                'special',
                ['! foo !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{! {{foo}} {{bar}} !}}', makeChecks([
            [
                'special',
                ['! {{foo}} {{bar}} !']
            ],
            [
                'done',
                []
            ]
        ]));
        parser('{{!\n{{foo}}\n{{bar}}\n!}}', makeChecks([
            [
                'special',
                ['!\n{{foo}}\n{{bar}}\n!']
            ],
            [
                'done',
                []
            ]
        ]));
    });
    test('spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo bar}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{foo bar}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('for attributes without values, spaces in attribute names that start with `{` or `(` are encoded (#48)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo }')]
            ],
            [
                'attrEnd',
                [encoder.encode('{foo }')]
            ],
            [
                'attrStart',
                [encoder.encode('{bar }')]
            ],
            [
                'attrEnd',
                [encoder.encode('{bar }')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo } {bar }></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: {(foo})', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{(foo})')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{(foo})')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {(foo})=\'a\'></h1>', makeChecks(tests));
    });
    test('mismatched brackets work: ({foo)}', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('({foo)}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('({foo)}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 ({foo)}=\'a\'></h1>', makeChecks(tests));
    });
    test('forward slashes are encoded (#52)', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('{foo/bar}')]
            ],
            [
                'attrValue',
                ['a']
            ],
            [
                'attrEnd',
                [encoder.encode('{foo/bar}')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 {foo/bar}=\'a\'></h1>', makeChecks(tests));
    });
    test('camelCase properties are encoded with on:, :to, :from, :bind bindings', function () {
        var tests = [
            [
                'start',
                [
                    'h1',
                    false
                ]
            ],
            [
                'attrStart',
                [encoder.encode('on:aB')]
            ],
            [
                'attrValue',
                ['c']
            ],
            [
                'attrEnd',
                [encoder.encode('on:aB')]
            ],
            [
                'attrStart',
                [encoder.encode('dE:to')]
            ],
            [
                'attrValue',
                ['f']
            ],
            [
                'attrEnd',
                [encoder.encode('dE:to')]
            ],
            [
                'attrStart',
                [encoder.encode('gH:from')]
            ],
            [
                'attrValue',
                ['i']
            ],
            [
                'attrEnd',
                [encoder.encode('gH:from')]
            ],
            [
                'attrStart',
                [encoder.encode('jK:bind')]
            ],
            [
                'attrValue',
                ['l']
            ],
            [
                'attrEnd',
                [encoder.encode('jK:bind')]
            ],
            [
                'end',
                [
                    'h1',
                    false
                ]
            ],
            [
                'close',
                ['h1']
            ],
            [
                'done',
                []
            ]
        ];
        parser('<h1 on:aB=\'c\' dE:to=\'f\' gH:from=\'i\' jK:bind=\'l\'></h1>', makeChecks(tests));
    });
    testHelpers.dev.devOnlyTest('Warn on missing attribute value end quotes (canjs/can-view-parser#7)', function () {
        var makeWarnChecks = function (input, texts) {
            var count = 0;
            var teardown = testHelpers.dev.willWarn(/End quote is missing for/, function (message, matched) {
                ok(matched, texts[count++]);
            });
            parser(input, {
                start: function (tagName, unary) {
                },
                end: function (tagName, unary) {
                },
                attrStart: function (attrName) {
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (val) {
                },
                done: function () {
                }
            });
            equal(count, teardown());
        };
        makeWarnChecks('<my-input {value}="name" (value)="updateNameOnEven(%viewModel.value)/>', ['1: End quote is missing for updateNameOnEven(%viewModel.value)']);
        makeWarnChecks('<input on:click="callback />', ['1: End quote is missing for callback']);
        makeWarnChecks('<my-input {an-attr}="aValue />', ['1: End quote is missing for aValue']);
        makeWarnChecks('<my-input {an-other-attr}=\'anotherValue />', ['1: End quote is missing for anotherValue']);
    });
    testHelpers.dev.devOnlyTest('Fix false warning on missing closed quote (canjs/can-view-parser#7#issuecomment-336468766)', function () {
        var makeWarnChecks = function (input, texts) {
            var count = 0;
            var teardown = testHelpers.dev.willWarn(/End quote is missing for/, function (message, matched) {
                notOk(matched, texts[count++]);
            });
            parser(input, {
                start: function (tagName, unary) {
                },
                end: function (tagName, unary) {
                },
                attrStart: function (attrName) {
                },
                attrEnd: function (attrName) {
                },
                attrValue: function (val) {
                },
                done: function () {
                },
                special: function () {
                    return [
                        '#if',
                        '/if'
                    ];
                }
            });
            equal(count, teardown());
        };
        var truthy = true;
        makeWarnChecks('<div {{#if truthy}} class="current-page"{{/if}} />', ['1: End quote is missing for current-page']);
        makeWarnChecks('<div class="current-page"($click)="" />', ['1: End quote is missing for current-page']);
        makeWarnChecks('<input type="text">', ['1: End quote is missing for current-page']);
    });
    testHelpers.dev.devOnlyTest('deprecation warning given when using magicMatch', function () {
        var teardown = testHelpers.dev.willWarn('can-view-parser: magicMatch is deprecated.');
        parser('<div />', {
            start: function (tagName, unary) {
            },
            end: function (tagName, unary) {
            },
            attrStart: function (attrName) {
            },
            attrEnd: function (attrName) {
            },
            attrValue: function (val) {
            },
            done: function () {
            },
            special: function () {
            },
            magicMatch: /\{([^\}]*)\}/g
        });
        QUnit.equal(teardown(), 1);
    });
    testHelpers.dev.devOnlyTest('deprecation warning given when using magicStart', function () {
        var teardown = testHelpers.dev.willWarn('can-view-parser: magicStart is deprecated.');
        parser('<div />', {
            start: function (tagName, unary) {
            },
            end: function (tagName, unary) {
            },
            attrStart: function (attrName) {
            },
            attrEnd: function (attrName) {
            },
            attrValue: function (val) {
            },
            done: function () {
            },
            special: function () {
            },
            magicStart: '{'
        });
        QUnit.equal(teardown(), 1);
    });
});
/*can@3.14.0#view/parser/parser_test*/
define('can@3.14.0#view/parser/parser_test', [
    'require',
    'exports',
    'module',
    'can-view-parser/test/can-view-parser-test'
], function (require, exports, module) {
    require('can-view-parser/test/can-view-parser-test');
});
/*can-view-scope@3.6.0#test/scope-define-test*/
define('can-view-scope@3.6.0#test/scope-define-test', [
    'require',
    'exports',
    'module',
    'can-view-scope',
    'can-define/map/map',
    'can-define/list/list',
    'can-stache-key',
    'can-compute',
    'steal-qunit'
], function (require, exports, module) {
    'use strict';
    var Scope = require('can-view-scope');
    var DefineMap = require('can-define/map/map');
    require('can-define/list/list');
    var observeReader = require('can-stache-key');
    var compute = require('can-compute');
    var QUnit = require('steal-qunit');
    QUnit.module('can-view-scope with define');
    test('basics', function () {
        var items = new DefineMap({
            people: [
                { name: 'Justin' },
                { name: 'Brian' }
            ],
            count: 1000
        });
        var itemsScope = new Scope(items), arrayScope = new Scope(itemsScope.peek('people'), itemsScope), firstItem = new Scope(arrayScope.peek('0'), arrayScope);
        var nameInfo;
        var c = compute(function () {
            nameInfo = firstItem.read('name');
        });
        c.bind('change', function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, firstItem, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, items.people[0], 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new DefineMap({ age: undefined });
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.age, 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new DefineMap({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new DefineMap({ name: { first: 'Justin' } });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        compute.bind('change', function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        });
        equal(compute(), 'Justin', 'read value after bind');
        me.name.first = 'Brian';
        me.name = undefined;
        me.name = { first: 'Payal' };
        me.name = new DefineMap({ first: 'Curtis' });
    });
    test('binds to the right scope only', 3, function () {
        var baseMap = new DefineMap({ me: { name: { first: 'Justin' } } });
        var base = new Scope(baseMap);
        var topMap = new DefineMap({ me: { name: {} } });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        baseMap.me.name.first = 'Brian';
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = DefineMap.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new DefineMap({ name: { first: 'Justin' } });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.name = new DefineMap({ first: 'Brian' });
        equal(compute(), 'Brian');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = DefineMap.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('setting props in a compute (#18)', function () {
        var map = new DefineMap({ complete: true });
        var computeVal = compute(map);
        var base = new Scope(computeVal);
        var complete = base.computeData('complete').compute;
        equal(complete(), true, 'can read the value');
        complete(false);
        QUnit.equal(map.complete, false, 'value set');
    });
    test('undefined DefineMap props should be a scope hit (#20)', function () {
        var MyType = DefineMap.extend('MyType', { value: 'string' });
        var EmptyType = DefineMap.extend('EmptyType', {});
        var instance = new MyType();
        var scope = new Scope(instance).add(new EmptyType());
        var c1 = scope.computeData('value').compute;
        c1.on('change', function () {
        });
        c1('BAR');
        QUnit.equal(instance.value, 'BAR');
        var instance2 = new MyType();
        var scope2 = new Scope(instance2).add(compute());
        var c2 = scope2.computeData('value').compute;
        c2.on('change', function () {
        });
        c2('BAR');
        QUnit.equal(instance2.value, 'BAR');
    });
    test('that .set with ../ is able to skip notContext scopes (#43)', function () {
        var instance = new DefineMap({ prop: 0 });
        var notContextContext = { NAME: 'NOT CONTEXT' };
        var top = { NAME: 'TOP' };
        var scope = new Scope(instance).add(notContextContext, { notContext: true }).add(top);
        scope.set('../prop', 1);
        QUnit.equal(instance.prop, 1);
    });
    QUnit.test('this works everywhere (#45)', function () {
        var obj = { foo: 'bar' };
        var scope = new Scope(obj);
        QUnit.equal(scope.get('this.foo'), 'bar');
    });
    QUnit.test('\'this\' and %context give the context', 1, function () {
        var vm;
        var MyMap = DefineMap.extend({
            doSomething: function () {
                QUnit.equal(this, vm, 'event callback called on context');
            }
        });
        vm = new MyMap();
        var compute = new Scope(vm).computeData('this.doSomething', {
            isArgument: true,
            args: []
        }).compute;
        compute()();
    });
});
/*can-view-scope@3.6.0#test/scope-test*/
define('can-view-scope@3.6.0#test/scope-test', [
    'require',
    'exports',
    'module',
    './scope-define-test',
    'can-view-scope',
    'can-map',
    'can-list',
    'can-stache-key',
    'can-compute',
    '../template-context',
    'can-symbol',
    'steal-qunit',
    'can-event/batch/batch',
    'can-reflect',
    'can-observation',
    'can-test-helpers'
], function (require, exports, module) {
    require('./scope-define-test');
    var Scope = require('can-view-scope');
    var Map = require('can-map');
    var List = require('can-list');
    var observeReader = require('can-stache-key');
    var compute = require('can-compute');
    var TemplateContext = require('../template-context');
    var canSymbol = require('can-symbol');
    var QUnit = require('steal-qunit');
    var canBatch = require('can-event/batch/batch');
    var canReflect = require('can-reflect');
    var Observation = require('can-observation');
    var testHelpers = require('can-test-helpers');
    QUnit.module('can/view/scope');
    test('basics', function () {
        var items = new Map({
            people: [
                { name: 'Justin' },
                [{ name: 'Brian' }]
            ],
            count: 1000
        });
        var itemsScope = new Scope(items), arrayScope = new Scope(itemsScope.peek('people'), itemsScope), firstItem = new Scope(arrayScope.peek('0'), arrayScope);
        var nameInfo;
        var c = compute(function () {
            nameInfo = firstItem.read('name');
        });
        c.bind('change', function () {
        });
        deepEqual(nameInfo.reads, [{
                key: 'name',
                at: false
            }], 'reads');
        equal(nameInfo.scope, firstItem, 'scope');
        equal(nameInfo.value, 'Justin', 'value');
        equal(nameInfo.rootObserve, items.people[0], 'rootObserve');
    });
    test('Scope.prototype.computeData', function () {
        var map = new Map();
        var base = new Scope(map);
        var age = base.computeData('age').compute;
        equal(age(), undefined, 'age is not set');
        age.bind('change', function (ev, newVal, oldVal) {
            equal(newVal, 31, 'newVal is provided correctly');
            equal(oldVal, undefined, 'oldVal is undefined');
        });
        age(31);
        equal(map.attr('age'), 31, 'maps age is set correctly');
    });
    test('backtrack path (#163)', function () {
        var row = new Map({ first: 'Justin' }), col = { format: 'str' }, base = new Scope(row), cur = base.add(col);
        equal(cur.peek('.'), col, 'got col');
        equal(cur.peek('..'), row, 'got row');
        equal(cur.peek('../first'), 'Justin', 'got row');
    });
    test('nested properties with compute', function () {
        var me = new Map({ name: { first: 'Justin' } });
        var cur = new Scope(me);
        var compute = cur.computeData('name.first').compute;
        var changes = 0;
        compute.bind('change', function (ev, newVal, oldVal) {
            if (changes === 0) {
                equal(oldVal, 'Justin');
                equal(newVal, 'Brian');
            } else if (changes === 1) {
                equal(oldVal, 'Brian');
                equal(newVal, undefined);
            } else if (changes === 2) {
                equal(oldVal, undefined);
                equal(newVal, 'Payal');
            } else if (changes === 3) {
                equal(oldVal, 'Payal');
                equal(newVal, 'Curtis');
            }
            changes++;
        });
        equal(compute(), 'Justin', 'read value after bind');
        me.attr('name.first', 'Brian');
        me.removeAttr('name');
        me.attr('name', { first: 'Payal' });
        me.attr('name', new Map({ first: 'Curtis' }));
    });
    test('function at the end', function () {
        var compute = new Scope({
            me: {
                info: function () {
                    return 'Justin';
                }
            }
        }).computeData('me.info').compute;
        equal(compute(), 'Justin');
        var fn = function () {
            return this.name;
        };
        var compute2 = new Scope({
            me: {
                info: fn,
                name: 'Hank'
            }
        }).computeData('me.info', {
            isArgument: true,
            args: []
        }).compute;
        equal(compute2()(), 'Hank');
    });
    test('binds to the right scope only', function () {
        var baseMap = new Map({ me: { name: { first: 'Justin' } } });
        var base = new Scope(baseMap);
        var topMap = new Map({ me: { name: {} } });
        var scope = base.add(topMap);
        var compute = scope.computeData('me.name.first').compute;
        compute.bind('change', function (ev, newVal, oldVal) {
            equal(oldVal, 'Justin');
            equal(newVal, 'Brian');
        });
        equal(compute(), 'Justin');
        topMap.attr('me.name.first', 'Payal');
        baseMap.attr('me.name.first', 'Brian');
    });
    test('Scope read returnObserveMethods=true', function () {
        var MapConstruct = Map.extend({
            foo: function (arg) {
                equal(this, data.map, 'correct this');
                equal(arg, true, 'correct arg');
            }
        });
        var data = { map: new MapConstruct() };
        var res = Scope.read(data, observeReader.reads('map.foo'), { isArgument: true });
        res.value(true);
    });
    test('rooted observable is able to update correctly', function () {
        var baseMap = new Map({ name: { first: 'Justin' } });
        var scope = new Scope(baseMap);
        var compute = scope.computeData('name.first').compute;
        equal(compute(), 'Justin');
        baseMap.attr('name', new Map({ first: 'Brian' }));
        equal(compute(), 'Brian');
    });
    test('computeData reading an object with a compute', function () {
        var sourceAge = 21;
        var age = compute(function (newVal) {
            if (newVal) {
                sourceAge = newVal;
            } else {
                return sourceAge;
            }
        });
        var scope = new Scope({ person: { age: age } });
        var computeData = scope.computeData('person.age');
        var value = computeData.compute();
        equal(value, 21, 'correct value');
        computeData.compute(31);
        equal(age(), 31, 'age updated');
    });
    test('computeData with initial empty compute (#638)', function () {
        expect(2);
        var c = compute();
        var scope = new Scope({ compute: c });
        var computeData = scope.computeData('compute');
        equal(computeData.compute(), undefined);
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'compute value');
        });
        c('compute value');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = Map.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Can read static properties on constructors (#634)', function () {
        var Foo = Map.extend({ static_prop: 'baz' }, { proto_prop: 'thud' });
        var data = new Foo({ own_prop: 'quux' }), scope = new Scope(data);
        equal(scope.computeData('constructor.static_prop').compute(), 'baz', 'static prop');
    });
    test('Scope lookup restricted to current scope with ./ (#874)', function () {
        var current;
        var scope = new Scope(new Map({ value: 'A Value' })).add(current = new Map({}));
        var compute = scope.computeData('./value').compute;
        equal(compute(), undefined, 'no initial value');
        compute.bind('change', function (ev, newVal) {
            equal(newVal, 'B Value', 'changed');
        });
        compute('B Value');
        equal(current.attr('value'), 'B Value', 'updated');
    });
    test('reading properties on undefined (#1314)', function () {
        var scope = new Scope(undefined);
        var compute = scope.compute('property');
        equal(compute(), undefined, 'got back undefined');
    });
    test('Scope attributes can be set (#1297, #1304)', function () {
        var comp = compute('Test');
        var map = new Map({ other: { name: 'Justin' } });
        var scope = new Scope({
            name: 'Matthew',
            other: {
                person: { name: 'David' },
                comp: comp
            }
        });
        scope.set('name', 'Wilbur');
        equal(scope.get('name'), 'Wilbur', 'Value updated');
        scope.set('other.person.name', 'Dave');
        equal(scope.get('other.person.name'), 'Dave', 'Value updated');
        scope.set('other.comp', 'Changed');
        equal(comp(), 'Changed', 'Compute updated');
        scope = new Scope(map);
        scope.set('other.name', 'Brian');
        equal(scope.get('other.name'), 'Brian', 'Value updated');
        equal(map.attr('other.name'), 'Brian', 'Name update in map');
    });
    testHelpers.dev.devOnlyTest('Setting a value to an attribute with an undefined parent errors (canjs/can-stache-bindings#298)', function () {
        var teardown = testHelpers.dev.willError(/Attempting to set a value at (.+) where (.+) is undefined./);
        var scope = new Scope({});
        scope.set('person.name', 'Christopher');
        QUnit.equal(teardown(), 1, 'saw errors');
    });
    test('computeData.compute get/sets computes in maps', function () {
        var cmpt = compute(4);
        var map = new Map();
        map.attr('computer', cmpt);
        var scope = new Scope(map);
        var computeData = scope.computeData('computer', {});
        equal(computeData.compute(), 4, 'got the value');
        computeData.compute(5);
        equal(cmpt(), 5, 'updated compute value');
        equal(computeData.compute(), 5, 'the compute has the right value');
    });
    test('computesData can find update when initially undefined parent scope becomes defined (#579)', function () {
        expect(2);
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        var computeData = top.computeData('value', {});
        equal(computeData.compute(), undefined, 'initially undefined');
        computeData.compute.bind('change', function (ev, newVal) {
            equal(newVal, 'first');
        });
        map.attr('value', 'first');
    });
    test('A scope\'s %root is the last context', function () {
        var map = new Map();
        var refs = Scope.refsScope();
        var scope = refs.add(map).add(new Scope.Refs()).add(new Map());
        var root = scope.peek('%root');
        ok(!(root instanceof Scope.Refs), 'root isn\'t a reference');
        equal(root, map, 'The root is the map passed into the scope');
    });
    test('can set scope attributes with ../ (#2132)', function () {
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        top.set('../foo', 'bar');
        equal(map.attr('foo'), 'bar');
    });
    test('can read parent context with ../ (#2244)', function () {
        var map = new Map();
        var scope = new Scope(map);
        var top = scope.add(new Map());
        equal(top.peek('../'), map, 'looked up value correctly');
    });
    test('trying to read constructor from refs scope is ok', function () {
        var map = new TemplateContext();
        var construct = compute(function () {
            return map.constructor;
        });
        construct.bind('change', function () {
        });
        equal(construct(), TemplateContext);
    });
    test('reading from a string in a nested scope doesn\'t throw an error (#22)', function () {
        var foo = compute('foo');
        var bar = compute('bar');
        var scope = new Scope(foo);
        var localScope = scope.add(bar);
        equal(localScope.read('foo').value, undefined);
    });
    test('Optimize for compute().observableProperty (#29)', function () {
        var map = new Map({ value: 'a' });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var scopeCompute = scopeKeyData.compute;
        var changeNumber = 0;
        scopeCompute.on('change', function (ev, newVal, oldVal) {
            if (changeNumber === 1) {
                QUnit.equal(newVal, 'b');
                QUnit.equal(oldVal, 'a');
                QUnit.ok(scopeKeyData.fastPath, 'still fast path');
                changeNumber++;
                wrap(new Map({ value: 'c' }));
            } else if (changeNumber === 2) {
                QUnit.equal(newVal, 'c', 'got new value');
                QUnit.equal(oldVal, 'b', 'got old value');
                QUnit.notOk(scopeKeyData.fastPath, 'still fast path');
            }
        });
        QUnit.ok(scopeKeyData.fastPath, 'fast path');
        changeNumber++;
        map.attr('value', 'b');
    });
    test('read should support passing %scope (#24)', function () {
        var scope = new Scope(new Map({
            foo: '',
            bar: ''
        }));
        equal(scope.read('%scope').value, scope, 'looked up %scope correctly');
    });
    test('a compute can observe the ScopeKeyData', 2, function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var oldOnValue = scopeKeyData[canSymbol.for('can.onValue')];
        scopeKeyData[canSymbol.for('can.onValue')] = function () {
            QUnit.ok(true, 'bound on the scopeKeyData');
            return oldOnValue.apply(this, arguments);
        };
        var c = compute(function () {
            return scopeKeyData.getValue() + map.attr('other');
        });
        c.on('change', function (ev, newValue) {
            QUnit.equal(newValue, 'Ab');
        });
        map.attr('value', 'A');
    });
    QUnit.asyncTest('unbinding clears all event bindings', function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var c = compute(function () {
            return scopeKeyData.getValue() + map.attr('other');
        });
        var handlers = function (ev, newValue) {
            QUnit.equal(newValue, 'Ab');
        };
        c.on('change', handlers);
        c.off('change', handlers);
        setTimeout(function () {
            equal(map.__bindEvents._lifecycleBindings, 0, 'there are no bindings');
            start();
        }, 30);
    });
    QUnit.test('computes are read as this and . and  ../', function () {
        var value = compute(1);
        var scope = new Scope(value);
        QUnit.equal(scope.get('this'), 1, 'this read value');
        QUnit.equal(scope.get('.'), 1, '. read value');
        scope = scope.add({});
        QUnit.equal(scope.get('..'), 1, '.. read value');
    });
    QUnit.test('computes are set as this and . and  ../', function () {
        var value = compute(1);
        var scope = new Scope(value);
        scope.set('this', 2);
        QUnit.equal(scope.get('this'), 2, 'this read value');
        scope.set('.', 3);
        QUnit.equal(scope.get('this'), 3, '. read value');
        scope = scope.add({});
        scope.set('..', 4);
        QUnit.equal(scope.get('..'), 4, '.. read value');
    });
    QUnit.test('maps are set with this.foo and ./foo', function () {
        var map = compute(new Map({ value: 1 }));
        var scope = new Scope(map);
        scope.set('this.value', 2);
        QUnit.equal(scope.get('this.value'), 2, 'this read value');
        scope.set('./value', 3);
        QUnit.equal(scope.get('./value'), 3, '. read value');
    });
    QUnit.test('scopeKeyData fires during batch', function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var scope = new Scope(map);
        var batchNum;
        map.on('value', function () {
            batchNum = canBatch.batchNum;
        });
        var scopeKeyData = scope.computeData('value');
        scopeKeyData[canSymbol.for('can.onValue')](function (value) {
            QUnit.equal(batchNum, canBatch.batchNum);
        });
        map.attr('value', 'A');
    });
    QUnit.test('setting a key on a non observable context', function () {
        var context = { colors: new List([]) };
        var scope = new Scope(context);
        scope.set('colors', ['red']);
        QUnit.deepEqual(context.colors.attr(), ['red'], 'can updateDeep');
    });
    QUnit.test('observing scope key data does not observe observation', function () {
        var map = new Map({ value: 'a' });
        var scope = new Scope(map);
        var computeData = scope.computeData('value');
        var oldOnValue = computeData.observation[canSymbol.for('can.onValue')];
        var bindCount = 0;
        computeData.observation[canSymbol.for('can.onValue')] = function () {
            bindCount++;
            return oldOnValue.apply(this, arguments);
        };
        var valueCompute = computeData.compute;
        var oldComputeOnValue = valueCompute.computeInstance[canSymbol.for('can.onValue')];
        valueCompute.computeInstance[canSymbol.for('can.onValue')] = function () {
            bindCount++;
            return oldComputeOnValue.apply(this, arguments);
        };
        var c = compute(function () {
            return valueCompute();
        });
        c.on('change', function () {
        });
        QUnit.equal(bindCount, 2, 'there should only be one event bound');
    });
    QUnit.test('scopeKeyData offValue resets dependencyChange/start', function () {
        var map = new Map({
            value: 'a',
            other: 'b'
        });
        var wrap = compute(map);
        var scope = new Scope(wrap);
        var scopeKeyData = scope.computeData('value');
        var handler = function () {
        };
        canReflect.onValue(scopeKeyData, handler);
        canReflect.offValue(scopeKeyData, handler);
        QUnit.equal(scopeKeyData.observation.dependencyChange, Observation.prototype.dependencyChange, 'dependencyChange should be restored');
        QUnit.equal(scopeKeyData.observation.start, Observation.prototype.start, 'start should be restored');
    });
    QUnit.test('Rendering a template with a custom scope (#55)', function () {
        var scope = new Scope({}), scopeRefs;
        try {
            scopeRefs = scope.getRefs();
            QUnit.ok(true, 'Did not throw');
        } catch (e) {
            QUnit.ok(false, e.message);
        }
        QUnit.equal(scope.get('name'), undefined, 'No name');
        scope.set('name', 'John');
        QUnit.equal(scope.get('name'), 'John', 'Got the name');
        scope = scope.add({ name: 'Justin' });
        QUnit.equal(scope.get('name'), 'Justin', 'Got the top scope name');
        try {
            scopeRefs = scope.getRefs();
            QUnit.ok(true, 'Did not throw');
        } catch (e) {
            QUnit.ok(false, e.message);
        }
    });
    QUnit.test('generated refs scope is a Scope', function () {
        var scope = new Scope({});
        QUnit.equal(scope._parent, undefined, 'scope initially has no parent');
        var refScope = scope.getRefs();
        QUnit.ok(refScope instanceof Scope, 'refScope is a scope');
        QUnit.ok(refScope._context instanceof Scope.Refs, 'refScope context is a refs object');
    });
    QUnit.test('./ scope lookup should read current scope', function () {
        var parent = new Map();
        var map = new Map();
        var scope = new Scope(parent).add(map);
        QUnit.equal(scope.attr('./'), map);
    });
    QUnit.test('getTemplateContext() gives a scope with the templateContext', function () {
        var map = new Map();
        var scope = new Scope(map);
        var templateContext = scope.getTemplateContext();
        QUnit.ok(templateContext instanceof Scope, 'templateContext is a Scope');
        QUnit.ok(templateContext._context instanceof TemplateContext, 'templateContext context is a TemplateContext object');
    });
    QUnit.test('scope can be used to read from the templateContext', function () {
        var map = new Map();
        var scope = new Scope(map);
        QUnit.deepEqual(scope.peek('scope'), scope, 'scope');
        scope.set('scope.vars.name', 'Kevin');
        QUnit.equal(scope.peek('scope.vars.name'), 'Kevin', 'scope.vars.name === Kevin');
        QUnit.equal(scope.peek('*name'), 'Kevin', '*name === Kevin');
        scope.set('*name', 'Tracy');
        QUnit.equal(scope.peek('*name'), 'Tracy', '*name === Tracy');
        QUnit.equal(scope.peek('scope.vars.name'), 'Tracy', 'scope.vars.name === Tracy');
        var ageFn = function () {
            return '30';
        };
        scope.set('*age', ageFn);
        QUnit.equal(scope.peek('@*age')(), '30', '@*age returns a function');
        QUnit.equal(scope.peek('*age')(), '30', '*age returns a function');
        QUnit.equal(scope.peek('scope.vars.age'), '30', 'scope.vars.age === 30');
    });
    QUnit.test('scope.index reads from special scopes', function () {
        var map1 = new Map({ index: 1 });
        var map2 = new Map({ index: 3 });
        var scope = new Scope(map1);
        QUnit.equal(scope.peek('scope.index'), undefined, 'scope.index returns undefined if no special context exists');
        scope = scope.add({ index: 2 }, { special: true }).add(map2).add({ index: 4 }, { special: true });
        QUnit.equal(scope.peek('scope.index'), 4, 'scope.index is read correctly');
        QUnit.equal(scope._parent.peek('scope.index'), 2, 'scope.index is only read from special contexts');
    });
    QUnit.test('scope.key reads from special scopes', function () {
        var map1 = new Map({ key: 'one' });
        var map2 = new Map({ key: 3 });
        var scope = new Scope(map1).add({ key: 'two' }, { special: true }).add(map2).add({ key: 'four' }, { special: true });
        QUnit.equal(scope.peek('scope.key'), 'four', 'scope.key is read correctly');
        QUnit.equal(scope._parent.peek('scope.key'), 'two', 'scope.key is only read from special contexts');
    });
    QUnit.test('*self should return scope.view', function () {
        var view = function () {
        };
        var scope = new Scope({});
        scope.set('scope.view', view);
        QUnit.equal(scope.peek('scope.view'), view, 'scope.view');
        QUnit.equal(scope.peek('*self'), view, '*self');
    });
    testHelpers.dev.devOnlyTest('using {{>*self}} should show deprecation warning', function () {
        var teardown = testHelpers.dev.willWarn('filename:10: {{>*self}} is deprecated. Use {{>scope.view}} instead.');
        var scope = new Scope({});
        scope.set('scope.filename', 'filename');
        scope.set('scope.lineNumber', '10');
        scope.peek('*self');
        QUnit.equal(teardown(), 1, 'deprecation warning displayed');
    });
    testHelpers.dev.devOnlyTest('using *foo should show deprecation warning', function () {
        var teardown = testHelpers.dev.willWarn('filename:5: {{*foo}} is deprecated. Use {{scope.vars.foo}} instead.');
        var scope = new Scope({});
        scope.set('scope.filename', 'filename');
        scope.set('scope.lineNumber', '5');
        scope.peek('*foo');
        QUnit.equal(teardown(), 1, 'deprecation warning displayed');
    });
    QUnit.test('variables starting with \'scope\' should not be read from templateContext (#104)', function () {
        var map = new Map({ scope1: 'this is scope1' });
        var scope = new Scope(map);
        QUnit.deepEqual(scope.peek('scope1'), 'this is scope1', 'scope1');
    });
    QUnit.test('nested properties can be read from templateContext.vars', function () {
        var foo = new Map({ bar: 'baz' });
        var map = new Map();
        var scope = new Scope(map);
        QUnit.ok(!scope.peek('scope.vars.foo.bar'), 'vars.foo.bar === undefined');
        scope.set('scope.vars.foo', foo);
        QUnit.equal(scope.peek('scope.vars.foo.bar'), 'baz', 'vars.foo.bar === baz');
    });
    QUnit.test('filename and lineNumber can be read from anywhere in scope chain', function () {
        var parent = new Scope({});
        var scope = parent.add({});
        parent.set('scope.filename', 'my-cool-file.txt');
        parent.set('scope.lineNumber', '5');
        QUnit.equal(scope.peek('scope.filename'), 'my-cool-file.txt', 'scope.peek("scope.filename")');
        QUnit.equal(scope.peek('scope.lineNumber'), '5', 'scope.peek("scope.lineNumber")');
    });
    QUnit.test('nested properties can be read from templateContext.root', function () {
        var root = new Map({ bar: 'baz' });
        var map = new Map();
        var scope = new Scope(map);
        QUnit.ok(!scope.peek('scope.root.bar'), 'root.bar === undefined');
        scope.set('scope.root', root);
        QUnit.equal(scope.peek('scope.root.bar'), 'baz', 'root.bar === baz');
    });
    QUnit.test('special scopes are skipped if options.special !== true', function () {
        var map1 = new Map({ foo: 'one' });
        var scope = new Scope(map1).add({ foo: 'two' }, { special: true }).add({});
        QUnit.equal(scope.peek('foo'), 'one', 'foo is read from first non-special scope with a foo property');
        QUnit.equal(scope.peek('foo', { special: true }), 'two', 'foo is read from special scope');
    });
    QUnit.test('special scopes are skipped when using ../.', function () {
        var map = new Map({ foo: 'one' });
        var scope = new Scope(map).add({ foo: 'two' }, { special: true }).add({});
        QUnit.equal(scope.peek('../.'), map);
    });
    QUnit.test('special scopes are skipped when using .', function () {
        var map = new Map({ foo: 'one' });
        var scope = new Scope(map).add({ foo: 'two' }, { special: true });
        QUnit.equal(scope.peek('.'), map);
    });
    QUnit.test('scope.vm and scope.top', function () {
        var scope = new Scope({ name: 'foo' }).add({ name: 'Kevin' }, { viewModel: true }).add({ name: 'bar' }).add({ name: 'Ryan' }, { viewModel: true }).add({ name: 'baz' });
        QUnit.equal(scope.read('scope.vm.name').value, 'Ryan', 'scope.first can be used to read from the _first_ context with viewModel: true');
        QUnit.equal(scope.read('scope.top.name').value, 'Kevin', 'scope.top can be used to read from the _top_ context with viewModel: true');
    });
});
/*can@3.14.0#view/scope/scope_test*/
define('can@3.14.0#view/scope/scope_test', [
    'require',
    'exports',
    'module',
    'can-view-scope/test/scope-test',
    'can-view-scope/test/scope-define-test'
], function (require, exports, module) {
    require('can-view-scope/test/scope-test');
    require('can-view-scope/test/scope-define-test');
});
/*can-view-autorender@3.1.4#can-view-autorender_test*/
define('can-view-autorender@3.1.4#can-view-autorender_test', [
    'require',
    'exports',
    'module',
    'steal-qunit'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        var get = function (map, prop) {
            return map.attr ? map.attr(prop) : map.get(prop);
        };
        var makeBasicTestIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message || error);
                window.removeMyself();
            };
            window.isReady = function (el, scope) {
                equal(el.length, 1, 'only one my-component');
                equal(el[0].innerHTML, 'Hello World', 'template rendered');
                equal(get(scope, 'message'), 'Hello World', 'Scope correctly setup');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-autorender');
        if (__dirname !== '/') {
            QUnit.asyncTest('the basics are able to work for steal', function () {
                makeBasicTestIframe(__dirname + '/test/basics.html?' + Math.random());
            });
            QUnit.asyncTest('autoload loads a jquery viewmodel fn', function () {
                makeIframe(__dirname + '/test/steal-viewmodel.html?' + Math.random());
            });
            QUnit.asyncTest('works with a can-define/map/map', function () {
                makeBasicTestIframe(__dirname + '/test/define.html?' + Math.random());
            });
        }
    }('/', require, exports, module));
});
/*can@3.14.0#view/autorender/autorender_test*/
define('can@3.14.0#view/autorender/autorender_test', [
    'require',
    'exports',
    'module',
    'can-view-autorender/can-view-autorender_test'
], function (require, exports, module) {
    require('can-view-autorender/can-view-autorender_test');
});
/*can-view-target@3.1.6#test/test*/
define('can-view-target@3.1.6#test/test', [
    'require',
    'exports',
    'module',
    'can-view-target',
    'can-simple-dom',
    'steal-qunit',
    'can-globals/mutation-observer/mutation-observer'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var target = require('can-view-target');
        var simpleDom = require('can-simple-dom');
        var QUnit = require('steal-qunit');
        var MUTATION_OBSERVER = require('can-globals/mutation-observer/mutation-observer');
        QUnit.module('can-view-target');
        test('basics', function () {
            var classCallback = function () {
                    equal(this.nodeName.toLowerCase(), 'h1', 'class on the right element');
                    this.className = 'selected';
                }, attributesCallback = function () {
                    equal(this.nodeName.toLowerCase(), 'h1', 'attributes on the right element');
                }, textNodeCallback = function () {
                    equal(this.nodeType, 3, 'got a text node');
                    this.nodeValue = 'World';
                };
            var data = target([{
                    tag: 'h1',
                    attrs: {
                        'id': 'myh1',
                        'class': classCallback
                    },
                    attributes: [attributesCallback],
                    children: [{
                            tag: 'span',
                            children: [
                                'Hello ',
                                textNodeCallback,
                                '!'
                            ]
                        }]
                }]);
            equal(data.clone.childNodes.length, 1, 'there is one child');
            var h1 = data.clone.childNodes[0];
            equal(h1.nodeName.toLowerCase(), 'h1', 'there is one h1');
            equal(h1.id, 'myh1', 'the h1 has the right id');
            equal(h1.childNodes.length, 1, 'the h1 has span');
            equal(h1.childNodes[0].childNodes.length, 3, 'the span has 3 children');
            deepEqual(data.paths, [{
                    path: [0],
                    callbacks: [
                        { callback: classCallback },
                        { callback: attributesCallback }
                    ],
                    paths: [{
                            path: [
                                0,
                                1
                            ],
                            callbacks: [{ callback: target.keepsTextNodes ? textNodeCallback : data.paths[0].paths[0].callbacks[0].callback }]
                        }]
                }]);
            var result = data.hydrate();
            var newH1 = result.childNodes[0];
            equal(newH1.className, 'selected', 'got selected class name');
            equal(newH1.innerHTML.toLowerCase(), '<span>hello world!</span>');
        });
        test('replacing items', function () {
            var data = target([
                function () {
                    this.parentNode.insertBefore(document.createTextNode('inserted'), this.nextSibling);
                },
                'hi',
                function () {
                    equal(this.previousSibling.nodeValue, 'hi', 'previous is as expected');
                }
            ]);
            data.hydrate();
        });
        test('comments', function () {
            var data = target([
                { tag: 'h1' },
                { comment: 'foo bar' }
            ]);
            var node = data.clone.childNodes[1];
            equal(node.nodeValue, 'foo bar', 'node value is right');
            equal(node.nodeType, 8, 'node is a comment');
        });
        test('paths should be run in reverse order (#966)', function () {
            var data = target([{
                    tag: 'h1',
                    attributes: [function () {
                        }],
                    children: [
                        function () {
                            this.parentNode.insertBefore(document.createElement('div'), this.nextSibling);
                        },
                        {
                            tag: 'span',
                            children: [function () {
                                    equal(this.nodeType, 3, 'got an element');
                                }]
                        }
                    ]
                }]);
            data.hydrate();
        });
        test('renderToVirtualDOM', function () {
            var simpleDocument = new simpleDom.Document();
            var innerData = target([{ tag: 'span' }], simpleDocument);
            var outerData = target([{
                    tag: 'h1',
                    children: [
                        function (data) {
                            this.parentNode.insertBefore(innerData.hydrate(data), this);
                            this.parentNode.removeChild(this);
                        },
                        'foo'
                    ]
                }], simpleDocument);
            var out = outerData.hydrate({ foo: true });
            equal(out.firstChild.nodeName, 'H1');
            equal(out.firstChild.firstChild.nodeName, 'SPAN');
            equal(out.firstChild.lastChild.nodeValue, 'foo');
        });
        test('cloneNode works in IE11', function () {
            var frag = document.createDocumentFragment();
            var text = document.createTextNode('some-text');
            var MO = MUTATION_OBSERVER();
            var observer;
            frag.appendChild(text);
            var clone = target.cloneNode(frag);
            equal(clone.childNodes.length, 1, 'cloneNode should work');
            if (MO) {
                observer = new MO(function (mutations) {
                });
                observer.observe(document.documentElement, {
                    childList: true,
                    subtree: true
                });
                clone = target.cloneNode(frag);
                equal(clone.childNodes.length, 1, 'cloneNode should work after creating MutationObserver');
            }
        });
        test('cloneNode keeps non-default element namespace', function () {
            var frag = document.createDocumentFragment();
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            frag.appendChild(svg);
            var clone = target.cloneNode(frag);
            equal(clone.firstChild.namespaceURI, 'http://www.w3.org/2000/svg', 'cloneNode should keep non-default element namespace');
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.4.2#test/document-test*/
define('can-simple-dom@1.4.2#test/document-test', [
    'require',
    'exports',
    'module',
    '../lib/document',
    'steal-qunit'
], function (require, exports, module) {
    var Document = require('../lib/document');
    var unit = require('steal-qunit');
    unit.module('can-simple-dom - Document');
    unit.test('Document should contain appended Elements', function (assert) {
        var document = new Document();
        var element = document.createElement('div');
        document.body.appendChild(element);
        assert.ok(document.contains(element), 'document should contain element');
        document.body.removeChild(element);
        assert.notOk(document.contains(element), 'document should not contain element');
    });
});
/*can-simple-dom@1.4.2#test/support*/
define('can-simple-dom@1.4.2#test/support', [
    'require',
    'exports',
    'module',
    '../lib/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var Document = require('../lib/document');
        var root = typeof window !== 'undefined' ? window : global;
        var document = exports.document = new Document();
        exports.element = function (tagName, attrs) {
            var el = document.createElement(tagName);
            for (var key in attrs) {
                el.setAttribute(key, attrs[key]);
            }
            for (var i = 2; i < arguments.length; i++) {
                el.appendChild(arguments[i]);
            }
            return el;
        };
        exports.fragment = function () {
            var frag = document.createDocumentFragment();
            for (var i = 0; i < arguments.length; i++) {
                frag.appendChild(arguments[i]);
            }
            return frag;
        };
        exports.text = function (s) {
            return document.createTextNode(s);
        };
        exports.comment = function (s) {
            return document.createComment(s);
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-simple-dom@1.4.2#test/element-test*/
define('can-simple-dom@1.4.2#test/element-test', [
    'require',
    'exports',
    'module',
    '../lib/document',
    '../lib/html-serializer',
    '../lib/void-map',
    './support',
    'steal-qunit'
], function (require, exports, module) {
    var Document = require('../lib/document');
    var Serializer = require('../lib/html-serializer');
    var voidMap = require('../lib/void-map');
    var _support = require('./support');
    var element = _support.element;
    var fragment = _support.fragment;
    var text = _support.text;
    var QUnit = require('steal-qunit');
    QUnit.module('can-simple-dom - Element');
    QUnit.test('appending a document fragment appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new Document();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var head = document.head;
        var body = document.body;
        assert.ok(!!head, 'There is a <head> element');
        assert.ok(!!body, 'There is a <body> element');
        assert.strictEqual(body.firstChild, null, 'body has no children');
        frag.appendChild(elem);
        body.appendChild(frag);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'fragment\'s child is added as child of document');
    });
    QUnit.test('appending a document fragment (via insertBefore) appends the fragment\'s children and not the fragment itself', function (assert) {
        var document = new Document();
        var frag = document.createDocumentFragment();
        var elem = document.createElement('div');
        var existing = document.createElement('main');
        var body = document.body;
        body.appendChild(existing);
        assert.strictEqual(body.firstChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'sanity check: the main element was actually inserted');
        frag.appendChild(elem);
        body.insertBefore(frag, existing);
        assert.strictEqual(body.firstChild.tagName, 'DIV', 'The body\'s first child is now DIV');
        assert.strictEqual(body.lastChild.tagName, 'MAIN', 'The body\'s last child is now MAIN');
    });
    QUnit.test('child nodes can be access via item()', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        assert.strictEqual(parent.childNodes.item(0), null, 'attempting to access an item that doesn\'t exist returns null');
        parent.appendChild(child1);
        parent.appendChild(child2);
        assert.strictEqual(parent.childNodes.item(0), child1);
        assert.strictEqual(parent.childNodes.item(1), child2);
        assert.strictEqual(parent.childNodes.item(2), null);
        parent.removeChild(child1);
        assert.strictEqual(parent.childNodes.item(0), child2);
        assert.strictEqual(parent.childNodes.item(1), null);
        parent.removeChild(child2);
        assert.strictEqual(parent.childNodes.item(0), null);
        assert.strictEqual(parent.childNodes.item(1), null);
    });
    QUnit.test('insertBefore can insert before the last child node', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var child1 = document.createElement('p');
        var child2 = document.createElement('img');
        var child3 = document.createElement('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.insertBefore(child3, child2);
        assert.strictEqual(parent.childNodes.item(1), child3);
    });
    QUnit.test('cloneNode(true) recursively clones nodes', function (assert) {
        var parent = element('div');
        var child1 = element('p');
        var child2 = element('img', { src: 'hamster.png' });
        var child3 = element('span');
        parent.appendChild(child1);
        parent.appendChild(child2);
        parent.appendChild(child3);
        var child11 = text('hello');
        var child12 = element('span');
        child12.appendChild(text(' world'));
        var child13 = text('!');
        child1.appendChild(child11);
        child1.appendChild(child12);
        child1.appendChild(child13);
        var clone = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone.firstChild, parent.firstChild);
        var clone2 = parent.cloneNode(true);
        assert.notEqual(parent.firstChild, null);
        assert.notStrictEqual(clone2.firstChild, clone.firstChild);
        assert.notStrictEqual(clone2.firstChild, parent.firstChild);
        var actual = new Serializer(voidMap).serialize(fragment(clone));
        assert.equal(actual, '<div><p>hello<span> world</span>!</p><img src="hamster.png"><span></span></div>');
    });
    QUnit.test('anchor element is created successfully - micro-location works (see #11)', function (assert) {
        assert.expect(0);
        var document = new Document();
        try {
            document.createElement('a');
        } catch (ex) {
            assert.ok(false, 'Anchor throws exception');
        }
    });
    QUnit.test('style.cssText is two way bound to the style attribute (#13)', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.style.cssText = 'color: green;';
        assert.equal(el.getAttribute('style'), 'color: green;');
    });
    QUnit.test('replaceChild works', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var one = document.createElement('p');
        var two = document.createElement('span');
        parent.appendChild(one);
        assert.equal(parent.firstChild.nodeName, 'P', 'first child is a p');
        var oldChild = parent.replaceChild(two, one);
        assert.equal(oldChild, one, 'correct return value');
        assert.equal(parent.firstChild.nodeName, 'SPAN', 'child is now the span');
    });
    QUnit.test('Replacing the document\'s firstChild updates documentElement', function (assert) {
        var document = new Document();
        var first = document.documentElement;
        var html = document.createElement('html');
        var head = document.createElement('head');
        var body = document.createElement('body');
        html.appendChild(head);
        html.appendChild(body);
        document.replaceChild(html, document.documentElement);
        assert.equal(document.documentElement, html, 'documentElement is updated');
        assert.equal(document.body, body, 'document.body is updated');
        assert.equal(document.head, head, 'document.head is updated');
    });
    QUnit.test('setAttribute(\'class\', value) updates the className', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        assert.equal(el.className, 'foo bar', 'Element\'s className is same as the attribute class');
    });
    QUnit.test('setAttribute(\'class\', value) updates an existing className', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        el.setAttribute('class', 'baz foo');
        assert.equal(el.className, 'baz foo', 'Element\'s className is updated');
    });
    QUnit.test('setAttribute(\'value\', number) converts number to string', function (assert) {
        var document = new Document();
        var el = document.createElement('input');
        el.setAttribute('value', 10);
        assert.propEqual(el.value, '10', 'Element\'s value is coerced to a string');
        assert.equal(typeof el.value, 'string', 'Element\'s value is coerced to a string');
    });
    QUnit.test('removeAttribute(\'class\') updates the className', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.setAttribute('class', 'foo bar');
        el.removeAttribute('class');
        assert.equal(el.className, '', 'Element\'s className is same as the attribute class');
    });
    QUnit.test('innerHTML does not parse the contents of SCRIPT and STYLE nodes', function (assert) {
        var document = new Document();
        var div = document.createElement('div');
        var script = document.createElement('script');
        try {
            div.innerHTML = '<span>foo</span>';
            ok(0, 'should not make it here b/c no parser is shipped');
        } catch (ex) {
            ok(1, 'tried to parse content');
        }
        var jsCode = 'var foo = \'<span>bar</span>\';';
        try {
            script.innerHTML = jsCode;
            equal(script.firstChild, script.lastChild, 'script has one child');
            equal(script.firstChild.nodeType, 3, 'only child is a text node');
            equal(script.firstChild.nodeValue, jsCode, 'code matches');
        } catch (ex) {
            ok(0, 'should not cause an error');
        }
    });
    QUnit.test('removeChild should return the removed node', function (assert) {
        var document = new Document();
        var parent = document.createElement('div');
        var child = document.createElement('p');
        parent.appendChild(child);
        var removedNode = parent.removeChild(child);
        assert.strictEqual(removedNode, child, 'removeChild should return the removed node');
    });
    QUnit.test('Input\'s type property is two-way bound to the attribute', function (assert) {
        var document = new Document();
        var input = document.createElement('input');
        input.setAttribute('type', 'text');
        assert.equal(input.type, 'text');
        input.type = 'radio';
        assert.equal(input.type, 'radio');
        assert.equal(input.getAttribute('type'), 'radio');
    });
    QUnit.test('Input\'s value property is two-way bound to the attribute', function (assert) {
        var document = new Document();
        var input = document.createElement('input');
        input.setAttribute('value', 'foo');
        assert.equal(input.value, 'foo');
        input.value = 'bar';
        assert.equal(input.value, 'bar');
        assert.equal(input.getAttribute('value'), 'bar');
    });
    QUnit.test('Input\'s checked value is two-way bound', function (assert) {
        var document = new Document();
        var input = document.createElement('input');
        input.setAttribute('checked', '');
        assert.ok(input.checked);
        input.checked = false;
        assert.equal(input.hasAttribute('checked'), false);
        assert.equal(input.checked, false);
    });
    QUnit.test('Select\'s value attribute is two-way bound', function (assert) {
        var document = new Document();
        var select = document.createElement('select');
        select.setAttribute('value', 'foo');
        assert.equal(select.value, 'foo');
        select.value = 'bar';
        assert.equal(select.value, 'bar');
        assert.equal(select.getAttribute('value'), 'bar');
    });
    QUnit.test('Option\'s value attribute is two-way bound', function (assert) {
        var document = new Document();
        var option = document.createElement('option');
        option.setAttribute('value', 'foo');
        assert.equal(option.value, 'foo');
        option.value = 'bar';
        assert.equal(option.value, 'bar');
        assert.equal(option.getAttribute('value'), 'bar');
    });
    QUnit.test('Option\'s selected value is tied to parent select\'s value', function (assert) {
        var document = new Document();
        var select = document.createElement('select');
        var option = document.createElement('option');
        select.appendChild(option);
        select.value = 'foo';
        option.value = 'foo';
        assert.equal(option.selected, true);
        option.value = 'bar';
        assert.equal(option.selected, false);
        option.selected = true;
        assert.equal(select.value, 'bar');
    });
    QUnit.test('option\'s selected property is configurable and enumerable', function (assert) {
        var document = new Document();
        var option = document.createElement('option');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'selected');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    QUnit.test('The className property is configurable and enumerable', function (assert) {
        var document = new Document();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'className');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    QUnit.test('The innerHTML property is configurable and enumerable', function (assert) {
        var document = new Document();
        var option = document.createElement('some-el');
        var proto = Object.getPrototypeOf(option);
        var desc = Object.getOwnPropertyDescriptor(proto, 'innerHTML');
        assert.equal(desc.enumerable, true, 'selected is enumerable');
        assert.equal(desc.configurable, true, 'selected is configurable');
    });
    QUnit.test('Elements created in one document but inserted into another have their ownerDocument updated', function (assert) {
        var doc1 = new Document();
        var doc2 = new Document();
        var div = doc1.createElement('div');
        var span = doc1.createElement('span');
        div.appendChild(span);
        doc2.body.appendChild(div);
        assert.equal(div.ownerDocument, doc2, 'The ownerDocument was updated');
        assert.equal(span.ownerDocument, doc2, 'ownerDocument on a child was updated too');
    });
    QUnit.test('Elements created in one document but inserted into another have their ownerDocument updated (documentElement)', function (assert) {
        var doc1 = new Document();
        var doc2 = new Document();
        var html = doc1.createElement('html');
        doc2.replaceChild(html, doc2.documentElement);
        assert.equal(html.ownerDocument, doc2, 'The ownerDocument was updated');
    });
    QUnit.test('Elements created in one document but inserted into another have their ownerDocument updated (DocumentFragment)', function (assert) {
        var doc1 = new Document();
        var doc2 = new Document();
        var div = doc1.createElement('div');
        var span = doc1.createElement('span');
        div.appendChild(span);
        var frag = doc1.createDocumentFragment();
        frag.appendChild(div);
        doc2.body.appendChild(frag);
        assert.equal(div.ownerDocument, doc2, 'The ownerDocument was updated');
        assert.equal(span.ownerDocument, doc2, 'ownerDocument on a child was updated too');
    });
    QUnit.test('Setting an element\'s textContent inserts TextNode', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.textContent = 'foo';
        var tn = el.childNodes.item(0);
        assert.equal(tn.nodeType, 3, 'It is a TextNode');
        assert.equal(tn.nodeValue, 'foo', 'With the text');
        assert.equal(el.textContent, 'foo', 'Getter works');
    });
    QUnit.test('Setting textContent when there is already a child', function (assert) {
        var document = new Document();
        var el = document.createElement('div');
        el.appendChild(document.createElement('span'));
        assert.equal(el.childNodes.item(0).nodeName, 'SPAN', 'starts as a span');
        el.textContent = 'hello world';
        var tn = el.childNodes.item(0);
        assert.equal(tn.nodeType, 3, 'It is a TextNode');
        assert.equal(tn.nodeValue, 'hello world', 'With the text');
        assert.equal(el.textContent, 'hello world', 'Getter works');
        assert.equal(el.childNodes.item(1), null, 'span is gone');
    });
});
/*can-simple-dom@1.4.2#test/serializer-test*/
define('can-simple-dom@1.4.2#test/serializer-test', [
    'require',
    'exports',
    'module',
    './support',
    '../lib/html-serializer',
    '../lib/void-map',
    'steal-qunit'
], function (require, exports, module) {
    var _support = require('./support');
    var element = _support.element;
    var fragment = _support.fragment;
    var text = _support.text;
    var Serializer = require('../lib/html-serializer');
    var voidMap = require('../lib/void-map');
    var QUnit = require('steal-qunit');
    QUnit.module('can-simple-dom - Serializer', {
        beforeEach: function () {
            this.serializer = new Serializer(voidMap);
        }
    });
    QUnit.test('simple text', function (assert) {
        var actual = this.serializer.serialize(fragment(text('hello > world &amp; &nbsp;&nbsp; & goodbye')));
        assert.equal(actual, 'hello &gt; world &amp; &nbsp;&nbsp; &amp; goodbye');
    });
    QUnit.test('serializes correctly', function (assert) {
        var actual = this.serializer.serialize(fragment(element('div', {
            id: 'foo',
            title: '&amp;&"'
        }, element('b', {}, text('Foo & Bar &amp; Baz < Buz > Biz \xA9')))));
        assert.equal(actual, '<div id="foo" title="&amp;&amp;&quot;"><b>Foo &amp; Bar &amp; Baz &lt; Buz &gt; Biz \xA9</b></div>');
    });
    QUnit.test('serializes image correctly', function (assert) {
        var actual = this.serializer.serialize(fragment(element('img', { src: 'https://foo.com/foobar.jpg?foo=bar&bar=foo' })));
        assert.equal(actual, '<img src="https://foo.com/foobar.jpg?foo=bar&bar=foo">');
    });
    QUnit.test('serializes textContent', function (assert) {
        var el, actual, frag;
        el = element('div', {});
        el.textContent = 'hello world';
        actual = this.serializer.serialize(fragment(el));
        assert.equal(actual, '<div>hello world</div>');
    });
    QUnit.test('correctly serializes code blocks', function (assert) {
        var el, actual, frag;
        el = element('script', {});
        el.appendChild(text('<anonymous>'));
        actual = this.serializer.serialize(fragment(el));
        assert.equal(actual, '<script><anonymous></script>', 'script tag content serialized');
    });
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/utils', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.isSpace = isSpace;
    exports.isAlpha = isAlpha;
    exports.preprocessInput = preprocessInput;
    var WSP = /[\t\n\f ]/;
    var ALPHA = /[A-Za-z]/;
    var CRLF = /\r\n?/g;
    function isSpace(char) {
        return WSP.test(char);
    }
    function isAlpha(char) {
        return ALPHA.test(char);
    }
    function preprocessInput(input) {
        return input.replace(CRLF, '\n');
    }
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/evented-tokenizer', [
    'exports',
    './utils'
], function (exports, _utils) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EventedTokenizer(delegate, entityParser) {
        this.delegate = delegate;
        this.entityParser = entityParser;
        this.state = null;
        this.input = null;
        this.index = -1;
        this.line = -1;
        this.column = -1;
        this.tagLine = -1;
        this.tagColumn = -1;
        this.reset();
    }
    EventedTokenizer.prototype = {
        reset: function reset() {
            this.state = 'beforeData';
            this.input = '';
            this.index = 0;
            this.line = 1;
            this.column = 0;
            this.tagLine = -1;
            this.tagColumn = -1;
            this.delegate.reset();
        },
        tokenize: function tokenize(input) {
            this.reset();
            this.tokenizePart(input);
            this.tokenizeEOF();
        },
        tokenizePart: function tokenizePart(input) {
            this.input += (0, _utils.preprocessInput)(input);
            while (this.index < this.input.length) {
                this.states[this.state].call(this);
            }
        },
        tokenizeEOF: function tokenizeEOF() {
            this.flushData();
        },
        flushData: function flushData() {
            if (this.state === 'data') {
                this.delegate.finishData();
                this.state = 'beforeData';
            }
        },
        peek: function peek() {
            return this.input.charAt(this.index);
        },
        consume: function consume() {
            var char = this.peek();
            this.index++;
            if (char === '\n') {
                this.line++;
                this.column = 0;
            } else {
                this.column++;
            }
            return char;
        },
        consumeCharRef: function consumeCharRef() {
            var endIndex = this.input.indexOf(';', this.index);
            if (endIndex === -1) {
                return;
            }
            var entity = this.input.slice(this.index, endIndex);
            var chars = this.entityParser.parse(entity);
            if (chars) {
                var count = entity.length;
                while (count) {
                    this.consume();
                    count--;
                }
                this.consume();
                return chars;
            }
        },
        markTagStart: function markTagStart() {
            this.tagLine = this.line;
            this.tagColumn = this.column;
            if (this.delegate.tagOpen) {
                this.delegate.tagOpen();
            }
        },
        states: {
            beforeData: function beforeData() {
                var char = this.peek();
                if (char === '<') {
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else {
                    this.state = 'data';
                    this.delegate.beginData();
                }
            },
            data: function data() {
                var char = this.peek();
                if (char === '<') {
                    this.delegate.finishData();
                    this.state = 'tagOpen';
                    this.markTagStart();
                    this.consume();
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToData(this.consumeCharRef() || '&');
                } else {
                    this.consume();
                    this.delegate.appendToData(char);
                }
            },
            tagOpen: function tagOpen() {
                var char = this.consume();
                if (char === '!') {
                    this.state = 'markupDeclaration';
                } else if (char === '/') {
                    this.state = 'endTagOpen';
                } else if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginStartTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            },
            markupDeclaration: function markupDeclaration() {
                var char = this.consume();
                if (char === '-' && this.input.charAt(this.index) === '-') {
                    this.consume();
                    this.state = 'commentStart';
                    this.delegate.beginComment();
                }
            },
            commentStart: function commentStart() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentStartDash';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData(char);
                    this.state = 'comment';
                }
            },
            commentStartDash: function commentStartDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('-');
                    this.state = 'comment';
                }
            },
            comment: function comment() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEndDash';
                } else {
                    this.delegate.appendToCommentData(char);
                }
            },
            commentEndDash: function commentEndDash() {
                var char = this.consume();
                if (char === '-') {
                    this.state = 'commentEnd';
                } else {
                    this.delegate.appendToCommentData('-' + char);
                    this.state = 'comment';
                }
            },
            commentEnd: function commentEnd() {
                var char = this.consume();
                if (char === '>') {
                    this.delegate.finishComment();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToCommentData('--' + char);
                    this.state = 'comment';
                }
            },
            tagName: function tagName() {
                var char = this.consume();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.appendToTagName(char);
                }
            },
            beforeAttributeName: function beforeAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.state = 'selfClosingStartTag';
                    this.consume();
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            attributeName: function attributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.state = 'afterAttributeName';
                    this.consume();
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.state = 'beforeAttributeValue';
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeName(char);
                }
            },
            afterAttributeName: function afterAttributeName() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    return;
                } else if (char === '/') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '=') {
                    this.consume();
                    this.state = 'beforeAttributeValue';
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'attributeName';
                    this.delegate.beginAttribute();
                    this.delegate.appendToAttributeName(char);
                }
            },
            beforeAttributeValue: function beforeAttributeValue() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                } else if (char === '"') {
                    this.state = 'attributeValueDoubleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '\'') {
                    this.state = 'attributeValueSingleQuoted';
                    this.delegate.beginAttributeValue(true);
                    this.consume();
                } else if (char === '>') {
                    this.delegate.beginAttributeValue(false);
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'attributeValueUnquoted';
                    this.delegate.beginAttributeValue(false);
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueDoubleQuoted: function attributeValueDoubleQuoted() {
                var char = this.consume();
                if (char === '"') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('"') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueSingleQuoted: function attributeValueSingleQuoted() {
                var char = this.consume();
                if (char === '\'') {
                    this.delegate.finishAttributeValue();
                    this.state = 'afterAttributeValueQuoted';
                } else if (char === '&') {
                    this.delegate.appendToAttributeValue(this.consumeCharRef('\'') || '&');
                } else {
                    this.delegate.appendToAttributeValue(char);
                }
            },
            attributeValueUnquoted: function attributeValueUnquoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '&') {
                    this.consume();
                    this.delegate.appendToAttributeValue(this.consumeCharRef('>') || '&');
                } else if (char === '>') {
                    this.delegate.finishAttributeValue();
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.consume();
                    this.delegate.appendToAttributeValue(char);
                }
            },
            afterAttributeValueQuoted: function afterAttributeValueQuoted() {
                var char = this.peek();
                if ((0, _utils.isSpace)(char)) {
                    this.consume();
                    this.state = 'beforeAttributeName';
                } else if (char === '/') {
                    this.consume();
                    this.state = 'selfClosingStartTag';
                } else if (char === '>') {
                    this.consume();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            selfClosingStartTag: function selfClosingStartTag() {
                var char = this.peek();
                if (char === '>') {
                    this.consume();
                    this.delegate.markTagAsSelfClosing();
                    this.delegate.finishTag();
                    this.state = 'beforeData';
                } else {
                    this.state = 'beforeAttributeName';
                }
            },
            endTagOpen: function endTagOpen() {
                var char = this.consume();
                if ((0, _utils.isAlpha)(char)) {
                    this.state = 'tagName';
                    this.delegate.beginEndTag();
                    this.delegate.appendToTagName(char.toLowerCase());
                }
            }
        }
    };
    exports.default = EventedTokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenizer', [
    'exports',
    './evented-tokenizer'
], function (exports, _eventedTokenizer) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    var _eventedTokenizer2 = _interopRequireDefault(_eventedTokenizer);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function Tokenizer(entityParser, options) {
        this.token = null;
        this.startLine = 1;
        this.startColumn = 0;
        this.options = options || {};
        this.tokenizer = new _eventedTokenizer2.default(this, entityParser);
    }
    Tokenizer.prototype = {
        tokenize: function tokenize(input) {
            this.tokens = [];
            this.tokenizer.tokenize(input);
            return this.tokens;
        },
        tokenizePart: function tokenizePart(input) {
            this.tokens = [];
            this.tokenizer.tokenizePart(input);
            return this.tokens;
        },
        tokenizeEOF: function tokenizeEOF() {
            this.tokens = [];
            this.tokenizer.tokenizeEOF();
            return this.tokens[0];
        },
        reset: function reset() {
            this.token = null;
            this.startLine = 1;
            this.startColumn = 0;
        },
        addLocInfo: function addLocInfo() {
            if (this.options.loc) {
                this.token.loc = {
                    start: {
                        line: this.startLine,
                        column: this.startColumn
                    },
                    end: {
                        line: this.tokenizer.line,
                        column: this.tokenizer.column
                    }
                };
            }
            this.startLine = this.tokenizer.line;
            this.startColumn = this.tokenizer.column;
        },
        beginData: function beginData() {
            this.token = {
                type: 'Chars',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToData: function appendToData(char) {
            this.token.chars += char;
        },
        finishData: function finishData() {
            this.addLocInfo();
        },
        beginComment: function beginComment() {
            this.token = {
                type: 'Comment',
                chars: ''
            };
            this.tokens.push(this.token);
        },
        appendToCommentData: function appendToCommentData(char) {
            this.token.chars += char;
        },
        finishComment: function finishComment() {
            this.addLocInfo();
        },
        beginStartTag: function beginStartTag() {
            this.token = {
                type: 'StartTag',
                tagName: '',
                attributes: [],
                selfClosing: false
            };
            this.tokens.push(this.token);
        },
        beginEndTag: function beginEndTag() {
            this.token = {
                type: 'EndTag',
                tagName: ''
            };
            this.tokens.push(this.token);
        },
        finishTag: function finishTag() {
            this.addLocInfo();
        },
        markTagAsSelfClosing: function markTagAsSelfClosing() {
            this.token.selfClosing = true;
        },
        appendToTagName: function appendToTagName(char) {
            this.token.tagName += char;
        },
        beginAttribute: function beginAttribute() {
            this._currentAttribute = [
                '',
                '',
                null
            ];
            this.token.attributes.push(this._currentAttribute);
        },
        appendToAttributeName: function appendToAttributeName(char) {
            this._currentAttribute[0] += char;
        },
        beginAttributeValue: function beginAttributeValue(isQuoted) {
            this._currentAttribute[2] = isQuoted;
        },
        appendToAttributeValue: function appendToAttributeValue(char) {
            this._currentAttribute[1] = this._currentAttribute[1] || '';
            this._currentAttribute[1] += char;
        },
        finishAttributeValue: function finishAttributeValue() {
        }
    };
    exports.default = Tokenizer;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/entity-parser', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    function EntityParser(named) {
        this.named = named;
    }
    var HEXCHARCODE = /^#[xX]([A-Fa-f0-9]+)$/;
    var CHARCODE = /^#([0-9]+)$/;
    var NAMED = /^([A-Za-z0-9]+)$/;
    EntityParser.prototype.parse = function (entity) {
        if (!entity) {
            return;
        }
        var matches = entity.match(HEXCHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 16));
        }
        matches = entity.match(CHARCODE);
        if (matches) {
            return String.fromCharCode(parseInt(matches[1], 10));
        }
        matches = entity.match(NAMED);
        if (matches) {
            return this.named[matches[1]];
        }
    };
    exports.default = EntityParser;
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/html5-named-char-refs', ['exports'], function (exports) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = {
        Aacute: 'Á',
        aacute: 'á',
        Abreve: 'Ă',
        abreve: 'ă',
        ac: '\u223E',
        acd: '\u223F',
        acE: '\u223E̳',
        Acirc: 'Â',
        acirc: 'â',
        acute: '\xB4',
        Acy: 'А',
        acy: 'а',
        AElig: 'Æ',
        aelig: 'æ',
        af: '\u2061',
        Afr: '\uD835\uDD04',
        afr: '\uD835\uDD1E',
        Agrave: 'À',
        agrave: 'à',
        alefsym: 'ℵ',
        aleph: 'ℵ',
        Alpha: 'Α',
        alpha: 'α',
        Amacr: 'Ā',
        amacr: 'ā',
        amalg: '\u2A3F',
        AMP: '&',
        amp: '&',
        And: '\u2A53',
        and: '\u2227',
        andand: '\u2A55',
        andd: '\u2A5C',
        andslope: '\u2A58',
        andv: '\u2A5A',
        ang: '\u2220',
        ange: '\u29A4',
        angle: '\u2220',
        angmsd: '\u2221',
        angmsdaa: '\u29A8',
        angmsdab: '\u29A9',
        angmsdac: '\u29AA',
        angmsdad: '\u29AB',
        angmsdae: '\u29AC',
        angmsdaf: '\u29AD',
        angmsdag: '\u29AE',
        angmsdah: '\u29AF',
        angrt: '\u221F',
        angrtvb: '\u22BE',
        angrtvbd: '\u299D',
        angsph: '\u2222',
        angst: 'Å',
        angzarr: '\u237C',
        Aogon: 'Ą',
        aogon: 'ą',
        Aopf: '\uD835\uDD38',
        aopf: '\uD835\uDD52',
        ap: '\u2248',
        apacir: '\u2A6F',
        apE: '\u2A70',
        ape: '\u224A',
        apid: '\u224B',
        apos: '\'',
        ApplyFunction: '\u2061',
        approx: '\u2248',
        approxeq: '\u224A',
        Aring: 'Å',
        aring: 'å',
        Ascr: '\uD835\uDC9C',
        ascr: '\uD835\uDCB6',
        Assign: '\u2254',
        ast: '*',
        asymp: '\u2248',
        asympeq: '\u224D',
        Atilde: 'Ã',
        atilde: 'ã',
        Auml: 'Ä',
        auml: 'ä',
        awconint: '\u2233',
        awint: '\u2A11',
        backcong: '\u224C',
        backepsilon: '\u03F6',
        backprime: '\u2035',
        backsim: '\u223D',
        backsimeq: '\u22CD',
        Backslash: '\u2216',
        Barv: '\u2AE7',
        barvee: '\u22BD',
        Barwed: '\u2306',
        barwed: '\u2305',
        barwedge: '\u2305',
        bbrk: '\u23B5',
        bbrktbrk: '\u23B6',
        bcong: '\u224C',
        Bcy: 'Б',
        bcy: 'б',
        bdquo: '\u201E',
        becaus: '\u2235',
        Because: '\u2235',
        because: '\u2235',
        bemptyv: '\u29B0',
        bepsi: '\u03F6',
        bernou: 'ℬ',
        Bernoullis: 'ℬ',
        Beta: 'Β',
        beta: 'β',
        beth: 'ℶ',
        between: '\u226C',
        Bfr: '\uD835\uDD05',
        bfr: '\uD835\uDD1F',
        bigcap: '\u22C2',
        bigcirc: '\u25EF',
        bigcup: '\u22C3',
        bigodot: '\u2A00',
        bigoplus: '\u2A01',
        bigotimes: '\u2A02',
        bigsqcup: '\u2A06',
        bigstar: '\u2605',
        bigtriangledown: '\u25BD',
        bigtriangleup: '\u25B3',
        biguplus: '\u2A04',
        bigvee: '\u22C1',
        bigwedge: '\u22C0',
        bkarow: '\u290D',
        blacklozenge: '\u29EB',
        blacksquare: '\u25AA',
        blacktriangle: '\u25B4',
        blacktriangledown: '\u25BE',
        blacktriangleleft: '\u25C2',
        blacktriangleright: '\u25B8',
        blank: '\u2423',
        blk12: '\u2592',
        blk14: '\u2591',
        blk34: '\u2593',
        block: '\u2588',
        bne: '=⃥',
        bnequiv: '\u2261⃥',
        bNot: '\u2AED',
        bnot: '\u2310',
        Bopf: '\uD835\uDD39',
        bopf: '\uD835\uDD53',
        bot: '\u22A5',
        bottom: '\u22A5',
        bowtie: '\u22C8',
        boxbox: '\u29C9',
        boxDL: '\u2557',
        boxDl: '\u2556',
        boxdL: '\u2555',
        boxdl: '\u2510',
        boxDR: '\u2554',
        boxDr: '\u2553',
        boxdR: '\u2552',
        boxdr: '\u250C',
        boxH: '\u2550',
        boxh: '\u2500',
        boxHD: '\u2566',
        boxHd: '\u2564',
        boxhD: '\u2565',
        boxhd: '\u252C',
        boxHU: '\u2569',
        boxHu: '\u2567',
        boxhU: '\u2568',
        boxhu: '\u2534',
        boxminus: '\u229F',
        boxplus: '\u229E',
        boxtimes: '\u22A0',
        boxUL: '\u255D',
        boxUl: '\u255C',
        boxuL: '\u255B',
        boxul: '\u2518',
        boxUR: '\u255A',
        boxUr: '\u2559',
        boxuR: '\u2558',
        boxur: '\u2514',
        boxV: '\u2551',
        boxv: '\u2502',
        boxVH: '\u256C',
        boxVh: '\u256B',
        boxvH: '\u256A',
        boxvh: '\u253C',
        boxVL: '\u2563',
        boxVl: '\u2562',
        boxvL: '\u2561',
        boxvl: '\u2524',
        boxVR: '\u2560',
        boxVr: '\u255F',
        boxvR: '\u255E',
        boxvr: '\u251C',
        bprime: '\u2035',
        Breve: '\u02D8',
        breve: '\u02D8',
        brvbar: '\xA6',
        Bscr: 'ℬ',
        bscr: '\uD835\uDCB7',
        bsemi: '\u204F',
        bsim: '\u223D',
        bsime: '\u22CD',
        bsol: '\\',
        bsolb: '\u29C5',
        bsolhsub: '\u27C8',
        bull: '\u2022',
        bullet: '\u2022',
        bump: '\u224E',
        bumpE: '\u2AAE',
        bumpe: '\u224F',
        Bumpeq: '\u224E',
        bumpeq: '\u224F',
        Cacute: 'Ć',
        cacute: 'ć',
        Cap: '\u22D2',
        cap: '\u2229',
        capand: '\u2A44',
        capbrcup: '\u2A49',
        capcap: '\u2A4B',
        capcup: '\u2A47',
        capdot: '\u2A40',
        CapitalDifferentialD: 'ⅅ',
        caps: '\u2229︀',
        caret: '\u2041',
        caron: 'ˇ',
        Cayleys: 'ℭ',
        ccaps: '\u2A4D',
        Ccaron: 'Č',
        ccaron: 'č',
        Ccedil: 'Ç',
        ccedil: 'ç',
        Ccirc: 'Ĉ',
        ccirc: 'ĉ',
        Cconint: '\u2230',
        ccups: '\u2A4C',
        ccupssm: '\u2A50',
        Cdot: 'Ċ',
        cdot: 'ċ',
        cedil: '\xB8',
        Cedilla: '\xB8',
        cemptyv: '\u29B2',
        cent: '\xA2',
        CenterDot: '\xB7',
        centerdot: '\xB7',
        Cfr: 'ℭ',
        cfr: '\uD835\uDD20',
        CHcy: 'Ч',
        chcy: 'ч',
        check: '\u2713',
        checkmark: '\u2713',
        Chi: 'Χ',
        chi: 'χ',
        cir: '\u25CB',
        circ: 'ˆ',
        circeq: '\u2257',
        circlearrowleft: '\u21BA',
        circlearrowright: '\u21BB',
        circledast: '\u229B',
        circledcirc: '\u229A',
        circleddash: '\u229D',
        CircleDot: '\u2299',
        circledR: '\xAE',
        circledS: '\u24C8',
        CircleMinus: '\u2296',
        CirclePlus: '\u2295',
        CircleTimes: '\u2297',
        cirE: '\u29C3',
        cire: '\u2257',
        cirfnint: '\u2A10',
        cirmid: '\u2AEF',
        cirscir: '\u29C2',
        ClockwiseContourIntegral: '\u2232',
        CloseCurlyDoubleQuote: '\u201D',
        CloseCurlyQuote: '\u2019',
        clubs: '\u2663',
        clubsuit: '\u2663',
        Colon: '\u2237',
        colon: ':',
        Colone: '\u2A74',
        colone: '\u2254',
        coloneq: '\u2254',
        comma: ',',
        commat: '@',
        comp: '\u2201',
        compfn: '\u2218',
        complement: '\u2201',
        complexes: 'ℂ',
        cong: '\u2245',
        congdot: '\u2A6D',
        Congruent: '\u2261',
        Conint: '\u222F',
        conint: '\u222E',
        ContourIntegral: '\u222E',
        Copf: 'ℂ',
        copf: '\uD835\uDD54',
        coprod: '\u2210',
        Coproduct: '\u2210',
        COPY: '\xA9',
        copy: '\xA9',
        copysr: '\u2117',
        CounterClockwiseContourIntegral: '\u2233',
        crarr: '\u21B5',
        Cross: '\u2A2F',
        cross: '\u2717',
        Cscr: '\uD835\uDC9E',
        cscr: '\uD835\uDCB8',
        csub: '\u2ACF',
        csube: '\u2AD1',
        csup: '\u2AD0',
        csupe: '\u2AD2',
        ctdot: '\u22EF',
        cudarrl: '\u2938',
        cudarrr: '\u2935',
        cuepr: '\u22DE',
        cuesc: '\u22DF',
        cularr: '\u21B6',
        cularrp: '\u293D',
        Cup: '\u22D3',
        cup: '\u222A',
        cupbrcap: '\u2A48',
        CupCap: '\u224D',
        cupcap: '\u2A46',
        cupcup: '\u2A4A',
        cupdot: '\u228D',
        cupor: '\u2A45',
        cups: '\u222A︀',
        curarr: '\u21B7',
        curarrm: '\u293C',
        curlyeqprec: '\u22DE',
        curlyeqsucc: '\u22DF',
        curlyvee: '\u22CE',
        curlywedge: '\u22CF',
        curren: '\xA4',
        curvearrowleft: '\u21B6',
        curvearrowright: '\u21B7',
        cuvee: '\u22CE',
        cuwed: '\u22CF',
        cwconint: '\u2232',
        cwint: '\u2231',
        cylcty: '\u232D',
        Dagger: '\u2021',
        dagger: '\u2020',
        daleth: 'ℸ',
        Darr: '\u21A1',
        dArr: '\u21D3',
        darr: '\u2193',
        dash: '\u2010',
        Dashv: '\u2AE4',
        dashv: '\u22A3',
        dbkarow: '\u290F',
        dblac: '\u02DD',
        Dcaron: 'Ď',
        dcaron: 'ď',
        Dcy: 'Д',
        dcy: 'д',
        DD: 'ⅅ',
        dd: 'ⅆ',
        ddagger: '\u2021',
        ddarr: '\u21CA',
        DDotrahd: '\u2911',
        ddotseq: '\u2A77',
        deg: '\xB0',
        Del: '\u2207',
        Delta: 'Δ',
        delta: 'δ',
        demptyv: '\u29B1',
        dfisht: '\u297F',
        Dfr: '\uD835\uDD07',
        dfr: '\uD835\uDD21',
        dHar: '\u2965',
        dharl: '\u21C3',
        dharr: '\u21C2',
        DiacriticalAcute: '\xB4',
        DiacriticalDot: '\u02D9',
        DiacriticalDoubleAcute: '\u02DD',
        DiacriticalGrave: '`',
        DiacriticalTilde: '\u02DC',
        diam: '\u22C4',
        Diamond: '\u22C4',
        diamond: '\u22C4',
        diamondsuit: '\u2666',
        diams: '\u2666',
        die: '\xA8',
        DifferentialD: 'ⅆ',
        digamma: 'ϝ',
        disin: '\u22F2',
        div: '\xF7',
        divide: '\xF7',
        divideontimes: '\u22C7',
        divonx: '\u22C7',
        DJcy: 'Ђ',
        djcy: 'ђ',
        dlcorn: '\u231E',
        dlcrop: '\u230D',
        dollar: '$',
        Dopf: '\uD835\uDD3B',
        dopf: '\uD835\uDD55',
        Dot: '\xA8',
        dot: '\u02D9',
        DotDot: '⃜',
        doteq: '\u2250',
        doteqdot: '\u2251',
        DotEqual: '\u2250',
        dotminus: '\u2238',
        dotplus: '\u2214',
        dotsquare: '\u22A1',
        doublebarwedge: '\u2306',
        DoubleContourIntegral: '\u222F',
        DoubleDot: '\xA8',
        DoubleDownArrow: '\u21D3',
        DoubleLeftArrow: '\u21D0',
        DoubleLeftRightArrow: '\u21D4',
        DoubleLeftTee: '\u2AE4',
        DoubleLongLeftArrow: '\u27F8',
        DoubleLongLeftRightArrow: '\u27FA',
        DoubleLongRightArrow: '\u27F9',
        DoubleRightArrow: '\u21D2',
        DoubleRightTee: '\u22A8',
        DoubleUpArrow: '\u21D1',
        DoubleUpDownArrow: '\u21D5',
        DoubleVerticalBar: '\u2225',
        DownArrow: '\u2193',
        Downarrow: '\u21D3',
        downarrow: '\u2193',
        DownArrowBar: '\u2913',
        DownArrowUpArrow: '\u21F5',
        DownBreve: '̑',
        downdownarrows: '\u21CA',
        downharpoonleft: '\u21C3',
        downharpoonright: '\u21C2',
        DownLeftRightVector: '\u2950',
        DownLeftTeeVector: '\u295E',
        DownLeftVector: '\u21BD',
        DownLeftVectorBar: '\u2956',
        DownRightTeeVector: '\u295F',
        DownRightVector: '\u21C1',
        DownRightVectorBar: '\u2957',
        DownTee: '\u22A4',
        DownTeeArrow: '\u21A7',
        drbkarow: '\u2910',
        drcorn: '\u231F',
        drcrop: '\u230C',
        Dscr: '\uD835\uDC9F',
        dscr: '\uD835\uDCB9',
        DScy: 'Ѕ',
        dscy: 'ѕ',
        dsol: '\u29F6',
        Dstrok: 'Đ',
        dstrok: 'đ',
        dtdot: '\u22F1',
        dtri: '\u25BF',
        dtrif: '\u25BE',
        duarr: '\u21F5',
        duhar: '\u296F',
        dwangle: '\u29A6',
        DZcy: 'Џ',
        dzcy: 'џ',
        dzigrarr: '\u27FF',
        Eacute: 'É',
        eacute: 'é',
        easter: '\u2A6E',
        Ecaron: 'Ě',
        ecaron: 'ě',
        ecir: '\u2256',
        Ecirc: 'Ê',
        ecirc: 'ê',
        ecolon: '\u2255',
        Ecy: 'Э',
        ecy: 'э',
        eDDot: '\u2A77',
        Edot: 'Ė',
        eDot: '\u2251',
        edot: 'ė',
        ee: 'ⅇ',
        efDot: '\u2252',
        Efr: '\uD835\uDD08',
        efr: '\uD835\uDD22',
        eg: '\u2A9A',
        Egrave: 'È',
        egrave: 'è',
        egs: '\u2A96',
        egsdot: '\u2A98',
        el: '\u2A99',
        Element: '\u2208',
        elinters: '\u23E7',
        ell: 'ℓ',
        els: '\u2A95',
        elsdot: '\u2A97',
        Emacr: 'Ē',
        emacr: 'ē',
        empty: '\u2205',
        emptyset: '\u2205',
        EmptySmallSquare: '\u25FB',
        emptyv: '\u2205',
        EmptyVerySmallSquare: '\u25AB',
        emsp: '\u2003',
        emsp13: '\u2004',
        emsp14: '\u2005',
        ENG: 'Ŋ',
        eng: 'ŋ',
        ensp: '\u2002',
        Eogon: 'Ę',
        eogon: 'ę',
        Eopf: '\uD835\uDD3C',
        eopf: '\uD835\uDD56',
        epar: '\u22D5',
        eparsl: '\u29E3',
        eplus: '\u2A71',
        epsi: 'ε',
        Epsilon: 'Ε',
        epsilon: 'ε',
        epsiv: 'ϵ',
        eqcirc: '\u2256',
        eqcolon: '\u2255',
        eqsim: '\u2242',
        eqslantgtr: '\u2A96',
        eqslantless: '\u2A95',
        Equal: '\u2A75',
        equals: '=',
        EqualTilde: '\u2242',
        equest: '\u225F',
        Equilibrium: '\u21CC',
        equiv: '\u2261',
        equivDD: '\u2A78',
        eqvparsl: '\u29E5',
        erarr: '\u2971',
        erDot: '\u2253',
        Escr: 'ℰ',
        escr: 'ℯ',
        esdot: '\u2250',
        Esim: '\u2A73',
        esim: '\u2242',
        Eta: 'Η',
        eta: 'η',
        ETH: 'Ð',
        eth: 'ð',
        Euml: 'Ë',
        euml: 'ë',
        euro: '\u20AC',
        excl: '!',
        exist: '\u2203',
        Exists: '\u2203',
        expectation: 'ℰ',
        ExponentialE: 'ⅇ',
        exponentiale: 'ⅇ',
        fallingdotseq: '\u2252',
        Fcy: 'Ф',
        fcy: 'ф',
        female: '\u2640',
        ffilig: 'ﬃ',
        fflig: 'ﬀ',
        ffllig: 'ﬄ',
        Ffr: '\uD835\uDD09',
        ffr: '\uD835\uDD23',
        filig: 'ﬁ',
        FilledSmallSquare: '\u25FC',
        FilledVerySmallSquare: '\u25AA',
        fjlig: 'fj',
        flat: '\u266D',
        fllig: 'ﬂ',
        fltns: '\u25B1',
        fnof: 'ƒ',
        Fopf: '\uD835\uDD3D',
        fopf: '\uD835\uDD57',
        ForAll: '\u2200',
        forall: '\u2200',
        fork: '\u22D4',
        forkv: '\u2AD9',
        Fouriertrf: 'ℱ',
        fpartint: '\u2A0D',
        frac12: '\xBD',
        frac13: '\u2153',
        frac14: '\xBC',
        frac15: '\u2155',
        frac16: '\u2159',
        frac18: '\u215B',
        frac23: '\u2154',
        frac25: '\u2156',
        frac34: '\xBE',
        frac35: '\u2157',
        frac38: '\u215C',
        frac45: '\u2158',
        frac56: '\u215A',
        frac58: '\u215D',
        frac78: '\u215E',
        frasl: '\u2044',
        frown: '\u2322',
        Fscr: 'ℱ',
        fscr: '\uD835\uDCBB',
        gacute: 'ǵ',
        Gamma: 'Γ',
        gamma: 'γ',
        Gammad: 'Ϝ',
        gammad: 'ϝ',
        gap: '\u2A86',
        Gbreve: 'Ğ',
        gbreve: 'ğ',
        Gcedil: 'Ģ',
        Gcirc: 'Ĝ',
        gcirc: 'ĝ',
        Gcy: 'Г',
        gcy: 'г',
        Gdot: 'Ġ',
        gdot: 'ġ',
        gE: '\u2267',
        ge: '\u2265',
        gEl: '\u2A8C',
        gel: '\u22DB',
        geq: '\u2265',
        geqq: '\u2267',
        geqslant: '\u2A7E',
        ges: '\u2A7E',
        gescc: '\u2AA9',
        gesdot: '\u2A80',
        gesdoto: '\u2A82',
        gesdotol: '\u2A84',
        gesl: '\u22DB︀',
        gesles: '\u2A94',
        Gfr: '\uD835\uDD0A',
        gfr: '\uD835\uDD24',
        Gg: '\u22D9',
        gg: '\u226B',
        ggg: '\u22D9',
        gimel: 'ℷ',
        GJcy: 'Ѓ',
        gjcy: 'ѓ',
        gl: '\u2277',
        gla: '\u2AA5',
        glE: '\u2A92',
        glj: '\u2AA4',
        gnap: '\u2A8A',
        gnapprox: '\u2A8A',
        gnE: '\u2269',
        gne: '\u2A88',
        gneq: '\u2A88',
        gneqq: '\u2269',
        gnsim: '\u22E7',
        Gopf: '\uD835\uDD3E',
        gopf: '\uD835\uDD58',
        grave: '`',
        GreaterEqual: '\u2265',
        GreaterEqualLess: '\u22DB',
        GreaterFullEqual: '\u2267',
        GreaterGreater: '\u2AA2',
        GreaterLess: '\u2277',
        GreaterSlantEqual: '\u2A7E',
        GreaterTilde: '\u2273',
        Gscr: '\uD835\uDCA2',
        gscr: 'ℊ',
        gsim: '\u2273',
        gsime: '\u2A8E',
        gsiml: '\u2A90',
        GT: '>',
        Gt: '\u226B',
        gt: '>',
        gtcc: '\u2AA7',
        gtcir: '\u2A7A',
        gtdot: '\u22D7',
        gtlPar: '\u2995',
        gtquest: '\u2A7C',
        gtrapprox: '\u2A86',
        gtrarr: '\u2978',
        gtrdot: '\u22D7',
        gtreqless: '\u22DB',
        gtreqqless: '\u2A8C',
        gtrless: '\u2277',
        gtrsim: '\u2273',
        gvertneqq: '\u2269︀',
        gvnE: '\u2269︀',
        Hacek: 'ˇ',
        hairsp: '\u200A',
        half: '\xBD',
        hamilt: 'ℋ',
        HARDcy: 'Ъ',
        hardcy: 'ъ',
        hArr: '\u21D4',
        harr: '\u2194',
        harrcir: '\u2948',
        harrw: '\u21AD',
        Hat: '^',
        hbar: 'ℏ',
        Hcirc: 'Ĥ',
        hcirc: 'ĥ',
        hearts: '\u2665',
        heartsuit: '\u2665',
        hellip: '\u2026',
        hercon: '\u22B9',
        Hfr: 'ℌ',
        hfr: '\uD835\uDD25',
        HilbertSpace: 'ℋ',
        hksearow: '\u2925',
        hkswarow: '\u2926',
        hoarr: '\u21FF',
        homtht: '\u223B',
        hookleftarrow: '\u21A9',
        hookrightarrow: '\u21AA',
        Hopf: 'ℍ',
        hopf: '\uD835\uDD59',
        horbar: '\u2015',
        HorizontalLine: '\u2500',
        Hscr: 'ℋ',
        hscr: '\uD835\uDCBD',
        hslash: 'ℏ',
        Hstrok: 'Ħ',
        hstrok: 'ħ',
        HumpDownHump: '\u224E',
        HumpEqual: '\u224F',
        hybull: '\u2043',
        hyphen: '\u2010',
        Iacute: 'Í',
        iacute: 'í',
        ic: '\u2063',
        Icirc: 'Î',
        icirc: 'î',
        Icy: 'И',
        icy: 'и',
        Idot: 'İ',
        IEcy: 'Е',
        iecy: 'е',
        iexcl: '\xA1',
        iff: '\u21D4',
        Ifr: 'ℑ',
        ifr: '\uD835\uDD26',
        Igrave: 'Ì',
        igrave: 'ì',
        ii: 'ⅈ',
        iiiint: '\u2A0C',
        iiint: '\u222D',
        iinfin: '\u29DC',
        iiota: '\u2129',
        IJlig: 'Ĳ',
        ijlig: 'ĳ',
        Im: 'ℑ',
        Imacr: 'Ī',
        imacr: 'ī',
        image: 'ℑ',
        ImaginaryI: 'ⅈ',
        imagline: 'ℐ',
        imagpart: 'ℑ',
        imath: 'ı',
        imof: '\u22B7',
        imped: 'Ƶ',
        Implies: '\u21D2',
        in: '\u2208',
        incare: '\u2105',
        infin: '\u221E',
        infintie: '\u29DD',
        inodot: 'ı',
        Int: '\u222C',
        int: '\u222B',
        intcal: '\u22BA',
        integers: 'ℤ',
        Integral: '\u222B',
        intercal: '\u22BA',
        Intersection: '\u22C2',
        intlarhk: '\u2A17',
        intprod: '\u2A3C',
        InvisibleComma: '\u2063',
        InvisibleTimes: '\u2062',
        IOcy: 'Ё',
        iocy: 'ё',
        Iogon: 'Į',
        iogon: 'į',
        Iopf: '\uD835\uDD40',
        iopf: '\uD835\uDD5A',
        Iota: 'Ι',
        iota: 'ι',
        iprod: '\u2A3C',
        iquest: '\xBF',
        Iscr: 'ℐ',
        iscr: '\uD835\uDCBE',
        isin: '\u2208',
        isindot: '\u22F5',
        isinE: '\u22F9',
        isins: '\u22F4',
        isinsv: '\u22F3',
        isinv: '\u2208',
        it: '\u2062',
        Itilde: 'Ĩ',
        itilde: 'ĩ',
        Iukcy: 'І',
        iukcy: 'і',
        Iuml: 'Ï',
        iuml: 'ï',
        Jcirc: 'Ĵ',
        jcirc: 'ĵ',
        Jcy: 'Й',
        jcy: 'й',
        Jfr: '\uD835\uDD0D',
        jfr: '\uD835\uDD27',
        jmath: 'ȷ',
        Jopf: '\uD835\uDD41',
        jopf: '\uD835\uDD5B',
        Jscr: '\uD835\uDCA5',
        jscr: '\uD835\uDCBF',
        Jsercy: 'Ј',
        jsercy: 'ј',
        Jukcy: 'Є',
        jukcy: 'є',
        Kappa: 'Κ',
        kappa: 'κ',
        kappav: 'ϰ',
        Kcedil: 'Ķ',
        kcedil: 'ķ',
        Kcy: 'К',
        kcy: 'к',
        Kfr: '\uD835\uDD0E',
        kfr: '\uD835\uDD28',
        kgreen: 'ĸ',
        KHcy: 'Х',
        khcy: 'х',
        KJcy: 'Ќ',
        kjcy: 'ќ',
        Kopf: '\uD835\uDD42',
        kopf: '\uD835\uDD5C',
        Kscr: '\uD835\uDCA6',
        kscr: '\uD835\uDCC0',
        lAarr: '\u21DA',
        Lacute: 'Ĺ',
        lacute: 'ĺ',
        laemptyv: '\u29B4',
        lagran: 'ℒ',
        Lambda: 'Λ',
        lambda: 'λ',
        Lang: '\u27EA',
        lang: '\u27E8',
        langd: '\u2991',
        langle: '\u27E8',
        lap: '\u2A85',
        Laplacetrf: 'ℒ',
        laquo: '\xAB',
        Larr: '\u219E',
        lArr: '\u21D0',
        larr: '\u2190',
        larrb: '\u21E4',
        larrbfs: '\u291F',
        larrfs: '\u291D',
        larrhk: '\u21A9',
        larrlp: '\u21AB',
        larrpl: '\u2939',
        larrsim: '\u2973',
        larrtl: '\u21A2',
        lat: '\u2AAB',
        lAtail: '\u291B',
        latail: '\u2919',
        late: '\u2AAD',
        lates: '\u2AAD︀',
        lBarr: '\u290E',
        lbarr: '\u290C',
        lbbrk: '\u2772',
        lbrace: '{',
        lbrack: '[',
        lbrke: '\u298B',
        lbrksld: '\u298F',
        lbrkslu: '\u298D',
        Lcaron: 'Ľ',
        lcaron: 'ľ',
        Lcedil: 'Ļ',
        lcedil: 'ļ',
        lceil: '\u2308',
        lcub: '{',
        Lcy: 'Л',
        lcy: 'л',
        ldca: '\u2936',
        ldquo: '\u201C',
        ldquor: '\u201E',
        ldrdhar: '\u2967',
        ldrushar: '\u294B',
        ldsh: '\u21B2',
        lE: '\u2266',
        le: '\u2264',
        LeftAngleBracket: '\u27E8',
        LeftArrow: '\u2190',
        Leftarrow: '\u21D0',
        leftarrow: '\u2190',
        LeftArrowBar: '\u21E4',
        LeftArrowRightArrow: '\u21C6',
        leftarrowtail: '\u21A2',
        LeftCeiling: '\u2308',
        LeftDoubleBracket: '\u27E6',
        LeftDownTeeVector: '\u2961',
        LeftDownVector: '\u21C3',
        LeftDownVectorBar: '\u2959',
        LeftFloor: '\u230A',
        leftharpoondown: '\u21BD',
        leftharpoonup: '\u21BC',
        leftleftarrows: '\u21C7',
        LeftRightArrow: '\u2194',
        Leftrightarrow: '\u21D4',
        leftrightarrow: '\u2194',
        leftrightarrows: '\u21C6',
        leftrightharpoons: '\u21CB',
        leftrightsquigarrow: '\u21AD',
        LeftRightVector: '\u294E',
        LeftTee: '\u22A3',
        LeftTeeArrow: '\u21A4',
        LeftTeeVector: '\u295A',
        leftthreetimes: '\u22CB',
        LeftTriangle: '\u22B2',
        LeftTriangleBar: '\u29CF',
        LeftTriangleEqual: '\u22B4',
        LeftUpDownVector: '\u2951',
        LeftUpTeeVector: '\u2960',
        LeftUpVector: '\u21BF',
        LeftUpVectorBar: '\u2958',
        LeftVector: '\u21BC',
        LeftVectorBar: '\u2952',
        lEg: '\u2A8B',
        leg: '\u22DA',
        leq: '\u2264',
        leqq: '\u2266',
        leqslant: '\u2A7D',
        les: '\u2A7D',
        lescc: '\u2AA8',
        lesdot: '\u2A7F',
        lesdoto: '\u2A81',
        lesdotor: '\u2A83',
        lesg: '\u22DA︀',
        lesges: '\u2A93',
        lessapprox: '\u2A85',
        lessdot: '\u22D6',
        lesseqgtr: '\u22DA',
        lesseqqgtr: '\u2A8B',
        LessEqualGreater: '\u22DA',
        LessFullEqual: '\u2266',
        LessGreater: '\u2276',
        lessgtr: '\u2276',
        LessLess: '\u2AA1',
        lesssim: '\u2272',
        LessSlantEqual: '\u2A7D',
        LessTilde: '\u2272',
        lfisht: '\u297C',
        lfloor: '\u230A',
        Lfr: '\uD835\uDD0F',
        lfr: '\uD835\uDD29',
        lg: '\u2276',
        lgE: '\u2A91',
        lHar: '\u2962',
        lhard: '\u21BD',
        lharu: '\u21BC',
        lharul: '\u296A',
        lhblk: '\u2584',
        LJcy: 'Љ',
        ljcy: 'љ',
        Ll: '\u22D8',
        ll: '\u226A',
        llarr: '\u21C7',
        llcorner: '\u231E',
        Lleftarrow: '\u21DA',
        llhard: '\u296B',
        lltri: '\u25FA',
        Lmidot: 'Ŀ',
        lmidot: 'ŀ',
        lmoust: '\u23B0',
        lmoustache: '\u23B0',
        lnap: '\u2A89',
        lnapprox: '\u2A89',
        lnE: '\u2268',
        lne: '\u2A87',
        lneq: '\u2A87',
        lneqq: '\u2268',
        lnsim: '\u22E6',
        loang: '\u27EC',
        loarr: '\u21FD',
        lobrk: '\u27E6',
        LongLeftArrow: '\u27F5',
        Longleftarrow: '\u27F8',
        longleftarrow: '\u27F5',
        LongLeftRightArrow: '\u27F7',
        Longleftrightarrow: '\u27FA',
        longleftrightarrow: '\u27F7',
        longmapsto: '\u27FC',
        LongRightArrow: '\u27F6',
        Longrightarrow: '\u27F9',
        longrightarrow: '\u27F6',
        looparrowleft: '\u21AB',
        looparrowright: '\u21AC',
        lopar: '\u2985',
        Lopf: '\uD835\uDD43',
        lopf: '\uD835\uDD5D',
        loplus: '\u2A2D',
        lotimes: '\u2A34',
        lowast: '\u2217',
        lowbar: '_',
        LowerLeftArrow: '\u2199',
        LowerRightArrow: '\u2198',
        loz: '\u25CA',
        lozenge: '\u25CA',
        lozf: '\u29EB',
        lpar: '(',
        lparlt: '\u2993',
        lrarr: '\u21C6',
        lrcorner: '\u231F',
        lrhar: '\u21CB',
        lrhard: '\u296D',
        lrm: '\u200E',
        lrtri: '\u22BF',
        lsaquo: '\u2039',
        Lscr: 'ℒ',
        lscr: '\uD835\uDCC1',
        Lsh: '\u21B0',
        lsh: '\u21B0',
        lsim: '\u2272',
        lsime: '\u2A8D',
        lsimg: '\u2A8F',
        lsqb: '[',
        lsquo: '\u2018',
        lsquor: '\u201A',
        Lstrok: 'Ł',
        lstrok: 'ł',
        LT: '<',
        Lt: '\u226A',
        lt: '<',
        ltcc: '\u2AA6',
        ltcir: '\u2A79',
        ltdot: '\u22D6',
        lthree: '\u22CB',
        ltimes: '\u22C9',
        ltlarr: '\u2976',
        ltquest: '\u2A7B',
        ltri: '\u25C3',
        ltrie: '\u22B4',
        ltrif: '\u25C2',
        ltrPar: '\u2996',
        lurdshar: '\u294A',
        luruhar: '\u2966',
        lvertneqq: '\u2268︀',
        lvnE: '\u2268︀',
        macr: '\xAF',
        male: '\u2642',
        malt: '\u2720',
        maltese: '\u2720',
        Map: '\u2905',
        map: '\u21A6',
        mapsto: '\u21A6',
        mapstodown: '\u21A7',
        mapstoleft: '\u21A4',
        mapstoup: '\u21A5',
        marker: '\u25AE',
        mcomma: '\u2A29',
        Mcy: 'М',
        mcy: 'м',
        mdash: '\u2014',
        mDDot: '\u223A',
        measuredangle: '\u2221',
        MediumSpace: '\u205F',
        Mellintrf: 'ℳ',
        Mfr: '\uD835\uDD10',
        mfr: '\uD835\uDD2A',
        mho: '\u2127',
        micro: 'µ',
        mid: '\u2223',
        midast: '*',
        midcir: '\u2AF0',
        middot: '\xB7',
        minus: '\u2212',
        minusb: '\u229F',
        minusd: '\u2238',
        minusdu: '\u2A2A',
        MinusPlus: '\u2213',
        mlcp: '\u2ADB',
        mldr: '\u2026',
        mnplus: '\u2213',
        models: '\u22A7',
        Mopf: '\uD835\uDD44',
        mopf: '\uD835\uDD5E',
        mp: '\u2213',
        Mscr: 'ℳ',
        mscr: '\uD835\uDCC2',
        mstpos: '\u223E',
        Mu: 'Μ',
        mu: 'μ',
        multimap: '\u22B8',
        mumap: '\u22B8',
        nabla: '\u2207',
        Nacute: 'Ń',
        nacute: 'ń',
        nang: '\u2220⃒',
        nap: '\u2249',
        napE: '\u2A70̸',
        napid: '\u224B̸',
        napos: 'ŉ',
        napprox: '\u2249',
        natur: '\u266E',
        natural: '\u266E',
        naturals: 'ℕ',
        nbsp: '\xA0',
        nbump: '\u224E̸',
        nbumpe: '\u224F̸',
        ncap: '\u2A43',
        Ncaron: 'Ň',
        ncaron: 'ň',
        Ncedil: 'Ņ',
        ncedil: 'ņ',
        ncong: '\u2247',
        ncongdot: '\u2A6D̸',
        ncup: '\u2A42',
        Ncy: 'Н',
        ncy: 'н',
        ndash: '\u2013',
        ne: '\u2260',
        nearhk: '\u2924',
        neArr: '\u21D7',
        nearr: '\u2197',
        nearrow: '\u2197',
        nedot: '\u2250̸',
        NegativeMediumSpace: '\u200B',
        NegativeThickSpace: '\u200B',
        NegativeThinSpace: '\u200B',
        NegativeVeryThinSpace: '\u200B',
        nequiv: '\u2262',
        nesear: '\u2928',
        nesim: '\u2242̸',
        NestedGreaterGreater: '\u226B',
        NestedLessLess: '\u226A',
        NewLine: '\n',
        nexist: '\u2204',
        nexists: '\u2204',
        Nfr: '\uD835\uDD11',
        nfr: '\uD835\uDD2B',
        ngE: '\u2267̸',
        nge: '\u2271',
        ngeq: '\u2271',
        ngeqq: '\u2267̸',
        ngeqslant: '\u2A7E̸',
        nges: '\u2A7E̸',
        nGg: '\u22D9̸',
        ngsim: '\u2275',
        nGt: '\u226B⃒',
        ngt: '\u226F',
        ngtr: '\u226F',
        nGtv: '\u226B̸',
        nhArr: '\u21CE',
        nharr: '\u21AE',
        nhpar: '\u2AF2',
        ni: '\u220B',
        nis: '\u22FC',
        nisd: '\u22FA',
        niv: '\u220B',
        NJcy: 'Њ',
        njcy: 'њ',
        nlArr: '\u21CD',
        nlarr: '\u219A',
        nldr: '\u2025',
        nlE: '\u2266̸',
        nle: '\u2270',
        nLeftarrow: '\u21CD',
        nleftarrow: '\u219A',
        nLeftrightarrow: '\u21CE',
        nleftrightarrow: '\u21AE',
        nleq: '\u2270',
        nleqq: '\u2266̸',
        nleqslant: '\u2A7D̸',
        nles: '\u2A7D̸',
        nless: '\u226E',
        nLl: '\u22D8̸',
        nlsim: '\u2274',
        nLt: '\u226A⃒',
        nlt: '\u226E',
        nltri: '\u22EA',
        nltrie: '\u22EC',
        nLtv: '\u226A̸',
        nmid: '\u2224',
        NoBreak: '\u2060',
        NonBreakingSpace: '\xA0',
        Nopf: 'ℕ',
        nopf: '\uD835\uDD5F',
        Not: '\u2AEC',
        not: '\xAC',
        NotCongruent: '\u2262',
        NotCupCap: '\u226D',
        NotDoubleVerticalBar: '\u2226',
        NotElement: '\u2209',
        NotEqual: '\u2260',
        NotEqualTilde: '\u2242̸',
        NotExists: '\u2204',
        NotGreater: '\u226F',
        NotGreaterEqual: '\u2271',
        NotGreaterFullEqual: '\u2267̸',
        NotGreaterGreater: '\u226B̸',
        NotGreaterLess: '\u2279',
        NotGreaterSlantEqual: '\u2A7E̸',
        NotGreaterTilde: '\u2275',
        NotHumpDownHump: '\u224E̸',
        NotHumpEqual: '\u224F̸',
        notin: '\u2209',
        notindot: '\u22F5̸',
        notinE: '\u22F9̸',
        notinva: '\u2209',
        notinvb: '\u22F7',
        notinvc: '\u22F6',
        NotLeftTriangle: '\u22EA',
        NotLeftTriangleBar: '\u29CF̸',
        NotLeftTriangleEqual: '\u22EC',
        NotLess: '\u226E',
        NotLessEqual: '\u2270',
        NotLessGreater: '\u2278',
        NotLessLess: '\u226A̸',
        NotLessSlantEqual: '\u2A7D̸',
        NotLessTilde: '\u2274',
        NotNestedGreaterGreater: '\u2AA2̸',
        NotNestedLessLess: '\u2AA1̸',
        notni: '\u220C',
        notniva: '\u220C',
        notnivb: '\u22FE',
        notnivc: '\u22FD',
        NotPrecedes: '\u2280',
        NotPrecedesEqual: '\u2AAF̸',
        NotPrecedesSlantEqual: '\u22E0',
        NotReverseElement: '\u220C',
        NotRightTriangle: '\u22EB',
        NotRightTriangleBar: '\u29D0̸',
        NotRightTriangleEqual: '\u22ED',
        NotSquareSubset: '\u228F̸',
        NotSquareSubsetEqual: '\u22E2',
        NotSquareSuperset: '\u2290̸',
        NotSquareSupersetEqual: '\u22E3',
        NotSubset: '\u2282⃒',
        NotSubsetEqual: '\u2288',
        NotSucceeds: '\u2281',
        NotSucceedsEqual: '\u2AB0̸',
        NotSucceedsSlantEqual: '\u22E1',
        NotSucceedsTilde: '\u227F̸',
        NotSuperset: '\u2283⃒',
        NotSupersetEqual: '\u2289',
        NotTilde: '\u2241',
        NotTildeEqual: '\u2244',
        NotTildeFullEqual: '\u2247',
        NotTildeTilde: '\u2249',
        NotVerticalBar: '\u2224',
        npar: '\u2226',
        nparallel: '\u2226',
        nparsl: '\u2AFD⃥',
        npart: '\u2202̸',
        npolint: '\u2A14',
        npr: '\u2280',
        nprcue: '\u22E0',
        npre: '\u2AAF̸',
        nprec: '\u2280',
        npreceq: '\u2AAF̸',
        nrArr: '\u21CF',
        nrarr: '\u219B',
        nrarrc: '\u2933̸',
        nrarrw: '\u219D̸',
        nRightarrow: '\u21CF',
        nrightarrow: '\u219B',
        nrtri: '\u22EB',
        nrtrie: '\u22ED',
        nsc: '\u2281',
        nsccue: '\u22E1',
        nsce: '\u2AB0̸',
        Nscr: '\uD835\uDCA9',
        nscr: '\uD835\uDCC3',
        nshortmid: '\u2224',
        nshortparallel: '\u2226',
        nsim: '\u2241',
        nsime: '\u2244',
        nsimeq: '\u2244',
        nsmid: '\u2224',
        nspar: '\u2226',
        nsqsube: '\u22E2',
        nsqsupe: '\u22E3',
        nsub: '\u2284',
        nsubE: '\u2AC5̸',
        nsube: '\u2288',
        nsubset: '\u2282⃒',
        nsubseteq: '\u2288',
        nsubseteqq: '\u2AC5̸',
        nsucc: '\u2281',
        nsucceq: '\u2AB0̸',
        nsup: '\u2285',
        nsupE: '\u2AC6̸',
        nsupe: '\u2289',
        nsupset: '\u2283⃒',
        nsupseteq: '\u2289',
        nsupseteqq: '\u2AC6̸',
        ntgl: '\u2279',
        Ntilde: 'Ñ',
        ntilde: 'ñ',
        ntlg: '\u2278',
        ntriangleleft: '\u22EA',
        ntrianglelefteq: '\u22EC',
        ntriangleright: '\u22EB',
        ntrianglerighteq: '\u22ED',
        Nu: 'Ν',
        nu: 'ν',
        num: '#',
        numero: '\u2116',
        numsp: '\u2007',
        nvap: '\u224D⃒',
        nVDash: '\u22AF',
        nVdash: '\u22AE',
        nvDash: '\u22AD',
        nvdash: '\u22AC',
        nvge: '\u2265⃒',
        nvgt: '>⃒',
        nvHarr: '\u2904',
        nvinfin: '\u29DE',
        nvlArr: '\u2902',
        nvle: '\u2264⃒',
        nvlt: '<⃒',
        nvltrie: '\u22B4⃒',
        nvrArr: '\u2903',
        nvrtrie: '\u22B5⃒',
        nvsim: '\u223C⃒',
        nwarhk: '\u2923',
        nwArr: '\u21D6',
        nwarr: '\u2196',
        nwarrow: '\u2196',
        nwnear: '\u2927',
        Oacute: 'Ó',
        oacute: 'ó',
        oast: '\u229B',
        ocir: '\u229A',
        Ocirc: 'Ô',
        ocirc: 'ô',
        Ocy: 'О',
        ocy: 'о',
        odash: '\u229D',
        Odblac: 'Ő',
        odblac: 'ő',
        odiv: '\u2A38',
        odot: '\u2299',
        odsold: '\u29BC',
        OElig: 'Œ',
        oelig: 'œ',
        ofcir: '\u29BF',
        Ofr: '\uD835\uDD12',
        ofr: '\uD835\uDD2C',
        ogon: '\u02DB',
        Ograve: 'Ò',
        ograve: 'ò',
        ogt: '\u29C1',
        ohbar: '\u29B5',
        ohm: 'Ω',
        oint: '\u222E',
        olarr: '\u21BA',
        olcir: '\u29BE',
        olcross: '\u29BB',
        oline: '\u203E',
        olt: '\u29C0',
        Omacr: 'Ō',
        omacr: 'ō',
        Omega: 'Ω',
        omega: 'ω',
        Omicron: 'Ο',
        omicron: 'ο',
        omid: '\u29B6',
        ominus: '\u2296',
        Oopf: '\uD835\uDD46',
        oopf: '\uD835\uDD60',
        opar: '\u29B7',
        OpenCurlyDoubleQuote: '\u201C',
        OpenCurlyQuote: '\u2018',
        operp: '\u29B9',
        oplus: '\u2295',
        Or: '\u2A54',
        or: '\u2228',
        orarr: '\u21BB',
        ord: '\u2A5D',
        order: 'ℴ',
        orderof: 'ℴ',
        ordf: 'ª',
        ordm: 'º',
        origof: '\u22B6',
        oror: '\u2A56',
        orslope: '\u2A57',
        orv: '\u2A5B',
        oS: '\u24C8',
        Oscr: '\uD835\uDCAA',
        oscr: 'ℴ',
        Oslash: 'Ø',
        oslash: 'ø',
        osol: '\u2298',
        Otilde: 'Õ',
        otilde: 'õ',
        Otimes: '\u2A37',
        otimes: '\u2297',
        otimesas: '\u2A36',
        Ouml: 'Ö',
        ouml: 'ö',
        ovbar: '\u233D',
        OverBar: '\u203E',
        OverBrace: '\u23DE',
        OverBracket: '\u23B4',
        OverParenthesis: '\u23DC',
        par: '\u2225',
        para: '\xB6',
        parallel: '\u2225',
        parsim: '\u2AF3',
        parsl: '\u2AFD',
        part: '\u2202',
        PartialD: '\u2202',
        Pcy: 'П',
        pcy: 'п',
        percnt: '%',
        period: '.',
        permil: '\u2030',
        perp: '\u22A5',
        pertenk: '\u2031',
        Pfr: '\uD835\uDD13',
        pfr: '\uD835\uDD2D',
        Phi: 'Φ',
        phi: 'φ',
        phiv: 'ϕ',
        phmmat: 'ℳ',
        phone: '\u260E',
        Pi: 'Π',
        pi: 'π',
        pitchfork: '\u22D4',
        piv: 'ϖ',
        planck: 'ℏ',
        planckh: 'ℎ',
        plankv: 'ℏ',
        plus: '+',
        plusacir: '\u2A23',
        plusb: '\u229E',
        pluscir: '\u2A22',
        plusdo: '\u2214',
        plusdu: '\u2A25',
        pluse: '\u2A72',
        PlusMinus: '\xB1',
        plusmn: '\xB1',
        plussim: '\u2A26',
        plustwo: '\u2A27',
        pm: '\xB1',
        Poincareplane: 'ℌ',
        pointint: '\u2A15',
        Popf: 'ℙ',
        popf: '\uD835\uDD61',
        pound: '\xA3',
        Pr: '\u2ABB',
        pr: '\u227A',
        prap: '\u2AB7',
        prcue: '\u227C',
        prE: '\u2AB3',
        pre: '\u2AAF',
        prec: '\u227A',
        precapprox: '\u2AB7',
        preccurlyeq: '\u227C',
        Precedes: '\u227A',
        PrecedesEqual: '\u2AAF',
        PrecedesSlantEqual: '\u227C',
        PrecedesTilde: '\u227E',
        preceq: '\u2AAF',
        precnapprox: '\u2AB9',
        precneqq: '\u2AB5',
        precnsim: '\u22E8',
        precsim: '\u227E',
        Prime: '\u2033',
        prime: '\u2032',
        primes: 'ℙ',
        prnap: '\u2AB9',
        prnE: '\u2AB5',
        prnsim: '\u22E8',
        prod: '\u220F',
        Product: '\u220F',
        profalar: '\u232E',
        profline: '\u2312',
        profsurf: '\u2313',
        prop: '\u221D',
        Proportion: '\u2237',
        Proportional: '\u221D',
        propto: '\u221D',
        prsim: '\u227E',
        prurel: '\u22B0',
        Pscr: '\uD835\uDCAB',
        pscr: '\uD835\uDCC5',
        Psi: 'Ψ',
        psi: 'ψ',
        puncsp: '\u2008',
        Qfr: '\uD835\uDD14',
        qfr: '\uD835\uDD2E',
        qint: '\u2A0C',
        Qopf: 'ℚ',
        qopf: '\uD835\uDD62',
        qprime: '\u2057',
        Qscr: '\uD835\uDCAC',
        qscr: '\uD835\uDCC6',
        quaternions: 'ℍ',
        quatint: '\u2A16',
        quest: '?',
        questeq: '\u225F',
        QUOT: '"',
        quot: '"',
        rAarr: '\u21DB',
        race: '\u223Ḏ',
        Racute: 'Ŕ',
        racute: 'ŕ',
        radic: '\u221A',
        raemptyv: '\u29B3',
        Rang: '\u27EB',
        rang: '\u27E9',
        rangd: '\u2992',
        range: '\u29A5',
        rangle: '\u27E9',
        raquo: '\xBB',
        Rarr: '\u21A0',
        rArr: '\u21D2',
        rarr: '\u2192',
        rarrap: '\u2975',
        rarrb: '\u21E5',
        rarrbfs: '\u2920',
        rarrc: '\u2933',
        rarrfs: '\u291E',
        rarrhk: '\u21AA',
        rarrlp: '\u21AC',
        rarrpl: '\u2945',
        rarrsim: '\u2974',
        Rarrtl: '\u2916',
        rarrtl: '\u21A3',
        rarrw: '\u219D',
        rAtail: '\u291C',
        ratail: '\u291A',
        ratio: '\u2236',
        rationals: 'ℚ',
        RBarr: '\u2910',
        rBarr: '\u290F',
        rbarr: '\u290D',
        rbbrk: '\u2773',
        rbrace: '}',
        rbrack: ']',
        rbrke: '\u298C',
        rbrksld: '\u298E',
        rbrkslu: '\u2990',
        Rcaron: 'Ř',
        rcaron: 'ř',
        Rcedil: 'Ŗ',
        rcedil: 'ŗ',
        rceil: '\u2309',
        rcub: '}',
        Rcy: 'Р',
        rcy: 'р',
        rdca: '\u2937',
        rdldhar: '\u2969',
        rdquo: '\u201D',
        rdquor: '\u201D',
        rdsh: '\u21B3',
        Re: 'ℜ',
        real: 'ℜ',
        realine: 'ℛ',
        realpart: 'ℜ',
        reals: 'ℝ',
        rect: '\u25AD',
        REG: '\xAE',
        reg: '\xAE',
        ReverseElement: '\u220B',
        ReverseEquilibrium: '\u21CB',
        ReverseUpEquilibrium: '\u296F',
        rfisht: '\u297D',
        rfloor: '\u230B',
        Rfr: 'ℜ',
        rfr: '\uD835\uDD2F',
        rHar: '\u2964',
        rhard: '\u21C1',
        rharu: '\u21C0',
        rharul: '\u296C',
        Rho: 'Ρ',
        rho: 'ρ',
        rhov: 'ϱ',
        RightAngleBracket: '\u27E9',
        RightArrow: '\u2192',
        Rightarrow: '\u21D2',
        rightarrow: '\u2192',
        RightArrowBar: '\u21E5',
        RightArrowLeftArrow: '\u21C4',
        rightarrowtail: '\u21A3',
        RightCeiling: '\u2309',
        RightDoubleBracket: '\u27E7',
        RightDownTeeVector: '\u295D',
        RightDownVector: '\u21C2',
        RightDownVectorBar: '\u2955',
        RightFloor: '\u230B',
        rightharpoondown: '\u21C1',
        rightharpoonup: '\u21C0',
        rightleftarrows: '\u21C4',
        rightleftharpoons: '\u21CC',
        rightrightarrows: '\u21C9',
        rightsquigarrow: '\u219D',
        RightTee: '\u22A2',
        RightTeeArrow: '\u21A6',
        RightTeeVector: '\u295B',
        rightthreetimes: '\u22CC',
        RightTriangle: '\u22B3',
        RightTriangleBar: '\u29D0',
        RightTriangleEqual: '\u22B5',
        RightUpDownVector: '\u294F',
        RightUpTeeVector: '\u295C',
        RightUpVector: '\u21BE',
        RightUpVectorBar: '\u2954',
        RightVector: '\u21C0',
        RightVectorBar: '\u2953',
        ring: '\u02DA',
        risingdotseq: '\u2253',
        rlarr: '\u21C4',
        rlhar: '\u21CC',
        rlm: '\u200F',
        rmoust: '\u23B1',
        rmoustache: '\u23B1',
        rnmid: '\u2AEE',
        roang: '\u27ED',
        roarr: '\u21FE',
        robrk: '\u27E7',
        ropar: '\u2986',
        Ropf: 'ℝ',
        ropf: '\uD835\uDD63',
        roplus: '\u2A2E',
        rotimes: '\u2A35',
        RoundImplies: '\u2970',
        rpar: ')',
        rpargt: '\u2994',
        rppolint: '\u2A12',
        rrarr: '\u21C9',
        Rrightarrow: '\u21DB',
        rsaquo: '\u203A',
        Rscr: 'ℛ',
        rscr: '\uD835\uDCC7',
        Rsh: '\u21B1',
        rsh: '\u21B1',
        rsqb: ']',
        rsquo: '\u2019',
        rsquor: '\u2019',
        rthree: '\u22CC',
        rtimes: '\u22CA',
        rtri: '\u25B9',
        rtrie: '\u22B5',
        rtrif: '\u25B8',
        rtriltri: '\u29CE',
        RuleDelayed: '\u29F4',
        ruluhar: '\u2968',
        rx: '\u211E',
        Sacute: 'Ś',
        sacute: 'ś',
        sbquo: '\u201A',
        Sc: '\u2ABC',
        sc: '\u227B',
        scap: '\u2AB8',
        Scaron: 'Š',
        scaron: 'š',
        sccue: '\u227D',
        scE: '\u2AB4',
        sce: '\u2AB0',
        Scedil: 'Ş',
        scedil: 'ş',
        Scirc: 'Ŝ',
        scirc: 'ŝ',
        scnap: '\u2ABA',
        scnE: '\u2AB6',
        scnsim: '\u22E9',
        scpolint: '\u2A13',
        scsim: '\u227F',
        Scy: 'С',
        scy: 'с',
        sdot: '\u22C5',
        sdotb: '\u22A1',
        sdote: '\u2A66',
        searhk: '\u2925',
        seArr: '\u21D8',
        searr: '\u2198',
        searrow: '\u2198',
        sect: '\xA7',
        semi: ';',
        seswar: '\u2929',
        setminus: '\u2216',
        setmn: '\u2216',
        sext: '\u2736',
        Sfr: '\uD835\uDD16',
        sfr: '\uD835\uDD30',
        sfrown: '\u2322',
        sharp: '\u266F',
        SHCHcy: 'Щ',
        shchcy: 'щ',
        SHcy: 'Ш',
        shcy: 'ш',
        ShortDownArrow: '\u2193',
        ShortLeftArrow: '\u2190',
        shortmid: '\u2223',
        shortparallel: '\u2225',
        ShortRightArrow: '\u2192',
        ShortUpArrow: '\u2191',
        shy: '\xAD',
        Sigma: 'Σ',
        sigma: 'σ',
        sigmaf: 'ς',
        sigmav: 'ς',
        sim: '\u223C',
        simdot: '\u2A6A',
        sime: '\u2243',
        simeq: '\u2243',
        simg: '\u2A9E',
        simgE: '\u2AA0',
        siml: '\u2A9D',
        simlE: '\u2A9F',
        simne: '\u2246',
        simplus: '\u2A24',
        simrarr: '\u2972',
        slarr: '\u2190',
        SmallCircle: '\u2218',
        smallsetminus: '\u2216',
        smashp: '\u2A33',
        smeparsl: '\u29E4',
        smid: '\u2223',
        smile: '\u2323',
        smt: '\u2AAA',
        smte: '\u2AAC',
        smtes: '\u2AAC︀',
        SOFTcy: 'Ь',
        softcy: 'ь',
        sol: '/',
        solb: '\u29C4',
        solbar: '\u233F',
        Sopf: '\uD835\uDD4A',
        sopf: '\uD835\uDD64',
        spades: '\u2660',
        spadesuit: '\u2660',
        spar: '\u2225',
        sqcap: '\u2293',
        sqcaps: '\u2293︀',
        sqcup: '\u2294',
        sqcups: '\u2294︀',
        Sqrt: '\u221A',
        sqsub: '\u228F',
        sqsube: '\u2291',
        sqsubset: '\u228F',
        sqsubseteq: '\u2291',
        sqsup: '\u2290',
        sqsupe: '\u2292',
        sqsupset: '\u2290',
        sqsupseteq: '\u2292',
        squ: '\u25A1',
        Square: '\u25A1',
        square: '\u25A1',
        SquareIntersection: '\u2293',
        SquareSubset: '\u228F',
        SquareSubsetEqual: '\u2291',
        SquareSuperset: '\u2290',
        SquareSupersetEqual: '\u2292',
        SquareUnion: '\u2294',
        squarf: '\u25AA',
        squf: '\u25AA',
        srarr: '\u2192',
        Sscr: '\uD835\uDCAE',
        sscr: '\uD835\uDCC8',
        ssetmn: '\u2216',
        ssmile: '\u2323',
        sstarf: '\u22C6',
        Star: '\u22C6',
        star: '\u2606',
        starf: '\u2605',
        straightepsilon: 'ϵ',
        straightphi: 'ϕ',
        strns: '\xAF',
        Sub: '\u22D0',
        sub: '\u2282',
        subdot: '\u2ABD',
        subE: '\u2AC5',
        sube: '\u2286',
        subedot: '\u2AC3',
        submult: '\u2AC1',
        subnE: '\u2ACB',
        subne: '\u228A',
        subplus: '\u2ABF',
        subrarr: '\u2979',
        Subset: '\u22D0',
        subset: '\u2282',
        subseteq: '\u2286',
        subseteqq: '\u2AC5',
        SubsetEqual: '\u2286',
        subsetneq: '\u228A',
        subsetneqq: '\u2ACB',
        subsim: '\u2AC7',
        subsub: '\u2AD5',
        subsup: '\u2AD3',
        succ: '\u227B',
        succapprox: '\u2AB8',
        succcurlyeq: '\u227D',
        Succeeds: '\u227B',
        SucceedsEqual: '\u2AB0',
        SucceedsSlantEqual: '\u227D',
        SucceedsTilde: '\u227F',
        succeq: '\u2AB0',
        succnapprox: '\u2ABA',
        succneqq: '\u2AB6',
        succnsim: '\u22E9',
        succsim: '\u227F',
        SuchThat: '\u220B',
        Sum: '\u2211',
        sum: '\u2211',
        sung: '\u266A',
        Sup: '\u22D1',
        sup: '\u2283',
        sup1: '\xB9',
        sup2: '\xB2',
        sup3: '\xB3',
        supdot: '\u2ABE',
        supdsub: '\u2AD8',
        supE: '\u2AC6',
        supe: '\u2287',
        supedot: '\u2AC4',
        Superset: '\u2283',
        SupersetEqual: '\u2287',
        suphsol: '\u27C9',
        suphsub: '\u2AD7',
        suplarr: '\u297B',
        supmult: '\u2AC2',
        supnE: '\u2ACC',
        supne: '\u228B',
        supplus: '\u2AC0',
        Supset: '\u22D1',
        supset: '\u2283',
        supseteq: '\u2287',
        supseteqq: '\u2AC6',
        supsetneq: '\u228B',
        supsetneqq: '\u2ACC',
        supsim: '\u2AC8',
        supsub: '\u2AD4',
        supsup: '\u2AD6',
        swarhk: '\u2926',
        swArr: '\u21D9',
        swarr: '\u2199',
        swarrow: '\u2199',
        swnwar: '\u292A',
        szlig: 'ß',
        Tab: '\t',
        target: '\u2316',
        Tau: 'Τ',
        tau: 'τ',
        tbrk: '\u23B4',
        Tcaron: 'Ť',
        tcaron: 'ť',
        Tcedil: 'Ţ',
        tcedil: 'ţ',
        Tcy: 'Т',
        tcy: 'т',
        tdot: '⃛',
        telrec: '\u2315',
        Tfr: '\uD835\uDD17',
        tfr: '\uD835\uDD31',
        there4: '\u2234',
        Therefore: '\u2234',
        therefore: '\u2234',
        Theta: 'Θ',
        theta: 'θ',
        thetasym: 'ϑ',
        thetav: 'ϑ',
        thickapprox: '\u2248',
        thicksim: '\u223C',
        ThickSpace: '\u205F\u200A',
        thinsp: '\u2009',
        ThinSpace: '\u2009',
        thkap: '\u2248',
        thksim: '\u223C',
        THORN: 'Þ',
        thorn: 'þ',
        Tilde: '\u223C',
        tilde: '\u02DC',
        TildeEqual: '\u2243',
        TildeFullEqual: '\u2245',
        TildeTilde: '\u2248',
        times: '\xD7',
        timesb: '\u22A0',
        timesbar: '\u2A31',
        timesd: '\u2A30',
        tint: '\u222D',
        toea: '\u2928',
        top: '\u22A4',
        topbot: '\u2336',
        topcir: '\u2AF1',
        Topf: '\uD835\uDD4B',
        topf: '\uD835\uDD65',
        topfork: '\u2ADA',
        tosa: '\u2929',
        tprime: '\u2034',
        TRADE: '\u2122',
        trade: '\u2122',
        triangle: '\u25B5',
        triangledown: '\u25BF',
        triangleleft: '\u25C3',
        trianglelefteq: '\u22B4',
        triangleq: '\u225C',
        triangleright: '\u25B9',
        trianglerighteq: '\u22B5',
        tridot: '\u25EC',
        trie: '\u225C',
        triminus: '\u2A3A',
        TripleDot: '⃛',
        triplus: '\u2A39',
        trisb: '\u29CD',
        tritime: '\u2A3B',
        trpezium: '\u23E2',
        Tscr: '\uD835\uDCAF',
        tscr: '\uD835\uDCC9',
        TScy: 'Ц',
        tscy: 'ц',
        TSHcy: 'Ћ',
        tshcy: 'ћ',
        Tstrok: 'Ŧ',
        tstrok: 'ŧ',
        twixt: '\u226C',
        twoheadleftarrow: '\u219E',
        twoheadrightarrow: '\u21A0',
        Uacute: 'Ú',
        uacute: 'ú',
        Uarr: '\u219F',
        uArr: '\u21D1',
        uarr: '\u2191',
        Uarrocir: '\u2949',
        Ubrcy: 'Ў',
        ubrcy: 'ў',
        Ubreve: 'Ŭ',
        ubreve: 'ŭ',
        Ucirc: 'Û',
        ucirc: 'û',
        Ucy: 'У',
        ucy: 'у',
        udarr: '\u21C5',
        Udblac: 'Ű',
        udblac: 'ű',
        udhar: '\u296E',
        ufisht: '\u297E',
        Ufr: '\uD835\uDD18',
        ufr: '\uD835\uDD32',
        Ugrave: 'Ù',
        ugrave: 'ù',
        uHar: '\u2963',
        uharl: '\u21BF',
        uharr: '\u21BE',
        uhblk: '\u2580',
        ulcorn: '\u231C',
        ulcorner: '\u231C',
        ulcrop: '\u230F',
        ultri: '\u25F8',
        Umacr: 'Ū',
        umacr: 'ū',
        uml: '\xA8',
        UnderBar: '_',
        UnderBrace: '\u23DF',
        UnderBracket: '\u23B5',
        UnderParenthesis: '\u23DD',
        Union: '\u22C3',
        UnionPlus: '\u228E',
        Uogon: 'Ų',
        uogon: 'ų',
        Uopf: '\uD835\uDD4C',
        uopf: '\uD835\uDD66',
        UpArrow: '\u2191',
        Uparrow: '\u21D1',
        uparrow: '\u2191',
        UpArrowBar: '\u2912',
        UpArrowDownArrow: '\u21C5',
        UpDownArrow: '\u2195',
        Updownarrow: '\u21D5',
        updownarrow: '\u2195',
        UpEquilibrium: '\u296E',
        upharpoonleft: '\u21BF',
        upharpoonright: '\u21BE',
        uplus: '\u228E',
        UpperLeftArrow: '\u2196',
        UpperRightArrow: '\u2197',
        Upsi: 'ϒ',
        upsi: 'υ',
        upsih: 'ϒ',
        Upsilon: 'Υ',
        upsilon: 'υ',
        UpTee: '\u22A5',
        UpTeeArrow: '\u21A5',
        upuparrows: '\u21C8',
        urcorn: '\u231D',
        urcorner: '\u231D',
        urcrop: '\u230E',
        Uring: 'Ů',
        uring: 'ů',
        urtri: '\u25F9',
        Uscr: '\uD835\uDCB0',
        uscr: '\uD835\uDCCA',
        utdot: '\u22F0',
        Utilde: 'Ũ',
        utilde: 'ũ',
        utri: '\u25B5',
        utrif: '\u25B4',
        uuarr: '\u21C8',
        Uuml: 'Ü',
        uuml: 'ü',
        uwangle: '\u29A7',
        vangrt: '\u299C',
        varepsilon: 'ϵ',
        varkappa: 'ϰ',
        varnothing: '\u2205',
        varphi: 'ϕ',
        varpi: 'ϖ',
        varpropto: '\u221D',
        vArr: '\u21D5',
        varr: '\u2195',
        varrho: 'ϱ',
        varsigma: 'ς',
        varsubsetneq: '\u228A︀',
        varsubsetneqq: '\u2ACB︀',
        varsupsetneq: '\u228B︀',
        varsupsetneqq: '\u2ACC︀',
        vartheta: 'ϑ',
        vartriangleleft: '\u22B2',
        vartriangleright: '\u22B3',
        Vbar: '\u2AEB',
        vBar: '\u2AE8',
        vBarv: '\u2AE9',
        Vcy: 'В',
        vcy: 'в',
        VDash: '\u22AB',
        Vdash: '\u22A9',
        vDash: '\u22A8',
        vdash: '\u22A2',
        Vdashl: '\u2AE6',
        Vee: '\u22C1',
        vee: '\u2228',
        veebar: '\u22BB',
        veeeq: '\u225A',
        vellip: '\u22EE',
        Verbar: '\u2016',
        verbar: '|',
        Vert: '\u2016',
        vert: '|',
        VerticalBar: '\u2223',
        VerticalLine: '|',
        VerticalSeparator: '\u2758',
        VerticalTilde: '\u2240',
        VeryThinSpace: '\u200A',
        Vfr: '\uD835\uDD19',
        vfr: '\uD835\uDD33',
        vltri: '\u22B2',
        vnsub: '\u2282⃒',
        vnsup: '\u2283⃒',
        Vopf: '\uD835\uDD4D',
        vopf: '\uD835\uDD67',
        vprop: '\u221D',
        vrtri: '\u22B3',
        Vscr: '\uD835\uDCB1',
        vscr: '\uD835\uDCCB',
        vsubnE: '\u2ACB︀',
        vsubne: '\u228A︀',
        vsupnE: '\u2ACC︀',
        vsupne: '\u228B︀',
        Vvdash: '\u22AA',
        vzigzag: '\u299A',
        Wcirc: 'Ŵ',
        wcirc: 'ŵ',
        wedbar: '\u2A5F',
        Wedge: '\u22C0',
        wedge: '\u2227',
        wedgeq: '\u2259',
        weierp: '\u2118',
        Wfr: '\uD835\uDD1A',
        wfr: '\uD835\uDD34',
        Wopf: '\uD835\uDD4E',
        wopf: '\uD835\uDD68',
        wp: '\u2118',
        wr: '\u2240',
        wreath: '\u2240',
        Wscr: '\uD835\uDCB2',
        wscr: '\uD835\uDCCC',
        xcap: '\u22C2',
        xcirc: '\u25EF',
        xcup: '\u22C3',
        xdtri: '\u25BD',
        Xfr: '\uD835\uDD1B',
        xfr: '\uD835\uDD35',
        xhArr: '\u27FA',
        xharr: '\u27F7',
        Xi: 'Ξ',
        xi: 'ξ',
        xlArr: '\u27F8',
        xlarr: '\u27F5',
        xmap: '\u27FC',
        xnis: '\u22FB',
        xodot: '\u2A00',
        Xopf: '\uD835\uDD4F',
        xopf: '\uD835\uDD69',
        xoplus: '\u2A01',
        xotime: '\u2A02',
        xrArr: '\u27F9',
        xrarr: '\u27F6',
        Xscr: '\uD835\uDCB3',
        xscr: '\uD835\uDCCD',
        xsqcup: '\u2A06',
        xuplus: '\u2A04',
        xutri: '\u25B3',
        xvee: '\u22C1',
        xwedge: '\u22C0',
        Yacute: 'Ý',
        yacute: 'ý',
        YAcy: 'Я',
        yacy: 'я',
        Ycirc: 'Ŷ',
        ycirc: 'ŷ',
        Ycy: 'Ы',
        ycy: 'ы',
        yen: '\xA5',
        Yfr: '\uD835\uDD1C',
        yfr: '\uD835\uDD36',
        YIcy: 'Ї',
        yicy: 'ї',
        Yopf: '\uD835\uDD50',
        yopf: '\uD835\uDD6A',
        Yscr: '\uD835\uDCB4',
        yscr: '\uD835\uDCCE',
        YUcy: 'Ю',
        yucy: 'ю',
        Yuml: 'Ÿ',
        yuml: 'ÿ',
        Zacute: 'Ź',
        zacute: 'ź',
        Zcaron: 'Ž',
        zcaron: 'ž',
        Zcy: 'З',
        zcy: 'з',
        Zdot: 'Ż',
        zdot: 'ż',
        zeetrf: 'ℨ',
        ZeroWidthSpace: '\u200B',
        Zeta: 'Ζ',
        zeta: 'ζ',
        Zfr: 'ℨ',
        zfr: '\uD835\uDD37',
        ZHcy: 'Ж',
        zhcy: 'ж',
        zigrarr: '\u21DD',
        Zopf: 'ℤ',
        zopf: '\uD835\uDD6B',
        Zscr: '\uD835\uDCB5',
        zscr: '\uD835\uDCCF',
        zwj: '‍',
        zwnj: '‌'
    };
});
/*simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize*/
define('simple-html-tokenizer@0.2.6#lib/simple-html-tokenizer/tokenize', [
    'exports',
    './tokenizer',
    './entity-parser',
    './html5-named-char-refs'
], function (exports, _tokenizer, _entityParser, _html5NamedCharRefs) {
    'use strict';
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.default = tokenize;
    var _tokenizer2 = _interopRequireDefault(_tokenizer);
    var _entityParser2 = _interopRequireDefault(_entityParser);
    var _html5NamedCharRefs2 = _interopRequireDefault(_html5NamedCharRefs);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    function tokenize(input, options) {
        var tokenizer = new _tokenizer2.default(new _entityParser2.default(_html5NamedCharRefs2.default), options);
        return tokenizer.tokenize(input);
    }
});
/*can-simple-dom@1.4.2#lib/default-tokenize*/
define('can-simple-dom@1.4.2#lib/default-tokenize', [
    'require',
    'exports',
    'module',
    'simple-html-tokenizer/lib/simple-html-tokenizer/tokenize'
], function (require, exports, module) {
    var tokenize = require('simple-html-tokenizer/lib/simple-html-tokenizer/tokenize').default;
    module.exports = function (input) {
        return tokenize(input);
    };
});
/*can-simple-dom@1.4.2#test/element-sp-test*/
define('can-simple-dom@1.4.2#test/element-sp-test', [
    'require',
    'exports',
    'module',
    '../can-simple-dom',
    'steal-qunit',
    '../lib/html-parser',
    '../lib/void-map',
    '../lib/html-serializer',
    '../lib/default-tokenize'
], function (require, exports, module) {
    var Document = require('../can-simple-dom');
    var QUnit = require('steal-qunit');
    var Parser = require('../lib/html-parser');
    var voidMap = require('../lib/void-map');
    var Serializer = require('../lib/html-serializer');
    var tokenize = require('../lib/default-tokenize');
    QUnit.module('can-simple-dom - Element with serialization and parsing');
    QUnit.test('document.implementation is supported (#23)', function () {
        var document = new Document();
        document.__addSerializerAndParser(new Serializer(voidMap), new Parser(tokenize, document, voidMap));
        ok(document.implementation, 'implementation exists');
        var doc2 = document.implementation.createHTMLDocument('');
        ok(doc2.body, 'has a body');
    });
    QUnit.test('innerHTML supported', function () {
        var document = new Document();
        document.__addSerializerAndParser(new Serializer(voidMap), new Parser(tokenize, document, voidMap));
        document.body.innerHTML = '<span class=\'bar\'>HI</span>';
        QUnit.equal(document.body.firstChild.nodeName, 'SPAN');
        QUnit.equal(document.body.firstChild.className, 'bar');
        QUnit.equal(document.body.firstChild.firstChild.nodeValue, 'HI');
        QUnit.equal(document.body.innerHTML, '<span class="bar">HI</span>');
    });
    QUnit.test('outerHTML supported', function () {
        var document = new Document();
        document.__addSerializerAndParser(new Serializer(voidMap), new Parser(tokenize, document, voidMap));
        document.body.innerHTML = '<span/><div id=\'item\'>HI</div><span/>';
        var item = document.getElementById('item');
        QUnit.equal(item.outerHTML, '<div id="item">HI</div>', 'getter');
        item.outerHTML = '<label>IT</label>';
        QUnit.equal(document.body.innerHTML, '<span></span><label>IT</label><span></span>', 'setter');
    });
});
/*can-simple-dom@1.4.2#test/element-event-test*/
define('can-simple-dom@1.4.2#test/element-event-test', [
    'require',
    'exports',
    'module',
    '../lib/document',
    '../lib/html-serializer',
    '../lib/void-map',
    './support',
    'steal-qunit'
], function (require, exports, module) {
    var Document = require('../lib/document');
    var Serializer = require('../lib/html-serializer');
    var voidMap = require('../lib/void-map');
    var _support = require('./support');
    var element = _support.element;
    var fragment = _support.fragment;
    var text = _support.text;
    var QUnit = require('steal-qunit');
    QUnit.module('can-simple-dom - Event');
    QUnit.test('basic bubbling', 4, function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('stop propagation', 2, function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document, 'document current target');
        });
        document.documentElement.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.documentElement, 'documentElement current target');
        });
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('initEvent without bubbling', 2, function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        document.body.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, document.body, 'body current target');
            event.stopPropagation();
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        elem.addEventListener('foo', function (event) {
            assert.strictEqual(event.currentTarget, elem, 'elem current target');
        });
        document.body.appendChild(elem);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', false, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('this inside event handler', function (assert) {
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        elem.addEventListener('foo', function () {
            assert.equal(this, elem, 'this is the element');
        });
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
    QUnit.test('deduplicate event handlers', function (assert) {
        var done = assert.async();
        var document = new Document();
        var elem = document.createElement('div');
        document.body.appendChild(elem);
        var handler = function () {
            assert.ok(true, 'event dispatched');
            done();
        };
        elem.addEventListener('foo', handler);
        elem.addEventListener('foo', handler);
        var ev = document.createEvent('HTMLEvents');
        ev.initEvent('foo', true, false);
        elem.dispatchEvent(ev);
    });
});
/*can-simple-dom@1.4.2#test/parser-test*/
define('can-simple-dom@1.4.2#test/parser-test', [
    'require',
    'exports',
    'module',
    './support',
    '../lib/html-parser',
    '../lib/void-map',
    '../lib/default-tokenize',
    'steal-qunit'
], function (require, exports, module) {
    var _support = require('./support');
    var document = _support.document;
    var Parser = require('../lib/html-parser');
    var voidMap = require('../lib/void-map');
    var tokenize = require('../lib/default-tokenize');
    var QUnit = require('steal-qunit');
    QUnit.module('can-simple-dom - Basic HTML parsing', {
        beforeEach: function () {
            this.parser = new Parser(tokenize, document, voidMap);
        }
    });
    QUnit.test('simple parse', function (assert) {
        var fragment = this.parser.parse('<div>Hello</div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName.toLowerCase(), 'div');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
    });
    QUnit.test('nested parse', function (assert) {
        var fragment = this.parser.parse('text before<div>Hello</div>text between<div id=foo title="Hello World">World</div>text after');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text before');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text between');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var expectedValues = {
            id: 'foo',
            title: 'Hello World'
        };
        assert.equal(node.attributes.length, 2);
        assert.equal(node.attributes[0].value, expectedValues[node.attributes[0].name]);
        assert.equal(node.attributes[1].value, expectedValues[node.attributes[1].name]);
        assert.equal(node.attributes.length, 2);
        assert.ok(node.firstChild);
        assert.equal(node.firstChild.nodeType, 3);
        assert.equal(node.firstChild.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'text after');
    });
    QUnit.test('void tags', function (assert) {
        var fragment = this.parser.parse('<div>Hello<br>World<img src="http://example.com/image.png?foo=bar&bar=foo"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        node = node.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'Hello');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'BR');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 3);
        assert.equal(node.nodeValue, 'World');
        node = node.nextSibling;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'IMG');
        assert.equal(node.getAttribute('src'), 'http://example.com/image.png?foo=bar&bar=foo');
        assert.equal(node.nextSibling, null);
    });
    QUnit.test('node attribute charater encode', function (assert) {
        var fragment = this.parser.parse('<div title="&nbsp;foo & bar &amp; baz < buz > biz"></div>');
        assert.ok(fragment);
        var node = fragment.firstChild;
        assert.ok(node);
        assert.equal(node.nodeType, 1);
        assert.equal(node.nodeName, 'DIV');
        var attibutes = node.attributes;
        assert.ok(attibutes.length);
        var title = attibutes[0];
        assert.equal(title.name, 'title');
        assert.equal(title.value, '&#xA0;foo &#x26; bar &#x26; baz &#x3C; buz &#x3E; biz');
    });
});
/*can-simple-dom@1.4.2#test/style-test*/
define('can-simple-dom@1.4.2#test/style-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../lib/document/style'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var CSSStyleDeclaration = require('../lib/document/style');
    QUnit.module('can-simple-dom - CSStyleDeclaration');
    QUnit.test('cssText is enumerable', function () {
        var proto = CSSStyleDeclaration.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        QUnit.equal(descriptor.enumerable, true, 'it is enumerable');
    });
    QUnit.test('cssText is configurable', function () {
        var proto = CSSStyleDeclaration.prototype;
        var descriptor = Object.getOwnPropertyDescriptor(proto, 'cssText');
        QUnit.equal(descriptor.configurable, true, 'it is configurable');
    });
    QUnit.test('getPropertyValue must be a function', function () {
        var proto = CSSStyleDeclaration.prototype;
        QUnit.equal(typeof proto.getPropertyValue, 'function', 'it is a function');
    });
});
/*can-simple-dom@1.4.2#test/test*/
define('can-simple-dom@1.4.2#test/test', [
    'require',
    'exports',
    'module',
    './document-test',
    './element-test',
    './serializer-test',
    './element-sp-test',
    './element-event-test',
    './parser-test',
    './style-test'
], function (require, exports, module) {
    require('./document-test');
    require('./element-test');
    require('./serializer-test');
    require('./element-sp-test');
    require('./element-event-test');
    require('./parser-test');
    require('./style-test');
});
/*can-simple-observable@1.0.2#can-simple-observable-test*/
define('can-simple-observable@1.0.2#can-simple-observable-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-simple-observable',
    'can-reflect'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var observable = require('can-simple-observable');
    var canReflect = require('can-reflect');
    QUnit.module('can-simple-observable');
    QUnit.test('basics', function () {
        expect(4);
        var obs = observable('one');
        QUnit.equal(canReflect.getValue(obs), 'one', 'getValue');
        canReflect.setValue(obs, 'two');
        QUnit.equal(canReflect.getValue(obs), 'two', 'setValue');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'three', 'onValue');
        };
        canReflect.onValue(obs, handler);
        canReflect.setValue(obs, 'three');
        canReflect.offValue(obs, handler);
        canReflect.setValue(obs, 'four');
        QUnit.equal(canReflect.getValue(obs), 'four', 'getValue after offValue');
    });
});
/*can-symbol@1.6.1#can-symbol-test*/
define('can-symbol@1.6.1#can-symbol-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    QUnit.module('can-symbol');
    QUnit.test('for and keyFor', function () {
        var symbol = canSymbol.for('abc');
        QUnit.ok(canSymbol.for('abc') === canSymbol.for('abc'));
        QUnit.equal(canSymbol.keyFor(symbol), 'abc', 'key for');
    });
    QUnit.test('can get/set symbols', function () {
        var obj = {};
        var symbol1 = canSymbol('prop1'), symbol2 = canSymbol('prop2');
        obj[symbol1] = 'VALUE';
        QUnit.equal(obj[symbol1], 'VALUE', 'got value');
        Object.defineProperty(obj, symbol2, { value: 'DP-VALUE' });
        QUnit.equal(obj[symbol2], 'DP-VALUE', 'got define property value');
    });
});
/*can-reflect@1.17.5#reflections/get-name/get-name-test*/
define('can-reflect@1.17.5#reflections/get-name/get-name-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './get-name'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var reflexions = require('./get-name');
    var supportsFunctionName = function name() {
    }.name === 'name';
    QUnit.module('can-reflect: getName');
    QUnit.test('it works with strings', function (assert) {
        var f = function () {
        };
        reflexions.setName(f, 'Christopher');
        assert.equal(reflexions.getName(f), 'Christopher');
    });
    QUnit.test('it works with functions', function (assert) {
        var f = function () {
        };
        reflexions.setName(f, function () {
            return 'Christopher';
        });
        assert.equal(reflexions.getName(f), 'Christopher');
    });
    if (supportsFunctionName) {
        QUnit.test('returns function name by default', function (assert) {
            assert.equal(reflexions.getName(function foo() {
            }), 'foo', 'should return function name');
        });
        QUnit.test('returns empty string for anonymous functions', function (assert) {
            assert.equal(reflexions.getName(function () {
            }), '', 'should return empty string');
        });
        QUnit.test('returns constructor name by default', function (assert) {
            assert.equal(reflexions.getName({}), 'Object{}', 'should return constructor name');
        });
    }
    QUnit.test('handles list-likes', function (assert) {
        function ListThing(id) {
            this.id = id;
        }
        ListThing.prototype[canSymbol.for('can.isMoreListLikeThanMapLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new ListThing()), 'ListThing[]', 'should use can.getName symbol behavior');
        }
        reflexions.setName(ListThing, 'ListThing');
        assert.equal(reflexions.getName(new ListThing()), 'ListThing[]', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles map-likes', function (assert) {
        function MapThing(id) {
            this.id = id;
        }
        MapThing.prototype[canSymbol.for('can.isMapLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new MapThing()), 'MapThing{}', 'should use can.getName symbol behavior');
        }
        reflexions.setName(MapThing, 'MapThing');
        assert.equal(reflexions.getName(new MapThing()), 'MapThing{}', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles value-likes', function (assert) {
        function ValueThing(id) {
            this.id = id;
        }
        ValueThing.prototype[canSymbol.for('can.isValueLike')] = true;
        if (supportsFunctionName) {
            assert.equal(reflexions.getName(new ValueThing()), 'ValueThing<>', 'should use can.getName symbol behavior');
        }
        reflexions.setName(ValueThing, 'ValueThing');
        assert.equal(reflexions.getName(new ValueThing()), 'ValueThing<>', 'should use can.getName symbol behavior');
    });
    QUnit.test('handles null, undefined, etc', function (assert) {
        assert.equal(reflexions.getName(null), 'null');
        assert.equal(reflexions.getName(undefined), 'undefined');
        assert.equal(reflexions.getName(NaN), 'NaN');
        assert.equal(reflexions.getName(0), '0');
    });
});
/*can-reflect@1.17.5#can-reflect-test_helpers*/
define('can-reflect@1.17.5#can-reflect-test_helpers', [
    'require',
    'exports',
    'module',
    'can-symbol'
], function (require, exports, module) {
    var canSymbol = require('can-symbol');
    var mapSupported = function () {
        if (typeof Map !== 'undefined' && typeof Map.prototype.keys === 'function') {
            var myMap = new Map();
            return myMap.toString() === '[object Map]';
        }
        return false;
    }();
    var setSupported = function () {
        if (typeof Set !== 'undefined') {
            var mySet = new Set();
            return mySet.toString() === '[object Set]' && canSymbol.iterator in mySet;
        }
        return false;
    }();
    var helpers = {
        mapSupported: mapSupported,
        setSupported: setSupported
    };
    module.exports = helpers;
});
/*can-reflect@1.17.5#reflections/type/type-test*/
define('can-reflect@1.17.5#reflections/type/type-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './type',
    '../get-set/get-set',
    '../../can-reflect-test_helpers'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var typeReflections = require('./type');
    var getSetReflections = require('../get-set/get-set');
    var testHelpers = require('../../can-reflect-test_helpers');
    QUnit.module('can-reflect: type reflections');
    QUnit.test('isConstructorLike', function () {
        var Constructor = function () {
        };
        Constructor.prototype.method = function () {
        };
        ok(typeReflections.isConstructorLike(Constructor));
        ok(!typeReflections.isConstructorLike(Constructor.prototype.method));
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), function () {
        });
        ok(typeReflections.isConstructorLike(obj));
        ok(!typeReflections.isConstructorLike({}));
    });
    QUnit.test('isFunctionLike', function () {
        ok(!typeReflections.isFunctionLike({}), 'object is not function like');
        ok(typeReflections.isFunctionLike(function () {
        }), 'function is function like');
        var nonFunctionFunction = function () {
        };
        getSetReflections.setKeyValue(nonFunctionFunction, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(nonFunctionFunction), 'function with can.isFunctionLike set to false is not function like');
        var obj = {};
        var func = function () {
        };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.new'), func);
        getSetReflections.setKeyValue(obj, canSymbol.for('can.apply'), func);
        ok(typeReflections.isFunctionLike(obj), 'object with can.new and can.apply symbols is function like');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.isFunctionLike'), false);
        ok(!typeReflections.isFunctionLike(obj), 'object with can.new, can.apply, and can.isFunctionLike set to false is not function like');
        equal(typeReflections.isFunctionLike(null), false, 'null is not a function');
        equal(typeReflections.isFunctionLike(undefined), false, 'undefined is not a function');
    });
    QUnit.test('isIteratorLike', function () {
        ok(!typeReflections.isIteratorLike({}));
        ok(typeReflections.isIteratorLike({
            next: function () {
            }
        }));
    });
    QUnit.test('isListLike', function () {
        ok(typeReflections.isListLike({
            0: 1,
            length: 1
        }));
        ok(typeReflections.isListLike('yes'), 'string');
        ok(typeReflections.isListLike({ length: 0 }), 'object with 0 length');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), false);
        ok(!typeReflections.isListLike(symboled), '!@@can.isListLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isListLike'), true);
        ok(typeReflections.isListLike(symboled), '@@can.isListLike');
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            ok(typeReflections.isListLike(ul.childNodes), 'nodeList');
        }
        if (testHelpers.setSupported) {
            ok(typeReflections.isListLike(new Set()), 'Set');
        }
    });
    QUnit.test('isMapLike', function () {
        ok(typeReflections.isMapLike({}), 'Object');
        ok(typeReflections.isMapLike([]), 'Array');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), false);
        ok(!typeReflections.isMapLike(symboled), '!@@can.isMapLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isMapLike'), true);
        ok(typeReflections.isMapLike(symboled), '@@can.isMapLike');
        ok(!typeReflections.isMapLike('String'), 'String');
    });
    QUnit.test('isMoreListLikeThanMapLike', function () {
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike({}), false, 'Object');
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike([]), true, 'Array');
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike(null), false, 'null');
        QUnit.equal(typeReflections.isMoreListLikeThanMapLike(undefined), false, 'undefined');
    });
    QUnit.test('isObservableLike', function () {
        ok(typeReflections.isObservableLike({}) === false, 'Object');
        ok(typeReflections.isObservableLike([]) === false, 'Array');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function () {
        });
        ok(typeReflections.isObservableLike(obj), 'Object');
    });
    QUnit.test('isPrimitive', function () {
        ok(!typeReflections.isPrimitive({}), 'Object');
        ok(typeReflections.isPrimitive(null), 'null');
        ok(typeReflections.isPrimitive(1), '1');
    });
    QUnit.test('isBuiltIn', function () {
        ok(typeReflections.isBuiltIn(1), 'Primitive');
        ok(typeReflections.isBuiltIn({}), 'Object');
        ok(typeReflections.isBuiltIn([]), 'Array');
        ok(typeReflections.isBuiltIn(function () {
        }), 'Function');
        ok(typeReflections.isBuiltIn(new Date()), 'Date');
        ok(typeReflections.isBuiltIn(/[foo].[bar]/), 'RegEx');
        if (document) {
            ok(typeReflections.isBuiltIn(document.createElement('div')), 'Elements');
        }
        var Foo = function () {
        };
        var customObj = new Foo();
        ok(!typeReflections.isBuiltIn(customObj), 'Custom Object');
        if (testHelpers.mapSupported) {
            var map = new Map();
            ok(typeReflections.isBuiltIn(map), 'Map');
        }
    });
    QUnit.test('isValueLike', function () {
        ok(!typeReflections.isValueLike({}), 'Object');
        ok(!typeReflections.isValueLike(function () {
        }), 'Function');
        ok(typeReflections.isValueLike('String'), 'String');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), true);
        ok(typeReflections.isValueLike(obj), 'symboled');
        var symboled = {};
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), false);
        ok(!typeReflections.isValueLike(symboled), '!@@can.isValueLike');
        getSetReflections.setKeyValue(symboled, canSymbol.for('can.isValueLike'), true);
        ok(typeReflections.isValueLike(symboled), '@@can.isValueLike');
    });
    QUnit.test('isSymbolLike', function () {
        if (typeof Symbol !== 'undefined') {
            ok(typeReflections.isSymbolLike(Symbol('a symbol')), 'Native Symbol');
        }
        ok(typeReflections.isSymbolLike(canSymbol('another Symbol')), 'canSymbol Symbol');
    });
    QUnit.test('isPromise', function () {
        QUnit.ok(!typeReflections.isPromise({}), 'Object is not a promise');
        QUnit.ok(!typeReflections.isPromise({
            catch: function () {
            },
            then: function () {
            }
        }), 'function with then and catch is not a Promise');
        QUnit.ok(typeReflections.isPromise(new Promise(function () {
        })), 'a new Promise() is a Promise');
    });
    QUnit.test('isConstructor - non enumerable properties on the prototype chain (#18)', function () {
        var Constructor = function () {
        };
        Object.defineProperty(Constructor.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
    QUnit.test('functions without prototypes (#20)', function () {
        var method = function () {
        }.bind({});
        QUnit.notOk(typeReflections.isConstructorLike(method), 'not a constructor');
    });
    QUnit.test('functions with deep non enumerable properties - non default proto chains (#22)', function () {
        var Base = function () {
        };
        Object.defineProperty(Base.prototype, 'prop', {
            enumerable: false,
            value: 1
        });
        var Constructor = function () {
        };
        Constructor.prototype = new Base();
        Constructor.prototype.constructor = Constructor;
        QUnit.ok(typeReflections.isConstructorLike(Constructor), 'decorated prototype means constructor');
    });
    QUnit.test('array -like type is MoreListLikeThanMapLike', function () {
        var MyArray = function (values) {
            this.push.apply(this, values || []);
        };
        MyArray.prototype = Object.create(Array.prototype);
        MyArray.prototype.constructor = MyArray;
        var arr = new MyArray();
        QUnit.ok(typeReflections.isMoreListLikeThanMapLike(arr), 'is array like');
    });
});
/*can-reflect@1.17.5#reflections/shape/schema/schema-test*/
define('can-reflect@1.17.5#reflections/shape/schema/schema-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './schema',
    '../shape'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var schemaReflections = require('./schema');
    var shapeReflections = require('../shape');
    QUnit.module('can-reflect: shape reflections: schema');
    var MyType = function (id) {
        this._id = id;
        this.name = 'nameValue';
    };
    MyType[canSymbol.for('can.getSchema')] = function () {
        return { identity: ['_id'] };
    };
    MyType.prototype.method = function () {
    };
    QUnit.test('getSchema', function () {
        var schema = schemaReflections.getSchema(MyType);
        QUnit.deepEqual(schema, { identity: ['_id'] });
        var instance = new MyType('_id');
        schema = schemaReflections.getSchema(instance);
        QUnit.deepEqual(schema, { identity: ['_id'] });
    });
    QUnit.test('cloneKeySort', function (assert) {
        var obj = {
            'z': 0,
            'a': 0
        };
        var same = {
            'a': 0,
            'z': 0
        };
        assert.equal(JSON.stringify(schemaReflections.cloneKeySort(obj)), JSON.stringify(same));
    });
    QUnit.test('cloneKeySort with strings', function (assert) {
        var obj = {
            'z': '0',
            'a': '0'
        };
        var same = {
            'a': '0',
            'z': '0'
        };
        assert.equal(JSON.stringify(schemaReflections.cloneKeySort(obj)), JSON.stringify(same));
    });
    QUnit.test('getIdentity', function () {
        var value = new MyType(5);
        QUnit.equal(schemaReflections.getIdentity(value), 5, 'used schema');
        QUnit.equal(schemaReflections.getIdentity(value, {
            identity: [
                '_id',
                'name'
            ]
        }), '{"_id":5,"name":"nameValue"}');
    });
    QUnit.test('getSchema returns undefined when there is not schema', function () {
        QUnit.equal(schemaReflections.getSchema(function () {
        }), undefined, 'is undefined');
    });
    QUnit.test('getSchema returns undefined when passed undefined', function () {
        QUnit.equal(schemaReflections.getSchema(undefined), undefined, 'is undefined');
    });
    QUnit.test('canReflect.convert', function () {
        var res = schemaReflections.convert('1', Number);
        QUnit.equal(typeof res, 'number', 'is right type');
        QUnit.equal(res, 1, 'string -> number');
        QUnit.equal(schemaReflections.convert('Infinity', Number), Infinity, 'string -> number');
        QUnit.equal(schemaReflections.convert(1, String), '1', 'string');
        QUnit.equal(schemaReflections.convert(true, String), 'true', 'boolean -> string');
        QUnit.equal(schemaReflections.convert(false, String), 'false', 'boolean -> string');
        QUnit.equal(schemaReflections.convert('true', Boolean), true, 'string true -> boolean');
        var MyConstructor = function (val) {
            this.val = val;
        };
        MyConstructor.prototype.method = function () {
        };
        QUnit.equal(schemaReflections.convert('abc', MyConstructor).val, 'abc', 'creates new instance');
        var abc = new MyConstructor('abc');
        QUnit.equal(schemaReflections.convert(abc, MyConstructor), abc, 'is instance');
        var MaybeString = shapeReflections.assignSymbols({}, {
            'can.new': function (val) {
                if (val == null) {
                    return val;
                }
                return '' + val;
            }
        });
        QUnit.equal(schemaReflections.convert('1', MaybeString), '1', '\'1\' -> MaybeString');
        QUnit.equal(schemaReflections.convert(null, MaybeString), null, 'null -> MaybeString');
        var toStringIsh = function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        };
        QUnit.equal(schemaReflections.convert('1', toStringIsh), '1', '\'1\' -> MaybeString');
        QUnit.equal(schemaReflections.convert(null, toStringIsh), null, 'null -> MaybeString');
    });
});
/*can-reflect@1.17.5#reflections/shape/shape-test*/
define('can-reflect@1.17.5#reflections/shape/shape-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './shape',
    '../get-set/get-set',
    '../../can-reflect-test_helpers',
    './schema/schema-test'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('./shape');
    var getSetReflections = require('../get-set/get-set');
    var testHelpers = require('../../can-reflect-test_helpers');
    require('./schema/schema-test');
    QUnit.module('can-reflect: shape reflections: own+enumerable');
    function testModifiedMap(callback, symbolToMethod) {
        symbolToMethod = symbolToMethod || {
            getOwnEnumerableKeys: 'keys',
            hasOwnKey: 'has',
            getKeyValue: 'get'
        };
        if (testHelpers.mapSupported) {
            shapeReflections.eachKey(symbolToMethod, function (method, symbol) {
                getSetReflections.setKeyValue(Map.prototype, canSymbol.for('can.' + symbol), function () {
                    return this[method].apply(this, arguments);
                });
            });
            callback();
            shapeReflections.eachKey(symbolToMethod, function (symbol) {
                delete Map.prototype[canSymbol.for('can.' + symbol)];
            });
        }
    }
    QUnit.test('getOwnEnumerableKeys (aka: keys)', function () {
        QUnit.deepEqual(shapeReflections.keys({
            foo: 1,
            bar: 2
        }), [
            'foo',
            'bar'
        ], 'POJO');
        QUnit.deepEqual(shapeReflections.keys([
            '0',
            '1'
        ]), Object.keys([
            1,
            2
        ]), 'Array');
        testModifiedMap(function () {
            var map = new Map(), obj = {};
            map.set('foo', 1);
            map.set(obj, 2);
            QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(map)), [
                'foo',
                {}
            ], 'Decorated Map with can.getOwnEnumerableKeys');
        });
        var proto = {};
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeys'), function () {
            return [
                'a',
                'b',
                'c'
            ];
        });
        getSetReflections.setKeyValue(proto, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                a: { enumerable: false },
                b: { enumerable: true },
                c: { enumerable: true }
            }[key];
        });
        var defineMapLike = Object.create(proto, {});
        QUnit.deepEqual(shapeReflections.toArray(shapeReflections.keys(defineMapLike)), [
            'b',
            'c'
        ], 'Decorated Object with can.getOwnKeys and can.getOwnKeyDescriptor');
    });
    QUnit.test('eachIndex', function () {
        var Ctr = function () {
        };
        var arr = [
            'a',
            'b'
        ];
        getSetReflections.setKeyValue(Ctr.prototype, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 1) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: arr,
                        done: false
                    };
                }
            };
        });
        var obj = new Ctr();
        shapeReflections.eachIndex(obj, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, arr);
        });
        shapeReflections.eachIndex(['a'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
        function ArrayLike() {
        }
        ArrayLike.prototype = [];
        ArrayLike.prototype[canSymbol.iterator] = null;
        var noniterator = new ArrayLike();
        noniterator.push('a');
        shapeReflections.eachIndex(noniterator, function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'a');
        });
    });
    QUnit.test('eachKey', function () {
        var index;
        var answers, map;
        testModifiedMap(function () {
            var o1 = {}, o2 = {};
            map = new Map([
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ]);
            index = 0;
            answers = [
                [
                    o1,
                    '1'
                ],
                [
                    o2,
                    2
                ]
            ];
            shapeReflections.eachKey(map, function (value, key) {
                var answer = answers[index++];
                QUnit.equal(value, answer[1], 'map value');
                QUnit.equal(key, answer[0], 'map key');
            });
        });
        var obj = {
            a: '1',
            b: '2'
        };
        index = 0;
        answers = [
            [
                'a',
                '1'
            ],
            [
                'b',
                '2'
            ]
        ];
        shapeReflections.eachKey(obj, function (value, key) {
            var answer = answers[index++];
            QUnit.equal(value, answer[1], 'object value');
            QUnit.equal(key, answer[0], 'object key');
        });
    });
    QUnit.test('each', function () {
        shapeReflections.each({ foo: 'bar' }, function (value, key) {
            QUnit.equal(key, 'foo');
            QUnit.equal(value, 'bar');
        });
        shapeReflections.each(['bar'], function (value, index) {
            QUnit.equal(index, 0);
            QUnit.equal(value, 'bar');
        });
    });
    QUnit.test('toArray', function () {
        if (typeof document !== 'undefined') {
            var ul = document.createElement('ul');
            ul.innerHTML = '<li/><li/>';
            var arr = shapeReflections.toArray(ul.childNodes);
            QUnit.equal(arr.length, 2, 'childNodes');
            QUnit.equal(arr[0].nodeName.toLowerCase(), 'li', 'childNodes');
        }
    });
    QUnit.module('can-reflect: shape reflections: own');
    QUnit.test('hasOwnKey', function () {
        var map;
        testModifiedMap(function () {
            var o1 = {};
            map = new Map();
            map.set(o1, '1');
            QUnit.ok(shapeReflections.hasOwnKey(map, o1), 'Map');
        });
        var obj = { foo: 'bar' };
        QUnit.ok(shapeReflections.hasOwnKey(obj, 'foo'), 'obj');
        QUnit.ok(!shapeReflections.hasOwnKey(obj, 'bar'), 'obj');
    });
    QUnit.test('getOwnKeys', function () {
        var obj = Object.create(null, {
            foo: {
                value: '1',
                enumerable: true
            },
            bar: {
                value: '2',
                enumerable: false
            }
        });
        QUnit.deepEqual(shapeReflections.getOwnKeys(obj), [
            'foo',
            'bar'
        ], 'obj');
    });
    QUnit.test('getOwnKeyDescriptor', function () {
        var obj = { foo: 'bar' };
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj, 'foo'), Object.getOwnPropertyDescriptor(obj, 'foo'), 'POJO');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getOwnKeyDescriptor'), function (key) {
            return {
                foo: {
                    enumerable: true,
                    type: 'thing'
                }
            }[key];
        });
        QUnit.deepEqual(shapeReflections.getOwnKeyDescriptor(obj2, 'foo'), {
            enumerable: true,
            type: 'thing'
        }, 'w/ symbol');
    });
    QUnit.test('unwrap basics', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('unwrap handles POJOs', function () {
        var a = { foo: 'bar' };
        var plain = shapeReflections.unwrap(a);
        QUnit.deepEqual(plain, a);
        QUnit.ok(a !== plain, 'returns copy');
    });
    if (typeof Map !== 'undefined') {
        QUnit.test('handles cycles', function () {
            var a = {}, b = {};
            a.b = b;
            b.a = a;
            var plain = shapeReflections.unwrap(a, Map);
            QUnit.equal(plain.b.a, plain, 'cycle intact');
            QUnit.ok(a !== plain, 'returns copy');
        });
    }
    QUnit.test('isBuiltIn is only called after decorators are checked in shouldSerialize', function () {
        var arr = [];
        QUnit.ok(!shapeReflections.isSerialized(arr), 'array is not isSerialized');
        QUnit.ok(!shapeReflections.isSerialized({}), 'obj is not isSerialized');
        arr[canSymbol.for('can.setKeyValue')] = function () {
        };
        QUnit.ok(!shapeReflections.isSerialized(arr));
        if (testHelpers.setSupported) {
            var set = new Set([
                {},
                {},
                {}
            ]);
            QUnit.ok(shapeReflections.isSerialized(set));
            set[canSymbol.for('can.setKeyValue')] = function () {
            };
            QUnit.ok(!shapeReflections.isSerialized(set));
        }
    });
    QUnit.test('.serialize handles recursion with .unwrap', function () {
        var list = {};
        getSetReflections.setKeyValue(list, canSymbol.iterator, function () {
            return {
                i: 0,
                next: function () {
                    if (this.i === 3) {
                        return {
                            value: undefined,
                            done: true
                        };
                    }
                    this.i++;
                    return {
                        value: (this.i - 1) * 2,
                        done: false
                    };
                }
            };
        });
        getSetReflections.setKeyValue(list, canSymbol.for('can.isMoreListLikeThanMapLike'), true);
        var compute = {};
        getSetReflections.setKeyValue(compute, canSymbol.for('can.getValue'), function () {
            var map = {};
            getSetReflections.setKeyValue(map, canSymbol.for('can.getOwnEnumerableKeys'), function () {
                return [
                    'a',
                    'b',
                    'c',
                    'list'
                ];
            });
            getSetReflections.setKeyValue(map, canSymbol.for('can.getKeyValue'), function (key) {
                return key === 'list' ? list : key.toUpperCase();
            });
            return map;
        });
        var plain = shapeReflections.unwrap(compute);
        QUnit.deepEqual(plain, {
            a: 'A',
            b: 'B',
            c: 'C',
            list: [
                0,
                2,
                4
            ]
        });
    });
    QUnit.test('.serialize with recursive data structures', function () {
        var obj = {};
        obj.prop = obj;
        var s = shapeReflections.serialize(obj);
        QUnit.equal(s.prop, s, 'Object points to itself');
    });
    QUnit.test('objects that serialize to strings should cache properly', function () {
        function SimpleType() {
        }
        getSetReflections.setKeyValue(SimpleType.prototype, canSymbol.for('can.serialize'), function () {
            return 'baz';
        });
        var obj = new SimpleType();
        var p = {
            foo: obj,
            bar: obj
        };
        deepEqual(shapeReflections.serialize(p, window.Map), {
            foo: 'baz',
            bar: 'baz'
        });
    });
    QUnit.test('throw error when serializing circular reference', function () {
        function SimpleType() {
        }
        var a = new SimpleType();
        var b = new SimpleType();
        a.b = b;
        b.a = a;
        getSetReflections.setKeyValue(a, canSymbol.for('can.serialize'), function () {
            return { b: shapeReflections.serialize(this.b) };
        });
        getSetReflections.setKeyValue(b, canSymbol.for('can.serialize'), function () {
            return { a: shapeReflections.serialize(this.a) };
        });
        try {
            shapeReflections.serialize(a, window.Map);
            QUnit.ok(false);
        } catch (e) {
            QUnit.ok(true);
        }
    });
    QUnit.test('throw should not when serializing circular reference properly', function () {
        function SimpleType() {
        }
        var a = new SimpleType();
        var b = new SimpleType();
        a.b = b;
        b.a = a;
        getSetReflections.setKeyValue(a, canSymbol.for('can.serialize'), function (proto) {
            return proto.b = shapeReflections.serialize(this.b);
        });
        getSetReflections.setKeyValue(b, canSymbol.for('can.serialize'), function (proto) {
            return proto.a = shapeReflections.serialize(this.a);
        });
        try {
            shapeReflections.serialize(a, window.Map);
            QUnit.ok(true);
        } catch (e) {
            QUnit.ok(false);
        }
    });
    QUnit.test('Correctly serializes after throwing for circular reference', function () {
        function SimpleType() {
        }
        var a = new SimpleType();
        var b = new SimpleType();
        a.b = b;
        b.a = a;
        getSetReflections.setKeyValue(a, canSymbol.for('can.serialize'), function () {
            return { b: shapeReflections.serialize(this.b) };
        });
        getSetReflections.setKeyValue(b, canSymbol.for('can.serialize'), function () {
            return { a: shapeReflections.serialize(this.a) };
        });
        try {
            shapeReflections.serialize(a, window.Map);
            QUnit.ok(false);
        } catch (e) {
            QUnit.ok(true);
            a = [
                1,
                2
            ];
            shapeReflections.serialize(a, window.Map);
            b = a;
            b.shift();
            var s = shapeReflections.serialize(b, window.Map);
            QUnit.equal(s.length, 1, 'there is one item');
            QUnit.equal(s[0], 2, 'correct item');
        }
    });
    QUnit.test('updateDeep basics', function () {
        var obj = {
            name: 'Justin',
            hobbies: [
                {
                    id: 1,
                    name: 'js'
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        };
        var hobbies = obj.hobbies;
        var js = obj.hobbies[0];
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [{
                    id: 1,
                    name: 'JS',
                    fun: true
                }]
        });
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
        shapeReflections.updateDeep(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        });
        QUnit.deepEqual(obj, {
            age: 34,
            hobbies: [
                {
                    id: 1,
                    name: 'JS',
                    fun: true
                },
                {
                    id: 2,
                    name: 'foosball'
                }
            ]
        }, 'added foosball');
        QUnit.equal(obj.hobbies, hobbies, 'merged hobbies');
        QUnit.equal(obj.hobbies[0], js, 'merged js');
    });
    QUnit.test('updateDeep', function () {
        var a = [];
        shapeReflections.updateDeep(a, [
            'a',
            'b'
        ]);
        QUnit.deepEqual(a, [
            'a',
            'b'
        ]);
    });
    QUnit.test('can assign undefined values', function () {
        var obj = shapeReflections.assignMap({}, { foo: undefined });
        QUnit.ok(obj.hasOwnProperty('foo'), 'has an undefined foo');
    });
    QUnit.test('assignMap', function () {
        var target = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 2;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 2 : undefined;
            }
        });
        target.a = 22;
        var source = shapeReflections.assignSymbols({}, {
            'can.setKeyValue': function (key, value) {
                this[key] = value * 3;
            },
            'can.getKeyValue': function (key) {
                return this[key] !== undefined ? this[key] / 3 : undefined;
            }
        });
        shapeReflections.assignMap(source, {
            a: 1,
            b: 2
        });
        QUnit.deepEqual(source, {
            a: 3,
            b: 6
        }, 'set values on source');
        shapeReflections.assignMap(target, source);
        QUnit.deepEqual(target, {
            a: 2,
            b: 4
        }, 'set values on target');
    });
    QUnit.test('getOwnEnumerableKeys with primitives', function () {
        QUnit.deepEqual(shapeReflections.getOwnEnumerableKeys(1), [], 'works with primitive');
    });
    if (typeof Symbol !== 'undefined') {
        QUnit.test('assignSymbols can set Symbol.iterator', function () {
            var fn = function () {
            };
            var obj = shapeReflections.assignSymbols({}, { 'iterator': fn });
            QUnit.equal(obj[Symbol.iterator], fn, 'works');
        });
    }
    QUnit.test('defineInstanceKey with symbol on prototype', function () {
        var testKey = 'foo';
        var testDef = { value: 'bar' };
        function Foo() {
        }
        Foo.prototype[canSymbol.for('can.defineInstanceKey')] = function (key, definition) {
            QUnit.equal(key, testKey);
            QUnit.deepEqual(definition, testDef);
        };
        shapeReflections.defineInstanceKey(Foo, testKey, testDef);
    });
    QUnit.test('defineInstanceKey with no symbol on prototype', function () {
        var testKey = 'foo';
        var testDef = { value: 'bar' };
        var def;
        function Foo() {
        }
        shapeReflections.defineInstanceKey(Foo, testKey, testDef);
        QUnit.ok(def = Object.getOwnPropertyDescriptor(Foo.prototype, testKey), 'Has descriptor');
        QUnit.equal(def.value, testDef.value, 'Value is correctly set');
        QUnit.equal(def.configurable, true, 'value is configurable');
        QUnit.equal(def.writable, true, 'value is writable');
    });
    QUnit.test('updateDeep recurses correctly (#73)', function () {
        var source = {
                name: 'juan',
                hobbies: [
                    'games',
                    'photography',
                    'building'
                ]
            }, sourceArray = source.hobbies;
        shapeReflections.updateDeep(source, { hobbies: ['headdesk'] });
        QUnit.deepEqual(source, { hobbies: ['headdesk'] }, 'source looks right');
        QUnit.equal(sourceArray, source.hobbies, 'array updated');
    });
    QUnit.module('can-reflect: shape reflections: proto chain');
    QUnit.test('hasKey', function () {
        var objHasKey = {};
        Object.defineProperty(objHasKey, '_keys', { value: { foo: true } });
        getSetReflections.setKeyValue(objHasKey, canSymbol.for('can.hasKey'), function (key) {
            return key in this._keys;
        });
        QUnit.ok(shapeReflections.hasKey(objHasKey, 'foo'), 'returns true when hasKey Symbol returns true');
        QUnit.ok(!shapeReflections.hasKey(objHasKey, 'bar'), 'returns false when hasKey Symbol returns false');
        var objHasOwnKey = {};
        Object.defineProperty(objHasOwnKey, '_keys', { value: { foo: true } });
        getSetReflections.setKeyValue(objHasOwnKey, canSymbol.for('can.hasOwnKey'), function (key) {
            return key in this._keys;
        });
        QUnit.ok(shapeReflections.hasKey(objHasOwnKey, 'foo'), 'returns true when hasOwnKey Symbol returns true');
        QUnit.ok(!shapeReflections.hasKey(objHasOwnKey, 'bar'), 'returns false when hasOwnKey Symbol returns false');
        objHasOwnKey.bar = 'baz';
        QUnit.ok(shapeReflections.hasKey(objHasOwnKey, 'bar'), 'returns true when hasOwnKey Symbol returns false but `in` returns true');
        QUnit.ok(shapeReflections.hasKey(55, 'toFixed'), 'works on primitives');
        QUnit.ok(shapeReflections.hasKey(true, 'valueOf'), 'works on primitives');
        QUnit.ok(shapeReflections.hasKey('foo', 'length'), 'works on primitives');
        QUnit.notOk(shapeReflections.hasKey(null, 'length'), 'works on null');
        QUnit.notOk(shapeReflections.hasKey(undefined, 'length'), 'works on undefined');
    });
    QUnit.test('serialize clones', function () {
        var obj = { foo: { bar: 'zed' } };
        var res = shapeReflections.serialize(obj);
        QUnit.deepEqual(res, obj, 'look equal');
        QUnit.notOk(res === obj);
        QUnit.notOk(res.foo === obj.foo);
    });
    QUnit.test('serialize clones arrays', function () {
        var obj = { foo: [{ zed: 'ted' }] };
        var obj2 = shapeReflections.serialize(obj);
        QUnit.deepEqual(obj2, obj, 'deep equal');
        QUnit.notOk(obj === obj2, 'ret not the same');
        QUnit.notOk(obj.foo === obj2.foo, 'foo not the same');
        QUnit.notOk(obj.foo[0] === obj2.foo[0]);
    });
    QUnit.test('.size', function () {
        QUnit.equal(shapeReflections.size([1]), 1, 'array');
        QUnit.equal(shapeReflections.size([]), 0, 'array');
        QUnit.equal(shapeReflections.size('a'), 1, 'string');
        QUnit.equal(shapeReflections.size(''), 0, 'array');
        QUnit.equal(shapeReflections.size({}), 0, 'empty object');
        QUnit.equal(shapeReflections.size({ foo: 'bar' }), 1, 'object');
        QUnit.equal(shapeReflections.size(null), 0, 'null');
        QUnit.equal(shapeReflections.size(undefined), 0, 'undefined');
    });
    QUnit.test('size works with out hasOwnProperty (#109)', function () {
        var obj = Object.create(null);
        QUnit.equal(shapeReflections.size(obj), 0, 'empty object');
        obj.foo = 'bar';
        QUnit.equal(shapeReflections.size(obj), 1, 'has value');
    });
    QUnit.test('each loops without needing `this`', function () {
        var each = shapeReflections.each;
        each({}, function () {
        });
        QUnit.ok(true, 'no error');
    });
    QUnit.test('assignDeepList', function () {
        var justin = {
                name: 'Justin',
                age: 35
            }, payal = {
                name: 'Payal',
                age: 35
            };
        var people = [
            justin,
            payal
        ];
        shapeReflections.assignDeep(people, [{ age: 36 }]);
        QUnit.deepEqual(people, [
            {
                name: 'Justin',
                age: 36
            },
            {
                name: 'Payal',
                age: 35
            }
        ], 'assigned right');
    });
});
/*can-reflect@1.17.5#reflections/get-set/get-set-test*/
define('can-reflect@1.17.5#reflections/get-set/get-set-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    '../shape/shape',
    './get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var shapeReflections = require('../shape/shape');
    var getSetReflections = require('./get-set');
    QUnit.module('can-reflect: get-set reflections: key');
    QUnit.test('getKeyValue', function () {
        QUnit.equal(getSetReflections.getKeyValue({ foo: 'bar' }, 'foo'), 'bar', 'POJO');
        QUnit.equal(getSetReflections.getKeyValue([1], 'length'), 1, 'Array length');
        QUnit.equal(getSetReflections.getKeyValue([2], 0), 2, 'Array index');
        var obj = {};
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getKeyValue'), function (key) {
            return { foo: 'bar' }[key];
        });
        QUnit.equal(getSetReflections.getKeyValue(obj, 'foo'), 'bar');
    });
    QUnit.test('get / set alias', function () {
        QUnit.equal(getSetReflections.get, getSetReflections.getKeyValue);
        QUnit.equal(getSetReflections.set, getSetReflections.setKeyValue);
    });
    QUnit.test('setKeyValue', function () {
        var obj = {};
        var mysymbol = canSymbol('some symbol');
        if (typeof mysymbol === 'object') {
            getSetReflections.setKeyValue(obj, mysymbol, 'VALUE');
            QUnit.deepEqual(Object.getOwnPropertyDescriptor(obj, mysymbol.toString()), {
                enumerable: false,
                writable: true,
                configurable: true,
                value: 'VALUE'
            });
        }
        obj = {};
        getSetReflections.setKeyValue(obj, 'prop', 'VALUE');
        QUnit.equal(obj.prop, 'VALUE');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setKeyValue'), function (prop, value) {
            QUnit.equal(prop, 'someProp', 'can.setKeyValue');
            QUnit.equal(value, 'someValue', 'can.setKeyValue');
        });
        getSetReflections.setKeyValue(obj, 'someProp', 'someValue');
    });
    QUnit.test('deleteKeyValue', function () {
        var obj = { prop: 'Value' };
        getSetReflections.deleteKeyValue(obj, 'prop');
        QUnit.equal(obj.prop, undefined, 'deleted');
    });
    QUnit.module('can-reflect: get-set reflections: value');
    QUnit.test('getValue', function () {
        [
            true,
            1,
            null,
            undefined,
            {}
        ].forEach(function (value) {
            QUnit.equal(getSetReflections.getValue(value), value, 'Value: ' + value);
        });
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.getValue'), function () {
            return this.value;
        });
        QUnit.equal(getSetReflections.getValue(obj), 0);
    });
    QUnit.test('setValue', function () {
        try {
            getSetReflections.setValue({}, {});
            QUnit.ok(false, 'set POJO');
        } catch (e) {
            QUnit.ok(true, 'set POJO errors');
        }
        var obj = { value: 0 };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.setValue'), function (value) {
            this.value = value;
        });
        getSetReflections.setValue(obj, 2);
        QUnit.deepEqual(obj, { value: 2 }, 'can.setValue');
    });
    QUnit.test('splice', function () {
        var arr = [
            'a',
            'b'
        ];
        getSetReflections.splice(arr, 0, 1);
        QUnit.deepEqual(arr, ['b'], 'removes item with no additions');
        arr = [
            'a',
            'b'
        ];
        getSetReflections.splice(arr, 0, 1, [
            'c',
            'd'
        ]);
        QUnit.deepEqual(arr, [
            'c',
            'd',
            'b'
        ], 'removes item with no additions');
    });
});
/*can-reflect@1.17.5#reflections/call/call-test*/
define('can-reflect@1.17.5#reflections/call/call-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './call',
    '../get-set/get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var callReflections = require('./call');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: function reflections');
    QUnit.test('call', function () {
        var obj = {};
        var ret = callReflections.call(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.call(func, obj, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('apply', function () {
        var obj = {};
        var ret = callReflections.apply(function (arg1, arg2) {
            QUnit.equal(this, obj, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        }, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
        var func = {};
        getSetReflections.setKeyValue(func, canSymbol.for('can.apply'), function (context, args) {
            QUnit.equal(this, func, 'this');
            QUnit.equal(context, obj, 'context');
            QUnit.equal(args[0], 1, 'arg1');
            QUnit.equal(args[1], 2, 'arg2');
            return 3;
        });
        ret = callReflections.apply(func, obj, [
            1,
            2
        ]);
        QUnit.equal(ret, 3, 'return value');
    });
    QUnit.test('new', function () {
        var Constructor = function (arg1, arg2) {
            QUnit.ok(this instanceof Constructor, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        };
        var instance = callReflections['new'](Constructor, 1, 2);
        QUnit.ok(instance instanceof Constructor, 'this');
        var Func = {};
        getSetReflections.setKeyValue(Func, canSymbol.for('can.new'), function (arg1, arg2) {
            QUnit.equal(this, Func, 'this');
            QUnit.equal(arg1, 1, 'arg1');
            QUnit.equal(arg2, 2, 'arg2');
            return 3;
        });
        var ret = callReflections.new(Func, 1, 2);
        QUnit.equal(ret, 3, 'return value');
    });
});
/*can-reflect@1.17.5#reflections/observe/observe-test*/
define('can-reflect@1.17.5#reflections/observe/observe-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-symbol',
    './observe',
    '../get-set/get-set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canSymbol = require('can-symbol');
    var observeReflections = require('./observe');
    var getSetReflections = require('../get-set/get-set');
    QUnit.module('can-reflect: observe reflections: key');
    QUnit.test('onKeyValue / offKeyValue', function () {
        var obj = { callbacks: { foo: [] } };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onKeyValue'), function (key, callback) {
            this.callbacks[key].push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onKeyValue(obj, 'foo', callback);
        obj.callbacks.foo[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offKeyValue'), function (key, callback) {
            var index = this.callbacks[key].indexOf(callback);
            this.callbacks[key].splice(index, 1);
        });
        observeReflections.offKeyValue(obj, 'foo', callback);
        QUnit.equal(obj.callbacks.foo.length, 0, 'no event handlers');
    });
    QUnit.test('onKeys', function () {
        try {
            observeReflections.onKeys({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('onKeysAdded / onKeysRemoved', function () {
        try {
            observeReflections.onKeysAdded({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
        try {
            observeReflections.onKeysRemoved({}, function () {
            });
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getKeyDependencies', function () {
        try {
            observeReflections.getKeyDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getWhatIChange', function () {
        try {
            observeReflections.getWhatIChange({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.test('getChangesDependencyRecord', function (assert) {
        assert.equal(typeof observeReflections.getChangesDependencyRecord({}), 'undefined', 'should return undefined when symbol is not implemented');
    });
    QUnit.module('can-reflect: observe reflections: value');
    QUnit.test('onValue / offValue', function () {
        var obj = { callbacks: [] };
        getSetReflections.setKeyValue(obj, canSymbol.for('can.onValue'), function (callback) {
            this.callbacks.push(callback);
        });
        var callback = function (ev, value) {
            QUnit.equal(value, 'bar');
        };
        observeReflections.onValue(obj, callback);
        obj.callbacks[0]({}, 'bar');
        getSetReflections.setKeyValue(obj, canSymbol.for('can.offValue'), function (callback) {
            var index = this.callbacks.indexOf(callback);
            this.callbacks.splice(index, 1);
        });
        observeReflections.offValue(obj, callback);
        QUnit.equal(obj.callbacks.length, 0, 'no event handlers');
    });
    QUnit.test('getValueDependencies', function () {
        try {
            observeReflections.getValueDependencies({});
            QUnit.ok(false, 'should throw error');
        } catch (e) {
            QUnit.ok(true, 'threw error');
        }
    });
    QUnit.module('can-reflect: observe reflections: event');
    QUnit.test('onEvent / offEvent', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
            },
            removeEventListener: function (arg1, arg2) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
            }
        };
        observeReflections.onEvent(obj, 'click', cb);
        observeReflections.offEvent(obj, 'click', cb);
    });
    QUnit.test('onEvent / offEvent gets 3rd argument', function () {
        var cb = function () {
        };
        var obj = {
            addEventListener: function (arg1, arg2, queue) {
                QUnit.equal(this, obj);
                QUnit.equal(arg2, cb);
                QUnit.equal(arg1, 'click', 'eventName');
                QUnit.equal(queue, 'mutate', 'queue');
            },
            removeEventListener: function (arg1, arg2, queue) {
                QUnit.equal(this, obj);
                QUnit.equal(arg1, 'click', 'event name');
                QUnit.equal(arg2, cb);
                QUnit.equal(queue, 'mutate', 'queue');
            }
        };
        observeReflections.onEvent(obj, 'click', cb, 'mutate');
        observeReflections.offEvent(obj, 'click', cb, 'mutate');
    });
    QUnit.test('setPriority', function () {
        var obj = {};
        QUnit.equal(observeReflections.setPriority(obj, 5), false, 'unable to set priority');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.setPriority'), function (number) {
            this.priority = number;
        });
        QUnit.equal(observeReflections.setPriority(obj2, 5), true, 'unable to set priority');
        QUnit.equal(obj2.priority, 5, 'set priority');
    });
    QUnit.test('getPriority', function () {
        var obj = {};
        QUnit.equal(observeReflections.getPriority(obj), undefined, 'no priority');
        var obj2 = {};
        getSetReflections.setKeyValue(obj2, canSymbol.for('can.getPriority'), function () {
            return 5;
        });
        QUnit.equal(observeReflections.getPriority(obj2), 5, 'unable to set priority');
    });
});
/*can-reflect@1.17.5#types/map-test*/
define('can-reflect@1.17.5#types/map-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../reflections/shape/shape',
    './map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var shape = require('../reflections/shape/shape');
    require('./map');
    if (typeof Map !== 'undefined') {
        QUnit.module('can-reflect/types/map Map');
        QUnit.test('assign', function () {
            var map = new Map();
            shape.assign(map, { name: 'CanJS' });
            QUnit.equal(map.get('name'), 'CanJS', 'object to map');
            var map1 = new Map();
            map = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map1.set(o1, o2);
            shape.assign(map, map1);
            QUnit.equal(map.get(o1), o2, 'map to map');
        });
        QUnit.test('has', function () {
            var map = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map.set(o1, o2);
            QUnit.ok(shape.hasOwnKey(map, o1), 'Shape has object key');
        });
        QUnit.test('update', function () {
            var map = new Map();
            var o1 = { name: 'o1' };
            var o2 = { name: 'o2' };
            var o3 = { name: 'o3' };
            map.set(o1, o2);
            map.set(o2, o1);
            var map2 = new Map();
            map2.set(o1, o3);
            map2.set(o3, o1);
            shape.update(map, map2);
            QUnit.notOk(map.has(o2), 'removed key');
            QUnit.equal(map.get(o3), o1, 'added key');
            QUnit.equal(map.get(o1), o3, 'updated key');
        });
    }
    if (typeof WeakMap !== 'undefined') {
        QUnit.module('can-reflect/types/map WeakMap');
        QUnit.test('assign', function () {
            var canjs = new Map();
            var name = { name: 'toUpperCase' };
            canjs.set(name, 'CANJS');
            var map = new WeakMap();
            shape.assign(map, canjs);
            QUnit.equal(map.get(name), 'CANJS', 'map to weakmap');
            map = new WeakMap();
            var map1 = new Map();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map1.set(o1, o2);
            shape.assign(map, map1);
            QUnit.equal(map.get(o1), o2, 'map to map');
        });
        QUnit.test('has', function () {
            var map = new WeakMap();
            var o1 = { name: 'foo' };
            var o2 = { name: 'bar' };
            map.set(o1, o2);
            QUnit.ok(shape.hasOwnKey(map, o1), 'Shape has object key');
        });
        QUnit.test('update', function () {
            var map = new WeakMap();
            var o1 = { name: 'o1' };
            var o2 = { name: 'o2' };
            var o3 = { name: 'o3' };
            map.set(o1, o2);
            map.set(o2, o1);
            var map2 = new WeakMap();
            map2.set(o1, o3);
            map2.set(o3, o1);
            try {
                shape.update(map, map2);
            } catch (e) {
                QUnit.ok(true, 'throws an error');
            }
        });
    }
});
/*can-reflect@1.17.5#types/set-test*/
define('can-reflect@1.17.5#types/set-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../reflections/shape/shape',
    '../reflections/type/type',
    './set'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var shape = require('../reflections/shape/shape');
    var type = require('../reflections/type/type');
    require('./set');
    function assertSetMatchesArray(set, array, msg) {
        QUnit.equal(set.size, array.length, msg + ' - size matches');
        for (var i = 0; i < array.length; i++) {
            QUnit.ok(set.has(array[i]), msg + ' - set contains ' + array[i]);
        }
    }
    if (typeof Set !== 'undefined') {
        QUnit.module('can-reflect/types/set Set');
        QUnit.test('isListLike', function () {
            QUnit.ok(type.isListLike(new Set()), 'isListLike');
            QUnit.ok(type.isMoreListLikeThanMapLike(new Set()), 'isMoreListLikeThanMapLike');
        });
        QUnit.test('shape.each', function () {
            var arr = [
                'a',
                'b'
            ];
            var set = new Set();
            arr.forEach(function (val) {
                set.add(val);
            });
            var count = 0;
            shape.each(set, function (value) {
                QUnit.equal(value, arr[count++], 'got the right values back');
            });
        });
        QUnit.test('shape.update', function () {
            var set = new Set([
                'a',
                'b'
            ]);
            shape.update(set, [
                'a',
                'a',
                'c'
            ]);
            assertSetMatchesArray(set, [
                'a',
                'c'
            ], '.update');
        });
        QUnit.test('shape.assign', function () {
            var arr = [
                'a',
                'b'
            ];
            var set = new Set();
            arr.forEach(function (val) {
                set.add(val);
            });
            shape.assign(set, [
                'a',
                'a',
                'c'
            ]);
            assertSetMatchesArray(set, [
                'a',
                'b',
                'c'
            ], '.assign');
        });
    }
    if (typeof WeakSet !== 'undefined') {
        QUnit.module('can-reflect/types/set WeakSet');
        QUnit.test('isListLike', function () {
            QUnit.ok(type.isListLike(new WeakSet()), 'isListLike');
            QUnit.ok(type.isMoreListLikeThanMapLike(new WeakSet()), 'isMoreListLikeThanMapLike');
        });
        QUnit.test('shape.each', function () {
            var arr = [
                {},
                {}
            ];
            var set = new WeakSet(arr);
            try {
                shape.each(set, function () {
                });
            } catch (e) {
                QUnit.ok(true, 'Error ' + e.message);
            }
        });
        QUnit.test('shape.update', function () {
            var a = {}, b = {}, c = {};
            var set = new WeakSet([
                a,
                b
            ]);
            try {
                shape.update(set, [
                    a,
                    a,
                    c
                ]);
            } catch (e) {
                QUnit.ok(true, 'Error ' + e.message);
            }
        });
        QUnit.test('shape.assign', function () {
            var a = {}, b = {}, c = {};
            var set = new WeakSet([
                a,
                b
            ]);
            shape.assign(set, [
                a,
                a,
                c
            ]);
            QUnit.ok(set.has(a));
            QUnit.ok(set.has(b));
            QUnit.ok(set.has(c));
        });
    }
});
/*can-reflect@1.17.5#can-reflect-test*/
define('can-reflect@1.17.5#can-reflect-test', [
    'require',
    'exports',
    'module',
    './reflections/get-name/get-name-test',
    './reflections/type/type-test',
    './reflections/shape/shape-test',
    './reflections/get-set/get-set-test',
    './reflections/call/call-test',
    './reflections/observe/observe-test',
    './types/map-test',
    './types/set-test',
    './can-reflect'
], function (require, exports, module) {
    require('./reflections/get-name/get-name-test');
    require('./reflections/type/type-test');
    require('./reflections/shape/shape-test');
    require('./reflections/get-set/get-set-test');
    require('./reflections/call/call-test');
    require('./reflections/observe/observe-test');
    require('./types/map-test');
    require('./types/set-test');
    require('./can-reflect');
});
/*can-reflect-promise@1.1.5#test/can-reflect-promise_test*/
define('can-reflect-promise@1.1.5#test/can-reflect-promise_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-util/js/global/global',
    'can-symbol',
    'can-reflect-promise'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var QUnit = require('steal-qunit');
        var GLOBAL = require('can-util/js/global/global');
        var canSymbol = require('can-symbol');
        var canReflectPromise = require('can-reflect-promise');
        var nativePromise = GLOBAL().Promise;
        var Promise;
        QUnit.module('can-reflect-promise', {
            setup: function () {
                function tempPromise() {
                    if ('Reflect' in GLOBAL() && typeof GLOBAL().Reflect.construct === 'function') {
                        return GLOBAL().Reflect.construct(nativePromise, arguments, tempPromise);
                    } else {
                        nativePromise.apply(this, arguments);
                        return this;
                    }
                }
                [
                    'resolve',
                    'reject'
                ].forEach(function (key) {
                    if (~nativePromise[key].toString().indexOf('[native code]')) {
                        tempPromise[key] = nativePromise[key];
                    } else {
                        tempPromise[key] = new Function('value', 'return new this(function(resolve, reject) { ' + key + '(value); });');
                    }
                });
                var protoDefs = {};
                protoDefs[canSymbol.for('can.observeData')] = {
                    value: null,
                    writable: true,
                    configurable: true
                };
                protoDefs[canSymbol.for('can.getKeyValue')] = {
                    value: null,
                    writable: true,
                    configurable: true
                };
                tempPromise.prototype = Object.create(nativePromise.prototype, protoDefs);
                Promise = tempPromise;
            },
            teardown: function () {
                Promise = null;
            }
        });
        QUnit.test('decorates promise', function () {
            QUnit.ok(!Promise.prototype[canSymbol.for('can.getKeyValue')], 'no decoration');
            canReflectPromise(new Promise(function () {
            }));
            QUnit.ok(Promise.prototype[canSymbol.for('can.getKeyValue')], 'has decoration');
        });
        QUnit.test('has all necessary symbols', function () {
            var p = new Promise(function () {
            });
            canReflectPromise(p);
            QUnit.ok(p[canSymbol.for('can.getKeyValue')], 'can.getKeyValue');
            QUnit.ok(p[canSymbol.for('can.getValue')], 'can.getValue');
            QUnit.ok(p[canSymbol.for('can.onValue')], 'can.onValue');
            QUnit.ok(p[canSymbol.for('can.onKeyValue')], 'can.onKeyValue');
            QUnit.equal(p[canSymbol.for('can.isValueLike')], false, 'can.isValueLike');
        });
        QUnit.test('getKeyValue for promise-specific values', 8, function () {
            var p = Promise.resolve('a');
            canReflectPromise(p);
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isPending'), true, 'isPending true in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isResolved'), false, 'isResolved false in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('value'), undefined, 'no value in sync');
            QUnit.equal(p[canSymbol.for('can.getKeyValue')]('state'), 'pending', 'state pending in sync');
            stop();
            setTimeout(function () {
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('value'), 'a', 'value in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isPending'), false, 'isPending false in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('isResolved'), true, 'isResolved true in async');
                QUnit.equal(p[canSymbol.for('can.getKeyValue')]('state'), 'resolved', 'state resolved in async');
                start();
            }, 10);
        });
        QUnit.test('onKeyValue for promise-specific values', 3, function () {
            stop(3);
            var p = Promise.resolve('a');
            canReflectPromise(p);
            p[canSymbol.for('can.onKeyValue')]('value', function (newVal) {
                QUnit.equal(newVal, 'a', 'value updates on event');
                start();
            });
            p[canSymbol.for('can.onKeyValue')]('isResolved', function (newVal) {
                QUnit.equal(newVal, true, 'isResolved updates on event');
                start();
            });
            p[canSymbol.for('can.onKeyValue')]('state', function (newVal) {
                QUnit.equal(newVal, 'resolved', 'state updates on event');
                start();
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-ajax@1.4.0#can-ajax*/
define('can-ajax@1.4.0#can-ajax', [
    'require',
    'exports',
    'module',
    'can-globals/global/global',
    'can-reflect',
    'can-namespace',
    'can-parse-uri',
    'can-param'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Global = require('can-globals/global/global');
        var canReflect = require('can-reflect');
        var namespace = require('can-namespace');
        var parseURI = require('can-parse-uri');
        var param = require('can-param');
        var xhrs = [
                function () {
                    return new XMLHttpRequest();
                },
                function () {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
                },
                function () {
                    return new ActiveXObject('MSXML2.XMLHTTP');
                }
            ], _xhrf = null;
        var originUrl = parseURI(Global().location.href);
        var globalSettings = {};
        var makeXhr = function () {
            if (_xhrf != null) {
                return _xhrf();
            }
            for (var i = 0, l = xhrs.length; i < l; i++) {
                try {
                    var f = xhrs[i], req = f();
                    if (req != null) {
                        _xhrf = f;
                        return req;
                    }
                } catch (e) {
                    continue;
                }
            }
            return function () {
            };
        };
        var contentTypes = {
            json: 'application/json',
            form: 'application/x-www-form-urlencoded'
        };
        var _xhrResp = function (xhr, options) {
            switch (options.dataType || xhr.getResponseHeader('Content-Type').split(';')[0]) {
            case 'text/xml':
            case 'xml':
                return xhr.responseXML;
            case 'text/json':
            case 'application/json':
            case 'text/javascript':
            case 'application/javascript':
            case 'application/x-javascript':
            case 'json':
                return xhr.responseText && JSON.parse(xhr.responseText);
            default:
                return xhr.responseText;
            }
        };
        function ajax(o) {
            var xhr = makeXhr(), timer, n = 0;
            var deferred = {}, isFormData;
            var promise = new Promise(function (resolve, reject) {
                deferred.resolve = resolve;
                deferred.reject = reject;
            });
            var requestUrl;
            promise.abort = function () {
                xhr.abort();
            };
            o = [
                {
                    userAgent: 'XMLHttpRequest',
                    lang: 'en',
                    type: 'GET',
                    data: null,
                    dataType: 'json'
                },
                globalSettings,
                o
            ].reduce(function (a, b, i) {
                return canReflect.assignDeep(a, b);
            });
            var async = o.async !== false;
            if (!o.contentType) {
                o.contentType = o.type.toUpperCase() === 'GET' ? contentTypes.form : contentTypes.json;
            }
            if (o.crossDomain == null) {
                try {
                    requestUrl = parseURI(o.url);
                    o.crossDomain = !!(requestUrl.protocol && requestUrl.protocol !== originUrl.protocol || requestUrl.host && requestUrl.host !== originUrl.host);
                } catch (e) {
                    o.crossDomain = true;
                }
            }
            if (o.timeout) {
                timer = setTimeout(function () {
                    xhr.abort();
                    if (o.timeoutFn) {
                        o.timeoutFn(o.url);
                    }
                }, o.timeout);
            }
            xhr.onreadystatechange = function () {
                try {
                    if (xhr.readyState === 4) {
                        if (timer) {
                            clearTimeout(timer);
                        }
                        if (xhr.status < 300) {
                            if (o.success) {
                                o.success(_xhrResp(xhr, o));
                            }
                        } else if (o.error) {
                            o.error(xhr, xhr.status, xhr.statusText);
                        }
                        if (o.complete) {
                            o.complete(xhr, xhr.statusText);
                        }
                        if (xhr.status >= 200 && xhr.status < 300) {
                            deferred.resolve(_xhrResp(xhr, o));
                        } else {
                            deferred.reject(xhr);
                        }
                    } else if (o.progress) {
                        o.progress(++n);
                    }
                } catch (e) {
                    deferred.reject(e);
                }
            };
            var url = o.url, data = null, type = o.type.toUpperCase();
            var isJsonContentType = o.contentType === contentTypes.json;
            var isPost = type === 'POST' || type === 'PUT';
            if (!isPost && o.data) {
                url += '?' + (isJsonContentType ? JSON.stringify(o.data) : param(o.data));
            }
            xhr.open(type, url, async);
            var isSimpleCors = o.crossDomain && [
                'GET',
                'POST',
                'HEAD'
            ].indexOf(type) !== -1;
            isFormData = typeof FormData !== 'undefined' && o.data instanceof FormData;
            if (isPost) {
                if (isFormData) {
                    data = o.data;
                } else {
                    data = isJsonContentType && !isSimpleCors ? typeof o.data === 'object' ? JSON.stringify(o.data) : o.data : param(o.data);
                }
                var setContentType = isJsonContentType && !isSimpleCors ? 'application/json' : 'application/x-www-form-urlencoded';
                xhr.setRequestHeader('Content-Type', setContentType);
            } else {
                xhr.setRequestHeader('Content-Type', o.contentType);
            }
            if (!isSimpleCors) {
                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
            }
            if (o.xhrFields) {
                for (var f in o.xhrFields) {
                    xhr[f] = o.xhrFields[f];
                }
            }
            xhr.send(data);
            return promise;
        }
        module.exports = namespace.ajax = ajax;
        module.exports.ajaxSetup = function (o) {
            globalSettings = o || {};
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-make-map@1.2.0#can-make-map*/
define('can-make-map@1.2.0#can-make-map', function (require, exports, module) {
    'use strict';
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        items.forEach(function (name) {
            obj[name] = true;
        });
        return obj;
    }
    module.exports = makeMap;
});
/*can-ajax@1.4.0#test/qunit*/
define('can-ajax@1.4.0#test/qunit', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    'use strict';
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isMochaQUnitUI = testType === 'mocha';
    var isQunit = testType === 'qunit';
    if (isMochaQUnitUI) {
        QUnit.assert.async = function () {
            QUnit.stop();
            return function done(error) {
                if (error) {
                    return QUnit.ok(false, '' + error);
                }
                QUnit.start();
            };
        };
        QUnit.test = test;
        module.exports = QUnit;
    } else if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-ajax@1.4.0#test/helpers*/
define('can-ajax@1.4.0#test/helpers', [
    'require',
    'exports',
    'module',
    'can-globals/global/global'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var getGlobal = require('can-globals/global/global');
        function isProduction() {
            var root = getGlobal();
            if (root.System) {
                return root.System.env.indexOf('production') !== -1;
            }
            if (root.process) {
                var nodeEnv = root.process.env.NODE_ENV;
                return nodeEnv === 'production' || nodeEnv === 'window-production';
            }
            return false;
        }
        function isServer() {
            var root = getGlobal();
            var testType = root.process && root.process.env.TEST;
            return testType === 'qunit';
        }
        module.exports = {
            isProduction: isProduction,
            isServer: isServer
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-ajax@1.4.0#can-ajax-test*/
define('can-ajax@1.4.0#can-ajax-test', [
    'require',
    'exports',
    'module',
    './can-ajax',
    'can-namespace',
    'can-make-map',
    'can-globals/global/global',
    'can-parse-uri',
    './test/qunit',
    './test/helpers'
], function (require, exports, module) {
    (function (global, __dirname, require, exports, module) {
        'use strict';
        var ajax = require('./can-ajax');
        var namespace = require('can-namespace');
        var makeMap = require('can-make-map');
        var GLOBAL = require('can-globals/global/global');
        var parseURI = require('can-parse-uri');
        var QUnit = require('./test/qunit');
        var helpers = require('./test/helpers');
        var isMainCanTest = typeof System === 'object' && System.env !== 'canjs-test';
        var hasLocalServer = !helpers.isServer() && !helpers.isProduction();
        QUnit.module('can-ajax');
        var makeFixture = function (XHR) {
            var oldXhr = window.XMLHttpRequest || window.ActiveXObject;
            if (window.XMLHttpRequest) {
                window.XMLHttpRequest = XHR;
            } else if (window.ActiveXObject) {
                window.ActiveXObject = XHR;
            }
            return function restoreXHR() {
                if (window.XMLHttpRequest) {
                    window.XMLHttpRequest = oldXhr;
                } else if (window.ActiveXObject) {
                    window.ActiveXObject = oldXhr;
                }
            };
        };
        var makePredicateContains = function (str) {
            var obj = makeMap(str);
            return function (val) {
                return obj[val];
            };
        };
        if (hasLocalServer) {
            QUnit.test('basic get request', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json'
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
            QUnit.test('synchronous get request', function (assert) {
                var done = assert.async();
                var ok = true;
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json',
                    async: false,
                    success: function () {
                        assert.ok(ok, 'Callback happens before returning.');
                    }
                }).then(function () {
                    assert.ok(!ok, 'Promise resolves after returning');
                    done();
                });
                ok = false;
            });
        }
        QUnit.test('added to namespace (#99)', function (assert) {
            assert.equal(namespace.ajax, ajax);
        });
        if (hasLocalServer) {
            QUnit.test('GET requests with dataType parse JSON (#106)', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.txt',
                    dataType: 'json'
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
        QUnit.test('ignores case of type parameter for a post request (#100)', function (assert) {
            var done = assert.async();
            var requestHeaders = { CONTENT_TYPE: 'Content-Type' }, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === requestHeaders.CONTENT_TYPE) {
                            var o = {};
                            o[header] = value;
                            this.responseText = JSON.stringify(o);
                        }
                    };
                });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { bar: 'qux' }
            }).then(function (value) {
                assert.equal(value[requestHeaders.CONTENT_TYPE], 'application/x-www-form-urlencoded');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('url encodes GET requests when no contentType', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' }
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                assert.equal(value.data, undefined, 'No data provided because it\'s a GET');
                assert.equal(value.url, 'http://anotherdomain.com/foo?foo=bar');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('Stringifies GET requests when contentType=application/json', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'get',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/json'
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.data, undefined, 'No data provided because it\'s a GET');
                assert.equal(value.url, 'http://anotherdomain.com/foo?{"foo":"bar"}');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('Stringifies POST requests when there is no contentType', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            var origin = parseURI(GLOBAL().location.href);
            var url = origin.protocol + origin.authority + '/foo';
            ajax({
                type: 'post',
                url: url,
                data: { foo: 'bar' }
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.data, '{"foo":"bar"}', 'Data was stringified');
                assert.equal(value.url, url);
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('url encodes POST requests when contentType=application/x-www-form-urlencoded', function (assert) {
            var done = assert.async();
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            ajax({
                type: 'post',
                url: 'http://anotherdomain.com/foo',
                data: { foo: 'bar' },
                contentType: 'application/x-www-form-urlencoded'
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/x-www-form-urlencoded');
                assert.equal(value.data, 'foo=bar', 'Data was url encoded');
                assert.equal(value.url, 'http://anotherdomain.com/foo');
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        if (typeof XDomainRequest === 'undefined') {
            if (!helpers.isServer()) {
                QUnit.test('cross domain post request should change data to form data (#90)', function (assert) {
                    var done = assert.async();
                    ajax({
                        type: 'POST',
                        url: 'http://httpbin.org/post',
                        data: { 'message': 'VALUE' },
                        dataType: 'application/json'
                    }).then(function (resp) {
                        assert.equal(resp.form.message, 'VALUE');
                        done();
                    });
                });
            }
            QUnit.test('GET CORS should be a simple request - without a preflight (#187)', function (assert) {
                var done = assert.async();
                var isSimpleRequest = true, restore;
                var isSimpleMethod = makePredicateContains('GET,POST,HEAD');
                var isSimpleHeader = makePredicateContains('Accept,Accept-Language,Content-Language,Content-Type,DPR,Downlink,Save-Data,Viewport-Width,Width');
                var isSimpleContentType = makePredicateContains('application/x-www-form-urlencoded,multipart/form-data,text/plain');
                restore = makeFixture(function () {
                    this.open = function (type, url) {
                        if (!isSimpleMethod(type)) {
                            isSimpleRequest = false;
                        }
                    };
                    var response = {};
                    this.send = function () {
                        this.responseText = JSON.stringify(response);
                        this.readyState = 4;
                        this.status = 200;
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        if (header === 'Content-Type' && !isSimpleContentType(value)) {
                            isSimpleRequest = false;
                        }
                        if (isSimpleRequest && !isSimpleHeader(header)) {
                            isSimpleRequest = false;
                        }
                        response[header] = value;
                    };
                });
                ajax({
                    url: 'http://query.yahooapis.com/v1/public/yql',
                    data: {
                        q: 'select * from geo.places where text="sunnyvale, ca"',
                        format: 'json'
                    }
                }).then(function (response) {
                    assert.ok(isSimpleRequest, 'CORS GET is simple');
                    restore();
                    done();
                }, function (err) {
                    assert.ok(false, 'Should be resolved');
                    restore();
                    done();
                });
            });
        }
        if (isMainCanTest && hasLocalServer) {
            QUnit.test('abort', function (assert) {
                var done = assert.async();
                var promise = ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.json'
                });
                promise.catch(function (xhr) {
                    if (xhr instanceof Error) {
                        assert.equal(xhr.message, 'Could not complete the operation due to error c00c023f.');
                        done();
                    } else {
                        setTimeout(function () {
                            assert.equal(xhr.readyState, 0, 'aborts the promise');
                            done();
                        }, 50);
                    }
                });
                promise.abort();
            });
        }
        QUnit.test('crossDomain is true for relative requests', function (assert) {
            var done = assert.async();
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 200;
                        this.responseText = JSON.stringify({ great: 'success' });
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'post',
                url: '/foo',
                data: { bar: 'qux' },
                dataType: 'json'
            }).then(function (value) {
                assert.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        QUnit.test('handles 204 No Content responses when expecting JSON', function (assert) {
            var done = assert.async();
            var headers = {}, restore = makeFixture(function () {
                    this.open = function (type, url) {
                    };
                    this.send = function () {
                        this.readyState = 4;
                        this.status = 204;
                        this.responseText = '';
                        this.onreadystatechange();
                    };
                    this.setRequestHeader = function (header, value) {
                        headers[header] = value;
                    };
                });
            ajax({
                type: 'delete',
                url: '/foo',
                data: { id: 'qux' },
                dataType: 'json'
            }).then(function () {
                assert.deepEqual(headers, {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                });
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
        if (hasLocalServer) {
            QUnit.test('correctly serializes null and undefined values (#177)', function (assert) {
                var done = assert.async();
                ajax({
                    type: 'get',
                    url: __dirname + '/can-ajax-test-result.txt',
                    data: { foo: null }
                }).then(function (resp) {
                    assert.equal(resp.message, 'VALUE');
                    done();
                });
            });
        }
        QUnit.test('It doesn\'t stringify FormData', function (assert) {
            var done = assert.async();
            var headers = {};
            var formData = new FormData();
            formData.append('foo', 'bar');
            var restore = makeFixture(function () {
                var o = {};
                this.open = function (type, url) {
                    o.url = url;
                };
                this.send = function (data) {
                    o.data = data;
                    this.readyState = 4;
                    this.status = 200;
                    this.responseText = JSON.stringify(o);
                    this.onreadystatechange();
                };
                this.setRequestHeader = function (header, value) {
                    if (header === 'Content-Type') {
                        o[header] = value;
                    }
                };
            });
            var origin = parseURI(GLOBAL().location.href);
            var url = origin.protocol + origin.authority + '/foo';
            ajax({
                type: 'post',
                url: url,
                data: formData
            }).then(function (value) {
                assert.equal(value['Content-Type'], 'application/json');
                assert.equal(value.url, url);
            }, function (reason) {
                assert.notOk(reason, 'request failed with reason = ', reason);
            }).then(function () {
                restore();
                done();
            });
        });
    }(function () {
        return this;
    }(), '/', require, exports, module));
});
/*can-globals@1.2.0#test-wrapper*/
define('can-globals@1.2.0#test-wrapper', [
    'require',
    'exports',
    'module',
    'qunitjs',
    'steal-qunit'
], function (require, exports, module) {
    'use strict';
    var testType = typeof process !== 'undefined' && process.env.TEST;
    var isMochaQUnitUI = testType === 'mocha';
    var isQunit = testType === 'qunit';
    if (isMochaQUnitUI) {
        QUnit.assert.async = function () {
            QUnit.stop();
            return function done(error) {
                if (error) {
                    return QUnit.ok(false, '' + error);
                }
                QUnit.start();
            };
        };
        QUnit.test = test;
        module.exports = QUnit;
    } else if (isQunit) {
        module.exports = require('qunitjs');
    } else {
        module.exports = require('steal-qunit');
    }
});
/*can-globals@1.2.0#spy*/
define('can-globals@1.2.0#spy', function (require, exports, module) {
    'use strict';
    function spy(value) {
        var fn;
        var calls = [];
        if (typeof value === 'function') {
            fn = value;
        } else {
            fn = function () {
                return value;
            };
        }
        function wrapper() {
            var args = Array.prototype.slice.call(arguments);
            var ret = fn.apply(this, args);
            calls.push({
                calledWith: args,
                returned: ret
            });
            return ret;
        }
        Object.defineProperties(wrapper, {
            reset: {
                value: function () {
                    calls = [];
                }
            },
            callCount: {
                get: function () {
                    return calls.length;
                }
            },
            calls: {
                get: function () {
                    return calls;
                }
            }
        });
        return wrapper;
    }
    module.exports = spy;
});
/*can-globals@1.2.0#can-globals-test*/
define('can-globals@1.2.0#can-globals-test', [
    'require',
    'exports',
    'module',
    './can-globals-proto',
    './test-wrapper',
    './spy'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var Globals = require('./can-globals-proto');
        var QUnit = require('./test-wrapper');
        var spy = require('./spy');
        var globals;
        function mapEvents(spy) {
            return spy.calls.reduce(function (acc, cur) {
                return acc.concat(cur.calledWith[0]);
            }, []);
        }
        function loop(fn, count, ctx) {
            for (var i = count; i > 0; i--) {
                if (ctx) {
                    fn.call(ctx, i);
                    continue;
                }
                fn(i);
            }
        }
        QUnit.module('can-globals/can-globals-proto');
        QUnit.test('getKeyValue of undefined property', function () {
            globals = new Globals();
            globals.getKeyValue('test');
            ok(true);
        });
        QUnit.test('setKeyValue of undefined property', function () {
            globals = new Globals();
            globals.setKeyValue('foo', 'bar');
            equal(globals.getKeyValue('foo'), 'bar');
        });
        QUnit.test('deleteKeyValue of undefined property', function () {
            globals = new Globals();
            globals.deleteKeyValue('test');
            ok(true);
        });
        QUnit.test('onKeyValue of undefined property', function () {
            globals = new Globals();
            globals.onKeyValue('test', function () {
            });
            ok(true);
            globals.offKeyValue('test');
        });
        QUnit.test('offKeyValue of undefined property', function () {
            globals = new Globals();
            globals.offKeyValue('test', function () {
            });
            ok(true);
        });
        QUnit.test('makeExport of undefined property', function () {
            globals = new Globals();
            globals.makeExport('test');
            ok(true);
        });
        QUnit.test('define with cache disabled', function () {
            var getter = spy('bar');
            globals = new Globals();
            globals.define('foo', getter, false);
            loop(function () {
                globals.getKeyValue('foo');
            }, 5);
            equal(getter.callCount, 5);
        });
        QUnit.test('define with cache enabled', function () {
            var getter = spy('bar');
            globals = new Globals();
            globals.define('foo', getter);
            loop(function () {
                globals.getKeyValue('foo');
            }, 5);
            equal(getter.callCount, 1);
        });
        QUnit.test('define and get a new property', function () {
            globals = new Globals();
            globals.define('test', 'default');
            equal(globals.getKeyValue('test'), 'default');
        });
        QUnit.test('setKeyValue of existing property to string', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', 'updated');
            equal(globals.getKeyValue('test'), 'updated');
        });
        QUnit.test('setKeyValue of existing property to undefined', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', undefined);
            equal(globals.getKeyValue('test'), undefined);
        });
        QUnit.test('setKeyValue of existing property to a function', function () {
            globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', function () {
                return 'foo';
            });
            equal(globals.getKeyValue('test'), 'foo');
        });
        QUnit.test('setKeyValue on an existing property should reset cache', function () {
            var globals = new Globals();
            var bar = function () {
                return 'bar';
            };
            globals.define('foo', bar);
            globals.getKeyValue('foo');
            globals.setKeyValue('foo', function () {
                return 'baz';
            });
            equal(globals.getKeyValue('foo'), 'baz');
        });
        QUnit.test('deleteKeyValue to reset property to default', function () {
            var globals = new Globals();
            globals.define('test', 'default');
            globals.setKeyValue('test', 'updated');
            globals.deleteKeyValue('test');
            equal(globals.getKeyValue('test'), 'default');
        });
        QUnit.test('deleteKeyValue should clear cache', function () {
            var globals = new Globals();
            var bar = spy('bar');
            globals.define('foo', bar);
            globals.getKeyValue('foo');
            globals.setKeyValue('foo', function () {
                return 'baz';
            });
            globals.deleteKeyValue('foo');
            globals.getKeyValue('foo');
            equal(bar.callCount, 2);
        });
        QUnit.test('listen for key change', function () {
            var globals = new Globals();
            var handler = spy();
            globals.define('test', 'default');
            globals.define('foo', 'bar');
            globals.onKeyValue('test', handler);
            globals.setKeyValue('test', 'updated');
            globals.setKeyValue('foo', 'baz');
            globals.deleteKeyValue('test');
            equal(handler.callCount, 2);
            deepEqual(mapEvents(handler), [
                'updated',
                'default'
            ]);
            globals.offKeyValue('test');
        });
        QUnit.test('remove event listener for key', function () {
            var globals = new Globals();
            var handler = spy();
            globals.define('test', 'foo');
            globals.onKeyValue('test', handler);
            globals.offKeyValue('test', handler);
            globals.setKeyValue('test', 'updated');
            equal(handler.callCount, 0);
        });
        QUnit.test('makeExport of key', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            var e = globals.makeExport('foo');
            equal(e(), 'bar');
            e('baz');
            equal(e(), 'baz');
            e(undefined);
            equal(e(), 'bar');
        });
        QUnit.test('reset export value with null (can-stache#288)', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            var e = globals.makeExport('foo');
            equal(e(), 'bar');
            e('baz');
            equal(e(), 'baz');
            e(null);
            equal(e(), 'bar');
        });
        QUnit.test('reset cleares cache on all keys', function () {
            var globals = new Globals();
            var bar = spy('bar');
            var qux = spy('qux');
            globals.define('foo', bar);
            globals.define('baz', qux);
            loop(function () {
                globals.getKeyValue('foo');
                globals.getKeyValue('baz');
            }, 5);
            globals.reset();
            loop(function () {
                globals.getKeyValue('foo');
                globals.getKeyValue('baz');
            }, 5);
            equal(bar.callCount, 2);
            equal(qux.callCount, 2);
        });
        QUnit.test('reset should reset all keys to default value (#31)', function () {
            var globals = new Globals();
            globals.define('foo', 'bar');
            globals.define('baz', 'qux');
            globals.setKeyValue('foo', 'red');
            globals.setKeyValue('baz', 'green');
            globals.reset();
            equal(globals.getKeyValue('foo'), 'bar');
            equal(globals.getKeyValue('baz'), 'qux');
        });
        QUnit.test('reset triggers events', function () {
            var globals = new Globals();
            var fooHandler = spy();
            var barHandler = spy();
            globals.define('foo', true);
            globals.define('bar', true);
            globals.setKeyValue('foo', false);
            globals.setKeyValue('bar', false);
            globals.onKeyValue('foo', fooHandler);
            globals.onKeyValue('bar', barHandler);
            globals.reset();
            equal(fooHandler.callCount, 1);
            equal(barHandler.callCount, 1);
            globals.offKeyValue('foo');
            globals.offKeyValue('bar');
        });
        QUnit.test('export helper value can be set to a function', function () {
            var globals = new Globals();
            var foo = spy();
            globals.setKeyValue('foo', function () {
                return function () {
                };
            });
            var fooExport = globals.makeExport('foo');
            fooExport(foo);
            QUnit.equal(typeof fooExport(), 'function');
            QUnit.equal(foo.callCount, 0);
            fooExport()();
            QUnit.equal(foo.callCount, 1);
        });
        QUnit.test('onKeyValue should dispatch the resolved value (#29)', function () {
            var globals = new Globals();
            var foo = 'foo';
            globals.define('foo', '');
            globals.onKeyValue('foo', function (value) {
                QUnit.equal(value, foo);
            });
            globals.setKeyValue('foo', function () {
                return foo;
            });
            globals.offKeyValue('foo');
        });
        QUnit.test('onKeyValue should not trigger multiple calls of the value function (#33)', function () {
            var globals = new Globals();
            var baz = spy('baz');
            globals.define('foo', 'bar');
            globals.onKeyValue('foo', function () {
            });
            globals.setKeyValue('foo', baz);
            globals.getKeyValue('foo');
            equal(baz.callCount, 1);
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-define-lazy-value@1.1.0#define-lazy-value-test*/
define('can-define-lazy-value@1.1.0#define-lazy-value-test', [
    'steal-qunit',
    './define-lazy-value'
], function (_stealQunit, _defineLazyValue) {
    'use strict';
    var _stealQunit2 = _interopRequireDefault(_stealQunit);
    var _defineLazyValue2 = _interopRequireDefault(_defineLazyValue);
    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
    }
    _stealQunit2.default.module('can-define-lazy-value');
    _stealQunit2.default.test('docs', function () {
        var _id = 1;
        function getId() {
            return _id++;
        }
        function MyObj(name) {
            this.name = name;
        }
        (0, _defineLazyValue2.default)(MyObj.prototype, 'id', getId);
        var obj1 = new MyObj('obj1');
        var obj2 = new MyObj('obj2');
        _stealQunit2.default.equal(obj2.id, 1, 'first object read should get id 1');
        _stealQunit2.default.equal(obj1.id, 2, 'second object read should get id 2');
        try {
            obj1.id = 3;
        } catch (e) {
            _stealQunit2.default.ok(true, 'obj1.id should not be writable by default');
        }
        (0, _defineLazyValue2.default)(MyObj.prototype, 'id', getId, true);
        var obj3 = new MyObj('obj3');
        _stealQunit2.default.equal(obj3.id, 3, 'obj3 should have id');
        obj3.id = 4;
        _stealQunit2.default.equal(obj3.id, 4, 'obj3.id should be writeable');
    });
});
/*can-assign@1.3.1#can-assign-test*/
define('can-assign@1.3.1#can-assign-test', [
    'require',
    'exports',
    'module',
    './can-assign',
    'steal-qunit'
], function (require, exports, module) {
    var assign = require('./can-assign');
    var QUnit = require('steal-qunit');
    QUnit.module('can-assign');
    QUnit.test('Assign all properties to an object', function () {
        var a = {
            a: 1,
            b: 2,
            d: 3
        };
        var b = {
            a: 1,
            b: 3,
            c: 2
        };
        var expected = {
            a: 1,
            b: 3,
            c: 2,
            d: 3
        };
        var actual = assign(a, b);
        for (var prop in actual) {
            equal(expected[prop], actual[prop]);
        }
    });
    QUnit.test('Works with readonly properties', function () {
        var obj = {};
        Object.defineProperty(obj, 'a', {
            value: 'a',
            writable: false
        });
        Object.defineProperty(obj, 'b', {
            value: 'b',
            writable: true
        });
        Object.defineProperty(obj, 'c', {
            get: function () {
                return 'c';
            },
            set: function (value) {
                this.b = value;
            },
            configurable: true
        });
        try {
            assign(obj, {
                a: 'c',
                b: 'f',
                d: 'd'
            });
            QUnit.equal(obj.a, 'a');
            QUnit.equal(obj.b, 'f');
            QUnit.equal(obj.c, 'c');
            QUnit.equal(obj.d, 'd');
            assign(obj, { c: 'h' });
            QUnit.equal(obj.a, 'a');
            QUnit.equal(obj.b, 'h');
            QUnit.equal(obj.c, 'c');
            QUnit.equal(obj.d, 'd');
        } catch (err) {
            QUnit.ok(false, err);
        }
    });
});
/*can-dom-events@1.3.0#helpers/make-event-registry-test*/
define('can-dom-events@1.3.0#helpers/make-event-registry-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './make-event-registry'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var makeEventRegistry = require('./make-event-registry');
    unit.module('make-event-registry');
    unit.test('add should register the event with the given eventType', function (assert) {
        var eventType = 'boi';
        var registry = makeEventRegistry();
        var exampleEvent = {
            defaultEventType: 'cake',
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        registry.add(exampleEvent, eventType);
        assert.equal(registry.has(eventType), true, 'event should be registered at "' + eventType + '"');
    });
    unit.test('add should use the event\'s defaultEventType unless eventType is provided', function (assert) {
        var eventType = 'boi';
        var registry = makeEventRegistry();
        var exampleEvent = {
            defaultEventType: eventType,
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        registry.add(exampleEvent);
        assert.equal(registry.has(eventType), true, 'event should be registered at "' + eventType + '"');
    });
    unit.test('has should return whether an event is registered', function (assert) {
        var eventType = 'boi';
        var exampleEvent = {
            defaultEventType: eventType,
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var registry = makeEventRegistry();
        assert.equal(registry.has(eventType), false, 'initial registry should not have the event');
        var remove = registry.add(exampleEvent);
        assert.equal(registry.has(eventType), true, 'updated registry should have the event');
        remove();
        assert.equal(registry.has(eventType), false, 'empty registry should not have the event');
    });
    unit.test('get should return the register event', function (assert) {
        var eventType = 'boi';
        var exampleEvent = {
            defaultEventType: eventType,
            addEventListener: function () {
            },
            removeEventListener: function () {
            }
        };
        var registry = makeEventRegistry();
        assert.equal(registry.get(eventType), undefined, 'initial registry should not have the event');
        var remove = registry.add(exampleEvent);
        assert.equal(registry.get(eventType), exampleEvent, 'updated registry should have the event');
        remove();
        assert.equal(registry.get(eventType), undefined, 'empty registry should not have the event');
    });
});
/*can-dom-events@1.3.0#helpers/add-event-compat-test*/
define('can-dom-events@1.3.0#helpers/add-event-compat-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './add-event-compat',
    '../can-dom-events'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var addEvent = require('./add-event-compat');
    var domEvents = require('../can-dom-events');
    var oldDomEventsMock = function (addSpy, removeSpy) {
        return {
            addEventListener: function () {
                addSpy(this, arguments);
                this.addEventListener.apply(this, arguments);
            },
            removeEventListener: function () {
                removeSpy(this, arguments);
                this.removeEventListener.apply(this, arguments);
            },
            dispatch: function () {
            }
        };
    };
    unit.module('add-event-compat');
    var mockEvent = function (addSpy, removeSpy) {
        return {
            defaultEventType: 'boi',
            addEventListener: function (target, eventName, handler) {
                addSpy(this, arguments);
                this.addEventListener(target, 'boi2', handler);
            },
            removeEventListener: function (target, eventName, handler) {
                removeSpy(this, arguments);
                this.removeEventListener(target, 'boi2', handler);
            }
        };
    };
    unit.test('should work with the can-dom-events', function (assert) {
        assert.expect(1 + 2 * 4);
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi3';
        var hookSpy = function (context, args) {
            assert.equal(context, domEvents, 'real domEvents should be context');
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(domEvents, event, customEventType);
        domEvents.addEventListener(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        domEvents.removeEventListener(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should work with the can-dom-events (no custom event type)', function (assert) {
        assert.expect(1 + 2 * 4);
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi';
        var hookSpy = function (context, args) {
            assert.equal(context, domEvents, 'real domEvents should be context');
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(domEvents, event);
        domEvents.addEventListener(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        domEvents.removeEventListener(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should work with the can-util/dom/events', function (assert) {
        assert.expect(1 + 2 * (2 + 3));
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi3';
        var eventsSpy = function (context, args) {
            var target = context;
            var eventType = args[0];
            var callback = args[1];
            if (eventType === customEventType) {
                assert.equal(target, input, 'input should be the target');
                assert.equal(callback, handler, 'callback should be the passed handler');
            }
        };
        var oldEvents = oldDomEventsMock(eventsSpy, eventsSpy);
        var hookSpy = function (context, args) {
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(oldEvents, event, customEventType);
        oldEvents.addEventListener.call(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        oldEvents.removeEventListener.call(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should work with the can-util/dom/events (no custom event type)', function (assert) {
        assert.expect(1 + 2 * (2 + 3));
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi';
        var eventsSpy = function (context, args) {
            var target = context;
            var eventType = args[0];
            var callback = args[1];
            if (eventType === customEventType) {
                assert.equal(target, input, 'input should be the target');
                assert.equal(callback, handler, 'callback should be the passed handler');
            }
        };
        var oldEvents = oldDomEventsMock(eventsSpy, eventsSpy);
        var hookSpy = function (context, args) {
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(hookSpy, hookSpy);
        var removeEvent = addEvent(oldEvents, event);
        oldEvents.addEventListener.call(input, customEventType, handler);
        domEvents.dispatch(input, 'boi2');
        oldEvents.removeEventListener.call(input, customEventType, handler);
        removeEvent();
    });
    unit.test('should not override can-util/dom/events twice for the same eventType', function (assert) {
        var done = assert.async();
        var input = document.createElement('input');
        var event = {
            addEventListener: function (target, eventType, handler) {
                target.addEventListener(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                target.removeEventListener(eventType, handler);
            }
        };
        var eventsSpy = function () {
        };
        var oldEvents = oldDomEventsMock(eventsSpy, eventsSpy);
        var removeEvent1 = addEvent(oldEvents, event, 'foo');
        var removeEvent2 = addEvent(oldEvents, event, 'foo');
        var handler = function () {
            removeEvent1();
            removeEvent2();
            assert.ok(true, 'This handler should only be called once');
            done();
        };
        oldEvents.addEventListener.call(input, 'foo', handler);
        domEvents.dispatch(input, 'foo');
        oldEvents.removeEventListener.call(input, 'foo', handler);
    });
});
/*jquery@3.4.0#dist/jquery*/
(function (global, factory) {
    'use strict';
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error('jQuery requires a window with a document');
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
}(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
    'use strict';
    var arr = [];
    var document = window.document;
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction = function isFunction(obj) {
        return typeof obj === 'function' && typeof obj.nodeType !== 'number';
    };
    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };
    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };
    function DOMEval(code, node, doc) {
        doc = doc || document;
        var i, val, script = doc.createElement('script');
        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {
                val = node[i] || node.getAttribute && node.getAttribute(i);
                if (val) {
                    script.setAttribute(i, val);
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
        if (obj == null) {
            return obj + '';
        }
        return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
    }
    var version = '3.4.0', jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context);
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function () {
            return slice.call(this);
        },
        get: function (num) {
            if (num == null) {
                return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
        },
        each: function (callback) {
            return jQuery.each(this, callback);
        },
        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function () {
            return this.eq(0);
        },
        last: function () {
            return this.eq(-1);
        },
        eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function () {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === 'boolean') {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== 'object' && !isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    copy = options[name];
                    if (name === '__proto__' || target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                        src = target[name];
                        if (copyIsArray && !Array.isArray(src)) {
                            clone = [];
                        } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                            clone = {};
                        } else {
                            clone = src;
                        }
                        copyIsArray = false;
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
        isReady: true,
        error: function (msg) {
            throw new Error(msg);
        },
        noop: function () {
        },
        isPlainObject: function (obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== '[object Object]') {
                return false;
            }
            proto = getProto(obj);
            if (!proto) {
                return true;
            }
            Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function (obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        globalEval: function (code, options) {
            DOMEval(code, { nonce: options && options.nonce });
        },
        each: function (obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function (text) {
            return text == null ? '' : (text + '').replace(rtrim, '');
        },
        makeArray: function (arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (; j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function (elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        support: support
    });
    if (typeof Symbol === 'function') {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {
        class2type['[object ' + name + ']'] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && 'length' in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) {
            return false;
        }
        return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
    }
    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                }
                return 0;
            }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length;
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i;
                    }
                }
                return -1;
            }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rdescend = new RegExp(whitespace + '|>'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                'ID': new RegExp('^#(' + identifier + ')'),
                'CLASS': new RegExp('^\\.(' + identifier + ')'),
                'TAG': new RegExp('^(' + identifier + '|[*])'),
                'ATTR': new RegExp('^' + attributes),
                'PSEUDO': new RegExp('^' + pseudos),
                'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
            }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                var high = '0x' + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
                if (asCodePoint) {
                    if (ch === '\0') {
                        return '\uFFFD';
                    }
                    return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
                }
                return '\\' + ch;
            }, unloadHandler = function () {
                setDocument();
            }, inDisabledFieldset = addCombinator(function (elem) {
                return elem.disabled === true && elem.nodeName.toLowerCase() === 'fieldset';
            }, {
                dir: 'parentNode',
                next: 'legend'
            });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els));
                } : function (target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !nonnativeSelectorCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== 'object')) {
                        newSelector = selector;
                        newContext = context;
                        if (nodeType === 1 && rdescend.test(selector)) {
                            if (nid = context.getAttribute('id')) {
                                nid = nid.replace(rcssescape, fcssescape);
                            } else {
                                context.setAttribute('id', nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            while (i--) {
                                groups[i] = '#' + nid + ' ' + toSelector(groups[i]);
                            }
                            newSelector = groups.join(',');
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector));
                            return results;
                        } catch (qsaError) {
                            nonnativeSelectorCache(selector, true);
                        } finally {
                            if (nid === expando) {
                                context.removeAttribute('id');
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, '$1'), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + ' ') > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + ' '] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var el = document.createElement('fieldset');
            try {
                return !!fn(el);
            } catch (e) {
                return false;
            } finally {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                }
                el = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split('|'), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return name === 'input' && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === 'input' || name === 'button') && elem.type === type;
            };
        }
        function createDisabledPseudo(disabled) {
            return function (elem) {
                if ('form' in elem) {
                    if (elem.parentNode && elem.disabled === false) {
                        if ('label' in elem) {
                            if ('label' in elem.parentNode) {
                                return elem.parentNode.disabled === disabled;
                            } else {
                                return elem.disabled === disabled;
                            }
                        }
                        return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                    }
                    return elem.disabled === disabled;
                } else if ('label' in elem) {
                    return elem.disabled === disabled;
                }
                return false;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument;
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== 'undefined' && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function (elem) {
            var namespace = elem.namespaceURI, docElem = (elem.ownerDocument || elem).documentElement;
            return !rhtml.test(namespace || docElem && docElem.nodeName || 'HTML');
        };
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
                if (subWindow.addEventListener) {
                    subWindow.addEventListener('unload', unloadHandler, false);
                } else if (subWindow.attachEvent) {
                    subWindow.attachEvent('onunload', unloadHandler);
                }
            }
            support.attributes = assert(function (el) {
                el.className = 'i';
                return !el.getAttribute('className');
            });
            support.getElementsByTagName = assert(function (el) {
                el.appendChild(document.createComment(''));
                return !el.getElementsByTagName('*').length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function (el) {
                docElem.appendChild(el).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        return elem.getAttribute('id') === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var elem = context.getElementById(id);
                        return elem ? [elem] : [];
                    }
                };
            } else {
                Expr.filter['ID'] = function (id) {
                    var attrId = id.replace(runescape, funescape);
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                        return node && node.value === attrId;
                    };
                };
                Expr.find['ID'] = function (id, context) {
                    if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                        var node, i, elems, elem = context.getElementById(id);
                        if (elem) {
                            node = elem.getAttributeNode('id');
                            if (node && node.value === id) {
                                return [elem];
                            }
                            elems = context.getElementsByName(id);
                            i = 0;
                            while (elem = elems[i++]) {
                                node = elem.getAttributeNode('id');
                                if (node && node.value === id) {
                                    return [elem];
                                }
                            }
                        }
                        return [];
                    }
                };
            }
            Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== 'undefined') {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === '*') {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function (el) {
                    docElem.appendChild(el).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                    if (el.querySelectorAll('[msallowcapture^=\'\']').length) {
                        rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                    }
                    if (!el.querySelectorAll('[selected]').length) {
                        rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                    }
                    if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
                        rbuggyQSA.push('~=');
                    }
                    if (!el.querySelectorAll(':checked').length) {
                        rbuggyQSA.push(':checked');
                    }
                    if (!el.querySelectorAll('a#' + expando + '+*').length) {
                        rbuggyQSA.push('.#.+[+~]');
                    }
                });
                assert(function (el) {
                    el.innerHTML = '<a href=\'\' disabled=\'disabled\'></a>' + '<select disabled=\'disabled\'><option/></select>';
                    var input = document.createElement('input');
                    input.setAttribute('type', 'hidden');
                    el.appendChild(input).setAttribute('name', 'D');
                    if (el.querySelectorAll('[name=d]').length) {
                        rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                    }
                    if (el.querySelectorAll(':enabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    docElem.appendChild(el).disabled = true;
                    if (el.querySelectorAll(':disabled').length !== 2) {
                        rbuggyQSA.push(':enabled', ':disabled');
                    }
                    el.querySelectorAll('*,:x');
                    rbuggyQSA.push(',.*:');
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (el) {
                    support.disconnectedMatch = matches.call(el, '*');
                    matches.call(el, '[s!=\'\']:x');
                    rbuggyMatches.push('!=', pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {
                    nonnativeSelectorCache(expr, true);
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.escape = function (sel) {
            return (sel + '').replace(rcssescape, fcssescape);
        };
        Sizzle.error = function (msg) {
            throw new Error('Syntax error, unrecognized expression: ' + msg);
        };
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function (elem) {
            var node, ret = '', i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === 'string') {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                '>': {
                    dir: 'parentNode',
                    first: true
                },
                ' ': { dir: 'parentNode' },
                '+': {
                    dir: 'previousSibling',
                    first: true
                },
                '~': { dir: 'previousSibling' }
            },
            preFilter: {
                'ATTR': function (match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                    if (match[2] === '~=') {
                        match[3] = ' ' + match[3] + ' ';
                    }
                    return match.slice(0, 4);
                },
                'CHILD': function (match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === 'nth') {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                        match[5] = +(match[7] + match[8] || match[3] === 'odd');
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                'PSEUDO': function (match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr['CHILD'].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || '';
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                'TAG': function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === '*' ? function () {
                        return true;
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                'CLASS': function (className) {
                    var pattern = classCache[className + ' '];
                    return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                    });
                },
                'ATTR': function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === '!=';
                        }
                        if (!operator) {
                            return true;
                        }
                        result += '';
                        return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                    };
                },
                'CHILD': function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode;
                    } : function (elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === 'only' && !start && 'nextSibling';
                                }
                                return true;
                            }
                            start = [forward ? parent.firstChild : parent.lastChild];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [
                                            dirruns,
                                            nodeIndex,
                                            diff
                                        ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [
                                                    dirruns,
                                                    diff
                                                ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                'PSEUDO': function (pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [
                            pseudo,
                            pseudo,
                            '',
                            argument
                        ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                'not': markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                'has': markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                'contains': markFunction(function (text) {
                    text = text.replace(runescape, funescape);
                    return function (elem) {
                        return (elem.textContent || getText(elem)).indexOf(text) > -1;
                    };
                }),
                'lang': markFunction(function (lang) {
                    if (!ridentifier.test(lang || '')) {
                        Sizzle.error('unsupported lang: ' + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function (elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                'target': function (elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                'root': function (elem) {
                    return elem === docElem;
                },
                'focus': function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                'enabled': createDisabledPseudo(false),
                'disabled': createDisabledPseudo(true),
                'checked': function (elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                },
                'selected': function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                'empty': function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                'parent': function (elem) {
                    return !Expr.pseudos['empty'](elem);
                },
                'header': function (elem) {
                    return rheader.test(elem.nodeName);
                },
                'input': function (elem) {
                    return rinputs.test(elem.nodeName);
                },
                'button': function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === 'button' || name === 'button';
                },
                'text': function (elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                },
                'first': createPositionalPseudo(function () {
                    return [0];
                }),
                'last': createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1];
                }),
                'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),
                'even': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'odd': createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument > length ? length : argument;
                    for (; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos['nth'] = Expr.pseudos['eq'];
        for (i in {
                radio: true,
                checkbox: true,
                file: true,
                password: true,
                image: true
            }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
                submit: true,
                reset: true
            }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, ' ')
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = '';
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === 'parentNode', doneName = done++;
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
                return false;
            } : function (elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [
                        dirruns,
                        doneName
                    ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if (skip && skip === elem.nodeName.toLowerCase()) {
                                elem = elem[dir] || elem;
                            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[key] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext;
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1;
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        checkContext = null;
                        return ret;
                    }];
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                    if (outermost) {
                        outermostContext = context === document || context || outermost;
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0;
                            if (!context && elem.ownerDocument !== document) {
                                setDocument(elem);
                                xml = !documentIsHTML;
                            }
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context || document, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--;
                            }
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        j = 0;
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml);
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results);
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }
                    return unmatched;
                };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function (el) {
            return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
        });
        if (!assert(function (el) {
                el.innerHTML = '<a href=\'#\'></a>';
                return el.firstChild.getAttribute('href') === '#';
            })) {
            addHandle('type|href|height|width', function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function (el) {
                el.innerHTML = '<input/>';
                el.firstChild.setAttribute('value', '');
                return el.firstChild.getAttribute('value') === '';
            })) {
            addHandle('value', function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function (el) {
                return el.getAttribute('disabled') == null;
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function (elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function (n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    ;
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier !== 'string') {
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            });
        }
        return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ':not(' + expr + ')';
        }
        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function (selector) {
            var i, ret, len = this.length, self = this;
            if (typeof selector !== 'string') {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            ret = this.pushStack([]);
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;
            if (!selector) {
                return this;
            }
            root = root || rootjQuery;
            if (typeof selector === 'string') {
                if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                    match = [
                        null,
                        selector,
                        null
                    ];
                } else {
                    match = rquickExpr.exec(selector);
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (isFunction(this[match])) {
                                    this[match](context[match]);
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }
                        return this;
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem) {
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);
                } else {
                    return this.constructor(context).find(selector);
                }
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;
            } else if (isFunction(selector)) {
                return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
            }
            return jQuery.makeArray(selector, this);
        };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== 'string' && jQuery(selectors);
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break;
                        }
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === 'string') {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function (selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur;
    }
    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, 'parentNode');
        },
        parentsUntil: function (elem, i, until) {
            return dir(elem, 'parentNode', until);
        },
        next: function (elem) {
            return sibling(elem, 'nextSibling');
        },
        prev: function (elem) {
            return sibling(elem, 'previousSibling');
        },
        nextAll: function (elem) {
            return dir(elem, 'nextSibling');
        },
        prevAll: function (elem) {
            return dir(elem, 'previousSibling');
        },
        nextUntil: function (elem, i, until) {
            return dir(elem, 'nextSibling', until);
        },
        prevUntil: function (elem, i, until) {
            return dir(elem, 'previousSibling', until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            if (typeof elem.contentDocument !== 'undefined') {
                return elem.contentDocument;
            }
            if (nodeName(elem, 'template')) {
                elem = elem.content || elem;
            }
            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== 'Until') {
                selector = until;
            }
            if (selector && typeof selector === 'string') {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function (options) {
        options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                locked = locked || options.once;
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {
                        if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }
                if (!options.memory) {
                    memory = false;
                }
                firing = false;
                if (locked) {
                    if (memory) {
                        list = [];
                    } else {
                        list = '';
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && toType(arg) !== 'string') {
                                    add(arg);
                                }
                            });
                        }(arguments));
                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },
                has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                },
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },
                disable: function () {
                    locked = queue = [];
                    list = memory = '';
                    return this;
                },
                disabled: function () {
                    return !list;
                },
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = '';
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [
                            context,
                            args.slice ? args.slice() : args
                        ];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },
                fired: function () {
                    return !!fired;
                }
            };
        return self;
    };
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
            if (value && isFunction(method = value.promise)) {
                method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
                method.call(value, resolve, reject);
            } else {
                resolve.apply(undefined, [value].slice(noValue));
            }
        } catch (value) {
            reject.apply(undefined, [value]);
        }
    }
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [
                    [
                        'notify',
                        'progress',
                        jQuery.Callbacks('memory'),
                        jQuery.Callbacks('memory'),
                        2
                    ],
                    [
                        'resolve',
                        'done',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        0,
                        'resolved'
                    ],
                    [
                        'reject',
                        'fail',
                        jQuery.Callbacks('once memory'),
                        jQuery.Callbacks('once memory'),
                        1,
                        'rejected'
                    ]
                ], state = 'pending', promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    'catch': function (fn) {
                        return promise.then(null, fn);
                    },
                    pipe: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && isFunction(returned.promise)) {
                                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + 'With'](this, fn ? [returned] : arguments);
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;
                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this, args = arguments, mightThrow = function () {
                                        var returned, then;
                                        if (depth < maxDepth) {
                                            return;
                                        }
                                        returned = handler.apply(that, args);
                                        if (returned === deferred.promise()) {
                                            throw new TypeError('Thenable self-resolution');
                                        }
                                        then = returned && (typeof returned === 'object' || typeof returned === 'function') && returned.then;
                                        if (isFunction(then)) {
                                            if (special) {
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                            } else {
                                                maxDepth++;
                                                then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                            }
                                        } else {
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    }, process = special ? mightThrow : function () {
                                        try {
                                            mightThrow();
                                        } catch (e) {
                                            if (jQuery.Deferred.exceptionHook) {
                                                jQuery.Deferred.exceptionHook(e, process.stackTrace);
                                            }
                                            if (depth + 1 >= maxDepth) {
                                                if (handler !== Thrower) {
                                                    that = undefined;
                                                    args = [e];
                                                }
                                                deferred.rejectWith(that, args);
                                            }
                                        }
                                    };
                                if (depth) {
                                    process();
                                } else {
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }
                        return jQuery.Deferred(function (newDefer) {
                            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                        }).promise();
                    },
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                }, deferred = {};
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function () {
                        state = stateString;
                    }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
                }
                list.add(tuple[3].fire);
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + 'With'](this === deferred ? undefined : this, arguments);
                    return this;
                };
                deferred[tuple[0] + 'With'] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function (singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!--remaining) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
                if (master.state() === 'pending' || isFunction(resolveValues[i] && resolveValues[i].then)) {
                    return master.then();
                }
            }
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function (error, stack) {
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn('jQuery.Deferred exception: ' + error.message, error.stack, stack);
        }
    };
    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function (fn) {
        readyList.then(fn).catch(function (error) {
            jQuery.readyException(error);
        });
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [jQuery]);
        }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
        document.removeEventListener('DOMContentLoaded', completed);
        window.removeEventListener('load', completed);
        jQuery.ready();
    }
    if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
        window.setTimeout(jQuery.ready);
    } else {
        document.addEventListener('DOMContentLoaded', completed);
        window.addEventListener('load', completed);
    }
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (toType(key) === 'object') {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        if (chainable) {
            return elems;
        }
        if (bulk) {
            return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(all, letter) {
        return letter.toUpperCase();
    }
    function camelCase(string) {
        return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        cache: function (owner) {
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function (owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === 'string') {
                cache[camelCase(data)] = value;
            } else {
                for (prop in data) {
                    cache[camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function (owner, key, value) {
            if (key === undefined || key && typeof key === 'string' && value === undefined) {
                return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key !== undefined) {
                if (Array.isArray(key)) {
                    key = key.map(camelCase);
                } else {
                    key = camelCase(key);
                    key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
                }
                i = key.length;
                while (i--) {
                    delete cache[key[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
        if (data === 'true') {
            return true;
        }
        if (data === 'false') {
            return false;
        }
        if (data === 'null') {
            return null;
        }
        if (data === +data + '') {
            return +data;
        }
        if (rbrace.test(data)) {
            return JSON.parse(data);
        }
        return data;
    }
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === 'string') {
                try {
                    data = getData(data);
                } catch (e) {
                }
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf('data-') === 0) {
                                    name = camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, 'hasDataAttrs', true);
                    }
                }
                return data;
            }
            if (typeof key === 'object') {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }
            return access(this, function (value) {
                var data;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                this.each(function () {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;
            if (elem) {
                type = (type || 'fx') + 'queue';
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function (elem, type) {
            type = type || 'fx';
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type);
                };
            if (fn === 'inprogress') {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === 'fx') {
                    queue.unshift('inprogress');
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function (elem, type) {
            var key = type + 'queueHooks';
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks('once memory').add(function () {
                    dataPriv.remove(elem, [
                        type + 'queue',
                        key
                    ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;
            if (typeof type !== 'string') {
                data = type;
                type = 'fx';
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === 'fx' && queue[0] !== 'inprogress') {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || 'fx', []);
        },
        promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    if (!--count) {
                        defer.resolveWith(elements, [elements]);
                    }
                };
            if (typeof type !== 'string') {
                obj = type;
                type = undefined;
            }
            type = type || 'fx';
            while (i--) {
                tmp = dataPriv.get(elements[i], type + 'queueHooks');
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');
    var cssExpand = [
        'Top',
        'Right',
        'Bottom',
        'Left'
    ];
    var documentElement = document.documentElement;
    var isAttached = function (elem) {
            return jQuery.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
    if (documentElement.attachShadow) {
        isAttached = function (elem) {
            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
    }
    var isHiddenWithinTree = function (elem, el) {
        elem = el || elem;
        return elem.style.display === 'none' || elem.style.display === '' && isAttached(elem) && jQuery.css(elem, 'display') === 'none';
    };
    var swap = function (elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function () {
                return tween.cur();
            } : function () {
                return jQuery.css(elem, prop, '');
            }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        if (display) {
            return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, 'display');
        temp.parentNode.removeChild(temp);
        if (display === 'none') {
            display = 'block';
        }
        defaultDisplayMap[nodeName] = display;
        return display;
    }
    function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            display = elem.style.display;
            if (show) {
                if (display === 'none') {
                    values[index] = dataPriv.get(elem, 'display') || null;
                    if (!values[index]) {
                        elem.style.display = '';
                    }
                }
                if (elem.style.display === '' && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== 'none') {
                    values[index] = 'none';
                    dataPriv.set(elem, 'display', display);
                }
            }
        }
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }
        return elements;
    }
    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === 'boolean') {
                return state ? this.show() : this.hide();
            }
            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [
            1,
            '<select multiple=\'multiple\'>',
            '</select>'
        ],
        thead: [
            1,
            '<table>',
            '</table>'
        ],
        col: [
            2,
            '<table><colgroup>',
            '</colgroup></table>'
        ],
        tr: [
            2,
            '<table><tbody>',
            '</tbody></table>'
        ],
        td: [
            3,
            '<table><tbody><tr>',
            '</tr></tbody></table>'
        ],
        _default: [
            0,
            '',
            ''
        ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== 'undefined') {
            ret = context.getElementsByTagName(tag || '*');
        } else if (typeof context.querySelectorAll !== 'undefined') {
            ret = context.querySelectorAll(tag || '*');
        } else {
            ret = [];
        }
        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }
        return ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
            dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (toType(elem) === 'object') {
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement('div'));
                    tag = (rtagName.exec(elem) || [
                        '',
                        ''
                    ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = '';
                }
            }
        }
        fragment.textContent = '';
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), 'script');
            if (attached) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || '')) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
        input.setAttribute('type', 'radio');
        input.setAttribute('checked', 'checked');
        input.setAttribute('name', 't');
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = '<textarea>x</textarea>';
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }());
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function expectSync(elem, type) {
        return elem === safeActiveElement() === (type === 'focus');
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {
        }
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === 'object') {
            if (typeof selector !== 'string') {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === 'string') {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function (event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join('.')
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || '').match(rnothtmlwhite) || [''];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || '').split('.').sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, 'handle events');
            }
        },
        dispatch: function (nativeEvent) {
            var event = jQuery.event.fix(nativeEvent);
            var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !(event.type === 'click' && event.button >= 1)) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && !(event.type === 'click' && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + ' ';
                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matchedHandlers
                            });
                        }
                    }
                }
            }
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: cur,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,
                get: isFunction(hook) ? function () {
                    if (this.originalEvent) {
                        return hook(this.originalEvent);
                    }
                } : function () {
                    if (this.originalEvent) {
                        return this.originalEvent[name];
                    }
                },
                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },
        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: { noBubble: true },
            click: {
                setup: function (data) {
                    var el = this || data;
                    if (rcheckableType.test(el.type) && el.click && nodeName(el, 'input') && dataPriv.get(el, 'click') === undefined) {
                        leverageNative(el, 'click', returnTrue);
                    }
                    return false;
                },
                trigger: function (data) {
                    var el = this || data;
                    if (rcheckableType.test(el.type) && el.click && nodeName(el, 'input') && dataPriv.get(el, 'click') === undefined) {
                        leverageNative(el, 'click');
                    }
                    return true;
                },
                _default: function (event) {
                    var target = event.target;
                    return rcheckableType.test(target.type) && target.click && nodeName(target, 'input') && dataPriv.get(target, 'click') || nodeName(target, 'a');
                }
            },
            beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    function leverageNative(el, type, expectSync) {
        if (!expectSync) {
            jQuery.event.add(el, type, returnTrue);
            return;
        }
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
            namespace: false,
            handler: function (event) {
                var notAsync, result, saved = dataPriv.get(this, type);
                if (event.isTrigger & 1 && this[type]) {
                    if (!saved) {
                        saved = slice.call(arguments);
                        dataPriv.set(this, type, saved);
                        notAsync = expectSync(this, type);
                        this[type]();
                        result = dataPriv.get(this, type);
                        if (saved !== result || notAsync) {
                            dataPriv.set(this, type, false);
                        } else {
                            result = undefined;
                        }
                        if (saved !== result) {
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            return result;
                        }
                    } else if ((jQuery.event.special[type] || {}).delegateType) {
                        event.stopPropagation();
                    }
                } else if (saved) {
                    dataPriv.set(this, type, jQuery.event.trigger(jQuery.extend(saved.shift(), jQuery.Event.prototype), saved, this));
                    event.stopImmediatePropagation();
                }
            }
        });
    }
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function () {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        'char': true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: function (event) {
            var button = event.button;
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }
                if (button & 2) {
                    return 3;
                }
                if (button & 4) {
                    return 2;
                }
                return 0;
            }
            return event.which;
        }
    }, jQuery.event.addProp);
    jQuery.each({
        focus: 'focusin',
        blur: 'focusout'
    }, function (type, delegateType) {
        jQuery.event.special[type] = {
            setup: function () {
                leverageNative(this, type, expectSync);
                return false;
            },
            trigger: function () {
                leverageNative(this, type);
                return true;
            },
            delegateType: delegateType
        };
    });
    jQuery.each({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout',
        pointerenter: 'pointerover',
        pointerleave: 'pointerout'
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === 'object') {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === 'function') {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        if (nodeName(elem, 'table') && nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')) {
            return jQuery(elem).children('tbody')[0] || elem;
        }
        return elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || '').slice(0, 5) === 'true/') {
            elem.type = elem.type.slice(5);
        } else {
            elem.removeAttribute('type');
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === 'input' || nodeName === 'textarea') {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
        if (valueIsFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (valueIsFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                hasScripts = scripts.length;
                for (; i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, 'script'));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                            if (node.src && (node.type || '').toLowerCase() !== 'module') {
                                if (jQuery._evalUrl && !node.noModule) {
                                    jQuery._evalUrl(node.src, { nonce: node.nonce || node.getAttribute('nonce') });
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ''), node, doc);
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && isAttached(node)) {
                    setGlobalEval(getAll(node, 'script'));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function (html) {
            return html.replace(rxhtmlTag, '<$1></$2>');
        },
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, 'script');
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
            }
            return clone;
        },
        cleanData: function (elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },
        remove: function (selector) {
            return remove(this, selector);
        },
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function () {
            var elem, i = 0;
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = '';
                }
            }
            return this;
        },
        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                        '',
                        ''
                    ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function () {
            var ignored = [];
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: 'append',
        prependTo: 'prepend',
        insertBefore: 'before',
        insertAfter: 'after',
        replaceAll: 'replaceWith'
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
    var getStyles = function (elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    var rboxStyle = new RegExp(cssExpand.join('|'), 'i');
    (function () {
        function computeStyleTests() {
            if (!div) {
                return;
            }
            container.style.cssText = 'position:absolute;left:-11111px;width:60px;' + 'margin-top:1px;padding:0;border:0';
            div.style.cssText = 'position:relative;display:block;box-sizing:border-box;overflow:scroll;' + 'margin:auto;border:1px;padding:1px;' + 'width:60%;top:1%';
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== '1%';
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = '60%';
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = 'absolute';
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
        }
        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement('div'), div = document.createElement('div');
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = 'content-box';
        div.cloneNode(true).style.backgroundClip = '';
        support.clearCloneStyle = div.style.backgroundClip === 'content-box';
        jQuery.extend(support, {
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function () {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function () {
                computeStyleTests();
                return scrollboxSizeVal;
            }
        });
    }());
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (ret === '' && !isAttached(elem)) {
                ret = jQuery.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + '' : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var cssPrefixes = [
            'Webkit',
            'Moz',
            'ms'
        ], emptyStyle = document.createElement('div').style, vendorProps = {};
    function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) {
            return final;
        }
        if (name in emptyStyle) {
            return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = {
            position: 'absolute',
            visibility: 'hidden',
            display: 'block'
        }, cssNormalTransform = {
            letterSpacing: '0',
            fontWeight: '400'
        };
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === 'width' ? 1 : 0, extra = 0, delta = 0;
        if (box === (isBorderBox ? 'border' : 'content')) {
            return 0;
        }
        for (; i < 4; i += 2) {
            if (box === 'margin') {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }
            if (!isBorderBox) {
                delta += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                if (box !== 'padding') {
                    delta += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                } else {
                    extra += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            } else {
                if (box === 'content') {
                    delta -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                }
                if (box !== 'margin') {
                    delta -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                }
            }
        }
        if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
        }
        return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = 'offset' + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
            if (!extra) {
                return val;
            }
            val = 'auto';
        }
        if ((!support.boxSizingReliable() && isBorderBox || val === 'auto' || !parseFloat(val) && jQuery.css(elem, 'display', false, styles) === 'inline') && elem.getClientRects().length) {
            isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
                val = elem[offsetProp];
            }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles, val) + 'px';
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, 'opacity');
                        return ret === '' ? '1' : ret;
                    }
                }
            }
        },
        cssNumber: {
            'animationIterationCount': true,
            'columnCount': true,
            'fillOpacity': true,
            'flexGrow': true,
            'flexShrink': true,
            'fontWeight': true,
            'gridArea': true,
            'gridColumn': true,
            'gridColumnEnd': true,
            'gridColumnStart': true,
            'gridRow': true,
            'gridRowEnd': true,
            'gridRowStart': true,
            'lineHeight': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'widows': true,
            'zIndex': true,
            'zoom': true
        },
        cssProps: {},
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
                name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = 'number';
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === 'number' && !isCustomProp) {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');
                }
                if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                    style[name] = 'inherit';
                }
                if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }
            } else {
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
                name = finalPropName(origName);
            }
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && 'get' in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === 'normal' && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === '' || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([
        'height',
        'width'
    ], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, 'display')) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, dimension, extra);
                    }) : getWidthOrHeight(elem, dimension, extra);
                }
            },
            set: function (elem, value, extra) {
                var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === 'absolute', boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                if (isBorderBox && scrollboxSizeBuggy) {
                    subtract -= Math.ceil(elem['offset' + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, 'border', false, styles) - 0.5);
                }
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                return elem.getBoundingClientRect().left;
            })) + 'px';
        }
    });
    jQuery.each({
        margin: '',
        padding: '',
        border: 'Width'
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (prefix !== 'margin') {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, '');
                return !result || result === 'auto' ? 0 : result;
            },
            set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: 'swing'
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }
            jQuery.fx.tick();
        }
    }
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs['margin' + which] = attrs['padding' + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']), index = 0, length = collection.length;
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = 'width' in props || 'height' in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, 'fxshow');
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, 'fx');
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, 'fx').length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === 'toggle';
                if (value === (hidden ? 'hide' : 'show')) {
                    if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }
        if (isBox && elem.nodeType === 1) {
            opts.overflow = [
                style.overflow,
                style.overflowX,
                style.overflowY
            ];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, 'display');
            }
            display = jQuery.css(elem, 'display');
            if (display === 'none') {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, 'display');
                    showHide([elem]);
                }
            }
            if (display === 'inline' || display === 'inline-block' && restoreDisplay != null) {
                if (jQuery.css(elem, 'float') === 'none') {
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === 'none' ? '' : display;
                        }
                    }
                    style.display = 'inline-block';
                }
            }
        }
        if (opts.overflow) {
            style.overflow = 'hidden';
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        propTween = false;
        for (prop in orig) {
            if (!propTween) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, 'fxshow', { display: restoreDisplay });
                }
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    showHide([elem], true);
                }
                anim.done(function () {
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && 'expand' in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem;
            }), tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }
                deferred.notifyWith(elem, [
                    animation,
                    percent,
                    remaining
                ]);
                if (percent < 1 && length) {
                    return remaining;
                }
                if (!length) {
                    deferred.notifyWith(elem, [
                        animation,
                        1,
                        0
                    ]);
                }
                deferred.resolveWith(elem, [animation]);
                return false;
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [
                            animation,
                            1,
                            0
                        ]);
                        deferred.resolveWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    } else {
                        deferred.rejectWith(elem, [
                            animation,
                            gotoEnd
                        ]);
                    }
                    return this;
                }
            }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            '*': [function (prop, value) {
                    var tween = this.createTween(prop, value);
                    adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                    return tween;
                }]
        },
        tweener: function (props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = ['*'];
            } else {
                props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [defaultPrefilter],
        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };
        if (jQuery.fx.off) {
            opt.duration = 0;
        } else {
            if (typeof opt.duration !== 'number') {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];
                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }
        if (opt.queue == null || opt.queue === true) {
            opt.queue = 'fx';
        }
        opt.old = opt.complete;
        opt.complete = function () {
            if (isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    if (empty || dataPriv.get(this, 'finish')) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== 'string') {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || 'fx', []);
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || 'fx';
            }
            return this.each(function () {
                var index, data = dataPriv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([
        'toggle',
        'show',
        'hide'
    ], function (i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx('show'),
        slideUp: genFx('hide'),
        slideToggle: genFx('toggle'),
        fadeIn: { opacity: 'show' },
        fadeOut: { opacity: 'hide' },
        fadeToggle: { opacity: 'toggle' }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }
        inProgress = true;
        schedule();
    };
    jQuery.fx.stop = function () {
        inProgress = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || 'fx';
        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };
    (function () {
        var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
        input.type = 'checkbox';
        support.checkOn = input.value !== '';
        support.optSelected = opt.selected;
        input = document.createElement('input');
        input.value = 't';
        input.type = 'radio';
        support.radioValue = input.value === 't';
    }());
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === 'undefined') {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + '');
                return value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === 'radio' && nodeName(elem, 'input')) {
                        var val = elem.value;
                        elem.setAttribute('type', value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function (elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            if (!isXML) {
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function (elem) {
                    var tabindex = jQuery.find.attr(elem, 'tabindex');
                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }
                    if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                        return 0;
                    }
                    return -1;
                }
            }
        },
        propFix: {
            'for': 'htmlFor',
            'class': 'className'
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each([
        'tabIndex',
        'readOnly',
        'maxLength',
        'cellSpacing',
        'cellPadding',
        'rowSpan',
        'colSpan',
        'useMap',
        'frameBorder',
        'contentEditable'
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(' ');
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute('class') || '';
    }
    function classesToArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value === 'string') {
            return value.match(rnothtmlwhite) || [];
        }
        return [];
    }
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            classes = classesToArray(value);
            if (classes.length) {
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                cur += clazz + ' ';
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr('class', '');
            }
            classes = classesToArray(value);
            if (classes.length) {
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && ' ' + stripAndCollapse(curValue) + ' ';
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(' ' + clazz + ' ') > -1) {
                                cur = cur.replace(' ' + clazz + ' ', ' ');
                            }
                        }
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute('class', finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function (value, stateVal) {
            var type = typeof value, isValidValue = type === 'string' || Array.isArray(value);
            if (typeof stateVal === 'boolean' && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function () {
                var className, i, self, classNames;
                if (isValidValue) {
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === 'boolean') {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, '__className__', className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');
                    }
                }
            });
        },
        hasClass: function (selector) {
            var className, elem, i = 0;
            className = ' ' + selector + ' ';
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (' ' + stripAndCollapse(getClass(elem)) + ' ').indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    if (typeof ret === 'string') {
                        return ret.replace(rreturn, '');
                    }
                    return ret == null ? '' : ret;
                }
                return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function (i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (valueIsFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = '';
                } else if (typeof val === 'number') {
                    val += '';
                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? '' : value + '';
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, 'value');
                    return val != null ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one', values = one ? null : [], max = one ? index + 1 : options.length;
                    if (index < 0) {
                        i = max;
                    } else {
                        i = one ? index : 0;
                    }
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, 'optgroup'))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([
        'radio',
        'checkbox'
    ], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (Array.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute('value') === null ? 'on' : elem.value;
            };
        }
    });
    support.focusin = 'onfocusin' in window;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function (e) {
            e.stopPropagation();
        };
    jQuery.extend(jQuery.event, {
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
            cur = lastElement = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf('.') > -1) {
                namespaces = type.split('.');
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(':') < 0 && 'on' + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join('.');
            event.rnamespace = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        if (event.isPropagationStopped()) {
                            lastElement.addEventListener(type, stopPropagationCallback);
                        }
                        elem[type]();
                        if (event.isPropagationStopped()) {
                            lastElement.removeEventListener(type, stopPropagationCallback);
                        }
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function (type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    if (!support.focusin) {
        jQuery.each({
            focus: 'focusin',
            blur: 'focusout'
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = Date.now();
    var rquery = /\?/;
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== 'string') {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, 'text/xml');
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName('parsererror').length) {
            jQuery.error('Invalid XML: ' + data);
        }
        return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add);
                }
            });
        } else if (!traditional && toType(obj) === 'object') {
            for (name in obj) {
                buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, valueOrFunction) {
                var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value == null ? '' : value);
            };
        if (a == null) {
            return '';
        }
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join('&');
    };
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, 'elements');
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function () {
                var type = this.type;
                return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function (i, elem) {
                var val = jQuery(this).val();
                if (val == null) {
                    return null;
                }
                if (Array.isArray(val)) {
                    return jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    });
                }
                return {
                    name: elem.name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), originAnchor = document.createElement('a');
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== 'string') {
                func = dataTypeExpression;
                dataTypeExpression = '*';
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === '+') {
                        dataType = dataType.slice(1) || '*';
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === '*') {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === '*') {
                    current = prev;
                } else if (prev !== '*' && prev !== current) {
                    conv = converters[prev + ' ' + current] || converters['* ' + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(' ');
                            if (tmp[1] === current) {
                                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: 'parsererror',
                                    error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: 'success',
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: 'GET',
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
            accepts: {
                '*': allTypes,
                text: 'text/plain',
                html: 'text/html',
                xml: 'application/xml, text/xml',
                json: 'application/json, text/javascript'
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: 'responseXML',
                text: 'responseText',
                json: 'responseJSON'
            },
            converters: {
                '* text': String,
                'text html': true,
                'text json': JSON.parse,
                'text xml': jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === 'object') {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = 'canceled', jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase() + ' '] = (responseHeaders[match[1].toLowerCase() + ' '] || []).concat(match[2]);
                                }
                            }
                            match = responseHeaders[key.toLowerCase() + ' '];
                        }
                        return match == null ? null : match.join(', ');
                    },
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {
                                jqXHR.always(map[jqXHR.status]);
                            } else {
                                for (code in map) {
                                    statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                            }
                        }
                        return this;
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };
            deferred.promise(jqXHR);
            s.url = ((url || s.url || location.href) + '').replace(rprotocol, location.protocol + '//');
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = (s.dataType || '*').toLowerCase().match(rnothtmlwhite) || [''];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement('a');
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== 'string') {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (completed) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger('ajaxStart');
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url.replace(rhash, '');
            if (!s.hasContent) {
                uncached = s.url.slice(cacheURL.length);
                if (s.data && (s.processData || typeof s.data === 'string')) {
                    cacheURL += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, '$1');
                    uncached = (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++ + uncached;
                }
                s.url = cacheURL + uncached;
            } else if (s.data && s.processData && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0) {
                s.data = s.data.replace(r20, '+');
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader('Content-Type', s.contentType);
            }
            jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
                return jqXHR.abort();
            }
            strAbort = 'abort';
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, 'No Transport');
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxSend', [
                        jqXHR,
                        s
                    ]);
                }
                if (completed) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort('timeout');
                    }, s.timeout);
                }
                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) {
                        throw e;
                    }
                    done(-1, e);
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (completed) {
                    return;
                }
                completed = true;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || '';
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader('Last-Modified');
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader('etag');
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === 'HEAD') {
                        statusText = 'nocontent';
                    } else if (status === 304) {
                        statusText = 'notmodified';
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = 'error';
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + '';
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [
                        success,
                        statusText,
                        jqXHR
                    ]);
                } else {
                    deferred.rejectWith(callbackContext, [
                        jqXHR,
                        statusText,
                        error
                    ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                        jqXHR,
                        s,
                        isSuccess ? success : error
                    ]);
                }
                completeDeferred.fireWith(callbackContext, [
                    jqXHR,
                    statusText
                ]);
                if (fireGlobals) {
                    globalEventContext.trigger('ajaxComplete', [
                        jqXHR,
                        s
                    ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger('ajaxStop');
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, 'json');
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, 'script');
        }
    });
    jQuery.each([
        'get',
        'post'
    ], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function (url, options) {
        return jQuery.ajax({
            url: url,
            type: 'GET',
            dataType: 'script',
            cache: true,
            async: false,
            global: false,
            converters: {
                'text script': function () {
                }
            },
            dataFilter: function (response) {
                jQuery.globalEval(response, options);
            }
        });
    };
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;
            if (this[0]) {
                if (isFunction(html)) {
                    html = html.call(this[0]);
                }
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function () {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function (html) {
            if (isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function (html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function (selector) {
            this.parent(selector).not('body').each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });
    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {
        }
    };
    var xhrSuccessStatus = {
            0: 200,
            1223: 204
        }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers['X-Requested-With']) {
                        headers['X-Requested-With'] = 'XMLHttpRequest';
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                                if (type === 'abort') {
                                    xhr.abort();
                                } else if (type === 'error') {
                                    if (typeof xhr.status !== 'number') {
                                        complete(0, 'error');
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = callback('error');
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback('abort');
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });
    jQuery.ajaxSetup({
        accepts: { script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript' },
        contents: { script: /\b(?:java|ecma)script\b/ },
        converters: {
            'text script': function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter('script', function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = 'GET';
        }
    });
    jQuery.ajaxTransport('script', function (s) {
        if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery('<script>').attr(s.scriptAttrs || {}).prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on('load error', callback = function (evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === 'error' ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: 'callback',
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');
        if (jsonProp || s.dataTypes[0] === 'jsonp') {
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
            }
            s.converters['script json'] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + ' was not called');
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = 'json';
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };
            jqXHR.always(function () {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return 'script';
        }
    });
    support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument('').body;
        body.innerHTML = '<form></form><form></form>';
        return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== 'string') {
            return [];
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
            context = false;
        }
        var base, parsed, scripts;
        if (!context) {
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument('');
                base = context.createElement('base');
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
            return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(' ');
        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }
        if (isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === 'object') {
            type = 'POST';
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || 'GET',
                dataType: 'html',
                data: params
            }).done(function (responseText) {
                response = arguments;
                self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [
                        jqXHR.responseText,
                        status,
                        jqXHR
                    ]);
                });
            });
        }
        return this;
    };
    jQuery.each([
        'ajaxStart',
        'ajaxStop',
        'ajaxComplete',
        'ajaxError',
        'ajaxSuccess',
        'ajaxSend'
    ], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };
    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
            if (position === 'static') {
                elem.style.position = 'relative';
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, 'top');
            curCSSLeft = jQuery.css(elem, 'left');
            calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ('using' in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var rect, win, elem = this[0];
            if (!elem) {
                return;
            }
            if (!elem.getClientRects().length) {
                return {
                    top: 0,
                    left: 0
                };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },
        position: function () {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, doc, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
            if (jQuery.css(elem, 'position') === 'fixed') {
                offset = elem.getBoundingClientRect();
            } else {
                offset = this.offset();
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, 'borderTopWidth', true);
                    parentOffset.left += jQuery.css(offsetParent, 'borderLeftWidth', true);
                }
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
            };
        },
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: 'pageXOffset',
        scrollTop: 'pageYOffset'
    }, function (method, prop) {
        var top = 'pageYOffset' === prop;
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win;
                if (isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([
        'top',
        'left'
    ], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
        });
    });
    jQuery.each({
        Height: 'height',
        Width: 'width'
    }, function (name, type) {
        jQuery.each({
            padding: 'inner' + name,
            content: type,
            '': 'outer' + name
        }, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                return access(this, function (elem, type, value) {
                    var doc;
                    if (isWindow(elem)) {
                        return funcName.indexOf('outer') === 0 ? elem['inner' + name] : elem.document.documentElement['client' + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable);
            };
        });
    });
    jQuery.each(('blur focus focusin focusout resize scroll click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup contextmenu').split(' '), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    jQuery.fn.extend({
        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
        }
    });
    jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;
        if (typeof context === 'string') {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }
        if (!isFunction(fn)) {
            return undefined;
        }
        args = slice.call(arguments, 2);
        proxy = function () {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
    };
    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function (obj) {
        var type = jQuery.type(obj);
        return (type === 'number' || type === 'string') && !isNaN(obj - parseFloat(obj));
    };
    if (typeof define === 'function' && define.amd) {
        define('jquery@3.4.0#dist/jquery', [], function () {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
}));
/*can-dom-events@1.3.0#helpers/add-event-jquery*/
define('can-dom-events@1.3.0#helpers/add-event-jquery', [
    'require',
    'exports',
    'module',
    './util'
], function (require, exports, module) {
    'use strict';
    var util = require('./util');
    module.exports = function addEventJQuery(jQuery, customEvent, customEventType) {
        customEventType = customEventType || customEvent.defaultEventType;
        var existingEvent = jQuery.event.special[customEventType];
        if (existingEvent) {
            throw new Error('Special event type "' + customEventType + '" already exists');
        }
        var domEvents = {
            addEventListener: function (target, eventType, handler) {
                $(target).on(eventType, handler);
            },
            removeEventListener: function (target, eventType, handler) {
                $(target).off(eventType, handler);
            },
            dispatch: function (target) {
                var event = util.createEvent.apply(null, arguments);
                $(target).trigger(event);
            }
        };
        var event = {
            add: function (handleObj) {
                var target = this;
                var eventType = handleObj.origType;
                var handler = handleObj.handler;
                customEvent.addEventListener.call(domEvents, target, eventType, handler);
            },
            remove: function (handleObj) {
                var target = this;
                var eventType = handleObj.origType;
                var handler = handleObj.handler;
                customEvent.removeEventListener.call(domEvents, target, eventType, handler);
            }
        };
        jQuery.event.special[customEventType] = event;
        return function removeEventJQuery() {
            delete jQuery.event.special[customEventType];
        };
    };
});
/*can-dom-events@1.3.0#helpers/add-event-jquery-test*/
define('can-dom-events@1.3.0#helpers/add-event-jquery-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'jquery',
    './add-event-jquery'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var jQuery = require('jquery');
    var addEvent = require('./add-event-jquery');
    unit.module('add-event-jquery');
    var mockEvent = function (firstEvent, secondEvent, addSpy, removeSpy) {
        return {
            defaultEventName: firstEvent,
            addEventListener: function (target, eventName, handler) {
                addSpy(this, arguments);
                this.addEventListener(target, secondEvent, handler);
            },
            removeEventListener: function (target, eventName, handler) {
                removeSpy(this, arguments);
                this.removeEventListener(target, secondEvent, handler);
            }
        };
    };
    unit.test('should work with the jQuery', function (assert) {
        assert.expect(1 + 2 * 3);
        var input = document.createElement('input');
        var handler = function () {
            assert.ok(true, 'handler should be called');
        };
        var customEventType = 'boi3';
        var lowerEventType = 'boi2';
        var hookSpy = function (context, args) {
            var target = args[0];
            var eventType = args[1];
            var callback = args[2];
            assert.equal(target, input, 'input should be the target');
            assert.equal(eventType, customEventType, 'event type should match custom event type');
            assert.equal(callback, handler, 'callback should be the passed handler');
        };
        var event = mockEvent(customEventType, lowerEventType, hookSpy, hookSpy);
        var removeEvent = addEvent(jQuery, event, customEventType);
        $(input).on(customEventType, handler);
        $(input).trigger(lowerEventType);
        $(input).on(customEventType, handler);
        removeEvent();
    });
});
/*can-dom-events@1.3.0#helpers/add-jquery-events*/
define('can-dom-events@1.3.0#helpers/add-jquery-events', [
    'require',
    'exports',
    'module',
    '../can-dom-events',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var domEvents = require('../can-dom-events');
        var namespace = require('can-namespace');
        module.exports = namespace.addJQueryEvents = function addJQueryEvents(jQuery) {
            var jQueryEvents = jQuery.event.special;
            var removeEvents = [];
            for (var eventType in jQueryEvents) {
                if (!domEvents._eventRegistry.has(eventType)) {
                    var eventDefinition = {
                        defaultEventType: eventType,
                        addEventListener: function (target, eventType, handler) {
                            $(target).on(eventType, handler);
                        },
                        removeEventListener: function (target, eventType, handler) {
                            $(target).off(eventType, handler);
                        }
                    };
                    var removeEvent = domEvents.addEvent(eventDefinition);
                    removeEvents.push(removeEvent);
                }
            }
            return function removeJQueryEvents() {
                removeEvents.forEach(function (removeEvent) {
                    removeEvent();
                });
            };
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-dom-events@1.3.0#helpers/add-jquery-events-test*/
define('can-dom-events@1.3.0#helpers/add-jquery-events-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'jquery',
    './add-jquery-events',
    '../can-dom-events'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var $ = require('jquery');
    var addEvents = require('./add-jquery-events');
    var domEvents = require('../can-dom-events');
    unit.module('add-jquery-events');
    unit.test('should work with the jQuery', function (assert) {
        assert.expect(1 + 3);
        var divElement = document.createElement('div');
        var eventType = 'draginit';
        var handler = function (event) {
            assert.equal(event.target, divElement, 'div should be the target');
            assert.equal(event.type, eventType, 'event type should match custom event type');
            assert.equal(event.handleObj.handler, handler, 'callback should be the passed handler');
        };
        $.event.special[eventType] = {
            add: function () {
                assert.ok(true, 'add handler should be called');
            }
        };
        var removeEvents = addEvents($);
        domEvents.addEventListener(divElement, eventType, handler);
        $(divElement).trigger(eventType);
        removeEvents();
    });
});
/*can-dom-events@1.3.0#helpers/util-test*/
define('can-dom-events@1.3.0#helpers/util-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './util'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var util = require('./util');
    unit.module('util');
    unit.test('util.isDomEventTarget works', function (assert) {
        var element = document.createElement('div');
        assert.equal(util.isDomEventTarget(element), true, 'Elements work');
        assert.equal(util.isDomEventTarget(document), true, 'Documents work');
        assert.equal(util.isDomEventTarget(window), true, 'Window works');
        assert.equal(util.isDomEventTarget(8), false, 'Numbers should not work');
        assert.equal(util.isDomEventTarget('foo'), false, 'Strings should not work');
        assert.equal(util.isDomEventTarget({ a: 1 }), false, 'Plain objects should not work');
        var textNode = document.createTextNode('boi');
        assert.equal(util.isDomEventTarget(textNode), false, 'Text nodes should not work');
    });
    unit.test('util.createEvent should merge the eventData object properties', function (assert) {
        var target = document.createElement('input');
        var enterCode = 13;
        var event = util.createEvent(target, { keyCode: enterCode });
        assert.equal(event.keyCode, enterCode);
    });
    unit.test('util.createEvent should use eventData.type as the eventType', function (assert) {
        var target = document.createElement('input');
        var eventType = 'foo';
        var event = util.createEvent(target, { type: eventType });
        assert.equal(event.type, eventType);
    });
});
/*can-dom-events@1.3.0#can-dom-events-test*/
define('can-dom-events@1.3.0#can-dom-events-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    './can-dom-events',
    './helpers/make-event-registry-test',
    './helpers/add-event-compat-test',
    './helpers/add-event-jquery-test',
    './helpers/add-jquery-events-test',
    './helpers/util-test'
], function (require, exports, module) {
    var unit = require('steal-qunit');
    var domEvents = require('./can-dom-events');
    unit.module('can-dom-events');
    unit.test('domEvents.addEventListener works', function (assert) {
        assert.expect(1);
        var input = document.createElement('input');
        var eventType = 'click';
        var handler = function () {
            assert.ok(true, 'event handler should be called');
        };
        domEvents.addEventListener(input, eventType, handler);
        var event = new Event(eventType);
        input.dispatchEvent(event);
        domEvents.removeEventListener(input, eventType, handler);
    });
    unit.test('domEvents.removeEventListener works', function (assert) {
        assert.expect(1);
        var input = document.createElement('input');
        var eventType = 'click';
        var handler = function () {
            assert.ok(true, 'event handler should be called');
        };
        domEvents.addEventListener(input, eventType, handler);
        var event = new Event(eventType);
        input.dispatchEvent(event);
        domEvents.removeEventListener(input, eventType, handler);
        var event2 = new Event(eventType);
        input.dispatchEvent(event2);
    });
    unit.test('domEvents.dispatch works', function (assert) {
        assert.expect(1);
        var input = document.createElement('input');
        var eventType = 'click';
        var handler = function () {
            assert.ok(true, 'event handler should be called');
        };
        input.addEventListener(eventType, handler);
        domEvents.dispatch(input, eventType);
        input.removeEventListener(eventType, handler);
    });
    unit.test('domEvents.addDelegateListener works', function (assert) {
        var done = assert.async();
        var grandparent = document.createElement('div');
        var parent = document.createElement('div');
        var child = document.createElement('input');
        grandparent.appendChild(parent);
        parent.appendChild(child);
        domEvents.addDelegateListener(grandparent, 'click', 'input', function handler(event) {
            domEvents.removeDelegateListener(grandparent, 'click', 'input', handler);
            assert.equal(event.type, 'click', 'should be click event');
            assert.equal(event.target, child, 'should have input as the event.target');
            done();
        });
        domEvents.dispatch(child, 'click');
    });
    unit.test('domEvents.removeDelegateListener works', function (assert) {
        assert.expect(2);
        var grandparent = document.createElement('div');
        var parent = document.createElement('div');
        var child = document.createElement('input');
        grandparent.appendChild(parent);
        parent.appendChild(child);
        var handler = function handler(event) {
            assert.equal(event.type, 'click', 'should be click event');
            assert.equal(event.target, child, 'should have input as the event.target');
        };
        domEvents.addDelegateListener(grandparent, 'click', 'input', handler);
        domEvents.dispatch(child, 'click');
        domEvents.removeDelegateListener(grandparent, 'click', 'input', handler);
        domEvents.dispatch(child, 'click');
    });
    unit.test('can call removeDelegateListener without having previously called addDelegateListener', function (assert) {
        var ul = document.createElement('ul');
        domEvents.removeDelegateListener(ul, 'click', 'li', function () {
        });
        assert.ok(true, 'Calling removeDelegateListener does not throw');
    });
    unit.test('delegate events: focus should work using capture phase', function (assert) {
        var done = assert.async();
        var parent = document.createElement('div');
        var child = document.createElement('input');
        parent.appendChild(child);
        document.getElementById('qunit-fixture').appendChild(parent);
        domEvents.addDelegateListener(parent, 'focus', 'input', function handler(event) {
            domEvents.removeDelegateListener.call(parent, 'focus', 'input', handler);
            assert.equal(event.type, 'focus', 'should be focus event');
            assert.equal(event.target, child, 'should have input as event target');
            done();
        });
        domEvents.dispatch(child, 'focus', false);
    });
    unit.test('delegate events: blur should work using capture phase', function (assert) {
        var done = assert.async();
        var parent = document.createElement('div');
        var child = document.createElement('input');
        parent.appendChild(child);
        document.getElementById('qunit-fixture').appendChild(parent);
        domEvents.addDelegateListener(parent, 'blur', 'input', function handler(event) {
            domEvents.removeDelegateListener.call(parent, 'blur', 'input', handler);
            assert.equal(event.type, 'blur', 'should be blur event');
            assert.equal(event.target, child, 'should have input as event target');
            done();
        });
        domEvents.dispatch(child, 'blur', false);
    });
    unit.test('domEvents.addDelegateListener handles document correctly', function (assert) {
        var html = document.querySelector('html');
        var handler = function handler() {
        };
        domEvents.addDelegateListener(html, 'click', 'input', handler);
        domEvents.dispatch(html, 'click');
        domEvents.removeDelegateListener(html, 'click', 'input', handler);
        assert.ok(true, 'works');
    });
    require('./helpers/make-event-registry-test');
    require('./helpers/add-event-compat-test');
    require('./helpers/add-event-jquery-test');
    require('./helpers/add-jquery-events-test');
    require('./helpers/util-test');
});
/*can-event-dom-enter@1.0.4#can-event-dom-enter-test*/
define('can-event-dom-enter@1.0.4#can-event-dom-enter-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-dom-events',
    './can-event-dom-enter',
    './compat'
], function (require, exports, module) {
    'use strict';
    var unit = require('steal-qunit');
    var domEvents = require('can-dom-events');
    var definition = require('./can-event-dom-enter');
    var compat = require('./compat');
    function makeEnterEvent() {
        try {
            return new window.KeyboardEvent('keyup', { key: 'Enter' });
        } catch (e) {
            var event = document.createEvent('KeyboardEvent');
            event.initKeyboardEvent('keyup', true, false, document.parentWindow, 'Enter', 16, '', false, 'en-US');
            return event;
        }
    }
    function pressKey(target, keyCode) {
        var keyupEvent = {
            type: 'keyup',
            keyCode: keyCode
        };
        domEvents.dispatch(target, keyupEvent);
    }
    function pressEnter(target) {
        pressKey(target, 13);
    }
    var supportsKeyboardEvents = function () {
        if (typeof KeyboardEvent === 'undefined') {
            return false;
        }
        try {
            var eventType = 'keyup';
            var isSupported = false;
            var target = document.createElement('input');
            var handler = function (event) {
                if (event.key === 'Enter') {
                    isSupported = true;
                }
            };
            target.addEventListener(eventType, handler);
            target.dispatch(makeEnterEvent());
            target.removeEventListener(eventType, handler);
            return isSupported;
        } catch (error) {
            return false;
        }
    };
    var compatWithNew = {
        name: 'compat with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = compat(domEvents);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var rawNewDomEvents = {
        name: 'plain with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = domEvents.addEvent(definition);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var suites = [
        compatWithNew,
        rawNewDomEvents
    ];
    function runTests(mod) {
        unit.module(mod.name, {
            setup: mod.setup,
            teardown: mod.teardown
        });
        var domEvents = mod.domEvents;
        unit.test('calls enter event handler when enter key is pressed', function (assert) {
            assert.expect(1);
            var input = document.createElement('input');
            domEvents.addEventListener(input, 'enter', function () {
                assert.ok(true, 'enter key detected');
            });
            pressEnter(input);
        });
        if (supportsKeyboardEvents) {
            unit.test('works for KeyboardEvent\'s', function (assert) {
                assert.expect(1);
                var input = document.createElement('input');
                domEvents.addEventListener(input, 'enter', function () {
                    assert.ok(true, 'enter key detected');
                });
                domEvents.dispatch(input, makeEnterEvent());
            });
        }
        unit.test('does not call enter event handler when a different key is pressed', function (assert) {
            assert.expect(1);
            var input = document.createElement('input');
            domEvents.addEventListener(input, 'enter', function () {
                assert.ok(true, 'passed');
            });
            pressKey(input, 27);
            pressEnter(input);
        });
        unit.test('successfully removes enter event handler', function (assert) {
            assert.expect(1);
            var input = document.createElement('input');
            var enterEventHandler = function () {
                assert.ok(true);
            };
            domEvents.addEventListener(input, 'enter', enterEventHandler);
            pressEnter(input);
            domEvents.removeEventListener(input, 'enter', enterEventHandler);
            pressEnter(input);
        });
        unit.test('can have multiple enter event handlers and can remove them seperately', function (assert) {
            assert.expect(5);
            var input = document.createElement('input');
            var generateEvtHandler = function () {
                return function () {
                    assert.ok(true);
                };
            };
            var firstEvtHandler = generateEvtHandler();
            var secondEvtHandler = generateEvtHandler();
            domEvents.addEventListener(input, 'enter', firstEvtHandler);
            domEvents.addEventListener(input, 'enter', secondEvtHandler);
            pressEnter(input);
            pressEnter(input);
            domEvents.removeEventListener(input, 'enter', firstEvtHandler);
            pressEnter(input);
            domEvents.removeEventListener(input, 'enter', secondEvtHandler);
            pressEnter(input);
        });
        unit.test('still handles other event types appropriately', function (assert) {
            assert.expect(1);
            var button = document.createElement('button');
            domEvents.addEventListener(button, 'focus', function () {
                assert.ok(true, 'handles focus event still');
            });
            domEvents.dispatch(button, 'focus');
        });
    }
    suites.forEach(runTests);
    unit.module('can-event-dom-enter plain');
    unit.test('can use custom addEventListener and removeEventListener (#3)', function (assert) {
        assert.expect(2);
        var handler = function () {
        };
        var button = document.createElement('button');
        definition.addEventListener.call({
            addEventListener: function () {
                assert.ok(true, 'called custom addEventListener');
            }
        }, button, 'enter', handler);
        definition.removeEventListener.call({
            removeEventListener: function () {
                assert.ok(true, 'called custom removeEventListener');
            }
        }, button, 'enter', handler);
    });
});
/*can-event-dom-radiochange@1.0.5#can-event-dom-radiochange-test*/
define('can-event-dom-radiochange@1.0.5#can-event-dom-radiochange-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-dom-events',
    './can-event-dom-radiochange',
    './compat'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var domEvents = require('can-dom-events');
    var definition = require('./can-event-dom-radiochange');
    var compat = require('./compat');
    function fixture() {
        return document.getElementById('qunit-fixture');
    }
    var compatWithNew = {
        name: 'compat with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = compat(domEvents);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var rawNewDomEvents = {
        name: 'plain with can-dom-events',
        domEvents: domEvents,
        setup: function () {
            this.removeEvent = domEvents.addEvent(definition);
        },
        teardown: function () {
            this.removeEvent();
        }
    };
    var suites = [
        compatWithNew,
        rawNewDomEvents
    ];
    function runTests(mod) {
        QUnit.module(mod.name, {
            setup: mod.setup,
            teardown: mod.teardown
        });
        var domEvents = mod.domEvents;
        test('subscription to an untracked radio should call listener', function (assert) {
            assert.expect(1);
            var listener = document.createElement('input');
            listener.id = 'listener';
            listener.type = 'radio';
            listener.name = 'myfield';
            domEvents.addEventListener(listener, 'radiochange', function handler() {
                assert.ok(true, 'called from other element');
                domEvents.removeEventListener(listener, 'radiochange', handler);
            });
            var radio = document.createElement('input');
            radio.id = 'radio';
            radio.type = 'radio';
            radio.name = 'myfield';
            fixture().appendChild(listener);
            fixture().appendChild(radio);
            radio.setAttribute('checked', 'checked');
            domEvents.dispatch(radio, 'change');
        });
        test('subscription to a tracked radio should call itself', function (assert) {
            assert.expect(1);
            var radio = document.createElement('input');
            radio.id = 'selfish';
            radio.type = 'radio';
            radio.name = 'anynamejustsothereisaname';
            domEvents.addEventListener(radio, 'radiochange', function handler() {
                assert.ok(true, 'called from self');
                domEvents.removeEventListener(radio, 'radiochange', handler);
            });
            fixture().appendChild(radio);
            radio.setAttribute('checked', 'checked');
            domEvents.dispatch(radio, 'change');
        });
    }
    suites.forEach(runTests);
});
/*can-parse-uri@1.2.0#can-parse-uri-test*/
define('can-parse-uri@1.2.0#can-parse-uri-test', [
    'require',
    'exports',
    'module',
    './can-parse-uri',
    'steal-qunit'
], function (require, exports, module) {
    var parseURI = require('./can-parse-uri');
    var QUnit = require('steal-qunit');
    QUnit.module('can-parse-uri');
    QUnit.test('basics', function () {
        QUnit.deepEqual(parseURI('http://foo:8080/bar.html?query#change'), {
            authority: '//foo:8080',
            hash: '#change',
            host: 'foo:8080',
            hostname: 'foo',
            href: 'http://foo:8080/bar.html?query#change',
            pathname: '/bar.html',
            port: '8080',
            protocol: 'http:',
            search: '?query'
        });
    });
});
/*can-connect@1.5.18#connect*/
define('can-connect@1.5.18#connect', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var connect = function (behaviors, options) {
        behaviors = behaviors.map(function (behavior, index) {
            var sortedIndex = -1;
            if (typeof behavior === 'string') {
                sortedIndex = connect.order.indexOf(behavior);
                behavior = behaviorsMap[behavior];
            } else if (behavior.isBehavior) {
                sortedIndex = connect.order.indexOf(behavior.behaviorName);
            } else {
                behavior = connect.behavior(behavior);
            }
            return {
                originalIndex: index,
                sortedIndex: sortedIndex,
                behavior: behavior
            };
        });
        behaviors.sort(function (b1, b2) {
            if (~b1.sortedIndex && ~b2.sortedIndex) {
                return b1.sortedIndex - b2.sortedIndex;
            }
            return b1.originalIndex - b2.originalIndex;
        });
        behaviors = behaviors.map(function (b) {
            return b.behavior;
        });
        var behavior = connect.base(connect.behavior('options', function () {
            return options;
        })());
        behaviors.forEach(function (behave) {
            behavior = behave(behavior);
        });
        if (behavior.init) {
            behavior.init();
        }
        return behavior;
    };
    connect.order = [
        'data/localstorage-cache',
        'data/url',
        'data/parse',
        'cache-requests',
        'data/combine-requests',
        'constructor',
        'constructor/store',
        'can/map',
        'can/ref',
        'fall-through-cache',
        'data/worker',
        'real-time',
        'data/callbacks-cache',
        'data/callbacks',
        'constructor/callbacks-once'
    ];
    connect.behavior = function (name, behavior) {
        if (typeof name !== 'string') {
            behavior = name;
            name = undefined;
        }
        var behaviorMixin = function (base) {
            var Behavior = function () {
            };
            Behavior.name = name;
            Behavior.prototype = base;
            var newBehavior = new Behavior();
            var res = typeof behavior === 'function' ? behavior.apply(newBehavior, arguments) : behavior;
            assign(newBehavior, res);
            newBehavior.__behaviorName = name;
            return newBehavior;
        };
        if (name) {
            behaviorMixin.behaviorName = name;
            behaviorsMap[name] = behaviorMixin;
        }
        behaviorMixin.isBehavior = true;
        return behaviorMixin;
    };
    var behaviorsMap = {};
    module.exports = connect;
});
/*can-connect@1.5.18#base/base*/
define('can-connect@1.5.18#base/base', [
    'require',
    'exports',
    'module',
    'can-connect/connect'
], function (require, exports, module) {
    var connect = require('can-connect/connect');
    module.exports = connect.behavior('base', function (baseConnection) {
        return {
            id: function (instance) {
                var ids = [], algebra = this.algebra;
                if (algebra && algebra.clauses && algebra.clauses.id) {
                    for (var prop in algebra.clauses.id) {
                        ids.push(instance[prop]);
                    }
                }
                if (this.idProp && !ids.length) {
                    ids.push(instance[this.idProp]);
                }
                if (!ids.length) {
                    ids.push(instance.id);
                }
                return ids.length > 1 ? ids.join('@|@') : ids[0];
            },
            idProp: baseConnection.idProp || 'id',
            listSet: function (list) {
                return list[this.listSetProp];
            },
            listSetProp: '__listSet',
            init: function () {
            }
        };
    });
});
/*can-connect@1.5.18#can-connect*/
define('can-connect@1.5.18#can-connect', [
    'require',
    'exports',
    'module',
    'can-connect/connect',
    'can-connect/base/base',
    'can-namespace'
], function (require, exports, module) {
    var connect = require('can-connect/connect');
    var base = require('can-connect/base/base');
    var ns = require('can-namespace');
    connect.base = base;
    module.exports = ns.connect = connect;
});
/*can-validate-interface@0.1.2#index*/
define('can-validate-interface@0.1.2#index', function (require, exports, module) {
    'use strict';
    function flatten(arrays) {
        return arrays.reduce(function (ret, val) {
            return ret.concat(val);
        }, []);
    }
    function makeInterfaceValidator(interfacePropArrays) {
        var props = flatten(interfacePropArrays);
        return function (base) {
            var missingProps = props.reduce(function (missing, prop) {
                return prop in base ? missing : missing.concat(prop);
            }, []);
            return missingProps.length ? {
                message: 'missing expected properties',
                related: missingProps
            } : undefined;
        };
    }
    module.exports = makeInterfaceValidator;
});
/*can-validate-interface@0.1.2#test*/
define('can-validate-interface@0.1.2#test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-connect',
    './index.js'
], function (require, exports, module) {
    'use strict';
    var QUnit = require('steal-qunit');
    var connect = require('can-connect');
    var makeInterfaceValidator = require('./index.js');
    var BaseInterface = [
        'id',
        'idProp',
        'listSet',
        'listSetProp'
    ];
    QUnit.module('can-validate-interface/makeInterfaceValidator');
    QUnit.test('should return can-validate style error when can-connect connection is missing property', function () {
        var testBehavior = function (baseBehavior) {
            var validator = makeInterfaceValidator([
                    BaseInterface,
                    'testProp'
                ]), error = validator(baseBehavior);
            equal(error.message, 'missing expected properties', 'missing property validation error raised');
            deepEqual(error.related, ['testProp'], 'error contains missing property name');
            return baseBehavior;
        };
        connect([testBehavior], {});
    });
});
/*can-control@3.2.4#can-control_test*/
define('can-control@3.2.4#can-control_test', [
    'require',
    'exports',
    'module',
    'can-control',
    'steal-qunit',
    'can-util/dom/fragment/',
    'can-util/dom/data/',
    'can-util/js/dev/',
    'can-util/dom/dispatch/',
    'can-util/dom/class-name/',
    'can-util/dom/mutate/',
    'can-event',
    'can-types',
    'can-map',
    'can-define/map/'
], function (require, exports, module) {
    var Control = require('can-control');
    var QUnit = require('steal-qunit');
    var fragment = require('can-util/dom/fragment/');
    var domData = require('can-util/dom/data/');
    var dev = require('can-util/js/dev/');
    var domDispatch = require('can-util/dom/dispatch/');
    var className = require('can-util/dom/class-name/');
    var domMutate = require('can-util/dom/mutate/');
    var canEvent = require('can-event');
    var types = require('can-types');
    var CanMap = require('can-map');
    var DefineMap = require('can-define/map/');
    QUnit.module('can-control', {
        setup: function () {
            this.fixture = document.getElementById('qunit-fixture');
        }
    });
    test('data', function () {
        var Things = Control.extend({});
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        var c1 = new Things('#things', {});
        var c2 = new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
        c1.destroy();
        equal(domData.get.call(things, 'controls').length, 1, 'there is 1 item in the data array');
        c2.destroy();
        equal(domData.get.call(things, 'controls').length, 0, 'there are 0 items in the data array');
    });
    test('parameterized actions', function () {
        var called = false, WeirderBind = Control.extend({
                '{parameterized}': function () {
                    called = true;
                }
            }), a;
        this.fixture.appendChild(fragment('<div id=\'crazy\'></div>'));
        a = document.getElementById('crazy');
        new WeirderBind(a, { parameterized: 'sillyEvent' });
        domDispatch.call(a, 'sillyEvent');
        ok(called, 'heard the trigger');
    });
    test('windowresize', function () {
        var called = false, WindowBind = Control.extend('', {
                '{window} resize': function () {
                    called = true;
                }
            });
        this.fixture.appendChild(fragment('<div id=\'weird\'>'));
        new WindowBind('#weird');
        domDispatch.call(window, 'resize');
        ok(called, 'got window resize event');
    });
    test('on', 9, function () {
        var called = false, DelegateTest = Control.extend({
                click: function () {
                }
            }), Tester = Control.extend({
                init: function (el, ops) {
                    this.on(window, 'click', function (ev) {
                        ok(true, 'Got window click event');
                    });
                    this.on(window, 'click', 'clicked');
                    this.on('click', function () {
                        ok(true, 'Directly clicked element');
                    });
                    this.on('click', 'clicked');
                },
                clicked: function (context) {
                    ok(true, 'Controller action delegated click triggered, too');
                }
            }), div = document.createElement('div');
        this.fixture.appendChild(div);
        var rb = new Tester(div);
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'javascript://\' id=\'elsa\'>click me</a></span></div>'));
        var dt = new DelegateTest('#els');
        dt.on(document.querySelector('#els span'), 'a', 'click', function () {
            called = true;
        });
        domDispatch.call(document.querySelector('#els a'), 'click');
        ok(called, 'delegate works');
        domMutate.removeChild.call(this.fixture, document.querySelector('#els'));
        domDispatch.call(div, 'click');
        domDispatch.call(window, 'click');
        rb.destroy();
    });
    test('inherit', function () {
        var called = false, Parent = Control.extend({
                click: function () {
                    called = true;
                }
            }), Child = Parent.extend({});
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Child('#els');
        domDispatch.call(document.querySelector('#els'), 'click');
        ok(called, 'inherited the click method');
    });
    test('space makes event', 1, function () {
        var Dot = Control.extend({
            ' foo': function () {
                ok(true, 'called');
            }
        });
        this.fixture.appendChild(fragment('<div id=\'els\'><span id=\'elspan\'><a href=\'#\' id=\'elsa\'>click me</a></span></div>'));
        new Dot('#els');
        domDispatch.call(document.querySelector('#els'), 'foo');
    });
    test('custom events with hyphens work', 1, function () {
        this.fixture.appendChild(fragment('<div id=\'customEvent\'><span></span></div>'));
        var FooBar = Control.extend({
            'span custom-event': function () {
                ok(true, 'Custom event was fired.');
            }
        });
        new FooBar('#customEvent');
        domDispatch.call(document.querySelector('#customEvent span'), 'custom-event');
    });
    test('inherit defaults', function () {
        var BASE = Control.extend({ defaults: { foo: 'bar' } }, {});
        var INHERIT = BASE.extend({ defaults: { newProp: 'newVal' } }, {});
        ok(INHERIT.defaults.foo === 'bar', 'Class must inherit defaults from the parent class');
        ok(INHERIT.defaults.newProp === 'newVal', 'Class must have own defaults');
        var inst = new INHERIT(document.createElement('div'), {});
        ok(inst.options.foo === 'bar', 'Instance must inherit defaults from the parent class');
        ok(inst.options.newProp === 'newVal', 'Instance must have defaults of it`s class');
    });
    var bindable = function (b) {
        if (window.jQuery) {
            return b;
        } else {
        }
        return b;
    };
    test('on rebinding', 2, function () {
        var first = true;
        var Rebinder = Control.extend({
            '{item} foo': function (item, ev) {
                if (first) {
                    equal(item.id, 1, 'first item');
                    first = false;
                } else {
                    equal(item.id, 2, 'first item');
                }
            }
        });
        var item1 = bindable({ id: 1 }), item2 = bindable({ id: 2 }), rb = new Rebinder(document.createElement('div'), { item: item1 });
        canEvent.trigger.call(item1, 'foo');
        rb.options = { item: item2 };
        rb.on();
        canEvent.trigger.call(item2, 'foo');
    });
    test('actions provide method names', function () {
        var item1 = {};
        var item2 = {};
        var Tester = Control.extend({
            '{item1} foo': 'food',
            '{item2} bar': 'food',
            food: function (item, ev, data) {
                ok(true, 'food called');
                ok(item === item1 || item === item2, 'called with an item');
            }
        });
        new Tester(document.createElement('div'), {
            item1: item1,
            item2: item2
        });
        canEvent.trigger.call(item1, 'foo');
        canEvent.trigger.call(item2, 'bar');
    });
    test('Don\'t bind if there are undefined values in templates', function () {
        var C = Control.extend({}, {
            '{noExistStuff} proc': function () {
            }
        });
        var c = new C(document.createElement('div'));
        equal(c._bindings.user.length, 1, 'There is only one binding');
        var C2 = Control.extend({
            '{noExistStuff} click': function () {
                ok(false, 'should not fall through to click handler');
            }
        });
        var div = document.createElement('div');
        new C2(div, {});
        canEvent.trigger.call(div, 'click');
    });
    test('Multiple calls to destroy', 2, function () {
        var C = Control.extend({
                destroy: function () {
                    ok(true);
                    Control.prototype.destroy.call(this);
                }
            }), div = document.createElement('div'), c = new C(div);
        c.destroy();
        c.destroy();
    });
    test('drag and drop events', function () {
        expect(7);
        var DragDrop = Control.extend('', {
            ' dragstart': function () {
                ok(true, 'dragstart called');
            },
            ' dragenter': function () {
                ok(true, 'dragenter called');
            },
            ' dragover': function () {
                ok(true, 'dragover called');
            },
            ' dragleave': function () {
                ok(true, 'dragleave called');
            },
            ' drag': function () {
                ok(true, 'drag called');
            },
            ' drop': function () {
                ok(true, 'drop called');
            },
            ' dragend': function () {
                ok(true, 'dragend called');
            }
        });
        this.fixture.appendChild(fragment('<div id="draggable"/>'));
        new DragDrop('#draggable');
        var draggable = document.getElementById('draggable');
        domDispatch.call(draggable, 'dragstart');
        domDispatch.call(draggable, 'dragenter');
        domDispatch.call(draggable, 'dragover');
        domDispatch.call(draggable, 'dragleave');
        domDispatch.call(draggable, 'drag');
        domDispatch.call(draggable, 'drop');
        domDispatch.call(draggable, 'dragend');
    });
    test('beforeremove event', function () {
        expect(1);
        var Foo = Control.extend('', {
            'beforeremove': function () {
                ok(true, 'beforeremove called');
            }
        });
        var el = fragment('<div id="foo"/>');
        new Foo(el);
        domDispatch.call(el, 'beforeremove');
    });
    if (System.env.indexOf('production') < 0) {
        test('Control is logging information in dev mode', function () {
            expect(2);
            var oldlog = dev.log;
            var oldwarn = dev.warn;
            dev.log = function (text) {
                equal(text, 'can/control/control.js: No property found for handling {dummy} change', 'Text logged as expected');
            };
            var C = Control.extend({
                '{dummy} change': function () {
                }
            });
            var instance = new C(document.createElement('div'));
            dev.warn = function (text) {
                equal(text, 'can/control/control.js: Control already destroyed');
            };
            instance.destroy();
            instance.destroy();
            dev.warn = oldwarn;
            dev.log = oldlog;
        });
    }
    test('Uses types.wrapElement', function () {
        expect(3);
        var $ = function (element) {
            this.element = element;
        };
        var wrapElement = types.wrapElement;
        var unwrapElement = types.unwrapElement;
        types.wrapElement = function (element) {
            return new $(element);
        };
        types.unwrapElement = function (object) {
            return object.element;
        };
        var MyControl = Control.extend({
            init: function (element) {
                ok(element instanceof $, 'element is wrapped');
                ok(this.element instanceof $, 'this.element is wrapped');
            },
            'click': function (element) {
                types.wrapElement = wrapElement;
                types.unwrapElement = unwrapElement;
                ok(element instanceof $);
            }
        });
        var el = document.createElement('div');
        el.innerHTML = 'Click Me!';
        new MyControl(el);
        canEvent.trigger.call(el, 'click');
    });
    test('event handlers should rebind when target is replaced', function () {
        var nameChanges = 0;
        var MyControl = Control.extend({
            '{person.name} first': function () {
                nameChanges++;
            },
            name: function (name) {
                this.options.person.attr('name', name);
            }
        });
        var c = new MyControl(document.createElement('div'), { person: new CanMap({ name: { first: 'Kevin' } }) });
        c.options.person.attr('name.first', 'Tracy');
        c.name({ first: 'Kim' });
        c.options.person.attr('name.first', 'Max');
        equal(nameChanges, 2);
    });
    test('{element} event handling', function () {
        expect(3);
        stop();
        var MyControl = Control.extend({
            '{element} click': function (element) {
                if (element === this.element) {
                    ok(true, '`{element} click` should catch clicking on the element');
                } else {
                    ok(true, '`{element} click` should catch clicking on a child of the element');
                }
            },
            '{element} p click': function () {
                ok(true, '`{element} p click` works');
                start();
            }
        });
        var div = document.createElement('div');
        var p = document.createElement('p');
        div.appendChild(p);
        new MyControl(div, { foo: 'bar' });
        canEvent.trigger.call(div, 'click');
        canEvent.trigger.call(p, 'click');
    });
    test('Passing a Map as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var map = new CanMap({ eventType: 'click' });
        var div = document.createElement('div');
        new MyControl(div, map);
        map.attr('eventType', 'mouseenter');
        canEvent.trigger.call(div, 'mouseenter');
        canEvent.trigger.call(div, 'mouseleave');
    });
    test('Passing a DefineMap as options works', function () {
        expect(2);
        stop();
        var MyControl = Control.extend({ defaults: { testEndEvent: 'mouseleave' } }, {
            '{element} {eventType}': function () {
                ok(true, 'catches handler from options');
            },
            '{element} {testEndEvent}': function () {
                ok(true, 'catches handler from defaults');
                start();
            }
        });
        var MyMap = DefineMap.extend({
            eventType: 'string',
            testEndEvent: 'string'
        });
        var map = new MyMap();
        map.eventType = 'click';
        var div = document.createElement('div');
        new MyControl(div, map);
        map.eventType = 'mousenter';
        canEvent.trigger.call(div, 'mousenter');
        canEvent.trigger.call(div, 'mouseleave');
    });
    test('Creating an instance of a named control without passing an element', function () {
        var MyControl = Control.extend('MyControl');
        try {
            new MyControl();
        } catch (e) {
            ok(true, 'Caught an exception');
        }
    });
    test('Creating an instance of a named control passing a selector', function () {
        this.fixture.appendChild(fragment('<div id=\'my-control\'>d</div>'));
        var MyControl = Control.extend('MyControl');
        var myControlInstance = new MyControl('#my-control');
        ok(className.has.call(myControlInstance.element, 'MyControl'), 'Element has the correct class name');
    });
    test('destroy should not throw when domData is removed (#57)', function () {
        var Things = Control.extend({
            destroy: function () {
                if (this.element) {
                    domData.delete.call(this.element);
                }
                Control.prototype.destroy.call(this);
            }
        });
        this.fixture.appendChild(fragment('<div id=\'things\'>div<span>span</span></div>'));
        var things = document.getElementById('things');
        var c1 = new Things('#things', {});
        new Things('#things', {});
        equal(domData.get.call(things, 'controls').length, 2, 'there are 2 items in the data array');
        try {
            c1.destroy();
            QUnit.ok(true);
        } catch (e) {
            QUnit.ok(false, e);
        }
    });
});
/*can@3.14.0#control/control_test*/
define('can@3.14.0#control/control_test', [
    'require',
    'exports',
    'module',
    'can-control/can-control_test'
], function (require, exports, module) {
    require('can-control/can-control_test');
});
/*can-list@3.2.2#can-list_test*/
define('can-list@3.2.2#can-list_test', [
    'require',
    'exports',
    'module',
    'can-list',
    'steal-qunit',
    'can-observation',
    'can-map',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var List = require('can-list');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Map = require('can-map');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    QUnit.module('can-list');
    test('list attr changes length', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.attr(3, 3);
        equal(l.length, 4);
    });
    test('removeAttr on list', function () {
        var l = new List([
            0,
            1,
            2
        ]);
        l.removeAttr(1);
        equal(l.attr('length'), 2);
        deepEqual(l.attr(), [
            0,
            2
        ]);
    });
    test('list splice', function () {
        var l = new List([
                0,
                1,
                2,
                3
            ]), first = true;
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '1');
            if (first) {
                equal(how, 'remove', 'removing items');
                equal(newVals, undefined, 'no new Vals');
            } else {
                deepEqual(newVals, [
                    'a',
                    'b'
                ], 'got the right newVals');
                equal(how, 'add', 'adding items');
            }
            first = false;
        });
        l.splice(1, 2, 'a', 'b');
        deepEqual(l.serialize(), [
            0,
            'a',
            'b',
            3
        ], 'serialized');
    });
    test('list pop', function () {
        var l = new List([
            0,
            1,
            2,
            3
        ]);
        l.bind('change', function (ev, attr, how, newVals, oldVals) {
            equal(attr, '3');
            equal(how, 'remove');
            equal(newVals, undefined);
            deepEqual(oldVals, [3]);
        });
        l.pop();
        deepEqual(l.serialize(), [
            0,
            1,
            2
        ]);
    });
    test('remove nested property in item of array map', function () {
        var state = new List([{ nested: true }]);
        state.bind('change', function (ev, attr, how, newVal, old) {
            equal(attr, '0.nested');
            equal(how, 'remove');
            deepEqual(old, true);
        });
        state.removeAttr('0.nested');
        equal(undefined, state.attr('0.nested'));
    });
    test('pop unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar', 'read foo property');
        o.attr('foo', 'car');
        l.pop();
        o.attr('foo', 'bad');
    });
    test('splice unbinds', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0), count = 0;
        l.bind('change', function (ev, attr, how, newVal, oldVal) {
            count++;
            if (count === 1) {
                equal(attr, '0.foo', 'count is set');
            } else if (count === 2) {
                equal(how, 'remove');
                equal(attr, '0');
            } else {
                ok(false, 'called too many times');
            }
        });
        equal(o.attr('foo'), 'bar');
        o.attr('foo', 'car');
        l.splice(0, 1);
        o.attr('foo', 'bad');
    });
    test('always gets right attr even after moving array items', function () {
        var l = new List([{ foo: 'bar' }]);
        var o = l.attr(0);
        l.unshift('A new Value');
        l.bind('change', function (ev, attr, how) {
            equal(attr, '1.foo');
        });
        o.attr('foo', 'led you');
    });
    test('Array accessor methods', 11, function () {
        var l = new List([
                'a',
                'b',
                'c'
            ]), sliced = l.slice(2), joined = l.join(' | '), concatenated = l.concat([
                2,
                1
            ], new List([0]));
        ok(sliced instanceof List, 'Slice is an Observable list');
        equal(sliced.length, 1, 'Sliced off two elements');
        equal(sliced[0], 'c', 'Single element as expected');
        equal(joined, 'a | b | c', 'Joined list properly');
        ok(concatenated instanceof List, 'Concatenated is an Observable list');
        deepEqual(concatenated.serialize(), [
            'a',
            'b',
            'c',
            2,
            1,
            0
        ], 'List concatenated properly');
        l.forEach(function (letter, index) {
            ok(true, 'Iteration');
            if (index === 0) {
                equal(letter, 'a', 'First letter right');
            }
            if (index === 2) {
                equal(letter, 'c', 'Last letter right');
            }
        });
    });
    test('Concatenated list items Equal original', function () {
        var l = new List([
                { firstProp: 'Some data' },
                { secondProp: 'Next data' }
            ]), concatenated = l.concat([
                { hello: 'World' },
                { foo: 'Bar' }
            ]);
        ok(l[0] === concatenated[0], 'They are Equal');
        ok(l[1] === concatenated[1], 'They are Equal');
    });
    test('Lists with maps concatenate properly', function () {
        var Person = Map.extend();
        var People = List.extend({ Map: Person }, {});
        var Genius = Person.extend();
        var Animal = Map.extend();
        var me = new Person({ name: 'John' });
        var animal = new Animal({ name: 'Tak' });
        var genius = new Genius({ name: 'Einstein' });
        var hero = { name: 'Ghandi' };
        var people = new People([]);
        var specialPeople = new People([
            genius,
            hero
        ]);
        people = people.concat([
            me,
            animal,
            specialPeople
        ], specialPeople, [
            1,
            2
        ], 3);
        ok(people.attr('length') === 8, 'List length is right');
        ok(people[0] === me, 'Map in list === vars created before concat');
        ok(people[1] instanceof Person, 'Animal got serialized to Person');
    });
    test('splice removes items in IE (#562)', function () {
        var l = new List(['a']);
        l.splice(0, 1);
        ok(!l.attr(0), 'all props are removed');
    });
    test('reverse triggers add/remove events (#851)', function () {
        expect(6);
        var l = new List([
            1,
            2,
            3
        ]);
        l.bind('change', function () {
            ok(true, 'change should be called');
        });
        l.bind('set', function () {
            ok(false, 'set should not be called');
        });
        l.bind('add', function () {
            ok(true, 'add called');
        });
        l.bind('remove', function () {
            ok(true, 'remove called');
        });
        l.bind('length', function () {
            ok(true, 'length should be called');
        });
        l.reverse();
    });
    test('filter', function () {
        var l = new List([
            {
                id: 1,
                name: 'John'
            },
            {
                id: 2,
                name: 'Mary'
            }
        ]);
        var filtered = l.filter(function (item) {
            return item.name === 'Mary';
        });
        notEqual(filtered._cid, l._cid, 'not same object');
        equal(filtered.length, 1, 'one item');
        equal(filtered[0].name, 'Mary', 'filter works');
    });
    test('removing expandos on lists', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.removeAttr('foo');
        equal(list.length, 2);
    });
    test('No Add Events if List Splice adds the same items that it is removing. (#1277, #1399)', function () {
        var list = new List([
            'a',
            'b'
        ]);
        list.bind('add', function () {
            ok(false, 'Add callback should not be called.');
        });
        list.bind('remove', function () {
            ok(false, 'Remove callback should not be called.');
        });
        var result = list.splice(0, 2, 'a', 'b');
        deepEqual(result, [
            'a',
            'b'
        ]);
    });
    test('add event always returns an array as the value (#998)', function () {
        var list = new List([]), msg;
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [4], msg);
        });
        msg = 'works on push';
        list.push(4);
        list.pop();
        msg = 'works on attr()';
        list.attr(0, 4);
        list.pop();
        msg = 'works on replace()';
        list.replace([4]);
    });
    test('Setting with .attr() out of bounds of length triggers add event with leading undefineds', function () {
        var list = new List([1]);
        list.bind('add', function (ev, newElements, index) {
            deepEqual(newElements, [
                undefined,
                undefined,
                4
            ], 'Leading undefineds are included');
            equal(index, 1, 'Index takes into account the leading undefineds from a .attr()');
        });
        list.attr(3, 4);
    });
    test('No events should fire if removals happened on empty arrays', function () {
        var list = new List([]), msg;
        list.bind('remove', function (ev, removed, index) {
            ok(false, msg);
        });
        msg = 'works on pop';
        list.pop();
        msg = 'works on shift';
        list.shift();
        ok(true, 'No events were fired.');
    });
    test('setting an index out of bounds does not create an array', function () {
        expect(1);
        var l = new List();
        l.attr('1', 'foo');
        equal(l.attr('1'), 'foo');
    });
    test('splice with similar but less items works (#1606)', function () {
        var list = new List([
            'aa',
            'bb',
            'cc'
        ]);
        list.splice(0, list.length, 'aa', 'cc', 'dd');
        deepEqual(list.attr(), [
            'aa',
            'cc',
            'dd'
        ]);
        list.splice(0, list.length, 'aa', 'cc');
        deepEqual(list.attr(), [
            'aa',
            'cc'
        ]);
    });
    test('filter returns same list type (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.filter(function () {
        }) instanceof ChildList);
    });
    test('reverse returns the same list instance (#1744)', function () {
        var ParentList = List.extend();
        var ChildList = ParentList.extend();
        var children = new ChildList([
            1,
            2,
            3
        ]);
        ok(children.reverse() === children);
    });
    test('slice and join are observable by a compute (#1884)', function () {
        expect(2);
        var list = new List([
            1,
            2,
            3
        ]);
        var sliced = new Observation(function () {
            return list.slice(0, 1);
        }, null, {
            updater: function (newVal) {
                deepEqual(newVal.attr(), [2], 'got a new List');
            }
        });
        sliced.start();
        var joined = new Observation(function () {
            return list.join(',');
        }, null, {
            updater: function (newVal) {
                equal(newVal, '2,3', 'joined is observable');
            }
        });
        joined.start();
        list.shift();
    });
    test('list is always updated with the last promise passed to replace (#2136)', function () {
        var list = new List();
        stop();
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['A']);
                setTimeout(function () {
                    equal(list.attr(0), 'B', 'list set to last promise\'s value');
                    start();
                }, 10);
            }, 20);
        }));
        list.replace(new Promise(function (resolve) {
            setTimeout(function () {
                resolve(['B']);
            }, 10);
        }));
    });
    test('forEach callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.forEach(function (element, index, list) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
    test('each callback', function () {
        var list = new List([]), counter = 0;
        list.attr(9, 'foo');
        list.each(function (item, index) {
            counter++;
        });
        equal(counter, 1, 'Should not be invoked for uninitialized attr keys');
    });
    test('filter with context', function () {
        var l = new List([{ id: 1 }]);
        var context = {};
        var contextWasCorrect = false;
        l.filter(function () {
            contextWasCorrect = this === context;
            return true;
        }, context);
        equal(contextWasCorrect, true, 'context was correctly passed');
    });
    test('map with context', function () {
        var l = new List([{ id: 1 }]);
        var context = {};
        var contextWasCorrect = false;
        l.map(function () {
            contextWasCorrect = this === context;
            return true;
        }, context);
        equal(contextWasCorrect, true, 'context was correctly passed');
    });
    test('works with can-reflect', 11, function () {
        var a = new Map({ foo: 4 });
        var b = new List([
            'foo',
            'bar'
        ]);
        QUnit.equal(canReflect.getKeyValue(b, '0'), 'foo', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
        };
        QUnit.ok(!canReflect.isValueLike(b), 'isValueLike is false');
        QUnit.ok(canReflect.isMapLike(b), 'isMapLike is true');
        QUnit.ok(canReflect.isListLike(b), 'isListLike is false');
        QUnit.ok(!canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- false');
        b._computedAttrs['length'] = {
            compute: new Observation(function () {
                return a.attr('foo');
            }, null)
        };
        b._computedAttrs['length'].compute.start();
        QUnit.ok(canReflect.keyHasDependencies(b, 'length'), 'keyHasDependencies -- true');
        canReflect.onKeysAdded(b, handler);
        canReflect.onKeysRemoved(b, handler);
        QUnit.ok(b.__bindEvents.add, 'add handler added');
        QUnit.ok(b.__bindEvents.remove, 'remove handler added');
        b.push('quux');
        QUnit.equal(canReflect.getKeyValue(b, 'length'), '4', 'bound value');
        b.pop();
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new Map({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.attr('a'), 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new Map({ foo: 4 });
        var b = new List([
            'foo',
            'bar'
        ]);
        ok(!canReflect.getKeyDependencies(b, 'length'), 'No dependencies before binding');
        b._computedAttrs.length = {
            compute: new Observation(function () {
                return a.attr('foo');
            }, null)
        };
        b._computedAttrs.length.compute.start();
        ok(canReflect.getKeyDependencies(b, 'length'), 'dependencies exist');
        ok(canReflect.getKeyDependencies(b, 'length').valueDependencies.has(b._computedAttrs.length.compute), 'dependencies returned');
    });
    QUnit.test('registered symbols', function () {
        var a = new Map({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.attr('a'), 'b', 'can.setKeyValue');
        function handler(val) {
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.attr('a', 'c');
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.attr('a', 'd');
    });
});
/*can@3.14.0#list/list_test*/
define('can@3.14.0#list/list_test', [
    'require',
    'exports',
    'module',
    'can-list/can-list_test'
], function (require, exports, module) {
    require('can-list/can-list_test');
});
/*can-map@3.6.1#can-map_test*/
define('can-map@3.6.1#can-map_test', [
    'require',
    'exports',
    'module',
    'can-map',
    'steal-qunit',
    'can-observation',
    'can-construct',
    'can-stache-key',
    'can-reflect',
    'can-symbol',
    'can-compute'
], function (require, exports, module) {
    var Map = require('can-map');
    var QUnit = require('steal-qunit');
    var Observation = require('can-observation');
    var Construct = require('can-construct');
    var observeReader = require('can-stache-key');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var canCompute = require('can-compute');
    QUnit.module('can-map');
    test('Basic Map', 4, function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'category', 'correct change name');
            equal(how, 'set');
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('category', 6);
        state.unbind('change');
    });
    test('Nested Map', 5, function () {
        var me = new Map({
            name: {
                first: 'Justin',
                last: 'Meyer'
            }
        });
        ok(me.attr('name') instanceof Map);
        me.bind('change', function (ev, attr, how, val, old) {
            equal(attr, 'name.first', 'correct change name');
            equal(how, 'set');
            equal(val, 'Brian', 'correct');
            equal(old, 'Justin', 'correct');
        });
        me.attr('name.first', 'Brian');
        me.unbind('change');
    });
    test('remove attr', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        state.removeAttr('category');
        deepEqual(Map.keys(state), ['productType'], 'one property');
    });
    test('remove attr on key with dot', function () {
        var state = new Map({
            'key.with.dots': 12,
            productType: 4
        });
        var state2 = new Map({
            'key.with.dots': 4,
            key: { 'with': { someValue: 20 } }
        });
        state.removeAttr('key.with.dots');
        state2.removeAttr('key.with.someValue');
        deepEqual(Map.keys(state), ['productType'], 'one property');
        deepEqual(Map.keys(state2), [
            'key.with.dots',
            'key'
        ], 'two properties');
        deepEqual(Map.keys(state2.key['with']), [], 'zero properties');
    });
    test('nested event handlers are not run by changing the parent property (#280)', function () {
        var person = new Map({ name: { first: 'Justin' } });
        person.bind('name.first', function (ev, newName) {
            ok(false, 'name.first should never be called');
        });
        person.bind('name', function () {
            ok(true, 'name event triggered');
        });
        person.attr('name', { first: 'Hank' });
    });
    test('cyclical objects (#521)', function () {
        var foo = {};
        foo.foo = foo;
        var fooed = new Map(foo);
        ok(true, 'did not cause infinate recursion');
        ok(fooed.attr('foo') === fooed, 'map points to itself');
        var me = { name: 'Justin' };
        var references = {
            husband: me,
            friend: me
        };
        var ref = new Map(references);
        ok(ref.attr('husband') === ref.attr('friend'), 'multiple properties point to the same thing');
    });
    test('_cid add to original object', function () {
        var map = new Map(), obj = { 'name': 'thecountofzero' };
        map.attr('myObj', obj);
        ok(!obj._cid, '_cid not added to original object');
    });
    test('Map serialize triggers reading (#626)', function () {
        var old = Observation.add;
        var attributesRead = [];
        var readingTriggeredForKeys = false;
        Observation.add = function (object, attribute) {
            if (attribute === '__keys') {
                readingTriggeredForKeys = true;
            } else {
                attributesRead.push(attribute);
            }
        };
        var testMap = new Map({
            cats: 'meow',
            dogs: 'bark'
        });
        testMap.serialize();
        ok(attributesRead.indexOf('cats') !== -1 && attributesRead.indexOf('dogs') !== -1, 'map serialization triggered __reading on all attributes');
        ok(readingTriggeredForKeys, 'map serialization triggered __reading for __keys');
        Observation.add = old;
    });
    test('Test top level attributes', 7, function () {
        var test = new Map({
            'my.enable': false,
            'my.item': true,
            'my.count': 0,
            'my.newCount': 1,
            'my': {
                'value': true,
                'nested': { 'value': 100 }
            }
        });
        equal(test.attr('my.value'), true, 'correct');
        equal(test.attr('my.nested.value'), 100, 'correct');
        ok(test.attr('my.nested') instanceof Map);
        equal(test.attr('my.enable'), false, 'falsey (false) value accessed correctly');
        equal(test.attr('my.item'), true, 'truthey (true) value accessed correctly');
        equal(test.attr('my.count'), 0, 'falsey (0) value accessed correctly');
        equal(test.attr('my.newCount'), 1, 'falsey (1) value accessed correctly');
    });
    test('serializing cycles', function () {
        var map1 = new Map({ name: 'map1' });
        var map2 = new Map({ name: 'map2' });
        map1.attr('map2', map2);
        map2.attr('map1', map1);
        var res = map1.serialize();
        equal(res.name, 'map1');
        equal(res.map2.name, 'map2');
    });
    test('Unbinding from a map with no bindings doesn\'t throw an error (#1015)', function () {
        expect(0);
        var test = new Map({});
        try {
            test.unbind('change');
        } catch (e) {
            ok(false, 'No error should be thrown');
        }
    });
    test('Fast dispatch event still has target and type (#1082)', 4, function () {
        var data = new Map({ name: 'CanJS' });
        data.bind('change', function (ev) {
            equal(ev.type, 'change');
            equal(ev.target, data);
        });
        data.bind('name', function (ev) {
            equal(ev.type, 'name');
            equal(ev.target, data);
        });
        data.attr('name', 'David');
    });
    test('map passed to Map constructor (#1166)', function () {
        function y() {
        }
        var map = new Map({
            x: 1,
            y: y
        });
        var res = new Map(map);
        deepEqual(res.attr(), {
            x: 1,
            y: y
        }, 'has the same properties');
    });
    test('constructor passed to scope is threated as a property (#1261)', function () {
        var Constructor = Construct.extend({});
        var MyMap = Map.extend({ Todo: Constructor });
        var m = new MyMap();
        equal(m.attr('Todo'), Constructor);
    });
    test('_bindings count maintained after calling .off() on undefined property (#1490) ', function () {
        var map = new Map({ test: 1 });
        map.on('test', function () {
        });
        equal(map.__bindEvents._lifecycleBindings, 1, 'The number of bindings is correct');
        map.off('undefined_property');
        equal(map.__bindEvents._lifecycleBindings, 1, 'The number of bindings is still correct');
    });
    test('Should be able to get and set attribute named \'watch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('watch');
        ok(true, 'can have attribute named \'watch\' on a Map instance');
    });
    test('Should be able to get and set attribute named \'unwatch\' on Map in Firefox', function () {
        var map = new Map({});
        map.attr('unwatch');
        ok(true, 'can have attribute named \'unwatch\' on a Map instance');
    });
    test('should get an empty string property value correctly', function () {
        var map = new Map({
            foo: 'foo',
            '': 'empty string'
        });
        equal(map.attr(''), 'empty string');
    });
    test('ObserveReader - can.Construct derived classes should be considered objects, not functions (#450)', function () {
        var foostructor = Map.extend({ text: 'bar' }, {}), obj = {
                next_level: {
                    thing: foostructor,
                    text: 'In the inner context'
                }
            }, read;
        foostructor.self = foostructor;
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'));
        equal(read.value, 'bar', 'static properties on a can.Construct-based function');
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self'), { isArgument: true });
        ok(read.value === foostructor, 'arguments shouldn\'t be executed');
        foostructor.self = function () {
            return foostructor;
        };
        read = observeReader.read(obj, observeReader.reads('next_level.thing.self.text'), {});
        equal(read.value, 'bar', 'anonymous functions in the middle of a read should be executed if requested');
    });
    test('Basic Map.prototype.compute', function () {
        var state = new Map({
            category: 5,
            productType: 4
        });
        var catCompute = state.compute('category');
        var prodCompute = state.compute('productType');
        catCompute.bind('change', function (ev, val, old) {
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.bind('productType', function (ev, val, old) {
            equal(val, 5, 'correct');
            equal(old, 4, 'correct');
        });
        state.attr('category', 6);
        prodCompute(5);
        catCompute.unbind('change');
        state.unbind('productType');
    });
    test('Deep Map.prototype.compute', function () {
        var state = new Map({
            product: {
                category: 5,
                productType: 4
            }
        });
        var catCompute = state.compute('product.category');
        var prodCompute = state.compute('product.productType');
        catCompute.bind('change', function (ev, val, old) {
            equal(val, 6, 'correct');
            equal(old, 5, 'correct');
        });
        state.attr('product').bind('productType', function (ev, val, old) {
            equal(val, 5, 'correct');
            equal(old, 4, 'correct');
        });
        state.attr('product.category', 6);
        prodCompute(5);
        catCompute.unbind('change');
        state.unbind('productType');
    });
    test('works with can-reflect', 7, function () {
        var b = new Map({ 'foo': 'bar' });
        var c = new (Map.extend({
            'baz': canCompute(function () {
                return b.attr('foo');
            })
        }))({
            'foo': 'bar',
            thud: 'baz'
        });
        QUnit.equal(canReflect.getKeyValue(b, 'foo'), 'bar', 'unbound value');
        var handler = function (newValue) {
            QUnit.equal(newValue, 'quux', 'observed new value');
            canReflect.offKeyValue(c, 'baz', handler);
        };
        QUnit.ok(!canReflect.isValueLike(c), 'isValueLike is false');
        QUnit.ok(canReflect.isMapLike(c), 'isMapLike is true');
        QUnit.ok(!canReflect.isListLike(c), 'isListLike is false');
        canReflect.onKeyValue(c, 'baz', handler);
        canReflect.onKeyValue(c, 'thud', handler);
        b.attr('foo', 'quux');
        c.attr('thud', 'quux');
        QUnit.equal(canReflect.getKeyValue(c, 'baz'), 'quux', 'bound value');
        b.attr('foo', 'thud');
        c.attr('baz', 'jeek');
    });
    QUnit.test('can-reflect setKeyValue', function () {
        var a = new Map({ 'a': 'b' });
        canReflect.setKeyValue(a, 'a', 'c');
        QUnit.equal(a.attr('a'), 'c', 'setKeyValue');
    });
    QUnit.test('can-reflect getKeyDependencies', function () {
        var a = new Map({ 'a': 'a' });
        var b = new (Map.extend({
            'a': canCompute(function () {
                return a.attr('a');
            }),
            'b': 'b'
        }))();
        ok(canReflect.getKeyDependencies(b, 'a'), 'Dependencies on computed attr');
        ok(!canReflect.getKeyDependencies(b, 'b'), 'No dependencies on data attr');
        b.on('a', function () {
        });
        ok(canReflect.getKeyDependencies(b, 'a').valueDependencies.has(b._computedAttrs.a.compute), 'dependencies returned');
        ok(canReflect.getValueDependencies(b._computedAttrs.a.compute).valueDependencies, 'dependencies returned from compute');
    });
    QUnit.test('registered symbols', function () {
        var a = new Map({ 'a': 'a' });
        ok(a[canSymbol.for('can.isMapLike')], 'can.isMapLike');
        equal(a[canSymbol.for('can.getKeyValue')]('a'), 'a', 'can.getKeyValue');
        a[canSymbol.for('can.setKeyValue')]('a', 'b');
        equal(a.attr('a'), 'b', 'can.setKeyValue');
        function handler(val) {
            equal(this, a);
            equal(val, 'c', 'can.onKeyValue');
        }
        a[canSymbol.for('can.onKeyValue')]('a', handler);
        a.attr('a', 'c');
        a[canSymbol.for('can.offKeyValue')]('a', handler);
        a.attr('a', 'd');
    });
    QUnit.test('.attr(props) should overwrite if _legacyAttrBehavior is true (#112)', function () {
        Map.prototype._legacyAttrBehavior = true;
        var myMap1Instance = new Map({ prop1: new Map() });
        var changes = 0;
        myMap1Instance.on('prop1', function () {
            changes++;
        });
        var map2 = new Map({ prop1: 'xyz' });
        myMap1Instance.attr({ 'prop1': map2 });
        delete Map.prototype._legacyAttrBehavior;
        QUnit.equal(changes, 1, 'caused a change event');
        QUnit.equal(myMap1Instance.attr('prop1'), map2, 'overwrite with maps');
    });
    QUnit.test('.attr() leaves typed instances alone if _legacyAttrBehavior is true (#111)', function () {
        Map.prototype._legacyAttrBehavior = true;
        function MyClass(value) {
            this.value = value;
        }
        MyClass.prototype.log = function () {
            return this.value;
        };
        var myMap = new Map({ myClass: new MyClass(5) });
        QUnit.equal(myMap.attr().myClass, myMap.attr('myClass'));
        delete Map.prototype._legacyAttrBehavior;
    });
    QUnit.test('.serialize() leaves typed instances alone if _legacyAttrBehavior is true', function () {
        function MyClass(value) {
            this.value = value;
        }
        var myMap = new Map({
            _legacyAttrBehavior: true,
            myClass: new MyClass('foo')
        });
        var ser = myMap.serialize();
        QUnit.equal(ser.myClass, myMap.attr('myClass'));
    });
    QUnit.test('Can assign nested properties that are not CanMaps', function () {
        var MyType = function () {
            this.one = 'one';
            this.two = 'two';
            this.three = 'three';
        };
        MyType.prototype[canSymbol.for('can.onKeyValue')] = function () {
        };
        MyType.prototype[canSymbol.for('can.isMapLike')] = true;
        var map = new Map({
            _legacyAttrBehavior: true,
            foo: 'bar',
            prop: new MyType()
        });
        map.attr({
            prop: {
                one: '1',
                two: '2'
            }
        });
        QUnit.equal(map.attr('prop.one'), '1');
        QUnit.equal(map.attr('prop.two'), '2');
        QUnit.equal(map.attr('prop.three'), 'three');
        map.attr({
            prop: {
                one: 'one',
                two: 'two'
            }
        }, true);
        QUnit.equal(map.attr('prop.one'), 'one');
        QUnit.equal(map.attr('prop.two'), 'two');
        QUnit.equal(map.attr('prop.three'), undefined);
    });
});
/*can@3.14.0#map/map_test*/
define('can@3.14.0#map/map_test', [
    'require',
    'exports',
    'module',
    'can-map/can-map_test'
], function (require, exports, module) {
    require('can-map/can-map_test');
});
/*can-map-define@3.1.2#can-map-define*/
define('can-map-define@3.1.2#can-map-define', [
    'require',
    'exports',
    'module',
    'can-util/js/dev/dev',
    'can-util/js/assign/assign',
    'can-util/js/is-plain-object/is-plain-object',
    'can-event',
    'can-event/batch/batch',
    'can-map/map-helpers',
    'can-map',
    'can-compute',
    'can-list'
], function (require, exports, module) {
    var dev = require('can-util/js/dev/dev');
    var extend = require('can-util/js/assign/assign');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canEvent = require('can-event');
    var batch = require('can-event/batch/batch');
    var mapHelpers = require('can-map/map-helpers');
    var CanMap = require('can-map');
    var compute = require('can-compute');
    require('can-list');
    var define = {};
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop, defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else if (defaultProp && defaultProp[behavior] !== undefined) {
                return defaultProp[behavior];
            }
        }
    };
    mapHelpers.define = function (Map, baseDefine) {
        var definitions = Map.prototype.define;
        if (baseDefine) {
            var defines = {};
            mapHelpers.twoLevelDeepExtend(defines, baseDefine);
            mapHelpers.twoLevelDeepExtend(defines, definitions);
            extend(definitions, defines);
        }
        Map.defaultGenerators = {};
        for (var prop in definitions) {
            var type = definitions[prop].type;
            if (typeof type === 'string') {
                if (typeof define.types[type] === 'object') {
                    delete definitions[prop].type;
                    extend(definitions[prop], define.types[type]);
                }
            }
            if ('value' in definitions[prop]) {
                if (typeof definitions[prop].value === 'function') {
                    Map.defaultGenerators[prop] = definitions[prop].value;
                } else {
                    Map.defaults[prop] = definitions[prop].value;
                }
            }
            if (typeof definitions[prop].Value === 'function') {
                (function (Constructor) {
                    Map.defaultGenerators[prop] = function () {
                        return new Constructor();
                    };
                }(definitions[prop].Value));
            }
        }
    };
    var oldSetupDefaults = CanMap.prototype._setupDefaults;
    CanMap.prototype._setupDefaults = function (obj) {
        var defaults = extend({}, oldSetupDefaults.call(this)), propsCommittedToAttr = {}, Map = this.constructor, originalGet = this._get;
        this._get = function (originalProp) {
            var prop = originalProp.indexOf('.') !== -1 ? originalProp.substr(0, originalProp.indexOf('.')) : originalProp;
            if (prop in defaults && !(prop in propsCommittedToAttr)) {
                this.attr(prop, defaults[prop]);
                propsCommittedToAttr[prop] = true;
            }
            return originalGet.apply(this, arguments);
        };
        for (var prop in Map.defaultGenerators) {
            if (!obj || !(prop in obj)) {
                defaults[prop] = Map.defaultGenerators[prop].call(this);
            }
        }
        delete this._get;
        return defaults;
    };
    var proto = CanMap.prototype, oldSet = proto.__set;
    proto.__set = function (prop, value, current, success, error) {
        var self = this;
        var errorCallback = function (errors) {
                var stub = error && error.call(self, errors);
                if (stub !== false) {
                    canEvent.trigger(self, 'error', [
                        prop,
                        errors
                    ], true);
                }
                return false;
            }, setter = getPropDefineBehavior('set', prop, this.define), getter = getPropDefineBehavior('get', prop, this.define);
        if (setter) {
            batch.start();
            var setterCalled = false, setValue = setter.call(this, value, function (value) {
                    if (getter) {
                        self[prop](value);
                    } else {
                        oldSet.call(self, prop, value, current, success, errorCallback);
                    }
                    setterCalled = true;
                }, errorCallback, getter ? this._computedAttrs[prop].compute.computeInstance.lastSetValue.get() : current);
            if (getter) {
                if (setValue !== undefined && !setterCalled && setter.length >= 1) {
                    this._computedAttrs[prop].compute(setValue);
                }
                batch.stop();
                return;
            } else if (setValue === undefined && !setterCalled && setter.length > 1) {
                batch.stop();
                return;
            } else {
                if (!setterCalled) {
                    oldSet.call(self, prop, setter.length === 0 && setValue === undefined ? value : setValue, current, success, errorCallback);
                }
                batch.stop();
                return this;
            }
        } else {
            oldSet.call(self, prop, value, current, success, errorCallback);
        }
        return this;
    };
    define.types = {
        'date': function (str) {
            var type = typeof str;
            if (type === 'string') {
                str = Date.parse(str);
                return isNaN(str) ? null : new Date(str);
            } else if (type === 'number') {
                return new Date(str);
            } else {
                return str;
            }
        },
        'number': function (val) {
            if (val == null) {
                return val;
            }
            return +val;
        },
        'boolean': function (val) {
            if (val == null) {
                return val;
            }
            if (val === 'false' || val === '0' || !val) {
                return false;
            }
            return true;
        },
        'htmlbool': function (val) {
            return typeof val === 'string' || !!val;
        },
        '*': function (val) {
            return val;
        },
        'string': function (val) {
            if (val == null) {
                return val;
            }
            return '' + val;
        },
        'compute': {
            set: function (newValue, setVal, setErr, oldValue) {
                if (newValue && newValue.isComputed) {
                    return newValue;
                }
                if (oldValue && oldValue.isComputed) {
                    oldValue(newValue);
                    return oldValue;
                }
                return newValue;
            },
            get: function (value) {
                return value && value.isComputed ? value() : value;
            }
        }
    };
    var oldType = proto.__type;
    proto.__type = function (value, prop) {
        var type = getPropDefineBehavior('type', prop, this.define), Type = getPropDefineBehavior('Type', prop, this.define), newValue = value;
        if (typeof type === 'string') {
            type = define.types[type];
        }
        if (type || Type) {
            if (type) {
                newValue = type.call(this, newValue, prop);
            }
            if (Type && newValue != null && !(newValue instanceof Type)) {
                newValue = new Type(newValue);
            }
            return newValue;
        } else if (isPlainObject(newValue) && newValue.define) {
            newValue = CanMap.extend(newValue);
            newValue = new newValue();
        }
        return oldType.call(this, newValue, prop);
    };
    var oldRemove = proto.__remove;
    proto.__remove = function (prop, current) {
        var remove = getPropDefineBehavior('remove', prop, this.define), res;
        if (remove) {
            batch.start();
            res = remove.call(this, current);
            if (res === false) {
                batch.stop();
                return;
            } else {
                res = oldRemove.call(this, prop, current);
                batch.stop();
                return res;
            }
        }
        return oldRemove.call(this, prop, current);
    };
    var oldSetupComputes = proto._setupComputedProperties;
    proto._setupComputedProperties = function () {
        oldSetupComputes.apply(this, arguments);
        for (var attr in this.define) {
            var def = this.define[attr], get = def.get;
            if (get) {
                mapHelpers.addComputedAttr(this, attr, compute.async(undefined, get, this));
            }
        }
    };
    var oldSingleSerialize = proto.___serialize;
    var serializeProp = function (map, attr, val) {
        var serializer = attr === '*' ? false : getPropDefineBehavior('serialize', attr, map.define);
        if (serializer === undefined) {
            return oldSingleSerialize.call(map, attr, val);
        } else if (serializer !== false) {
            return typeof serializer === 'function' ? serializer.call(map, val, attr) : oldSingleSerialize.call(map, attr, val);
        }
    };
    proto.___serialize = function (name, val) {
        return serializeProp(this, name, val);
    };
    var oldSerialize = proto.serialize;
    proto.serialize = function (property) {
        var serialized = oldSerialize.apply(this, arguments);
        if (property) {
            return serialized;
        }
        var serializer, val;
        for (var attr in this.define) {
            if (!(attr in serialized)) {
                serializer = this.define && (this.define[attr] && this.define[attr].serialize || this.define['*'] && this.define['*'].serialize);
                if (serializer) {
                    val = serializeProp(this, attr, this.attr(attr));
                    if (val !== undefined) {
                        serialized[attr] = val;
                    }
                }
            }
        }
        return serialized;
    };
    module.exports = define;
});
/*can-map-define@3.1.2#can-map-define_test*/
define('can-map-define@3.1.2#can-map-define_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-util/js/string/string',
    'can-map',
    'can-list',
    'can-compute',
    './can-map-define'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var string = require('can-util/js/string/string');
    var CanMap = require('can-map');
    var List = require('can-list');
    var compute = require('can-compute');
    require('./can-map-define');
    QUnit.module('can/map/define');
    test('basics set', function () {
        var Defined = CanMap.extend({
            define: {
                prop: {
                    set: function (newVal) {
                        return 'foo' + newVal;
                    }
                }
            }
        });
        var def = new Defined();
        def.attr('prop', 'bar');
        equal(def.attr('prop'), 'foobar', 'setter works');
        Defined = CanMap.extend({
            define: {
                prop: {
                    set: function (newVal, setter) {
                        setter('foo' + newVal);
                    }
                }
            }
        });
        def = new Defined();
        def.attr('prop', 'bar');
        equal(def.attr('prop'), 'foobar', 'setter callback works');
    });
    test('basics remove', function () {
        var ViewModel = CanMap.extend({
            define: {
                makeId: {
                    remove: function () {
                        this.removeAttr('models');
                    }
                },
                models: {
                    remove: function () {
                        this.removeAttr('modelId');
                    }
                },
                modelId: {
                    remove: function () {
                        this.removeAttr('years');
                    }
                },
                years: {
                    remove: function () {
                        this.removeAttr('year');
                    }
                }
            }
        });
        var mmy = new ViewModel({
            makes: [{ id: 1 }],
            makeId: 1,
            models: [{ id: 2 }],
            modelId: 2,
            years: [2010],
            year: 2010
        });
        var events = [
                'year',
                'years',
                'modelId',
                'models',
                'makeId'
            ], eventCount = 0, batchNum;
        mmy.bind('change', function (ev, attr) {
            if (batchNum === undefined) {
                batchNum = ev.batchNum;
            }
            equal(attr, events[eventCount++], 'got correct attribute');
            ok(ev.batchNum && ev.batchNum === batchNum, 'batched');
        });
        mmy.removeAttr('makeId');
    });
    test('basics get', function () {
        var Person = CanMap.extend({
            define: {
                fullName: {
                    get: function () {
                        return this.attr('first') + ' ' + this.attr('last');
                    }
                }
            }
        });
        var p = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        equal(p.attr('fullName'), 'Justin Meyer', 'sync getter works');
        var Adder = CanMap.extend({
            define: {
                more: {
                    get: function (curVal, setVal) {
                        var num = this.attr('num');
                        setTimeout(function () {
                            setVal(num + 1);
                        }, 10);
                    }
                }
            }
        });
        var a = new Adder({ num: 1 }), callbackVals = [
                [
                    2,
                    undefined,
                    function () {
                        a.attr('num', 2);
                    }
                ],
                [
                    3,
                    2,
                    function () {
                        start();
                    }
                ]
            ], callbackCount = 0;
        a.bind('more', function (ev, newVal, oldVal) {
            var vals = callbackVals[callbackCount++];
            equal(newVal, vals[0], 'newVal is correct');
            equal(a.attr('more'), vals[0], 'attr value is correct');
            equal(oldVal, vals[1], 'oldVal is correct');
            setTimeout(vals[2], 10);
        });
        stop();
    });
    test('basic type', function () {
        expect(6);
        var Typer = CanMap.extend({
            define: {
                arrayWithAddedItem: {
                    type: function (value) {
                        if (value && value.push) {
                            value.push('item');
                        }
                        return value;
                    }
                },
                listWithAddedItem: {
                    type: function (value) {
                        if (value && value.push) {
                            value.push('item');
                        }
                        return value;
                    },
                    Type: List
                }
            }
        });
        var t = new Typer();
        deepEqual(CanMap.keys(t), [], 'no keys');
        var array = [];
        t.attr('arrayWithAddedItem', array);
        deepEqual(array, ['item'], 'updated array');
        equal(t.attr('arrayWithAddedItem'), array, 'leave value as array');
        t.attr('listWithAddedItem', []);
        ok(t.attr('listWithAddedItem') instanceof List, 'convert to List');
        equal(t.attr('listWithAddedItem').attr(0), 'item', 'has item in it');
        t.bind('change', function (ev, attr) {
            equal(attr, 'listWithAddedItem.1', 'got a bubbling event');
        });
        t.attr('listWithAddedItem').push('another item');
    });
    test('basic Type', function () {
        var Foo = function (name) {
            this.name = name;
        };
        Foo.prototype.getName = function () {
            return this.name;
        };
        var Typer = CanMap.extend({ define: { foo: { Type: Foo } } });
        var t = new Typer({ foo: 'Justin' });
        equal(t.attr('foo').getName(), 'Justin', 'correctly created an instance');
        var brian = new Foo('brian');
        t.attr('foo', brian);
        equal(t.attr('foo'), brian, 'same instances');
    });
    test('type converters', function () {
        var Typer = CanMap.extend({
            define: {
                date: { type: 'date' },
                string: { type: 'string' },
                number: { type: 'number' },
                'boolean': { type: 'boolean' },
                htmlbool: { type: 'htmlbool' },
                leaveAlone: { type: '*' }
            }
        });
        var obj = {};
        var t = new Typer({
            date: 1395896701516,
            string: 5,
            number: '5',
            'boolean': 'false',
            htmlbool: '',
            leaveAlone: obj
        });
        ok(t.attr('date') instanceof Date, 'converted to date');
        equal(t.attr('string'), '5', 'converted to string');
        equal(t.attr('number'), 5, 'converted to number');
        equal(t.attr('boolean'), false, 'converted to boolean');
        equal(t.attr('htmlbool'), true, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), obj, 'left as object');
        t.attr({ 'number': '15' });
        ok(t.attr('number') === 15, 'converted to number');
    });
    test('basics value', function () {
        var Typer = CanMap.extend({ define: { prop: { value: 'foo' } } });
        equal(new Typer().attr('prop'), 'foo', 'value is used as default value');
        var Typer2 = CanMap.extend({
            define: {
                prop: {
                    value: function () {
                        return [];
                    },
                    type: '*'
                }
            }
        });
        var t1 = new Typer2(), t2 = new Typer2();
        ok(t1.attr('prop') !== t2.attr('prop'), 'different array instances');
        ok(Array.isArray(t1.attr('prop')), 'its an array');
    });
    test('basics Value', function () {
        var Typer = CanMap.extend({
            define: {
                prop: {
                    Value: Array,
                    type: '*'
                }
            }
        });
        var t1 = new Typer(), t2 = new Typer();
        ok(t1.attr('prop') !== t2.attr('prop'), 'different array instances');
        ok(Array.isArray(t1.attr('prop')), 'its an array');
    });
    test('setter with no arguments and returns undefined does the default behavior, the setter is for side effects only', function () {
        var Typer = CanMap.extend({
            define: {
                prop: {
                    set: function () {
                        this.attr('foo', 'bar');
                    }
                }
            }
        });
        var t = new Typer();
        t.attr('prop', false);
        deepEqual(t.attr(), {
            foo: 'bar',
            prop: false
        });
    });
    test('type happens before the set', function () {
        var MyMap = CanMap.extend({
            define: {
                prop: {
                    type: 'number',
                    set: function (newValue) {
                        equal(typeof newValue, 'number', 'got a number');
                        return newValue + 1;
                    }
                }
            }
        });
        var map = new MyMap();
        map.attr('prop', '5');
        equal(map.attr('prop'), 6, 'number');
    });
    test('getter and setter work', function () {
        expect(5);
        var Paginate = CanMap.extend({
            define: {
                page: {
                    set: function (newVal) {
                        this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));
                    },
                    get: function () {
                        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;
                    }
                }
            }
        });
        var p = new Paginate({
            limit: 10,
            offset: 20
        });
        equal(p.attr('page'), 3, 'page get right');
        p.bind('page', function (ev, newValue, oldValue) {
            equal(newValue, 2, 'got new value event');
            equal(oldValue, 3, 'got old value event');
        });
        p.attr('page', 2);
        equal(p.attr('page'), 2, 'page set right');
        equal(p.attr('offset'), 10, 'page offset set');
    });
    test('getter with initial value', function () {
        var comp = compute(1);
        var Grabber = CanMap.extend({
            define: {
                vals: {
                    type: '*',
                    Value: Array,
                    get: function (current, setVal) {
                        if (setVal) {
                            current.push(comp());
                        }
                        return current;
                    }
                }
            }
        });
        var g = new Grabber();
        equal(g.attr('vals').length, 0, 'zero items in array');
    });
    test('serialize basics', function () {
        var MyMap = CanMap.extend({
            define: {
                name: {
                    serialize: function () {
                        return;
                    }
                },
                locations: { serialize: false },
                locationIds: {
                    get: function () {
                        var ids = [];
                        this.attr('locations').each(function (location) {
                            ids.push(location.id);
                        });
                        return ids;
                    },
                    serialize: function (locationIds) {
                        return locationIds.join(',');
                    }
                },
                bared: {
                    get: function () {
                        return this.attr('name') + '+bar';
                    },
                    serialize: true
                },
                ignored: {
                    get: function () {
                        return this.attr('name') + '+ignored';
                    }
                }
            }
        });
        var map = new MyMap({ name: 'foo' });
        map.attr('locations', [
            {
                id: 1,
                name: 'Chicago'
            },
            {
                id: 2,
                name: 'LA'
            }
        ]);
        equal(map.attr('locationIds').length, 2, 'get locationIds');
        equal(map.attr('locationIds')[0], 1, 'get locationIds index 0');
        equal(map.attr('locations')[0].id, 1, 'get locations index 0');
        var serialized = map.serialize();
        equal(serialized.locations, undefined, 'locations doesn\'t serialize');
        equal(serialized.locationIds, '1,2', 'locationIds serializes');
        equal(serialized.name, undefined, 'name doesn\'t serialize');
        equal(serialized.bared, 'foo+bar', 'true adds computed props');
        equal(serialized.ignored, undefined, 'computed props are not serialized by default');
    });
    test('serialize context', function () {
        var context, serializeContext;
        var MyMap = CanMap.extend({
            define: {
                name: {
                    serialize: function (obj) {
                        context = this;
                        return obj;
                    }
                }
            },
            serialize: function () {
                serializeContext = this;
                CanMap.prototype.serialize.apply(this, arguments);
            }
        });
        var map = new MyMap();
        map.serialize();
        equal(context, map);
        equal(serializeContext, map);
    });
    test('methods contexts', function () {
        var contexts = {};
        var MyMap = CanMap.extend({
            define: {
                name: {
                    value: 'John Galt',
                    get: function (obj) {
                        contexts.get = this;
                        return obj;
                    },
                    remove: function (obj) {
                        contexts.remove = this;
                        return obj;
                    },
                    set: function (obj) {
                        contexts.set = this;
                        return obj;
                    },
                    serialize: function (obj) {
                        contexts.serialize = this;
                        return obj;
                    },
                    type: function (val) {
                        contexts.type = this;
                        return val;
                    }
                }
            }
        });
        var map = new MyMap();
        map.serialize();
        map.removeAttr('name');
        equal(contexts.get, map);
        equal(contexts.remove, map);
        equal(contexts.set, map);
        equal(contexts.serialize, map);
        equal(contexts.type, map);
    });
    test('value generator is not called if default passed', function () {
        var TestMap = CanMap.extend({
            define: {
                foo: {
                    value: function () {
                        throw '"foo"\'s value method should not be called.';
                    }
                }
            }
        });
        var tm = new TestMap({ foo: 'baz' });
        equal(tm.attr('foo'), 'baz');
    });
    test('Value generator can read other properties', function () {
        var Map = CanMap.extend({
            letters: 'ABC',
            numbers: [
                1,
                2,
                3
            ],
            define: {
                definedLetters: { value: 'DEF' },
                definedNumbers: {
                    value: [
                        4,
                        5,
                        6
                    ]
                },
                generatedLetters: {
                    value: function () {
                        return 'GHI';
                    }
                },
                generatedNumbers: {
                    value: function () {
                        return new List([
                            7,
                            8,
                            9
                        ]);
                    }
                },
                firstLetter: {
                    value: function () {
                        return this.attr('letters').substr(0, 1);
                    }
                },
                firstNumber: {
                    value: function () {
                        return this.attr('numbers.0');
                    }
                },
                middleLetter: {
                    value: function () {
                        return this.attr('definedLetters').substr(1, 1);
                    }
                },
                middleNumber: {
                    value: function () {
                        return this.attr('definedNumbers.1');
                    }
                },
                lastLetter: {
                    value: function () {
                        return this.attr('generatedLetters').substr(2, 1);
                    }
                },
                lastNumber: {
                    value: function () {
                        return this.attr('generatedNumbers.2');
                    }
                }
            }
        });
        var map = new Map();
        var prefix = 'Was able to read dependent value from ';
        equal(map.attr('firstLetter'), 'A', prefix + 'traditional CanMap style property definition');
        equal(map.attr('firstNumber'), 1, prefix + 'traditional CanMap style property definition');
        equal(map.attr('middleLetter'), 'E', prefix + 'define plugin style default property definition');
        equal(map.attr('middleNumber'), 5, prefix + 'define plugin style default property definition');
        equal(map.attr('lastLetter'), 'I', prefix + 'define plugin style generated default property definition');
        equal(map.attr('lastNumber'), 9, prefix + 'define plugin style generated default property definition');
    });
    test('default behaviors with "*" work for attributes', function () {
        expect(9);
        var DefaultMap = CanMap.extend({
            define: {
                someNumber: { value: '5' },
                '*': {
                    type: 'number',
                    serialize: function (value) {
                        return '' + value;
                    },
                    set: function (newVal) {
                        ok(true, 'set called');
                        return newVal;
                    },
                    remove: function (currentVal) {
                        ok(true, 'remove called');
                        return false;
                    }
                }
            }
        });
        var map = new DefaultMap(), serializedMap;
        equal(map.attr('someNumber'), 5, 'value of someNumber should be converted to a number');
        map.attr('number', '10');
        equal(map.attr('number'), 10, 'value of number should be converted to a number');
        map.removeAttr('number');
        equal(map.attr('number'), 10, 'number should not be removed');
        serializedMap = map.serialize();
        equal(serializedMap.number, '10', 'number serialized as string');
        equal(serializedMap.someNumber, '5', 'someNumber serialized as string');
        equal(serializedMap['*'], undefined, '"*" is not a value in serialized object');
    });
    test('models properly serialize with default behaviors', function () {
        var DefaultMap = CanMap.extend({
            define: {
                name: { value: 'Alex' },
                shirt: {
                    value: 'blue',
                    serialize: true
                },
                '*': { serialize: false }
            }
        });
        var map = new DefaultMap({
                age: 10,
                name: 'John'
            }), serializedMap = map.serialize();
        equal(serializedMap.age, undefined, 'age doesn\'t exist');
        equal(serializedMap.name, undefined, 'name doesn\'t exist');
        equal(serializedMap.shirt, 'blue', 'shirt exists');
    });
    test('nested define', function () {
        var nailedIt = 'Nailed it';
        var Example = CanMap.extend({}, { define: { name: { value: nailedIt } } });
        var NestedMap = CanMap.extend({}, {
            define: {
                isEnabled: { value: true },
                test: { Value: Example },
                examples: {
                    value: {
                        define: {
                            one: { Value: Example },
                            two: { value: { define: { deep: { Value: Example } } } }
                        }
                    }
                }
            }
        });
        var nested = new NestedMap();
        equal(nested.attr('test.name'), nailedIt);
        equal(nested.attr('examples.one.name'), nailedIt);
        equal(nested.attr('examples.two.deep.name'), nailedIt);
        ok(nested.attr('test') instanceof Example);
        ok(nested.attr('examples.one') instanceof Example);
        ok(nested.attr('examples.two.deep') instanceof Example);
    });
    test('Can make an attr alias a compute (#1470)', 9, function () {
        var computeValue = compute(1);
        var GetMap = CanMap.extend({
            define: {
                value: {
                    set: function (newValue, setVal, setErr, oldValue) {
                        if (newValue.isComputed) {
                            return newValue;
                        }
                        if (oldValue && oldValue.isComputed) {
                            oldValue(newValue);
                            return oldValue;
                        }
                        return newValue;
                    },
                    get: function (value) {
                        return value && value.isComputed ? value() : value;
                    }
                }
            }
        });
        var getMap = new GetMap();
        getMap.attr('value', computeValue);
        equal(getMap.attr('value'), 1);
        var bindCallbacks = 0;
        getMap.bind('value', function (ev, newVal, oldVal) {
            switch (bindCallbacks) {
            case 0:
                equal(newVal, 2, '0 - bind called with new val');
                equal(oldVal, 1, '0 - bind called with old val');
                break;
            case 1:
                equal(newVal, 3, '1 - bind called with new val');
                equal(oldVal, 2, '1 - bind called with old val');
                break;
            case 2:
                equal(newVal, 4, '2 - bind called with new val');
                equal(oldVal, 3, '2 - bind called with old val');
                break;
            }
            bindCallbacks++;
        });
        computeValue(2);
        getMap.attr('value', 3);
        equal(getMap.attr('value'), 3, 'read value is 3');
        equal(computeValue(), 3, 'the compute value is 3');
        var newComputeValue = compute(4);
        getMap.attr('value', newComputeValue);
    });
    test('setting a value of a property with type "compute" triggers change events', function () {
        var handler;
        var message = 'The change event passed the correct {prop} when set with {method}';
        var createChangeHandler = function (expectedOldVal, expectedNewVal, method) {
            return function (ev, newVal, oldVal) {
                var subs = {
                    prop: 'newVal',
                    method: method
                };
                equal(newVal, expectedNewVal, string.sub(message, subs));
                subs.prop = 'oldVal';
                equal(oldVal, expectedOldVal, string.sub(message, subs));
            };
        };
        var ComputableMap = CanMap.extend({ define: { computed: { type: 'compute' } } });
        var computed = compute(0);
        var m1 = new ComputableMap({ computed: computed });
        equal(m1.attr('computed'), 0, 'm1 is 1');
        handler = createChangeHandler(0, 1, '.attr(\'computed\', newVal)');
        m1.bind('computed', handler);
        m1.attr('computed', 1);
        m1.unbind('computed', handler);
        handler = createChangeHandler(1, 2, 'computed()');
        m1.bind('computed', handler);
        computed(2);
        m1.unbind('computed', handler);
    });
    test('replacing the compute on a property with type "compute"', function () {
        var compute1 = compute(0);
        var compute2 = compute(1);
        var ComputableMap = CanMap.extend({ define: { computable: { type: 'compute' } } });
        var m = new ComputableMap();
        m.attr('computable', compute1);
        equal(m.attr('computable'), 0, 'compute1 readable via .attr()');
        m.attr('computable', compute2);
        equal(m.attr('computable'), 1, 'compute2 readable via .attr()');
    });
    test('value and get (#1521)', function () {
        var MyMap = CanMap.extend({
            define: {
                data: {
                    value: function () {
                        return new List(['test']);
                    }
                },
                size: {
                    value: 1,
                    get: function (val) {
                        var list = this.attr('data');
                        var length = list.attr('length');
                        return val + length;
                    }
                }
            }
        });
        var map = new MyMap({});
        equal(map.attr('size'), 2);
    });
    test('One event on getters (#1585)', function () {
        var AppState = CanMap.extend({
            define: {
                person: {
                    get: function (lastSetValue, setAttrValue) {
                        if (lastSetValue) {
                            return lastSetValue;
                        } else if (this.attr('personId')) {
                            setAttrValue(new CanMap({
                                name: 'Jose',
                                id: 5
                            }));
                        } else {
                            return null;
                        }
                    }
                }
            }
        });
        var appState = new AppState();
        var personEvents = 0;
        appState.bind('person', function (ev, person) {
            personEvents++;
        });
        appState.attr('personId', 5);
        appState.attr('person', new CanMap({ name: 'Julia' }));
        equal(personEvents, 2);
    });
    test('Can read a defined property with a set/get method (#1648)', function () {
        var Map = CanMap.extend({
            define: {
                foo: {
                    value: '',
                    set: function (setVal) {
                        return setVal;
                    },
                    get: function (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new Map();
        equal(map.attr('foo'), '', 'Calling .attr(\'foo\') returned the correct value');
        map.attr('foo', 'baz');
        equal(map.attr('foo'), 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('Can bind to a defined property with a set/get method (#1648)', 3, function () {
        var Map = CanMap.extend({
            define: {
                foo: {
                    value: '',
                    set: function (setVal) {
                        return setVal;
                    },
                    get: function (lastSetVal) {
                        return lastSetVal;
                    }
                }
            }
        });
        var map = new Map();
        map.bind('foo', function () {
            ok(true, 'Bound function is called');
        });
        equal(map.attr('foo'), '', 'Calling .attr(\'foo\') returned the correct value');
        map.attr('foo', 'baz');
        equal(map.attr('foo'), 'baz', 'Calling .attr(\'foo\') returned the correct value');
    });
    test('type converters handle null and undefined in expected ways (1693)', function () {
        var Typer = CanMap.extend({
            define: {
                date: { type: 'date' },
                string: { type: 'string' },
                number: { type: 'number' },
                'boolean': { type: 'boolean' },
                htmlbool: { type: 'htmlbool' },
                leaveAlone: { type: '*' }
            }
        });
        var t = new Typer().attr({
            date: undefined,
            string: undefined,
            number: undefined,
            'boolean': undefined,
            htmlbool: undefined,
            leaveAlone: undefined
        });
        equal(t.attr('date'), undefined, 'converted to date');
        equal(t.attr('string'), undefined, 'converted to string');
        equal(t.attr('number'), undefined, 'converted to number');
        equal(t.attr('boolean'), undefined, 'converted to boolean');
        equal(t.attr('htmlbool'), false, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), undefined, 'left as object');
        t = new Typer().attr({
            date: null,
            string: null,
            number: null,
            'boolean': null,
            htmlbool: null,
            leaveAlone: null
        });
        equal(t.attr('date'), null, 'converted to date');
        equal(t.attr('string'), null, 'converted to string');
        equal(t.attr('number'), null, 'converted to number');
        equal(t.attr('boolean'), null, 'converted to boolean');
        equal(t.attr('htmlbool'), false, 'converted to htmlbool');
        equal(t.attr('leaveAlone'), null, 'left as object');
    });
    test('Initial value does not call getter', function () {
        expect(0);
        var Map = CanMap.extend({
            define: {
                count: {
                    get: function (lastVal) {
                        ok(false, 'Should not be called');
                        return lastVal;
                    }
                }
            }
        });
        new Map({ count: 100 });
    });
    test('getters produce change events', function () {
        var Map = CanMap.extend({
            define: {
                count: {
                    get: function (lastVal) {
                        return lastVal;
                    }
                }
            }
        });
        var map = new Map();
        map.bind('change', function () {
            ok(true, 'change called');
        });
        map.attr('count', 22);
    });
    test('Asynchronous virtual properties cause extra recomputes (#1915)', function () {
        stop();
        var ran = false;
        var VM = CanMap.extend({
            define: {
                foo: {
                    get: function (lastVal, setVal) {
                        setTimeout(function () {
                            if (setVal) {
                                setVal(5);
                            }
                        }, 10);
                    }
                },
                bar: {
                    get: function () {
                        var foo = this.attr('foo');
                        if (foo) {
                            if (ran) {
                                ok(false, 'Getter ran twice');
                            }
                            ran = true;
                            return foo * 2;
                        }
                    }
                }
            }
        });
        var vm = new VM();
        vm.bind('bar', function () {
        });
        setTimeout(function () {
            equal(vm.attr('bar'), 10);
            start();
        }, 200);
    });
    test('double get in a compute (#2230)', function () {
        var VM = CanMap.extend({
            define: {
                names: {
                    get: function (val, setVal) {
                        ok(setVal, 'setVal passed');
                        return 'Hi!';
                    }
                }
            }
        });
        var vm = new VM();
        var c = compute(function () {
            return vm.attr('names');
        });
        c.bind('change', function () {
        });
    });
    test('nullish values are not converted for Type', function (assert) {
        var VM = CanMap.extend({
            define: {
                map: { Type: CanMap },
                notype: {}
            }
        });
        var vm = new VM({
            num: 1,
            bool: true,
            htmlbool: 'foo',
            str: 'foo',
            date: Date.now(),
            map: {},
            notype: {}
        });
        assert.ok(vm.attr('map') instanceof CanMap, 'map is a Map');
        assert.ok(vm.attr('notype') instanceof CanMap, 'notype is a Map');
        vm.attr({
            map: null,
            notype: null
        });
        assert.equal(vm.attr('map'), null, 'map is null');
        assert.equal(vm.attr('map'), null, 'notype is null');
    });
    test('Wildcard serialize doesn\'t apply to getter properties (#4)', function () {
        var VM = CanMap.extend({
            define: {
                explicitlySerialized: {
                    get: function () {
                        return true;
                    },
                    serialize: true
                },
                implicitlySerialized: {
                    get: function () {
                        return true;
                    }
                },
                '*': { serialize: true }
            }
        });
        var vm = new VM();
        vm.bind('change', function () {
        });
        deepEqual(vm.serialize(), {
            explicitlySerialized: true,
            implicitlySerialized: true
        });
    });
    test('compute props can be set to null or undefined (#2372)', function (assert) {
        var VM = CanMap.extend({ define: { foo: { type: 'compute' } } });
        var vmNull = new VM({ foo: null });
        assert.equal(vmNull.foo, null, 'foo is null, no error thrown');
        var vmUndef = new VM({ foo: undefined });
        assert.equal(vmUndef.foo, undefined, 'foo is null, no error thrown');
    });
    test('can inherit computes from another map (#2)', 4, function () {
        var string1 = 'a string';
        var string2 = 'another string';
        var MapA = CanMap.extend({
            define: {
                propA: {
                    get: function () {
                        return string1;
                    }
                },
                propB: {
                    get: function () {
                        return string1;
                    },
                    set: function (newVal) {
                        equal(newVal, string1, 'set was called');
                    }
                }
            }
        });
        var MapB = MapA.extend({
            define: {
                propC: {
                    get: function () {
                        return string2;
                    }
                },
                propB: {
                    get: function () {
                        return string2;
                    }
                }
            }
        });
        var map = new MapB();
        equal(map.attr('propC'), string2, 'props only in the child have the correct values');
        equal(map.attr('propB'), string2, 'props in both have the child values');
        equal(map.attr('propA'), string1, 'props only in the parent have the correct values');
        map.attr('propB', string1);
    });
    test('can inherit primitive values from another map (#2)', function () {
        var string1 = 'a';
        var string2 = 'b';
        var MapA = CanMap.extend({
            define: {
                propA: { value: string1 },
                propB: { value: string1 }
            }
        });
        var MapB = MapA.extend({
            define: {
                propC: { value: string2 },
                propB: { value: string2 }
            }
        });
        var map = new MapB();
        equal(map.propC, string2, 'props only in the child have the correct values');
        equal(map.propB, string2, 'props in both have the child values');
        equal(map.propA, string1, 'props only in the parent have the correct values');
    });
    test('can inherit object values from another map (#2)', function () {
        var object1 = { a: 'a' };
        var object2 = { b: 'b' };
        var MapA = CanMap.extend({
            define: {
                propA: {
                    get: function () {
                        return object1;
                    }
                },
                propB: {
                    get: function () {
                        return object1;
                    }
                }
            }
        });
        var MapB = MapA.extend({
            define: {
                propB: {
                    get: function () {
                        return object2;
                    }
                },
                propC: {
                    get: function () {
                        return object2;
                    }
                }
            }
        });
        var map = new MapB();
        equal(map.attr('propC'), object2, 'props only in the child have the correct values');
        equal(map.attr('propB'), object2, 'props in both have the child values');
        equal(map.attr('propA'), object1, 'props only in the parent have the correct values');
    });
    test('can set properties to undefined', function () {
        var MyMap = CanMap.extend({
            define: {
                foo: {
                    set: function (newVal) {
                        return newVal;
                    }
                }
            }
        });
        var map = new MyMap();
        map.attr('foo', 'bar');
        equal(map.attr('foo'), 'bar', 'foo should be bar');
        map.attr('foo', undefined);
        equal(typeof map.attr('foo'), 'undefined', 'foo should be undefined');
    });
    test('subclass defines do not affect superclass ones', function (assert) {
        var VM = CanMap.extend({
            define: {
                foo: {
                    type: 'string',
                    value: 'bar'
                }
            }
        });
        var VM2 = VM.extend({ define: { foo: { value: 'baz' } } });
        var VM2a = VM.extend({});
        var VM2b = VM.extend({
            define: {
                foo: {
                    get: function () {
                        return 'quux';
                    }
                }
            }
        });
        var VM2c = VM.extend({
            define: {
                foo: {
                    type: function (oldVal) {
                        return oldVal + 'thud';
                    }
                }
            }
        });
        assert.equal(new VM().attr('foo'), 'bar', 'correct define on parent class object');
        assert.equal(new VM2().attr('foo'), 'baz', 'correct define on redefined child class object');
        assert.equal(new VM2a().attr('foo'), 'bar', 'correct define on non-redefined child class object');
        assert.equal(new VM2b().attr('foo'), 'quux', 'correct define on child class object with different define');
        assert.equal(new VM2c().attr('foo'), 'barthud', 'correct define on child class object with extending define');
    });
    test('value function not set on constructor defaults', function () {
        var MyMap = CanMap.extend({
            define: {
                propA: {
                    value: function () {
                        return 1;
                    }
                }
            }
        });
        var map = new MyMap();
        equal(MyMap.defaults.propA, undefined, 'Generator function does not result in property set on defaults');
        notEqual(MyMap.defaultGenerators.propA, undefined, 'Generator function set on defaultGenerators');
        equal(map.attr('propA'), 1, 'Instance value set properly');
    });
});
/*can-util@3.14.0#js/is-browser-window/is-browser-window*/
define('can-util@3.14.0#js/is-browser-window/is-browser-window', [
    'require',
    'exports',
    'module',
    'can-namespace',
    'can-globals/is-browser-window/is-browser-window'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        'use strict';
        var namespace = require('can-namespace');
        module.exports = namespace.isBrowserWindow = require('can-globals/is-browser-window/is-browser-window');
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-route@3.3.4#can-route*/
define('can-route@3.3.4#can-route', [
    'require',
    'exports',
    'module',
    'can-event/batch/batch',
    'can-event',
    'can-observation',
    'can-compute',
    'can-namespace',
    'can-param',
    'can-deparam',
    'can-log/dev/dev',
    'can-util/js/each/each',
    'can-util/js/string/string',
    'can-util/js/is-function/is-function',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/deep-assign/deep-assign',
    'can-util/js/is-web-worker/is-web-worker',
    'can-util/js/is-browser-window/is-browser-window',
    'can-util/js/make-array/make-array',
    'can-util/js/assign/assign',
    'can-types',
    'can-util/js/dev/dev',
    'can-util/js/diff/diff',
    'can-util/js/diff-object/diff-object',
    'can-reflect',
    'can-symbol'
], function (require, exports, module) {
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var compute = require('can-compute');
    var namespace = require('can-namespace');
    var param = require('can-param');
    var deparam = require('can-deparam');
    var devLog = require('can-log/dev/dev');
    var each = require('can-util/js/each/each');
    var string = require('can-util/js/string/string');
    var isFunction = require('can-util/js/is-function/is-function');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var isWebWorker = require('can-util/js/is-web-worker/is-web-worker');
    var isBrowserWindow = require('can-util/js/is-browser-window/is-browser-window');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var types = require('can-types');
    var dev = require('can-util/js/dev/dev');
    var diff = require('can-util/js/diff/diff');
    var diffObject = require('can-util/js/diff-object/diff-object');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var curliesMatcher = /\{\s*([\w.]+)\s*\}/g;
    var colonMatcher = /\:([\w.]+)/g;
    var paramsMatcher = /^(?:&[^=]+=[^&]*)+/;
    var makeProps = function (props) {
        var tags = [];
        each(props, function (val, name) {
            tags.push((name === 'className' ? 'class' : name) + '="' + (name === 'href' ? val : string.esc(val)) + '"');
        });
        return tags.join(' ');
    };
    var matchesData = function (route, data) {
        var count = 0, i = 0, defaults = {};
        for (var name in route.defaults) {
            if (route.defaults[name] === data[name]) {
                defaults[name] = 1;
                count++;
            }
        }
        for (; i < route.names.length; i++) {
            if (!data.hasOwnProperty(route.names[i])) {
                return -1;
            }
            if (!defaults[route.names[i]]) {
                count++;
            }
        }
        return count;
    };
    var location = typeof window !== 'undefined' ? window.location : {};
    var wrapQuote = function (str) {
        return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
    };
    var attrHelper = function (prop, value) {
        if ('attr' in this) {
            return this.attr.apply(this, arguments);
        } else {
            if (arguments.length > 1) {
                canReflect.setKeyValue(this, prop, value);
                return this;
            } else if (typeof prop === 'object') {
                canReflect.assignDeep(this, prop);
                return this;
            } else if (arguments.length === 1) {
                return canReflect.getKeyValue(this, prop);
            } else {
                return canReflect.unwrap(this);
            }
        }
    };
    var stringify = function (obj) {
        if (obj && typeof obj === 'object') {
            if (obj && typeof obj === 'object' && 'serialize' in obj) {
                obj = obj.serialize();
            } else {
                obj = isFunction(obj.slice) ? obj.slice() : assign({}, obj);
            }
            each(obj, function (val, prop) {
                obj[prop] = stringify(val);
            });
        } else if (obj !== undefined && obj !== null && isFunction(obj.toString)) {
            obj = obj.toString();
        }
        return obj;
    };
    var removeBackslash = function (str) {
        return str.replace(/\\/g, '');
    };
    var timer;
    var curParams;
    var lastHash;
    var changingData;
    var changedAttrs = [];
    var eventsObject = assign({}, canEvent);
    var canRoute = function (url, defaults) {
        var root = canRoute._call('root');
        if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
            url = url.substr(1);
        }
        defaults = defaults || {};
        var names = [], res, test = '', matcher, lastIndex, next, querySeparator = canRoute._call('querySeparator'), matchSlashes = canRoute._call('matchSlashes');
        if (colonMatcher.test(url)) {
            matcher = colonMatcher;
        } else {
            matcher = curliesMatcher;
        }
        lastIndex = matcher.lastIndex = 0;
        while (res = matcher.exec(url)) {
            names.push(res[1]);
            test += removeBackslash(url.substring(lastIndex, matcher.lastIndex - res[0].length));
            next = '\\' + (removeBackslash(url.substr(matcher.lastIndex, 1)) || querySeparator + (matchSlashes ? '' : '|/'));
            test += '([^' + next + ']' + (defaults[res[1]] ? '*' : '+') + ')';
            lastIndex = matcher.lastIndex;
        }
        test += url.substr(lastIndex).replace('\\', '');
        canRoute.routes[url] = {
            test: new RegExp('^' + test + '($|' + wrapQuote(querySeparator) + ')'),
            route: url,
            names: names,
            defaults: defaults,
            length: url.split('/').length
        };
        return canRoute;
    };
    var oldProperties = null;
    var onRouteDataChange = function (ev, newProps, oldProps) {
        changingData = 1;
        if (!oldProperties) {
            oldProperties = oldProps;
        }
        clearTimeout(timer);
        timer = setTimeout(function () {
            var old = oldProperties;
            oldProperties = null;
            changingData = 0;
            var serialized = canRoute.data.serialize(), path = canRoute.param(serialized, true);
            canRoute._call('setURL', path, newProps, old);
            canEvent.dispatch.call(eventsObject, '__url', [
                path,
                lastHash
            ]);
            lastHash = path;
            changedAttrs = [];
        }, 10);
    };
    var stringCoercingMapDecorator = function (map) {
        var sym = canSymbol.for('can.route.stringCoercingMapDecorator');
        if (!map.attr[sym]) {
            var attrSuper = map.attr;
            map.attr = function (prop, val) {
                var serializable = this.define === undefined || this.define[prop] === undefined || !!this.define[prop].serialize, args;
                if (serializable) {
                    args = stringify(Array.apply(null, arguments));
                } else {
                    args = arguments;
                }
                return attrSuper.apply(this, args);
            };
            canReflect.setKeyValue(map.attr, sym, true);
        }
        return map;
    };
    var recursiveClean = function (old, cur, data) {
        for (var attr in old) {
            if (cur[attr] === undefined) {
                if ('removeAttr' in data) {
                    data.removeAttr(attr);
                } else {
                    cur[attr] = undefined;
                }
            } else if (Object.prototype.toString.call(old[attr]) === '[object Object]') {
                recursiveClean(old[attr], cur[attr], attrHelper.call(data, attr));
            }
        }
    };
    var matchCheck = function (source, matcher) {
        for (var prop in source) {
            var s = source[prop], m = matcher[prop];
            if (s && m && typeof s === 'object' && typeof matcher === 'object') {
                return matchCheck(s, m);
            }
            if (s != m) {
                return false;
            }
        }
        return true;
    };
    var setState = canRoute.setState = function () {
        var hash = canRoute._call('matchingPartOfURL');
        var oldParams = curParams;
        curParams = canRoute.deparam(hash);
        var matched;
        if (!changingData || hash !== lastHash) {
            canRoute.batch.start();
            recursiveClean(oldParams, curParams, canRoute.data);
            matched = curParams.route;
            delete curParams.route;
            canRoute.matched(matched);
            canRoute.attr(curParams);
            curParams.route = matched;
            canEvent.dispatch.call(eventsObject, '__url', [
                hash,
                lastHash
            ]);
            canRoute.batch.stop();
        }
    };
    var decode = function (str) {
        try {
            return decodeURIComponent(str);
        } catch (ex) {
            return unescape(str);
        }
    };
    assign(canRoute, {
        param: function (data, _setRoute) {
            var route, matches = 0, matchCount, routeName = data.route, propCount = 0, cpy, res, after, matcher;
            delete data.route;
            each(data, function () {
                propCount++;
            });
            each(canRoute.routes, function (temp, name) {
                matchCount = matchesData(temp, data);
                if (matchCount > matches) {
                    route = temp;
                    matches = matchCount;
                }
                if (matchCount >= propCount) {
                    return false;
                }
            });
            if (canRoute.routes[routeName] && matchesData(canRoute.routes[routeName], data) === matches) {
                route = canRoute.routes[routeName];
            }
            if (route) {
                cpy = assign({}, data);
                matcher = colonMatcher.test(route.route) ? colonMatcher : curliesMatcher;
                res = route.route.replace(matcher, function (whole, name) {
                    delete cpy[name];
                    return data[name] === route.defaults[name] ? '' : encodeURIComponent(data[name]);
                }).replace('\\', '');
                each(route.defaults, function (val, name) {
                    if (cpy[name] === val) {
                        delete cpy[name];
                    }
                });
                after = param(cpy);
                if (_setRoute) {
                    canRoute.matched(route.route);
                }
                return res + (after ? canRoute._call('querySeparator') + after : '');
            }
            return isEmptyObject(data) ? '' : canRoute._call('querySeparator') + param(data);
        },
        deparam: function (url) {
            var root = canRoute._call('root');
            if (root.lastIndexOf('/') === root.length - 1 && url.indexOf('/') === 0) {
                url = url.substr(1);
            }
            var route = { length: -1 }, querySeparator = canRoute._call('querySeparator'), paramsMatcher = canRoute._call('paramsMatcher');
            each(canRoute.routes, function (temp, name) {
                if (temp.test.test(url) && temp.length > route.length) {
                    route = temp;
                }
            });
            if (route.length > -1) {
                var parts = url.match(route.test), start = parts.shift(), remainder = url.substr(start.length - (parts[parts.length - 1] === querySeparator ? 1 : 0)), obj = remainder && paramsMatcher.test(remainder) ? deparam(remainder.slice(1)) : {};
                obj = deepAssign(true, {}, route.defaults, obj);
                each(parts, function (part, i) {
                    if (part && part !== querySeparator) {
                        obj[route.names[i]] = decode(part);
                    }
                });
                obj.route = route.route;
                return obj;
            }
            if (url.charAt(0) !== querySeparator) {
                url = querySeparator + url;
            }
            return paramsMatcher.test(url) ? deparam(url.slice(1)) : {};
        },
        map: function (data) {
            canRoute.data = data;
        },
        routes: {},
        ready: function (val) {
            canRoute.start();
            return canRoute;
        },
        start: function (val) {
            if (val !== true) {
                canRoute._setup();
                if (isBrowserWindow() || isWebWorker()) {
                    canRoute.setState();
                }
            }
            return canRoute;
        },
        url: function (options, merge) {
            if (merge) {
                Observation.add(eventsObject, '__url');
                var baseOptions = canRoute.deparam(canRoute._call('matchingPartOfURL'));
                options = assign(assign({}, baseOptions), options);
            }
            return canRoute._call('root') + canRoute.param(options);
        },
        link: function (name, options, props, merge) {
            return '<a ' + makeProps(assign({ href: canRoute.url(options, merge) }, props)) + '>' + name + '</a>';
        },
        current: function (options, subsetMatch) {
            Observation.add(eventsObject, '__url');
            if (subsetMatch) {
                var baseOptions = canRoute.deparam(canRoute._call('matchingPartOfURL'));
                return matchCheck(options, baseOptions);
            } else {
                return this._call('matchingPartOfURL') === canRoute.param(options);
            }
        },
        bindings: {
            hashchange: {
                paramsMatcher: paramsMatcher,
                querySeparator: '&',
                matchSlashes: false,
                bind: function () {
                    canEvent.on.call(window, 'hashchange', setState);
                },
                unbind: function () {
                    canEvent.on.call(window, 'hashchange', setState);
                },
                matchingPartOfURL: function () {
                    var loc = canRoute.location || location;
                    return loc.href.split(/#!?/)[1] || '';
                },
                setURL: function (path) {
                    if (location.hash !== '#' + path) {
                        location.hash = '!' + path;
                    }
                    return path;
                },
                root: '#!'
            }
        },
        defaultBinding: 'hashchange',
        currentBinding: null,
        _setup: function () {
            if (!canRoute.currentBinding) {
                canRoute._call('bind');
                canRoute.serializedCompute.addEventListener('change', onRouteDataChange);
                canRoute.currentBinding = canRoute.defaultBinding;
            }
        },
        _teardown: function () {
            if (canRoute.currentBinding) {
                canRoute._call('unbind');
                canRoute.serializedCompute.removeEventListener('change', onRouteDataChange);
                canRoute.currentBinding = null;
            }
            clearTimeout(timer);
            changingData = 0;
        },
        _call: function () {
            var args = makeArray(arguments), prop = args.shift(), binding = canRoute.bindings[canRoute.currentBinding || canRoute.defaultBinding], method = binding[prop];
            if (method.apply) {
                return method.apply(binding, args);
            } else {
                return method;
            }
        },
        matched: compute()
    });
    var bindToCanRouteData = function (name, args) {
        if (!canRoute.data[name]) {
            return;
        }
        return canRoute.data[name].apply(canRoute.data, args);
    };
    each([
        'addEventListener',
        'removeEventListener',
        'bind',
        'unbind',
        'on',
        'off'
    ], function (name) {
        canRoute[name] = function (eventName) {
            if (eventName === '__url') {
                return canEvent[name].apply(eventsObject, arguments);
            }
            return bindToCanRouteData(name, arguments);
        };
    });
    each([
        'delegate',
        'undelegate',
        'removeAttr',
        'compute',
        '_get',
        '___get',
        'each'
    ], function (name) {
        canRoute[name] = function () {
            return bindToCanRouteData(name, arguments);
        };
    });
    var routeData;
    var setRouteData = function (data) {
        routeData = data;
        return routeData;
    };
    var serializedCompute;
    Object.defineProperty(canRoute, 'serializedCompute', {
        get: function () {
            if (!serializedCompute) {
                serializedCompute = compute(function () {
                    return canRoute.data.serialize();
                });
            }
            return serializedCompute;
        }
    });
    Object.defineProperty(canRoute, 'data', {
        get: function () {
            if (routeData) {
                return routeData;
            } else if (types.DefaultMap) {
                if (types.DefaultMap.prototype.toObject) {
                    var DefaultRouteMap = types.DefaultMap.extend({ seal: false }, { '*': 'stringOrObservable' });
                    return setRouteData(new DefaultRouteMap());
                } else {
                    return setRouteData(stringCoercingMapDecorator(new types.DefaultMap()));
                }
            } else {
                throw new Error('can.route.data accessed without being set');
            }
        },
        set: function (data) {
            if (canReflect.isConstructorLike(data)) {
                data = new data();
            }
            if ('attr' in data) {
                setRouteData(stringCoercingMapDecorator(data));
            } else {
                setRouteData(data);
            }
        }
    });
    canRoute.attr = function () {
        return attrHelper.apply(canRoute.data, arguments);
    };
    canRoute.batch = canBatch;
    canReflect.setKeyValue(canRoute, canSymbol.for('can.isFunctionLike'), false);
    module.exports = namespace.route = canRoute;
});
/*can-view-href@3.1.1#can-view-href*/
define('can-view-href@3.1.1#can-view-href', [
    'require',
    'exports',
    'module',
    'can-stache/src/expression',
    'can-view-callbacks',
    'can-compute',
    'can-route',
    'can-util/dom/events/removed/removed',
    'can-util/dom/events/events'
], function (require, exports, module) {
    var expression = require('can-stache/src/expression');
    var viewCallbacks = require('can-view-callbacks');
    var compute = require('can-compute');
    var route = require('can-route');
    require('can-util/dom/events/removed/removed');
    var domEvents = require('can-util/dom/events/events');
    var removeCurly = function (value) {
        if (value[0] === '{' && value[value.length - 1] === '}') {
            return value.substr(1, value.length - 2);
        }
        return value;
    };
    viewCallbacks.attr('can-href', function (el, attrData) {
        var attrInfo = expression.parse('tmp(' + removeCurly(el.getAttribute('can-href')) + ')', { baseMethodType: 'Call' });
        var getHash = attrInfo.argExprs[0].value(attrData.scope, null);
        var routeHref = compute(function () {
            return route.url(getHash());
        });
        el.setAttribute('href', routeHref());
        var handler = function (ev, newVal) {
            el.setAttribute('href', newVal);
        };
        routeHref.on('change', handler);
        domEvents.addEventListener.call(el, 'removed', function () {
            routeHref.off('change', handler);
        });
    });
});
/*can-view-href@3.1.1#test/test*/
define('can-view-href@3.1.1#test/test', [
    'require',
    'exports',
    'module',
    'can-route',
    'steal-qunit',
    '../can-view-href'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        require('can-route');
        require('steal-qunit');
        require('../can-view-href');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                delete window.isReady;
                delete window.hasError;
                document.body.removeChild(iframe);
                start();
            };
            window.hasError = function (error) {
                ok(false, error.message);
                window.removeMyself();
            };
            window.isReady = function (el, viewModel, setPrettyUrl) {
                equal(el.getAttribute('href'), '#!&page=recipe&id=5', 'should set unpretty href attribute');
                viewModel.recipe.attr('id', 7);
                equal(el.getAttribute('href'), '#!&page=recipe&id=7', 'should update href');
                setPrettyUrl();
                viewModel.recipe.attr('id', 8);
                equal(el.getAttribute('href'), '#!recipe/8', 'should set pretty href');
                viewModel.recipe.attr('id', 9);
                equal(el.getAttribute('href'), '#!recipe/9', 'should update pretty href');
                window.removeMyself();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can-view-href');
        if (window.steal && __dirname !== '/') {
            asyncTest('the basics are able to work for steal', function () {
                makeIframe(__dirname + '/basics.html?' + Math.random());
            });
        }
    }('/', require, exports, module));
});
/*can-map-backup@3.1.1#can-map-backup*/
define('can-map-backup@3.1.1#can-map-backup', [
    'require',
    'exports',
    'module',
    'can-compute',
    'can-map',
    'can-set/src/compare',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var compute = require('can-compute');
    var CanMap = require('can-map');
    var compare = require('can-set/src/compare');
    var assign = require('can-util/js/assign/assign');
    var flatProps = function (a, cur) {
        var obj = {};
        for (var prop in a) {
            if (typeof a[prop] !== 'object' || a[prop] === null || a[prop] instanceof Date) {
                obj[prop] = a[prop];
            } else {
                obj[prop] = cur.attr(prop);
            }
        }
        return obj;
    };
    var oldSetup = CanMap.prototype.setup;
    assign(CanMap.prototype, {
        setup: function () {
            this._backupStore = compute();
            return oldSetup.apply(this, arguments);
        },
        backup: function () {
            this._backupStore(this.attr());
            return this;
        },
        isDirty: function (checkAssociations) {
            var backupStore = this._backupStore();
            if (!backupStore) {
                return false;
            }
            var currentValue = this.attr();
            var aParent, bParent, parentProp;
            var compares = {};
            var options = { deep: !!checkAssociations };
            return !compare.equal(currentValue, backupStore, aParent, bParent, parentProp, compares, options);
        },
        restore: function (restoreAssociations) {
            var props = restoreAssociations ? this._backupStore() : flatProps(this._backupStore(), this);
            if (this.isDirty(restoreAssociations)) {
                this.attr(props, true);
            }
            return this;
        }
    });
    module.exports = exports = CanMap;
});
/*can-map-backup@3.1.1#can-map-backup_test*/
define('can-map-backup@3.1.1#can-map-backup_test', [
    'require',
    'exports',
    'module',
    'can-compute',
    'can-map',
    'can-map-backup',
    'can-map-define',
    'steal-qunit'
], function (require, exports, module) {
    var compute = require('can-compute');
    var CanMap = require('can-map');
    require('can-map-backup');
    require('can-map-define');
    require('steal-qunit');
    var Recipe;
    QUnit.module('can/map/backup', {
        setup: function () {
            Recipe = CanMap.extend('Recipe');
        }
    });
    test('backing up', function () {
        var recipe = new Recipe({ name: 'cheese' });
        ok(!recipe.isDirty(), 'not backedup, but clean');
        recipe.backup();
        ok(!recipe.isDirty(), 'backedup, but clean');
        recipe.attr('name', 'blah');
        ok(recipe.isDirty(), 'dirty');
        recipe.restore();
        ok(!recipe.isDirty(), 'restored, clean');
        equal(recipe.name, 'cheese', 'name back');
    });
    test('backup / restore with associations', function () {
        var Instruction = CanMap.extend('Instruction');
        var Cookbook = CanMap.extend('Cookbook');
        var Recipe = CanMap.extend('Recipe', {
            define: {
                instructions: { Type: Instruction.List },
                cookbook: { Type: Cookbook }
            }
        }, {});
        var recipe = new Recipe({
            name: 'cheese burger',
            instructions: [
                { description: 'heat meat' },
                { description: 'add cheese' }
            ],
            cookbook: { title: 'Justin\'s Grillin Times' }
        });
        ok(!recipe.isDirty(), 'not backedup, but clean');
        recipe.backup();
        ok(!recipe.isDirty(), 'backedup, but clean');
        recipe.attr('name', 'blah');
        ok(recipe.isDirty(), 'dirty');
        recipe.restore();
        ok(!recipe.isDirty(), 'restored, clean');
        equal(recipe.name, 'cheese burger', 'name back');
        ok(!recipe.cookbook.isDirty(), 'cookbook not backedup, but clean');
        recipe.cookbook.backup();
        recipe.cookbook.attr('title', 'Brian\'s Burgers');
        ok(!recipe.isDirty(), 'recipe itself is clean');
        ok(recipe.isDirty(true), 'recipe is dirty if checking associations');
        recipe.cookbook.restore();
        ok(!recipe.isDirty(true), 'recipe is now clean with checking associations');
        equal(recipe.cookbook.title, 'Justin\'s Grillin Times', 'cookbook title back');
        recipe.cookbook.attr('title', 'Brian\'s Burgers');
        recipe.restore();
        ok(recipe.isDirty(true), 'recipe is dirty if checking associations, after a restore');
        recipe.restore(true);
        ok(!recipe.isDirty(true), 'cleaned all of recipe and its associations');
    });
    test('backup restore nested observables', function () {
        var observe = new CanMap({ nested: { test: 'property' } });
        equal(observe.attr('nested').attr('test'), 'property', 'Nested object got converted');
        observe.backup();
        observe.attr('nested').attr('test', 'changed property');
        equal(observe.attr('nested').attr('test'), 'changed property', 'Nested property changed');
        ok(observe.isDirty(true), 'Observe is dirty');
        observe.restore(true);
        equal(observe.attr('nested').attr('test'), 'property', 'Nested object got restored');
    });
    test('backup removes properties that were added (#607)', function () {
        var map = new CanMap({});
        map.backup();
        map.attr('foo', 'bar');
        ok(map.isDirty(), 'the map with an additional property is dirty');
        map.restore();
        ok(!map.attr('foo'), 'there is no foo property');
    });
    test('isDirty wrapped in a compute should trigger changes #1417', function () {
        expect(2);
        var recipe = new Recipe({ name: 'bread' });
        recipe.backup();
        var c = compute(function () {
            return recipe.isDirty();
        });
        ok(!c(), 'isDirty is false');
        c.bind('change', function () {
            ok(c(), 'isDirty is true and a change has occurred');
        });
        recipe.attr('name', 'cheese');
    });
});
/*can-validate-legacy@1.4.0#can-validate*/
define('can-validate-legacy@1.4.0#can-validate', [
    'require',
    'exports',
    'module',
    'can-log/dev/dev',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    var dev = require('can-log/dev/dev');
    var namespace = require('can-namespace');
    var Validate = {
        _validatorId: '',
        _validators: {},
        validator: function () {
            return this._validators[this._validatorId];
        },
        register: function (id, validator) {
            this._validatorId = id;
            this._validators[id] = validator;
        },
        isValid: function () {
            return this.validator().isValid.apply(this, arguments);
        },
        once: function () {
            return this.validator().once.apply(this, arguments);
        },
        validate: function () {
            var validateArgs = arguments;
            return this.validator().validate.apply(this, validateArgs);
        }
    };
    namespace.validate = Validate;
    module.exports = Validate;
});
/*can-validate-legacy@1.4.0#map/validate/validate*/
define('can-validate-legacy@1.4.0#map/validate/validate', [
    'require',
    'exports',
    'module',
    'can-assign',
    'can-map',
    'can-reflect',
    'can-validate-legacy',
    'can-compute'
], function (require, exports, module) {
    'use strict';
    var assign = require('can-assign');
    var Map = require('can-map');
    var canReflect = require('can-reflect');
    var validate = require('can-validate-legacy');
    var compute = require('can-compute');
    var deepAssign = function () {
        var objects = [].slice.call(arguments);
        var out = {};
        for (var i = 0; i < objects.length; i++) {
            assign(out, objects[i]);
        }
        return out;
    };
    var isEmptyObject = function (value) {
        return canReflect.size(value) === 0;
    };
    var proto = Map.prototype;
    var oldSet = proto.__set;
    var ErrorsObj;
    var defaultValidationOpts;
    var config = {
        errorKeyName: 'errors',
        validateOptionCacheKey: 'validateOptions'
    };
    var resolveComputes = function (itemObj, opts) {
        var processedObj = {};
        canReflect.eachKey(opts, function (item, key) {
            var actualOpts = item;
            if (typeof item === 'function') {
                actualOpts = item(itemObj.value);
            }
            processedObj[key] = actualOpts;
        });
        return processedObj;
    };
    var getPropDefineBehavior = function (behavior, attr, define) {
        var prop;
        var defaultProp;
        if (define) {
            prop = define[attr];
            defaultProp = define['*'];
            if (prop && prop[behavior] !== undefined) {
                return prop[behavior];
            } else {
                if (defaultProp && defaultProp[behavior] !== undefined) {
                    return defaultProp[behavior];
                }
            }
        }
    };
    ErrorsObj = Map.extend({}, {
        hasErrors: function () {
            return !isEmptyObject(this.attr());
        }
    });
    defaultValidationOpts = {
        mustValidate: false,
        validateOnInit: false
    };
    var getValidateFromCache = function () {
        var validateCacheKey = '__' + config.validateOptionCacheKey;
        if (!this[validateCacheKey]) {
            this[validateCacheKey] = {};
        }
        return this[validateCacheKey];
    };
    var initProperty = function (key, value) {
        var validateOpts;
        var mapValidateCache;
        var propIniting;
        mapValidateCache = getValidateFromCache.call(this);
        if (mapValidateCache[key] && !isEmptyObject(mapValidateCache[key])) {
            validateOpts = mapValidateCache[key];
            propIniting = false;
        } else {
            validateOpts = assign({}, getPropDefineBehavior('validate', key, this.define));
            propIniting = true;
        }
        if (typeof validateOpts !== 'undefined') {
            if (propIniting) {
                validateOpts = deepAssign(defaultValidationOpts, validateOpts, this._processValidateOpts({
                    key: key,
                    value: value
                }, validateOpts));
                mapValidateCache[key] = validateOpts;
            }
            return true;
        }
        return false;
    };
    var oldSetup = proto.setup;
    var oldInit = proto.init;
    proto.setup = function () {
        this._initValidate = true;
        oldSetup.apply(this, arguments);
    };
    proto.init = function () {
        this._initValidation();
        this._initValidate = false;
        if (oldInit) {
            oldInit.apply(this, arguments);
        }
    };
    assign(Map.prototype, {
        _initValidation: function () {
            var self = this;
            var validateCache = getValidateFromCache.call(this);
            canReflect.eachKey(this.define, function (props, key) {
                if (props.validate && !validateCache[key]) {
                    initProperty.call(self, key, self[key]);
                }
            });
        },
        validate: function () {
            return this._validate();
        },
        _validate: function () {
            var validateOpts = getValidateFromCache.call(this);
            var processedOpts = {};
            var self = this;
            canReflect.eachKey(this.define, function (value, key) {
                if (value.validate) {
                    processedOpts[key] = resolveComputes({
                        key: key,
                        value: self.attr(key)
                    }, validateOpts[key]);
                }
            });
            var errors = validate.validate(this.serialize(), processedOpts);
            this.attr('errors', new ErrorsObj(errors));
            return isEmptyObject(errors);
        },
        _validateOne: function (item, opts) {
            var errors;
            var allowSet = true;
            errors = validate.once(item.value, assign({}, opts), item.key);
            if (errors && errors.length > 0) {
                if (!this.attr('errors')) {
                    this.attr('errors', new ErrorsObj({}));
                }
                this.attr('errors').attr(item.key, errors);
                if (opts.mustValidate === true) {
                    allowSet = false;
                }
            } else {
                if (this.attr('errors') && this.attr('errors').attr(item.key)) {
                    this.attr('errors').removeAttr(item.key);
                }
            }
            return allowSet;
        },
        _processValidateOpts: function (itemObj, opts) {
            var processedObj = {};
            var computes = [];
            var self = this;
            canReflect.eachKey(opts, function (item, key) {
                processedObj[key] = item;
                if (typeof item === 'function') {
                    var newCompute = compute(item.bind(self));
                    computes.push({
                        key: key,
                        compute: newCompute
                    });
                    processedObj[key] = newCompute;
                }
            });
            canReflect.each(computes, function (item) {
                item.compute.bind('change', function () {
                    itemObj.value = self.attr(itemObj.key);
                    self._validateOne(itemObj, processedObj);
                });
            });
            return processedObj;
        }
    });
    proto.__set = function (prop, value, current, success, error) {
        var allowSet = true;
        var checkValidate = initProperty.call(this, prop, value);
        var validateOpts = getValidateFromCache.call(this)[prop];
        var mapIniting = this._initValidate;
        if (checkValidate !== false) {
            validateOpts = resolveComputes({
                key: prop,
                value: value
            }, validateOpts);
            if (validateOpts && !mapIniting || validateOpts && mapIniting && validateOpts.validateOnInit) {
                allowSet = this._validateOne({
                    key: prop,
                    value: value
                }, validateOpts);
            }
        }
        if (allowSet) {
            oldSet.call(this, prop, value, current, success, error);
        }
    };
});
/*validate.js@0.11.1#validate*/
(function (exports, module, define) {
    'use strict';
    var validate = function (attributes, constraints, options) {
        options = v.extend({}, v.options, options);
        var results = v.runValidations(attributes, constraints, options), attr, validator;
        for (attr in results) {
            for (validator in results[attr]) {
                if (v.isPromise(results[attr][validator])) {
                    throw new Error('Use validate.async if you want support for promises');
                }
            }
        }
        return validate.processValidationResults(results, options);
    };
    var v = validate;
    v.extend = function (obj) {
        [].slice.call(arguments, 1).forEach(function (source) {
            for (var attr in source) {
                obj[attr] = source[attr];
            }
        });
        return obj;
    };
    v.extend(validate, {
        version: {
            major: 0,
            minor: 11,
            patch: 1,
            metadata: null,
            toString: function () {
                var version = v.format('%{major}.%{minor}.%{patch}', v.version);
                if (!v.isEmpty(v.version.metadata)) {
                    version += '+' + v.version.metadata;
                }
                return version;
            }
        },
        Promise: typeof Promise !== 'undefined' ? Promise : null,
        EMPTY_STRING_REGEXP: /^\s*$/,
        runValidations: function (attributes, constraints, options) {
            var results = [], attr, validatorName, value, validators, validator, validatorOptions, error;
            if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {
                attributes = v.collectFormValues(attributes);
            }
            for (attr in constraints) {
                value = v.getDeepObjectValue(attributes, attr);
                validators = v.result(constraints[attr], value, attributes, attr, options, constraints);
                for (validatorName in validators) {
                    validator = v.validators[validatorName];
                    if (!validator) {
                        error = v.format('Unknown validator %{name}', { name: validatorName });
                        throw new Error(error);
                    }
                    validatorOptions = validators[validatorName];
                    validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);
                    if (!validatorOptions) {
                        continue;
                    }
                    results.push({
                        attribute: attr,
                        value: value,
                        validator: validatorName,
                        globalOptions: options,
                        attributes: attributes,
                        options: validatorOptions,
                        error: validator.call(validator, value, validatorOptions, attr, attributes, options)
                    });
                }
            }
            return results;
        },
        processValidationResults: function (errors, options) {
            errors = v.pruneEmptyErrors(errors, options);
            errors = v.expandMultipleErrors(errors, options);
            errors = v.convertErrorMessages(errors, options);
            var format = options.format || 'grouped';
            if (typeof v.formatters[format] === 'function') {
                errors = v.formatters[format](errors);
            } else {
                throw new Error(v.format('Unknown format %{format}', options));
            }
            return v.isEmpty(errors) ? undefined : errors;
        },
        async: function (attributes, constraints, options) {
            options = v.extend({}, v.async.options, options);
            var WrapErrors = options.wrapErrors || function (errors) {
                return errors;
            };
            if (options.cleanAttributes !== false) {
                attributes = v.cleanAttributes(attributes, constraints);
            }
            var results = v.runValidations(attributes, constraints, options);
            return new v.Promise(function (resolve, reject) {
                v.waitForResults(results).then(function () {
                    var errors = v.processValidationResults(results, options);
                    if (errors) {
                        reject(new WrapErrors(errors, options, attributes, constraints));
                    } else {
                        resolve(attributes);
                    }
                }, function (err) {
                    reject(err);
                });
            });
        },
        single: function (value, constraints, options) {
            options = v.extend({}, v.single.options, options, {
                format: 'flat',
                fullMessages: false
            });
            return v({ single: value }, { single: constraints }, options);
        },
        waitForResults: function (results) {
            return results.reduce(function (memo, result) {
                if (!v.isPromise(result.error)) {
                    return memo;
                }
                return memo.then(function () {
                    return result.error.then(function (error) {
                        result.error = error || null;
                    });
                });
            }, new v.Promise(function (r) {
                r();
            }));
        },
        result: function (value) {
            var args = [].slice.call(arguments, 1);
            if (typeof value === 'function') {
                value = value.apply(null, args);
            }
            return value;
        },
        isNumber: function (value) {
            return typeof value === 'number' && !isNaN(value);
        },
        isFunction: function (value) {
            return typeof value === 'function';
        },
        isInteger: function (value) {
            return v.isNumber(value) && value % 1 === 0;
        },
        isBoolean: function (value) {
            return typeof value === 'boolean';
        },
        isObject: function (obj) {
            return obj === Object(obj);
        },
        isDate: function (obj) {
            return obj instanceof Date;
        },
        isDefined: function (obj) {
            return obj !== null && obj !== undefined;
        },
        isPromise: function (p) {
            return !!p && v.isFunction(p.then);
        },
        isJqueryElement: function (o) {
            return o && v.isString(o.jquery);
        },
        isDomElement: function (o) {
            if (!o) {
                return false;
            }
            if (!o.querySelectorAll || !o.querySelector) {
                return false;
            }
            if (v.isObject(document) && o === document) {
                return true;
            }
            if (typeof HTMLElement === 'object') {
                return o instanceof HTMLElement;
            } else {
                return o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
            }
        },
        isEmpty: function (value) {
            var attr;
            if (!v.isDefined(value)) {
                return true;
            }
            if (v.isFunction(value)) {
                return false;
            }
            if (v.isString(value)) {
                return v.EMPTY_STRING_REGEXP.test(value);
            }
            if (v.isArray(value)) {
                return value.length === 0;
            }
            if (v.isDate(value)) {
                return false;
            }
            if (v.isObject(value)) {
                for (attr in value) {
                    return false;
                }
                return true;
            }
            return false;
        },
        format: v.extend(function (str, vals) {
            if (!v.isString(str)) {
                return str;
            }
            return str.replace(v.format.FORMAT_REGEXP, function (m0, m1, m2) {
                if (m1 === '%') {
                    return '%{' + m2 + '}';
                } else {
                    return String(vals[m2]);
                }
            });
        }, { FORMAT_REGEXP: /(%?)%\{([^\}]+)\}/g }),
        prettify: function (str) {
            if (v.isNumber(str)) {
                if (str * 100 % 1 === 0) {
                    return '' + str;
                } else {
                    return parseFloat(Math.round(str * 100) / 100).toFixed(2);
                }
            }
            if (v.isArray(str)) {
                return str.map(function (s) {
                    return v.prettify(s);
                }).join(', ');
            }
            if (v.isObject(str)) {
                return str.toString();
            }
            str = '' + str;
            return str.replace(/([^\s])\.([^\s])/g, '$1 $2').replace(/\\+/g, '').replace(/[_-]/g, ' ').replace(/([a-z])([A-Z])/g, function (m0, m1, m2) {
                return '' + m1 + ' ' + m2.toLowerCase();
            }).toLowerCase();
        },
        stringifyValue: function (value) {
            return v.prettify(value);
        },
        isString: function (value) {
            return typeof value === 'string';
        },
        isArray: function (value) {
            return {}.toString.call(value) === '[object Array]';
        },
        isHash: function (value) {
            return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);
        },
        contains: function (obj, value) {
            if (!v.isDefined(obj)) {
                return false;
            }
            if (v.isArray(obj)) {
                return obj.indexOf(value) !== -1;
            }
            return value in obj;
        },
        unique: function (array) {
            if (!v.isArray(array)) {
                return array;
            }
            return array.filter(function (el, index, array) {
                return array.indexOf(el) == index;
            });
        },
        forEachKeyInKeypath: function (object, keypath, callback) {
            if (!v.isString(keypath)) {
                return undefined;
            }
            var key = '', i, escape = false;
            for (i = 0; i < keypath.length; ++i) {
                switch (keypath[i]) {
                case '.':
                    if (escape) {
                        escape = false;
                        key += '.';
                    } else {
                        object = callback(object, key, false);
                        key = '';
                    }
                    break;
                case '\\':
                    if (escape) {
                        escape = false;
                        key += '\\';
                    } else {
                        escape = true;
                    }
                    break;
                default:
                    escape = false;
                    key += keypath[i];
                    break;
                }
            }
            return callback(object, key, true);
        },
        getDeepObjectValue: function (obj, keypath) {
            if (!v.isObject(obj)) {
                return undefined;
            }
            return v.forEachKeyInKeypath(obj, keypath, function (obj, key) {
                if (v.isObject(obj)) {
                    return obj[key];
                }
            });
        },
        collectFormValues: function (form, options) {
            var values = {}, i, j, input, inputs, option, value;
            if (v.isJqueryElement(form)) {
                form = form[0];
            }
            if (!form) {
                return values;
            }
            options = options || {};
            inputs = form.querySelectorAll('input[name], textarea[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (v.isDefined(input.getAttribute('data-ignored'))) {
                    continue;
                }
                value = v.sanitizeFormValue(input.value, options);
                if (input.type === 'number') {
                    value = value ? +value : null;
                } else if (input.type === 'checkbox') {
                    if (input.attributes.value) {
                        if (!input.checked) {
                            value = values[input.name] || null;
                        }
                    } else {
                        value = input.checked;
                    }
                } else if (input.type === 'radio') {
                    if (!input.checked) {
                        value = values[input.name] || null;
                    }
                }
                values[input.name] = value;
            }
            inputs = form.querySelectorAll('select[name]');
            for (i = 0; i < inputs.length; ++i) {
                input = inputs.item(i);
                if (input.multiple) {
                    value = [];
                    for (j in input.options) {
                        option = input.options[j];
                        if (option.selected) {
                            value.push(v.sanitizeFormValue(option.value, options));
                        }
                    }
                } else {
                    value = v.sanitizeFormValue(input.options[input.selectedIndex].value, options);
                }
                values[input.name] = value;
            }
            return values;
        },
        sanitizeFormValue: function (value, options) {
            if (options.trim && v.isString(value)) {
                value = value.trim();
            }
            if (options.nullify !== false && value === '') {
                return null;
            }
            return value;
        },
        capitalize: function (str) {
            if (!v.isString(str)) {
                return str;
            }
            return str[0].toUpperCase() + str.slice(1);
        },
        pruneEmptyErrors: function (errors) {
            return errors.filter(function (error) {
                return !v.isEmpty(error.error);
            });
        },
        expandMultipleErrors: function (errors) {
            var ret = [];
            errors.forEach(function (error) {
                if (v.isArray(error.error)) {
                    error.error.forEach(function (msg) {
                        ret.push(v.extend({}, error, { error: msg }));
                    });
                } else {
                    ret.push(error);
                }
            });
            return ret;
        },
        convertErrorMessages: function (errors, options) {
            options = options || {};
            var ret = [];
            errors.forEach(function (errorInfo) {
                var error = v.result(errorInfo.error, errorInfo.value, errorInfo.attribute, errorInfo.options, errorInfo.attributes, errorInfo.globalOptions);
                if (!v.isString(error)) {
                    ret.push(errorInfo);
                    return;
                }
                if (error[0] === '^') {
                    error = error.slice(1);
                } else if (options.fullMessages !== false) {
                    error = v.capitalize(v.prettify(errorInfo.attribute)) + ' ' + error;
                }
                error = error.replace(/\\\^/g, '^');
                error = v.format(error, { value: v.stringifyValue(errorInfo.value) });
                ret.push(v.extend({}, errorInfo, { error: error }));
            });
            return ret;
        },
        groupErrorsByAttribute: function (errors) {
            var ret = {};
            errors.forEach(function (error) {
                var list = ret[error.attribute];
                if (list) {
                    list.push(error);
                } else {
                    ret[error.attribute] = [error];
                }
            });
            return ret;
        },
        flattenErrorsToArray: function (errors) {
            return errors.map(function (error) {
                return error.error;
            }).filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
        },
        cleanAttributes: function (attributes, whitelist) {
            function whitelistCreator(obj, key, last) {
                if (v.isObject(obj[key])) {
                    return obj[key];
                }
                return obj[key] = last ? true : {};
            }
            function buildObjectWhitelist(whitelist) {
                var ow = {}, lastObject, attr;
                for (attr in whitelist) {
                    if (!whitelist[attr]) {
                        continue;
                    }
                    v.forEachKeyInKeypath(ow, attr, whitelistCreator);
                }
                return ow;
            }
            function cleanRecursive(attributes, whitelist) {
                if (!v.isObject(attributes)) {
                    return attributes;
                }
                var ret = v.extend({}, attributes), w, attribute;
                for (attribute in attributes) {
                    w = whitelist[attribute];
                    if (v.isObject(w)) {
                        ret[attribute] = cleanRecursive(ret[attribute], w);
                    } else if (!w) {
                        delete ret[attribute];
                    }
                }
                return ret;
            }
            if (!v.isObject(whitelist) || !v.isObject(attributes)) {
                return {};
            }
            whitelist = buildObjectWhitelist(whitelist);
            return cleanRecursive(attributes, whitelist);
        },
        exposeModule: function (validate, root, exports, module, define) {
            if (exports) {
                if (module && module.exports) {
                    exports = module.exports = validate;
                }
                exports.validate = validate;
            } else {
                root.validate = validate;
                if (validate.isFunction(define) && define.amd) {
                    define('validate.js@0.11.1#validate', [], function () {
                        return validate;
                    });
                }
            }
        },
        warn: function (msg) {
            if (typeof console !== 'undefined' && console.warn) {
                console.warn('[validate.js] ' + msg);
            }
        },
        error: function (msg) {
            if (typeof console !== 'undefined' && console.error) {
                console.error('[validate.js] ' + msg);
            }
        }
    });
    validate.validators = {
        presence: function (value, options) {
            options = v.extend({}, this.options, options);
            if (options.allowEmpty ? !v.isDefined(value) : v.isEmpty(value)) {
                return options.message || this.message || 'can\'t be blank';
            }
        },
        length: function (value, options, attribute) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var is = options.is, maximum = options.maximum, minimum = options.minimum, tokenizer = options.tokenizer || function (val) {
                    return val;
                }, err, errors = [];
            value = tokenizer(value);
            var length = value.length;
            if (!v.isNumber(length)) {
                v.error(v.format('Attribute %{attr} has a non numeric value for `length`', { attr: attribute }));
                return options.message || this.notValid || 'has an incorrect length';
            }
            if (v.isNumber(is) && length !== is) {
                err = options.wrongLength || this.wrongLength || 'is the wrong length (should be %{count} characters)';
                errors.push(v.format(err, { count: is }));
            }
            if (v.isNumber(minimum) && length < minimum) {
                err = options.tooShort || this.tooShort || 'is too short (minimum is %{count} characters)';
                errors.push(v.format(err, { count: minimum }));
            }
            if (v.isNumber(maximum) && length > maximum) {
                err = options.tooLong || this.tooLong || 'is too long (maximum is %{count} characters)';
                errors.push(v.format(err, { count: maximum }));
            }
            if (errors.length > 0) {
                return options.message || errors;
            }
        },
        numericality: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var errors = [], name, count, checks = {
                    greaterThan: function (v, c) {
                        return v > c;
                    },
                    greaterThanOrEqualTo: function (v, c) {
                        return v >= c;
                    },
                    equalTo: function (v, c) {
                        return v === c;
                    },
                    lessThan: function (v, c) {
                        return v < c;
                    },
                    lessThanOrEqualTo: function (v, c) {
                        return v <= c;
                    },
                    divisibleBy: function (v, c) {
                        return v % c === 0;
                    }
                };
            if (v.isString(value) && options.strict) {
                var pattern = '^(0|[1-9]\\d*)';
                if (!options.onlyInteger) {
                    pattern += '(\\.\\d+)?';
                }
                pattern += '$';
                if (!new RegExp(pattern).test(value)) {
                    return options.message || options.notValid || this.notValid || this.message || 'must be a valid number';
                }
            }
            if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {
                value = +value;
            }
            if (!v.isNumber(value)) {
                return options.message || options.notValid || this.notValid || this.message || 'is not a number';
            }
            if (options.onlyInteger && !v.isInteger(value)) {
                return options.message || options.notInteger || this.notInteger || this.message || 'must be an integer';
            }
            for (name in checks) {
                count = options[name];
                if (v.isNumber(count) && !checks[name](value, count)) {
                    var key = 'not' + v.capitalize(name);
                    var msg = options[key] || this[key] || this.message || 'must be %{type} %{count}';
                    errors.push(v.format(msg, {
                        count: count,
                        type: v.prettify(name)
                    }));
                }
            }
            if (options.odd && value % 2 !== 1) {
                errors.push(options.notOdd || this.notOdd || this.message || 'must be odd');
            }
            if (options.even && value % 2 !== 0) {
                errors.push(options.notEven || this.notEven || this.message || 'must be even');
            }
            if (errors.length) {
                return options.message || errors;
            }
        },
        datetime: v.extend(function (value, options) {
            if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {
                throw new Error('Both the parse and format functions needs to be set to use the datetime/date validator');
            }
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var err, errors = [], earliest = options.earliest ? this.parse(options.earliest, options) : NaN, latest = options.latest ? this.parse(options.latest, options) : NaN;
            value = this.parse(value, options);
            if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {
                err = options.notValid || options.message || this.notValid || 'must be a valid date';
                return v.format(err, { value: arguments[0] });
            }
            if (!isNaN(earliest) && value < earliest) {
                err = options.tooEarly || options.message || this.tooEarly || 'must be no earlier than %{date}';
                err = v.format(err, {
                    value: this.format(value, options),
                    date: this.format(earliest, options)
                });
                errors.push(err);
            }
            if (!isNaN(latest) && value > latest) {
                err = options.tooLate || options.message || this.tooLate || 'must be no later than %{date}';
                err = v.format(err, {
                    date: this.format(latest, options),
                    value: this.format(value, options)
                });
                errors.push(err);
            }
            if (errors.length) {
                return v.unique(errors);
            }
        }, {
            parse: null,
            format: null
        }),
        date: function (value, options) {
            options = v.extend({}, options, { dateOnly: true });
            return v.validators.datetime.call(v.validators.datetime, value, options);
        },
        format: function (value, options) {
            if (v.isString(options) || options instanceof RegExp) {
                options = { pattern: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is invalid', pattern = options.pattern, match;
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (v.isString(pattern)) {
                pattern = new RegExp(options.pattern, options.flags);
            }
            match = pattern.exec(value);
            if (!match || match[0].length != value.length) {
                return message;
            }
        },
        inclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is not included in the list';
            return v.format(message, { value: value });
        },
        exclusion: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isArray(options)) {
                options = { within: options };
            }
            options = v.extend({}, this.options, options);
            if (!v.contains(options.within, value)) {
                return;
            }
            var message = options.message || this.message || '^%{value} is restricted';
            return v.format(message, { value: value });
        },
        email: v.extend(function (value, options) {
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid email';
            if (!v.isDefined(value)) {
                return;
            }
            if (!v.isString(value)) {
                return message;
            }
            if (!this.PATTERN.exec(value)) {
                return message;
            }
        }, { PATTERN: /^[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9\u007F-\uffff!#$%&'*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z]{2,}$/i }),
        equality: function (value, options, attribute, attributes) {
            if (!v.isDefined(value)) {
                return;
            }
            if (v.isString(options)) {
                options = { attribute: options };
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not equal to %{attribute}';
            if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {
                throw new Error('The attribute must be a non empty string');
            }
            var otherValue = v.getDeepObjectValue(attributes, options.attribute), comparator = options.comparator || function (v1, v2) {
                    return v1 === v2;
                };
            if (!comparator(value, otherValue, options, attribute, attributes)) {
                return v.format(message, { attribute: v.prettify(options.attribute) });
            }
        },
        url: function (value, options) {
            if (!v.isDefined(value)) {
                return;
            }
            options = v.extend({}, this.options, options);
            var message = options.message || this.message || 'is not a valid url', schemes = options.schemes || this.schemes || [
                    'http',
                    'https'
                ], allowLocal = options.allowLocal || this.allowLocal || false;
            if (!v.isString(value)) {
                return message;
            }
            var regex = '^' + '(?:(?:' + schemes.join('|') + ')://)' + '(?:\\S+(?::\\S*)?@)?' + '(?:';
            var tld = '(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))';
            if (allowLocal) {
                tld += '?';
            } else {
                regex += '(?!(?:10|127)(?:\\.\\d{1,3}){3})' + '(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})' + '(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})';
            }
            regex += '(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])' + '(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}' + '(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))' + '|' + '(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)' + '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*' + tld + ')' + '(?::\\d{2,5})?' + '(?:[/?#]\\S*)?' + '$';
            var PATTERN = new RegExp(regex, 'i');
            if (!PATTERN.exec(value)) {
                return message;
            }
        }
    };
    validate.formatters = {
        detailed: function (errors) {
            return errors;
        },
        flat: v.flattenErrorsToArray,
        grouped: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = v.flattenErrorsToArray(errors[attr]);
            }
            return errors;
        },
        constraint: function (errors) {
            var attr;
            errors = v.groupErrorsByAttribute(errors);
            for (attr in errors) {
                errors[attr] = errors[attr].map(function (result) {
                    return result.validator;
                }).sort();
            }
            return errors;
        }
    };
    validate.exposeModule(validate, this, exports, module, define);
}.call(this, typeof exports !== 'undefined' ? exports : null, typeof module !== 'undefined' ? module : null, typeof define !== 'undefined' ? define : null));
/*can-validate-legacy@1.4.0#shims/validatejs*/
define('can-validate-legacy@1.4.0#shims/validatejs', [
    'require',
    'exports',
    'module',
    'can-validate-legacy',
    'validate.js'
], function (require, exports, module) {
    'use strict';
    var validate = require('can-validate-legacy');
    var validatejs = require('validate.js');
    var processOptions = function (opts) {
        if (typeof opts.required !== 'undefined') {
            opts.presence = opts.required;
            delete opts.required;
        }
        if (opts.hasOwnProperty('mustValidate')) {
            delete opts.mustValidate;
        }
        if (opts.hasOwnProperty('validateOnInit')) {
            delete opts.validateOnInit;
        }
        return opts;
    };
    var shim = {
        once: function (value, options, name) {
            var errors = [];
            var opts = [];
            var validationOpts = [];
            if (name) {
                opts[name] = value;
                validationOpts[name] = processOptions(options);
                errors = validatejs(opts, validationOpts);
                if (errors) {
                    errors = errors[name];
                }
            } else {
                errors = validatejs.single(value, processOptions(options));
            }
            return errors;
        },
        isValid: function (value, options) {
            var errors = validatejs.single(value, processOptions(options)) || [];
            return errors.length === 0;
        },
        validate: function (values, options) {
            var valueKeys = Object.keys(values);
            var processedOpts = {};
            for (var i = 0; i < valueKeys.length; i++) {
                var prop = valueKeys[i];
                if (options[prop]) {
                    processedOpts[prop] = processOptions(options[prop]);
                }
            }
            return validatejs(values, processedOpts);
        }
    };
    validate.register('validatejs', shim);
});
/*can-validate-legacy@1.4.0#can-validate-test*/
define('can-validate-legacy@1.4.0#can-validate-test', [
    'require',
    'exports',
    'module',
    'can-map',
    'can-reflect',
    'steal-qunit',
    'can-map-define',
    'can-validate-legacy',
    'can-validate-legacy/map/validate/',
    'can-validate-legacy/shims/validatejs'
], function (require, exports, module) {
    var Map = require('can-map');
    var canReflect = require('can-reflect');
    var QUnit = require('steal-qunit');
    require('can-map-define');
    require('can-validate-legacy');
    require('can-validate-legacy/map/validate/');
    require('can-validate-legacy/shims/validatejs');
    var validatedMap;
    var secondaryMap;
    var ValidatedMap = Map.extend({
        define: {
            myNumber: {
                value: 100,
                validate: { required: true }
            },
            computedProp: {
                validate: {
                    required: function () {
                        return this.attr('isRequired');
                    }
                },
                value: ''
            },
            isRequired: {
                value: false,
                type: 'boolean'
            }
        }
    });
    var isEmptyObject = function (value) {
        return canReflect.size(value) === 0;
    };
    QUnit.module('Map Validate Plugin');
    QUnit.test('when validateOnInit is not set, it should not run validation', function () {
        validatedMap = new ValidatedMap();
        QUnit.ok(isEmptyObject(validatedMap.errors));
    });
    QUnit.test('validations run when value is set', function () {
        validatedMap = new ValidatedMap();
        validatedMap.attr('myNumber', '');
        QUnit.equal(validatedMap.errors.myNumber.length, 1);
    });
    QUnit.test('when validate method is called, resolves computes before calling Validate method', function () {
        validatedMap = new ValidatedMap({
            isRequired: true,
            myNumber: 0
        });
        var success = false;
        try {
            validatedMap.validate();
            success = true;
        } catch (err) {
            success = err;
        }
        QUnit.ok(success);
    });
    QUnit.test('when creating multiple instances of the same map, each instance is discrete', function () {
        validatedMap = new ValidatedMap();
        validatedMap.attr('isRequired', true);
        secondaryMap = new ValidatedMap();
        secondaryMap.attr('computedProp', '');
        QUnit.equal(isEmptyObject(secondaryMap.attr('errors')), true, 'control map validates successfully');
        validatedMap.attr('computedProp', '');
        QUnit.equal(validatedMap.attr('computedProp'), '');
        QUnit.ok(typeof validatedMap.attr('errors.computedProp') !== 'undefined', 'other map validates, sets error');
    });
    var ShimValidatedMap = Map.extend({
        define: {
            myNumber: {
                value: 'test',
                validate: {
                    required: true,
                    numericality: true,
                    validateOnInit: true
                }
            },
            myString: {
                value: '12345',
                validate: {
                    required: true,
                    length: 2
                }
            }
        }
    });
    QUnit.module('Validate.js Shim', {
        setup: function () {
            validatedMap = new ShimValidatedMap({});
        }
    });
    QUnit.test('validates on init by default', function () {
        QUnit.equal(validatedMap.attr('errors').myNumber.length, 1);
    });
    QUnit.test('validates on init by default', function () {
        QUnit.equal(validatedMap.errors.myNumber.length, 1);
    });
    QUnit.test('does not validate on init, when validate on init is false', function () {
        QUnit.equal(validatedMap.errors.myString, undefined);
    });
    QUnit.test('runs validation on value', function () {
        validatedMap.attr('myString', '');
        QUnit.equal(validatedMap.errors.myString.length, 1);
    });
});
/*can-legacy-view-helpers@1.0.0#src/deferred*/
define('can-legacy-view-helpers@1.0.0#src/deferred', [
    'require',
    'exports',
    'module',
    'can-util/js/is-function/is-function',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each'
], function (require, exports, module) {
    var isFunction = require('can-util/js/is-function/is-function'), makeArray = require('can-util/js/make-array/make-array'), each = require('can-util/js/each/each');
    var extend = function (target, src) {
            for (var key in src) {
                if (src.hasOwnProperty(key)) {
                    target[key] = src[key];
                }
            }
        }, Deferred = function (func) {
            if (!(this instanceof Deferred)) {
                return new Deferred();
            }
            this._doneFuncs = [];
            this._failFuncs = [];
            this._resultArgs = null;
            this._status = '';
            if (func) {
                func.call(this, this);
            }
        };
    Deferred.when = function () {
        var args = makeArray(arguments);
        if (args.length < 2) {
            var obj = args[0];
            if (obj && (isFunction(obj.isResolved) && isFunction(obj.isRejected))) {
                return obj;
            } else {
                return Deferred().resolve(obj);
            }
        } else {
            var df = Deferred(), done = 0, rp = [];
            each(args, function (arg, j) {
                arg.done(function () {
                    rp[j] = arguments.length < 2 ? arguments[0] : arguments;
                    if (++done === args.length) {
                        df.resolve.apply(df, rp);
                    }
                }).fail(function () {
                    df.reject(arguments.length === 1 ? arguments[0] : arguments);
                });
            });
            return df;
        }
    };
    var resolveFunc = function (type, _status) {
            return function (context) {
                var args = this._resultArgs = arguments.length > 1 ? arguments[1] : [];
                return this.exec(context, this[type], args, _status);
            };
        }, doneFunc = function doneFunc(type, _status) {
            return function () {
                var self = this;
                each(Array.prototype.slice.call(arguments), function (v) {
                    if (!v) {
                        return;
                    }
                    if (v.constructor === Array) {
                        doneFunc.apply(self, v);
                    } else {
                        if (self._status === _status) {
                            v.apply(self, self._resultArgs || []);
                        }
                        self[type].push(v);
                    }
                });
                return this;
            };
        };
    var isDeferred = function (obj) {
        return obj && obj.then && obj.fail && obj.done;
    };
    var wire = function (parentDeferred, result, setter, value) {
        if (isDeferred(result)) {
            result.done(parentDeferred.resolve.bind(parentDeferred)).fail(parentDeferred.reject.bind(parentDeferred));
        } else {
            setter.call(parentDeferred, result !== undefined ? result : value);
        }
    };
    extend(Deferred.prototype, {
        then: function (done, fail) {
            var d = Deferred(), resolve = d.resolve, reject = d.reject;
            this.done(function (value) {
                if (typeof done === 'function') {
                    wire(d, done.apply(this, arguments), resolve, value);
                } else {
                    resolve.apply(d, arguments);
                }
            });
            this.fail(function (value) {
                if (typeof fail === 'function') {
                    wire(d, fail.apply(this, arguments), reject, value);
                } else {
                    reject.apply(d, arguments);
                }
            });
            return d;
        },
        resolveWith: resolveFunc('_doneFuncs', 'rs'),
        rejectWith: resolveFunc('_failFuncs', 'rj'),
        done: doneFunc('_doneFuncs', 'rs'),
        fail: doneFunc('_failFuncs', 'rj'),
        always: function () {
            var args = makeArray(arguments);
            if (args.length && args[0]) {
                this.done(args[0]).fail(args[0]);
            }
            return this;
        },
        state: function () {
            switch (this._status) {
            case 'rs':
                return 'resolved';
            case 'rj':
                return 'rejected';
            default:
                return 'pending';
            }
        },
        isResolved: function () {
            return this._status === 'rs';
        },
        isRejected: function () {
            return this._status === 'rj';
        },
        reject: function () {
            return this.rejectWith(this, arguments);
        },
        resolve: function () {
            return this.resolveWith(this, arguments);
        },
        exec: function (context, dst, args, st) {
            if (this._status !== '') {
                return this;
            }
            this._status = st;
            each(dst, function (d) {
                if (typeof d.apply === 'function') {
                    d.apply(context, args);
                }
            });
            return this;
        },
        promise: function () {
            var promise = this.then();
            promise.reject = promise.resolve = undefined;
            return promise;
        }
    });
    Deferred.prototype.pipe = Deferred.prototype.then;
    module.exports = Deferred;
});
/*can-legacy-view-helpers@1.0.0#src/view*/
define('can-legacy-view-helpers@1.0.0#src/view', [
    'require',
    'exports',
    'module',
    'can-util/js/is-function/is-function',
    'can-util/js/make-array/make-array',
    'can-util/js/deep-assign/deep-assign',
    'can-util/dom/frag/frag',
    'can-util/js/each/each',
    'can-namespace',
    'can-observation',
    'can-ajax/can-ajax',
    './deferred',
    'can-log/dev/dev'
], function (require, exports, module) {
    var isFunction = require('can-util/js/is-function/is-function'), makeArray = require('can-util/js/make-array/make-array'), deepAssign = require('can-util/js/deep-assign/deep-assign'), canFrag = require('can-util/dom/frag/frag'), each = require('can-util/js/each/each'), can = require('can-namespace'), Observation = require('can-observation'), ajax = require('can-ajax/can-ajax'), Deferred = require('./deferred'), dev = require('can-log/dev/dev'), hookupId = 1, $view;
    var isDeferred = function (maybeDeferred) {
        return maybeDeferred instanceof Deferred;
    };
    var makeRenderer = function (textRenderer) {
        if (textRenderer.renderType === 'fragment') {
            return textRenderer;
        }
        var renderer = function () {
            return $view.frag(textRenderer.apply(this, arguments));
        };
        renderer.render = function () {
            return textRenderer.apply(textRenderer, arguments);
        };
        return renderer;
    };
    var checkText = function (text, url) {
        if (!text.length) {
            throw new Error('can.view: No template or empty template:' + url);
        }
    };
    var getRenderer = function (obj, async) {
        if (isFunction(obj)) {
            var def = Deferred();
            return def.resolve(obj);
        }
        var url = typeof obj === 'string' ? obj : obj.url, suffix = obj.engine && '.' + obj.engine || url.match(/\.[\w\d]+$/), type, el, id;
        if (url.match(/^#/)) {
            url = url.substr(1);
        }
        if (el = document.getElementById(url)) {
            suffix = '.' + el.type.match(/\/(x\-)?(.+)/)[2];
        }
        if (!suffix && !$view.cached[url]) {
            url += suffix = $view.ext;
        }
        if (Array.isArray(suffix)) {
            suffix = suffix[0];
        }
        id = $view.toId(url);
        if (url.match(/^\/\//)) {
            url = url.substr(2);
            url = !window.steal ? url : steal.config().root.mapJoin('' + steal.id(url));
        }
        if (window.require) {
            if (require.toUrl) {
                url = require.toUrl(url);
            }
        }
        type = $view.types[suffix];
        if ($view.cached[id]) {
            return $view.cached[id];
        } else if (el) {
            return $view.registerView(id, el.innerHTML, type);
        } else {
            var d = new Deferred();
            ajax({
                async: async,
                url: url,
                dataType: 'text',
                error: function (jqXHR) {
                    checkText('', url);
                    d.reject(jqXHR);
                },
                success: function (text) {
                    checkText(text, url);
                    $view.registerView(id, text, type, d);
                }
            });
            return d;
        }
    };
    var getDeferreds = function (data) {
        var deferreds = [];
        if (isDeferred(data)) {
            return [data];
        } else {
            for (var prop in data) {
                if (isDeferred(data[prop])) {
                    deferreds.push(data[prop]);
                }
            }
        }
        return deferreds;
    };
    var usefulPart = function (resolved) {
        return Array.isArray(resolved) && resolved[1] === 'success' ? resolved[0] : resolved;
    };
    $view = function (view, data, helpers, callback) {
        if (isFunction(helpers)) {
            callback = helpers;
            helpers = undefined;
        }
        return $view.renderAs('fragment', view, data, helpers, callback);
    };
    if (can.view) {
        Object.assign($view, can.view);
    }
    deepAssign($view, {
        frag: function (result, parentNode) {
            return $view.hookup($view.fragment(result), parentNode);
        },
        fragment: function (result) {
            return canFrag(result, document);
        },
        toId: function (src) {
            return src.toString().split(/\/|\./g).map(function (part) {
                if (part) {
                    return part;
                }
            }).join('_');
        },
        toStr: function (txt) {
            return txt == null ? '' : '' + txt;
        },
        hookup: function (fragment, parentNode) {
            var hookupEls = [], id, func;
            each(fragment.childNodes ? makeArray(fragment.childNodes) : fragment, function (node) {
                if (node.nodeType === 1) {
                    hookupEls.push(node);
                    hookupEls.push.apply(hookupEls, makeArray(node.getElementsByTagName('*')));
                }
            });
            each(hookupEls, function (el) {
                if (el.getAttribute && (id = el.getAttribute('data-view-id')) && (func = $view.hookups[id])) {
                    func(el, parentNode, id);
                    delete $view.hookups[id];
                    el.removeAttribute('data-view-id');
                }
            });
            return fragment;
        },
        hookups: {},
        hook: function (cb) {
            $view.hookups[++hookupId] = cb;
            return ' data-view-id=\'' + hookupId + '\'';
        },
        cached: {},
        cachedRenderers: {},
        cache: true,
        register: function (info) {
            this.types['.' + info.suffix] = info;
            can[info.suffix] = $view[info.suffix] = function (id, text) {
                var renderer, renderFunc;
                if (!text) {
                    renderFunc = function () {
                        if (!renderer) {
                            if (info.fragRenderer) {
                                renderer = info.fragRenderer(null, id);
                            } else {
                                renderer = makeRenderer(info.renderer(null, id));
                            }
                        }
                        return renderer.apply(this, arguments);
                    };
                    renderFunc.render = function () {
                        var textRenderer = info.renderer(null, id);
                        return textRenderer.apply(textRenderer, arguments);
                    };
                    return renderFunc;
                }
                var registeredRenderer = function () {
                    if (!renderer) {
                        if (info.fragRenderer) {
                            renderer = info.fragRenderer(id, text);
                        } else {
                            renderer = info.renderer(id, text);
                        }
                    }
                    return renderer.apply(this, arguments);
                };
                if (info.fragRenderer) {
                    return $view.preload(id, registeredRenderer);
                } else {
                    return $view.preloadStringRenderer(id, registeredRenderer);
                }
            };
        },
        types: {},
        ext: '.ejs',
        registerScript: function (type, id, src) {
            return 'can.view.preloadStringRenderer(\'' + id + '\',' + $view.types['.' + type].script(id, src) + ');';
        },
        preload: function (id, renderer) {
            var def = $view.cached[id] = Deferred().resolve(function (data, helpers) {
                return renderer.call(data, data, helpers);
            });
            def.__view_id = id;
            $view.cachedRenderers[id] = renderer;
            return renderer;
        },
        preloadStringRenderer: function (id, stringRenderer) {
            return this.preload(id, makeRenderer(stringRenderer));
        },
        render: function (view, data, helpers, callback, nodelist) {
            return $view.renderAs('string', view, data, helpers, callback, nodelist);
        },
        renderTo: function (format, renderer, data, helpers, nodelist) {
            if (format === 'string') {
                if (renderer.renderAsString) {
                    renderer = renderer.renderAsString;
                } else if (renderer.render) {
                    renderer = renderer.render;
                }
            }
            return renderer(data, helpers, nodelist);
        },
        renderAs: function (format, view, data, helpers, callback, nodelist) {
            if (callback !== undefined && typeof callback.expression === 'string') {
                nodelist = callback;
                callback = undefined;
            }
            if (isFunction(helpers)) {
                callback = helpers;
                helpers = undefined;
            }
            helpers = Object.assign({ can: can }, helpers);
            var deferreds = getDeferreds(data);
            var deferred, dataCopy, async, response;
            if (deferreds.length) {
                deferred = new Deferred();
                dataCopy = Object.assign({}, data);
                deferreds.push(getRenderer(view, true));
                Deferred.when.apply(can, deferreds).then(function (resolved) {
                    var objs = makeArray(arguments), renderer = objs.pop(), result;
                    if (isDeferred(data)) {
                        dataCopy = usefulPart(resolved);
                    } else {
                        for (var prop in data) {
                            if (isDeferred(data[prop])) {
                                dataCopy[prop] = usefulPart(objs.shift());
                            }
                        }
                    }
                    result = can.view.renderTo(format, renderer, dataCopy, helpers, nodelist);
                    deferred.resolve(result, dataCopy);
                    if (callback) {
                        callback(result, dataCopy);
                    }
                }, function () {
                    deferred.reject.apply(deferred, arguments);
                });
                return deferred;
            } else {
                async = isFunction(callback);
                deferred = Observation.ignore(getRenderer)(view, async);
                if (async) {
                    response = deferred;
                    deferred.then(function (renderer) {
                        callback(data ? $view.renderTo(format, renderer, data, helpers, nodelist) : renderer);
                    });
                } else {
                    if (deferred.state() === 'resolved' && deferred.__view_id) {
                        var currentRenderer = $view.cachedRenderers[deferred.__view_id];
                        var result = data ? $view.renderTo(format, currentRenderer, data, helpers, nodelist) : currentRenderer;
                        return result;
                    } else {
                        deferred.then(function (renderer) {
                            response = data ? $view.renderTo(format, renderer, data, helpers, nodelist) : renderer;
                        });
                    }
                }
                return response;
            }
        },
        registerView: function (id, text, type, def) {
            var info = typeof type === 'object' ? type : $view.types[type || $view.ext], renderer;
            if (info.fragRenderer) {
                renderer = info.fragRenderer(id, text);
            } else {
                renderer = makeRenderer(info.renderer(id, text));
            }
            def = def || new Deferred();
            if ($view.cache) {
                $view.cached[id] = def;
                def.__view_id = id;
                $view.cachedRenderers[id] = renderer;
            }
            return def.resolve(renderer);
        },
        simpleHelper: function (fn) {
            return function () {
                var realArgs = [];
                var fnArgs = arguments;
                each(fnArgs, function (val, i) {
                    if (i <= fnArgs.length) {
                        while (val && val.isComputed) {
                            val = val();
                        }
                        realArgs.push(val);
                    }
                });
                return fn.apply(this, realArgs);
            };
        }
    });
    module.exports = can.view = $view;
});
/*can-legacy-view-helpers@1.0.0#src/node_list*/
define('can-legacy-view-helpers@1.0.0#src/node_list', [
    'require',
    'exports',
    'module',
    'can-util/js/make-array/make-array',
    'can-cid',
    'can-util/js/each/each',
    'can-util/dom/mutate/mutate'
], function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var CID = require('can-cid');
    var each = require('can-util/js/each/each');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canExpando = true, readId, nodeLists;
    try {
        document.createTextNode('')._ = 0;
    } catch (ex) {
        canExpando = false;
    }
    var nodeMap = {}, textNodeMap = {}, expando = 'ejs_' + Math.random(), _id = 0, id = function (node, localMap) {
            var _textNodeMap = localMap || textNodeMap;
            var id = readId(node, _textNodeMap);
            if (id) {
                return id;
            } else {
                if (canExpando || node.nodeType !== 3) {
                    ++_id;
                    return node[expando] = (node.nodeName ? 'element_' : 'obj_') + _id;
                } else {
                    ++_id;
                    _textNodeMap['text_' + _id] = node;
                    return 'text_' + _id;
                }
            }
        };
    readId = function (node, textNodeMap) {
        if (canExpando || node.nodeType !== 3) {
            return node[expando];
        } else {
            for (var textNodeID in textNodeMap) {
                if (textNodeMap[textNodeID] === node) {
                    return textNodeID;
                }
            }
        }
    };
    var splice = [].splice, push = [].push, itemsInChildListTree = function (list) {
            var count = 0;
            for (var i = 0, len = list.length; i < len; i++) {
                var item = list[i];
                if (item.nodeType) {
                    count++;
                } else {
                    count += itemsInChildListTree(item);
                }
            }
            return count;
        }, replacementMap = function (replacements, idMap) {
            var map = {};
            for (var i = 0, len = replacements.length; i < len; i++) {
                var node = nodeLists.first(replacements[i]);
                map[id(node, idMap)] = replacements[i];
            }
            return map;
        }, addUnfoundAsDeepChildren = function (list, rMap, foundIds) {
            for (var repId in rMap) {
                if (!foundIds[repId]) {
                    list.newDeepChildren.push(rMap[repId]);
                }
            }
        };
    nodeLists = {
        id: id,
        update: function (nodeList, newNodes) {
            var oldNodes = nodeLists.unregisterChildren(nodeList);
            newNodes = makeArray(newNodes);
            var oldListLength = nodeList.length;
            splice.apply(nodeList, [
                0,
                oldListLength
            ].concat(newNodes));
            if (nodeList.replacements) {
                nodeLists.nestReplacements(nodeList);
                nodeList.deepChildren = nodeList.newDeepChildren;
                nodeList.newDeepChildren = [];
            } else {
                nodeLists.nestList(nodeList);
            }
            return oldNodes;
        },
        nestReplacements: function (list) {
            var index = 0, idMap = {}, rMap = replacementMap(list.replacements, idMap), rCount = list.replacements.length, foundIds = {};
            while (index < list.length && rCount) {
                var node = list[index], nodeId = readId(node, idMap), replacement = rMap[nodeId];
                if (replacement) {
                    list.splice(index, itemsInChildListTree(replacement), replacement);
                    foundIds[nodeId] = true;
                    rCount--;
                }
                index++;
            }
            if (rCount) {
                addUnfoundAsDeepChildren(list, rMap, foundIds);
            }
            list.replacements = [];
        },
        nestList: function (list) {
            var index = 0;
            while (index < list.length) {
                var node = list[index], childNodeList = nodeMap[id(node)];
                if (childNodeList) {
                    if (childNodeList !== list) {
                        list.splice(index, itemsInChildListTree(childNodeList), childNodeList);
                    }
                } else {
                    nodeMap[id(node)] = list;
                }
                index++;
            }
        },
        last: function (nodeList) {
            var last = nodeList[nodeList.length - 1];
            if (last.nodeType) {
                return last;
            } else {
                return nodeLists.last(last);
            }
        },
        first: function (nodeList) {
            var first = nodeList[0];
            if (first.nodeType) {
                return first;
            } else {
                return nodeLists.first(first);
            }
        },
        flatten: function (nodeList) {
            var items = [];
            for (var i = 0; i < nodeList.length; i++) {
                var item = nodeList[i];
                if (item.nodeType) {
                    items.push(item);
                } else {
                    items.push.apply(items, nodeLists.flatten(item));
                }
            }
            return items;
        },
        register: function (nodeList, unregistered, parent, directlyNested) {
            CID(nodeList);
            nodeList.unregistered = unregistered;
            nodeList.parentList = parent;
            nodeList.nesting = parent && typeof parent.nesting !== 'undefined' ? parent.nesting + 1 : 0;
            if (parent) {
                nodeList.deepChildren = [];
                nodeList.newDeepChildren = [];
                nodeList.replacements = [];
                if (parent !== true) {
                    if (directlyNested) {
                        parent.replacements.push(nodeList);
                    } else {
                        parent.newDeepChildren.push(nodeList);
                    }
                }
            } else {
                nodeLists.nestList(nodeList);
            }
            return nodeList;
        },
        unregisterChildren: function (nodeList) {
            var nodes = [];
            each(nodeList, function (node) {
                if (node.nodeType) {
                    if (!nodeList.replacements) {
                        delete nodeMap[id(node)];
                    }
                    nodes.push(node);
                } else {
                    push.apply(nodes, nodeLists.unregister(node, true));
                }
            });
            each(nodeList.deepChildren, function (nodeList) {
                nodeLists.unregister(nodeList, true);
            });
            return nodes;
        },
        unregister: function (nodeList, isChild) {
            var nodes = nodeLists.unregisterChildren(nodeList, true);
            if (nodeList.unregistered) {
                var unregisteredCallback = nodeList.unregistered;
                nodeList.replacements = nodeList.unregistered = null;
                if (!isChild) {
                    var deepChildren = nodeList.parentList && nodeList.parentList.deepChildren;
                    if (deepChildren) {
                        var index = deepChildren.indexOf(nodeList);
                        if (index !== -1) {
                            deepChildren.splice(index, 1);
                        }
                    }
                }
                unregisteredCallback();
            }
            return nodes;
        },
        nodeMap: nodeMap,
        after: function (oldElements, newFrag) {
            var last = oldElements[oldElements.length - 1];
            if (last.nextSibling) {
                domMutate.insertBefore.call(last.parentNode, newFrag, last.nextSibling);
            } else {
                domMutate.appendChild.call(last.parentNode, newFrag);
            }
        },
        replace: function (oldElements, newFrag) {
            var selectedValue, parentNode = oldElements[0].parentNode;
            if (parentNode.nodeName.toUpperCase() === 'SELECT' && parentNode.selectedIndex >= 0) {
                selectedValue = parentNode.value;
            }
            if (oldElements.length === 1) {
                domMutate.replaceChild.call(parentNode, newFrag, oldElements[0]);
            } else {
                nodeLists.after(oldElements, newFrag);
                nodeLists.remove(oldElements);
            }
            if (selectedValue !== undefined) {
                parentNode.value = selectedValue;
            }
        },
        remove: function (elementsToBeRemoved) {
            var parent = elementsToBeRemoved[0] && elementsToBeRemoved[0].parentNode;
            each(elementsToBeRemoved, function (child) {
                domMutate.removeChild.call(parent, child);
            });
        }
    };
    module.exports = nodeLists;
});
/*can-legacy-view-helpers@1.0.0#src/elements*/
define('can-legacy-view-helpers@1.0.0#src/elements', [
    'require',
    'exports',
    'module',
    './node_list'
], function (require, exports, module) {
    var nodeLists = require('./node_list');
    var doc = typeof document !== 'undefined' ? document : null;
    var elements = {
        tagToContentPropMap: {
            option: doc && 'textContent' in document.createElement('option') ? 'textContent' : 'innerText',
            textarea: 'value'
        },
        tagMap: {
            '': 'span',
            colgroup: 'col',
            table: 'tbody',
            tr: 'td',
            ol: 'li',
            ul: 'li',
            tbody: 'tr',
            thead: 'tr',
            tfoot: 'tr',
            select: 'option',
            optgroup: 'option'
        },
        reverseTagMap: {
            col: 'colgroup',
            tr: 'tbody',
            option: 'select',
            td: 'tr',
            th: 'tr',
            li: 'ul'
        },
        selfClosingTags: { col: true },
        getParentNode: function (el, defaultParentNode) {
            return defaultParentNode && el.parentNode.nodeType === 11 ? defaultParentNode : el.parentNode;
        },
        contentText: function (text) {
            if (typeof text === 'string') {
                return text;
            }
            if (!text && text !== 0) {
                return '';
            }
            return '' + text;
        },
        after: nodeLists.after,
        replace: nodeLists.replace
    };
    module.exports = elements;
});
/*can-legacy-view-helpers@1.0.0#src/live*/
define('can-legacy-view-helpers@1.0.0#src/live', [
    'require',
    'exports',
    'module',
    './elements',
    './node_list',
    'can-view-parser',
    'can-util/js/diff/diff',
    './view',
    'can-util/dom/events/events',
    'can-util/dom/frag/frag',
    'can-util/js/make-array/make-array',
    'can-util/js/each/each',
    'can-compute',
    'can-util/dom/attr/attr',
    'can-util/dom/data/data',
    'can-util/dom/mutate/mutate',
    'can-event/batch/batch',
    'can-util/dom/events/removed/removed'
], function (require, exports, module) {
    var elements = require('./elements');
    var nodeLists = require('./node_list');
    var parser = require('can-view-parser');
    var diff = require('can-util/js/diff/diff');
    var view = require('./view');
    var domEvent = require('can-util/dom/events/events');
    var canFrag = require('can-util/dom/frag/frag');
    var makeArray = require('can-util/js/make-array/make-array');
    var each = require('can-util/js/each/each');
    var canCompute = require('can-compute');
    var domAttr = require('can-util/dom/attr/attr');
    var domData = require('can-util/dom/data/data');
    var domMutate = require('can-util/dom/mutate/mutate');
    var canBatch = require('can-event/batch/batch');
    require('can-util/dom/events/removed/removed');
    var newLine = /(\r|\n)+/g;
    var getValue = function (val) {
        var regexp = /^["'].*["']$/;
        val = val.replace(elements.attrReg, '').replace(newLine, '');
        return regexp.test(val) ? val.substr(1, val.length - 2) : val;
    };
    var setup = function (el, bind, unbind) {
            var data;
            var tornDown = false, teardown = function () {
                    if (!tornDown) {
                        tornDown = true;
                        unbind(data);
                        domEvent.removeEventListener.call(el, 'removed', teardown);
                    }
                    return true;
                };
            data = {
                teardownCheck: function (parent) {
                    return parent ? false : teardown();
                }
            };
            domEvent.addEventListener.call(el, 'removed', teardown);
            bind(data);
            return data;
        }, getChildNodes = function (node) {
            var childNodes = node.childNodes;
            if ('length' in childNodes) {
                return childNodes;
            } else {
                var cur = node.firstChild;
                var nodes = [];
                while (cur) {
                    nodes.push(cur);
                    cur = cur.nextSibling;
                }
                return nodes;
            }
        }, listen = function (el, compute, change) {
            return setup(el, function () {
                compute.computeInstance.bind('change', change);
            }, function (data) {
                compute.computeInstance.unbind('change', change);
                if (data.nodeList) {
                    nodeLists.unregister(data.nodeList);
                }
            });
        }, getAttributeParts = function (newVal) {
            var attrs = {}, attr;
            parser.parseAttrs(newVal, {
                attrStart: function (name) {
                    attrs[name] = '';
                    attr = name;
                },
                attrValue: function (value) {
                    attrs[attr] += value;
                },
                attrEnd: function () {
                }
            });
            return attrs;
        }, splice = [].splice, isNode = function (obj) {
            return obj && obj.nodeType;
        }, addTextNodeIfNoChildren = function (frag) {
            if (!frag.firstChild) {
                frag.appendChild(frag.ownerDocument.createTextNode(''));
            }
        }, getLiveFragment = function (itemHTML) {
            var gotText = typeof itemHTML === 'string', itemFrag = canFrag(itemHTML);
            return gotText ? view.hookup(itemFrag) : itemFrag;
        }, renderAndAddToNodeLists = function (newNodeLists, parentNodeList, render, context, args) {
            var itemNodeList = [];
            if (parentNodeList) {
                nodeLists.register(itemNodeList, null, true, true);
                itemNodeList.parentList = parentNodeList;
                itemNodeList.expression = '#each SUBEXPRESSION';
            }
            var itemHTML = render.apply(context, args.concat([itemNodeList])), itemFrag = getLiveFragment(itemHTML);
            var childNodes = makeArray(getChildNodes(itemFrag));
            if (parentNodeList) {
                nodeLists.update(itemNodeList, childNodes);
                newNodeLists.push(itemNodeList);
            } else {
                newNodeLists.push(nodeLists.register(childNodes));
            }
            return itemFrag;
        }, removeFromNodeList = function (masterNodeList, index, length) {
            var removedMappings = masterNodeList.splice(index + 1, length), itemsToRemove = [];
            each(removedMappings, function (nodeList) {
                var nodesToRemove = nodeLists.unregister(nodeList);
                [].push.apply(itemsToRemove, nodesToRemove);
            });
            return itemsToRemove;
        }, addFalseyIfEmpty = function (list, falseyRender, masterNodeList, nodeList) {
            if (falseyRender && list.length === 0) {
                var falseyNodeLists = [];
                var falseyFrag = renderAndAddToNodeLists(falseyNodeLists, nodeList, falseyRender, list, [list]);
                elements.after([masterNodeList[0]], falseyFrag);
                masterNodeList.push(falseyNodeLists[0]);
            }
        }, childMutationCallbacks = {};
    var live = {
        registerChildMutationCallback: function (tag, callback) {
            if (callback) {
                childMutationCallbacks[tag] = callback;
            } else {
                return childMutationCallbacks[tag];
            }
        },
        callChildMutationCallback: function (el) {
            var callback = el && childMutationCallbacks[el.nodeName.toLowerCase()];
            if (callback) {
                callback(el);
            }
        },
        list: function (el, compute, render, context, parentNode, nodeList, falseyRender) {
            var remove, text, list, data;
            var masterNodeList = nodeList || [el], indexMap = [], afterPreviousEvents = false, isTornDown = false, add = function (ev, items, index) {
                    if (!afterPreviousEvents) {
                        return;
                    }
                    var frag = text.ownerDocument.createDocumentFragment(), newNodeLists = [], newIndicies = [];
                    each(items, function (item, key) {
                        var itemIndex = canCompute(key + index), itemFrag = renderAndAddToNodeLists(newNodeLists, nodeList, render, context, [
                                item,
                                itemIndex
                            ]);
                        frag.appendChild(itemFrag);
                        newIndicies.push(itemIndex);
                    });
                    var masterListIndex = index + 1;
                    if (!indexMap.length) {
                        var falseyItemsToRemove = removeFromNodeList(masterNodeList, 0, masterNodeList.length - 1);
                        nodeLists.remove(falseyItemsToRemove);
                    }
                    if (!masterNodeList[masterListIndex]) {
                        elements.after(masterListIndex === 1 ? [text] : [nodeLists.last(masterNodeList[masterListIndex - 1])], frag);
                    } else {
                        var el = nodeLists.first(masterNodeList[masterListIndex]);
                        domMutate.insertBefore.call(el.parentNode, frag, el);
                    }
                    splice.apply(masterNodeList, [
                        masterListIndex,
                        0
                    ].concat(newNodeLists));
                    splice.apply(indexMap, [
                        index,
                        0
                    ].concat(newIndicies));
                    for (var i = index + newIndicies.length, len = indexMap.length; i < len; i++) {
                        indexMap[i](i);
                    }
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                }, set = function (ev, newVal, index) {
                    remove({}, { length: 1 }, index, true);
                    add({}, [newVal], index);
                };
            remove = function (ev, items, index, duringTeardown, fullTeardown) {
                if (!afterPreviousEvents) {
                    return;
                }
                if (!duringTeardown && data.teardownCheck(text.parentNode)) {
                    return;
                }
                if (index < 0) {
                    index = indexMap.length + index;
                }
                var itemsToRemove = removeFromNodeList(masterNodeList, index, items.length);
                indexMap.splice(index, items.length);
                for (var i = index, len = indexMap.length; i < len; i++) {
                    indexMap[i](i);
                }
                if (!fullTeardown) {
                    addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    nodeLists.remove(itemsToRemove);
                    if (ev.callChildMutationCallback !== false) {
                        live.callChildMutationCallback(text.parentNode);
                    }
                } else {
                    nodeLists.unregister(masterNodeList);
                }
            };
            var move = function (ev, item, newIndex, currentIndex) {
                if (!afterPreviousEvents) {
                    return;
                }
                newIndex = newIndex + 1;
                currentIndex = currentIndex + 1;
                var referenceNodeList = masterNodeList[newIndex];
                var movedElements = canFrag(nodeLists.flatten(masterNodeList[currentIndex]));
                var referenceElement;
                if (currentIndex < newIndex) {
                    referenceElement = nodeLists.last(referenceNodeList).nextSibling;
                } else {
                    referenceElement = nodeLists.first(referenceNodeList);
                }
                var parentNode = masterNodeList[0].parentNode;
                parentNode.insertBefore(movedElements, referenceElement);
                var temp = masterNodeList[currentIndex];
                [].splice.apply(masterNodeList, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(masterNodeList, [
                    newIndex,
                    0,
                    temp
                ]);
                newIndex = newIndex - 1;
                currentIndex = currentIndex - 1;
                var indexCompute = indexMap[currentIndex];
                [].splice.apply(indexMap, [
                    currentIndex,
                    1
                ]);
                [].splice.apply(indexMap, [
                    newIndex,
                    0,
                    indexCompute
                ]);
                var i = Math.min(currentIndex, newIndex);
                var len = indexMap.length;
                for (i, len; i < len; i++) {
                    indexMap[i](i);
                }
                if (ev.callChildMutationCallback !== false) {
                    live.callChildMutationCallback(text.parentNode);
                }
            };
            text = el.ownerDocument.createTextNode('');
            var teardownList = function (fullTeardown) {
                    if (list && list.unbind) {
                        list.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                    }
                    remove({ callChildMutationCallback: !!fullTeardown }, { length: masterNodeList.length - 1 }, 0, true, fullTeardown);
                }, updateList = function (ev, newList, oldList) {
                    if (isTornDown) {
                        return;
                    }
                    afterPreviousEvents = true;
                    if (newList && oldList) {
                        list = newList || [];
                        var patches = diff(oldList, newList);
                        if (oldList.unbind) {
                            oldList.unbind('add', add).unbind('set', set).unbind('remove', remove).unbind('move', move);
                        }
                        for (var i = 0, patchLen = patches.length; i < patchLen; i++) {
                            var patch = patches[i];
                            if (patch.deleteCount) {
                                remove({ callChildMutationCallback: false }, { length: patch.deleteCount }, patch.index, true);
                            }
                            if (patch.insert.length) {
                                add({ callChildMutationCallback: false }, patch.insert, patch.index);
                            }
                        }
                    } else {
                        if (oldList) {
                            teardownList();
                        }
                        list = newList || [];
                        add({ callChildMutationCallback: false }, list, 0);
                        addFalseyIfEmpty(list, falseyRender, masterNodeList, nodeList);
                    }
                    live.callChildMutationCallback(text.parentNode);
                    afterPreviousEvents = false;
                    if (list.bind) {
                        list.bind('add', add).bind('set', set).bind('remove', remove).bind('move', move);
                    }
                    canBatch.afterPreviousEvents(function () {
                        afterPreviousEvents = true;
                    });
                };
            parentNode = elements.getParentNode(el, parentNode);
            data = setup(parentNode, function () {
                if (typeof compute === 'function') {
                    compute.bind('change', updateList);
                }
            }, function () {
                if (typeof compute === 'function') {
                    compute.unbind('change', updateList);
                }
                teardownList(true);
            });
            if (!nodeList) {
                live.replace(masterNodeList, text, data.teardownCheck);
            } else {
                elements.replace(masterNodeList, text);
                nodeLists.update(masterNodeList, [text]);
                nodeList.unregistered = function () {
                    data.teardownCheck();
                    isTornDown = true;
                };
            }
            updateList({}, typeof compute === 'function' ? compute() : compute);
        },
        html: function (el, compute, parentNode, nodeList) {
            var data, nodes, makeAndPut;
            parentNode = elements.getParentNode(el, parentNode);
            data = listen(parentNode, compute, function (ev, newVal) {
                var attached = nodeLists.first(nodes).parentNode;
                if (attached) {
                    makeAndPut(newVal);
                }
                var pn = nodeLists.first(nodes).parentNode;
                data.teardownCheck(pn);
                live.callChildMutationCallback(pn);
            });
            nodes = nodeList || [el];
            makeAndPut = function (val) {
                var isFunction = typeof val === 'function', aNode = isNode(val), frag = canFrag(isFunction ? '' : val), oldNodes = makeArray(nodes);
                addTextNodeIfNoChildren(frag);
                if (!aNode && !isFunction) {
                    frag = view.hookup(frag, parentNode);
                }
                oldNodes = nodeLists.update(nodes, getChildNodes(frag));
                if (isFunction) {
                    val(frag.firstChild);
                }
                elements.replace(oldNodes, frag);
            };
            data.nodeList = nodes;
            if (!nodeList) {
                nodeLists.register(nodes, data.teardownCheck);
            } else {
                nodeList.unregistered = data.teardownCheck;
            }
            makeAndPut(compute());
        },
        replace: function (nodes, val, teardown) {
            var oldNodes = nodes.slice(0), frag = canFrag(val);
            nodeLists.register(nodes, teardown);
            if (typeof val === 'string') {
                frag = view.hookup(frag, nodes[0].parentNode);
            }
            nodeLists.update(nodes, getChildNodes(frag));
            elements.replace(oldNodes, frag);
            return nodes;
        },
        text: function (el, compute, parentNode, nodeList) {
            var parent = elements.getParentNode(el, parentNode), node;
            var data = listen(parent, compute, function (ev, newVal) {
                if (typeof node.nodeValue !== 'unknown') {
                    node.nodeValue = view.toStr(newVal);
                }
                data.teardownCheck(node.parentNode);
            });
            node = el.ownerDocument.createTextNode(view.toStr(compute()));
            if (nodeList) {
                nodeList.unregistered = data.teardownCheck;
                data.nodeList = nodeList;
                nodeLists.update(nodeList, [node]);
                elements.replace([el], node);
            } else {
                data.nodeList = live.replace([el], node, data.teardownCheck);
            }
        },
        setAttributes: function (el, newVal) {
            var attrs = getAttributeParts(newVal);
            for (var name in attrs) {
                domAttr.set(el, name, attrs[name]);
            }
        },
        attributes: function (el, compute, currentValue) {
            var oldAttrs = {};
            var setAttrs = function (newVal) {
                var newAttrs = getAttributeParts(newVal), name;
                for (name in newAttrs) {
                    var newValue = newAttrs[name], oldValue = oldAttrs[name];
                    if (newValue !== oldValue) {
                        domAttr.set(el, name, newValue);
                    }
                    delete oldAttrs[name];
                }
                for (name in oldAttrs) {
                    domAttr.remove(el, name);
                }
                oldAttrs = newAttrs;
            };
            listen(el, compute, function (ev, newVal) {
                setAttrs(newVal);
            });
            if (arguments.length >= 3) {
                oldAttrs = getAttributeParts(currentValue);
            } else {
                setAttrs(compute());
            }
        },
        attributePlaceholder: '__!!__',
        attributeReplace: /__!!__/g,
        attribute: function (el, attributeName, compute) {
            var hook;
            listen(el, compute, function () {
                domAttr.set(el, attributeName, hook.render());
            });
            var hooks;
            hooks = domData.get.call(el, 'hooks');
            if (!hooks) {
                domData.set.call(el, 'hooks', hooks = {});
            }
            var attr = String(domAttr.get(el, attributeName)), parts = attr.split(live.attributePlaceholder), goodParts = [];
            goodParts.push(parts.shift(), parts.join(live.attributePlaceholder));
            if (hooks[attributeName]) {
                hooks[attributeName].computes.push(compute);
            } else {
                hooks[attributeName] = {
                    render: function () {
                        var i = 0, newAttr = attr ? attr.replace(live.attributeReplace, function () {
                                return view.contentText(hook.computes[i++]());
                            }) : view.contentText(hook.computes[i++]());
                        return newAttr;
                    },
                    computes: [compute],
                    batchNum: undefined
                };
            }
            hook = hooks[attributeName];
            goodParts.splice(1, 0, compute());
            domAttr.set(el, attributeName, goodParts.join(''));
        },
        specialAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                domAttr.set(el, attributeName, getValue(newVal));
            });
            domAttr.set(el, attributeName, getValue(compute()));
        },
        simpleAttribute: function (el, attributeName, compute) {
            listen(el, compute, function (ev, newVal) {
                elements.setAttr(el, attributeName, newVal);
            });
            elements.setAttr(el, attributeName, compute());
        }
    };
    live.attr = live.simpleAttribute;
    live.attrs = live.attributes;
    live.getAttributeParts = getAttributeParts;
    module.exports = live;
});
/*can-legacy-view-helpers@1.0.0#src/render*/
define('can-legacy-view-helpers@1.0.0#src/render', [
    'require',
    'exports',
    'module',
    './view',
    './elements',
    'can-util/js/string/string',
    'can-util/js/deep-assign/deep-assign',
    'can-compute',
    './live'
], function (require, exports, module) {
    var view = require('./view');
    var elements = require('./elements');
    var string = require('can-util/js/string/string');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var canCompute = require('can-compute');
    var live = require('./live');
    var pendingHookups = [], tagChildren = function (tagName) {
            var newTag = elements.tagMap[tagName] || 'span';
            if (newTag === 'span') {
                return '@@!!@@';
            }
            return '<' + newTag + '>' + tagChildren(newTag) + '</' + newTag + '>';
        }, contentText = function (input, tag) {
            if (typeof input === 'string') {
                return input;
            }
            if (!input && input !== 0) {
                return '';
            }
            var hook = input.hookup && function (el, id) {
                input.hookup.call(input, el, id);
            } || typeof input === 'function' && input;
            if (hook) {
                if (tag) {
                    return '<' + tag + ' ' + view.hook(hook) + '></' + tag + '>';
                } else {
                    pendingHookups.push(hook);
                }
                return '';
            }
            return '' + input;
        }, contentEscape = function (txt, tag) {
            return typeof txt === 'string' || typeof txt === 'number' ? string.esc(txt) : contentText(txt, tag);
        }, withinTemplatedSectionWithinAnElement = false, emptyHandler = function () {
        };
    var lastHookups;
    deepAssign(view, {
        contentText: contentText,
        live: live,
        setupLists: function () {
            var old = view.lists, data;
            view.lists = function (list, renderer) {
                data = {
                    list: list,
                    renderer: renderer
                };
                return Math.random();
            };
            return function () {
                view.lists = old;
                return data;
            };
        },
        getHooks: function () {
            var hooks = pendingHookups.slice(0);
            lastHookups = hooks;
            pendingHookups = [];
            return hooks;
        },
        onlytxt: function (self, func) {
            return contentEscape(func.call(self));
        },
        txt: function (escape, tagName, status, self, func) {
            var tag = elements.tagMap[tagName] || 'span', setupLiveBinding = false, value, listData, compute, unbind = emptyHandler, attributeName;
            if (withinTemplatedSectionWithinAnElement) {
                value = func.call(self);
            } else {
                if (typeof status === 'string' || status === 1) {
                    withinTemplatedSectionWithinAnElement = true;
                }
                var listTeardown = view.setupLists();
                unbind = function () {
                    compute.unbind('change', emptyHandler);
                };
                compute = canCompute(func, self, false);
                compute.bind('change', emptyHandler);
                listData = listTeardown();
                value = compute();
                withinTemplatedSectionWithinAnElement = false;
                setupLiveBinding = compute.computeInstance.hasDependencies;
            }
            if (listData) {
                unbind();
                return '<' + tag + view.hook(function (el, parentNode) {
                    live.list(el, listData.list, listData.renderer, self, parentNode);
                }) + '></' + tag + '>';
            }
            if (!setupLiveBinding || typeof value === 'function') {
                unbind();
                return (withinTemplatedSectionWithinAnElement || escape === 2 || !escape ? contentText : contentEscape)(value, status === 0 && tag);
            }
            var contentProp = elements.tagToContentPropMap[tagName];
            if (status === 0 && !contentProp) {
                var selfClosing = !!elements.selfClosingTags[tag];
                return '<' + tag + view.hook(escape && typeof value !== 'object' ? function (el, parentNode) {
                    live.text(el, compute, parentNode);
                    unbind();
                } : function (el, parentNode) {
                    live.html(el, compute, parentNode);
                    unbind();
                }) + (selfClosing ? '/>' : '>' + tagChildren(tag) + '</' + tag + '>');
            } else if (status === 1) {
                pendingHookups.push(function (el) {
                    live.attributes(el, compute, compute());
                    unbind();
                });
                return compute();
            } else if (escape === 2) {
                attributeName = status;
                pendingHookups.push(function (el) {
                    live.specialAttribute(el, attributeName, compute);
                    unbind();
                });
                return compute();
            } else {
                attributeName = status === 0 ? contentProp : status;
                (status === 0 ? lastHookups : pendingHookups).push(function (el) {
                    live.attribute(el, attributeName, compute);
                    unbind();
                });
                return live.attributePlaceholder;
            }
        }
    });
    module.exports = view;
});
/*can-legacy-view-helpers@1.0.0#src/scanner*/
define('can-legacy-view-helpers@1.0.0#src/scanner', [
    'require',
    'exports',
    'module',
    './elements',
    'can-view-callbacks',
    'can-util/js/deep-assign/deep-assign',
    './view',
    'can-util/js/each/each'
], function (require, exports, module) {
    var elements = require('./elements');
    var viewCallbacks = require('can-view-callbacks');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var view = require('./view');
    var each = require('can-util/js/each/each');
    var newLine = /(\r|\n)+/g, notEndTag = /\//, clean = function (content) {
            return content.split('\\').join('\\\\').split('\n').join('\\n').split('"').join('\\"').split('\t').join('\\t');
        }, getTag = function (tagName, tokens, i) {
            if (tagName) {
                return tagName;
            } else {
                while (i < tokens.length) {
                    if (tokens[i] === '<' && !notEndTag.test(tokens[i + 1])) {
                        return elements.reverseTagMap[tokens[i + 1]] || 'span';
                    }
                    i++;
                }
            }
            return '';
        }, bracketNum = function (content) {
            return --content.split('{').length - --content.split('}').length;
        }, myEval = function (script) {
            eval(script);
        }, attrReg = /([^\s]+)[\s]*=[\s]*$/, startTxt = 'var ___v1ew = [];', finishTxt = 'return ___v1ew.join(\'\')', put_cmd = '___v1ew.push(\n', insert_cmd = put_cmd, htmlTag = null, quote = null, beforeQuote = null, rescan = null, getAttrName = function () {
            var matches = beforeQuote.match(attrReg);
            return matches && matches[1];
        }, _status = function () {
            return quote ? '\'' + getAttrName() + '\'' : htmlTag ? 1 : 0;
        }, _top = function (stack) {
            return stack[stack.length - 1];
        }, Scanner;
    var Scanner = function (options) {
        deepAssign(this, {
            text: {},
            tokens: []
        }, options);
        this.text.options = this.text.options || '';
        this.tokenReg = [];
        this.tokenSimple = {
            '<': '<',
            '>': '>',
            '"': '"',
            '\'': '\''
        };
        this.tokenComplex = [];
        this.tokenMap = {};
        for (var i = 0, token; token = this.tokens[i]; i++) {
            if (token[2]) {
                this.tokenReg.push(token[2]);
                this.tokenComplex.push({
                    abbr: token[1],
                    re: new RegExp(token[2]),
                    rescan: token[3]
                });
            } else {
                this.tokenReg.push(token[1]);
                this.tokenSimple[token[1]] = token[0];
            }
            this.tokenMap[token[0]] = token[1];
        }
        this.tokenReg = new RegExp('(' + this.tokenReg.slice(0).concat([
            '<',
            '>',
            '"',
            '\''
        ]).join('|') + ')', 'g');
    };
    Scanner.prototype = {
        helpers: [],
        scan: function (source, name) {
            var tokens = [], last = 0, simple = this.tokenSimple, complex = this.tokenComplex;
            source = source.replace(newLine, '\n');
            if (this.transform) {
                source = this.transform(source);
            }
            source.replace(this.tokenReg, function (whole, part) {
                var offset = arguments[arguments.length - 2];
                if (offset > last) {
                    tokens.push(source.substring(last, offset));
                }
                if (simple[whole]) {
                    tokens.push(whole);
                } else {
                    for (var i = 0, token; token = complex[i]; i++) {
                        if (token.re.test(whole)) {
                            tokens.push(token.abbr);
                            if (token.rescan) {
                                tokens.push(token.rescan(part));
                            }
                            break;
                        }
                    }
                }
                last = offset + part.length;
            });
            if (last < source.length) {
                tokens.push(source.substr(last));
            }
            var content = '', buff = [startTxt + (this.text.start || '')], put = function (content, bonus) {
                    buff.push(put_cmd, '"', clean(content), '"' + (bonus || '') + ');');
                }, endStack = [], lastToken, startTag = null, magicInTag = false, specialStates = {
                    attributeHookups: [],
                    tagHookups: [],
                    lastTagHookup: ''
                }, popTagHookup = function () {
                    specialStates.lastTagHookup = specialStates.tagHookups.pop() + specialStates.tagHookups.length;
                }, tagName = '', tagNames = [], popTagName = false, bracketCount, specialAttribute = false, i = 0, token, tmap = this.tokenMap, attrName;
            htmlTag = quote = beforeQuote = null;
            for (; (token = tokens[i++]) !== undefined;) {
                if (startTag === null) {
                    switch (token) {
                    case tmap.left:
                    case tmap.escapeLeft:
                    case tmap.returnLeft:
                        magicInTag = htmlTag && 1;
                    case tmap.commentLeft:
                        startTag = token;
                        if (content.length) {
                            put(content);
                        }
                        content = '';
                        break;
                    case tmap.escapeFull:
                        magicInTag = htmlTag && 1;
                        rescan = 1;
                        startTag = tmap.escapeLeft;
                        if (content.length) {
                            put(content);
                        }
                        rescan = tokens[i++];
                        content = rescan.content || rescan;
                        if (rescan.before) {
                            put(rescan.before);
                        }
                        tokens.splice(i, 0, tmap.right);
                        break;
                    case tmap.commentFull:
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    case '<':
                        if (tokens[i].indexOf('!--') !== 0) {
                            htmlTag = 1;
                            magicInTag = 0;
                        }
                        content += token;
                        break;
                    case '>':
                        htmlTag = 0;
                        var emptyElement = content.substr(content.length - 1) === '/' || content.substr(content.length - 2) === '--', attrs = '';
                        if (specialStates.attributeHookups.length) {
                            attrs = 'attrs: [\'' + specialStates.attributeHookups.join('\',\'') + '\'], ';
                            specialStates.attributeHookups = [];
                        }
                        if (tagName + specialStates.tagHookups.length !== specialStates.lastTagHookup && tagName === _top(specialStates.tagHookups)) {
                            if (emptyElement) {
                                content = content.substr(0, content.length - 1);
                            }
                            buff.push(put_cmd, '"', clean(content), '"', ',CAN_LEGACY_HELPERS.view.pending({tagName:\'' + tagName + '\',' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options);
                            if (emptyElement) {
                                buff.push('}));');
                                content = '/>';
                                popTagHookup();
                            } else if (tokens[i] === '<' && tokens[i + 1] === '/' + tagName) {
                                buff.push('}));');
                                content = token;
                                popTagHookup();
                            } else {
                                buff.push(',subtemplate: function(' + this.text.argNames + '){\n' + startTxt + (this.text.start || ''));
                                content = '';
                            }
                        } else if (magicInTag || !popTagName && elements.tagToContentPropMap[tagNames[tagNames.length - 1]] || attrs) {
                            var pendingPart = ',CAN_LEGACY_HELPERS.view.pending({' + attrs + 'scope: ' + (this.text.scope || 'this') + this.text.options + '}),"';
                            if (emptyElement) {
                                put(content.substr(0, content.length - 1), pendingPart + '/>"');
                            } else {
                                put(content, pendingPart + '>"');
                            }
                            content = '';
                            magicInTag = 0;
                        } else {
                            content += token;
                        }
                        if (emptyElement || popTagName) {
                            tagNames.pop();
                            tagName = tagNames[tagNames.length - 1];
                            popTagName = false;
                        }
                        specialStates.attributeHookups = [];
                        break;
                    case '\'':
                    case '"':
                        if (htmlTag) {
                            if (quote && quote === token) {
                                quote = null;
                                var attr = getAttrName();
                                if (viewCallbacks.attr(attr)) {
                                    specialStates.attributeHookups.push(attr);
                                }
                                if (specialAttribute) {
                                    content += token;
                                    put(content);
                                    buff.push(finishTxt, '}));\n');
                                    content = '';
                                    specialAttribute = false;
                                    break;
                                }
                            } else if (quote === null) {
                                quote = token;
                                beforeQuote = lastToken;
                                attrName = getAttrName();
                                if (tagName === 'img' && attrName === 'src' || attrName === 'style') {
                                    put(content.replace(attrReg, ''));
                                    content = '';
                                    specialAttribute = true;
                                    buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(2,\'' + getTag(tagName, tokens, i) + '\',' + _status() + ',this,function(){', startTxt);
                                    put(attrName + '=' + token);
                                    break;
                                }
                            }
                        }
                    default:
                        if (lastToken === '<') {
                            tagName = token.substr(0, 3) === '!--' ? '!--' : token.split(/\s/)[0];
                            var isClosingTag = false, cleanedTagName;
                            if (tagName.indexOf('/') === 0) {
                                isClosingTag = true;
                                cleanedTagName = tagName.substr(1);
                            }
                            if (isClosingTag) {
                                if (_top(tagNames) === cleanedTagName) {
                                    tagName = cleanedTagName;
                                    popTagName = true;
                                }
                                if (_top(specialStates.tagHookups) === cleanedTagName) {
                                    put(content.substr(0, content.length - 1));
                                    buff.push(finishTxt + '}}) );');
                                    content = '><';
                                    popTagHookup();
                                }
                            } else {
                                if (tagName.lastIndexOf('/') === tagName.length - 1) {
                                    tagName = tagName.substr(0, tagName.length - 1);
                                }
                                if (tagName !== '!--' && viewCallbacks.tag(tagName)) {
                                    if (tagName === 'content' && elements.tagMap[_top(tagNames)]) {
                                        token = token.replace('content', elements.tagMap[_top(tagNames)]);
                                    }
                                    specialStates.tagHookups.push(tagName);
                                }
                                tagNames.push(tagName);
                            }
                        }
                        content += token;
                        break;
                    }
                } else {
                    switch (token) {
                    case tmap.right:
                    case tmap.returnRight:
                        switch (startTag) {
                        case tmap.left:
                            bracketCount = bracketNum(content);
                            if (bracketCount === 1) {
                                buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(0,\'' + getTag(tagName, tokens, i) + '\',' + _status() + ',this,function(){', startTxt, content);
                                endStack.push({
                                    before: '',
                                    after: finishTxt + '}));\n'
                                });
                            } else {
                                last = endStack.length && bracketCount === -1 ? endStack.pop() : { after: ';' };
                                if (last.before) {
                                    buff.push(last.before);
                                }
                                buff.push(content, ';', last.after);
                            }
                            break;
                        case tmap.escapeLeft:
                        case tmap.returnLeft:
                            bracketCount = bracketNum(content);
                            if (bracketCount) {
                                endStack.push({
                                    before: finishTxt,
                                    after: '}));\n'
                                });
                            }
                            var escaped = startTag === tmap.escapeLeft ? 1 : 0, commands = {
                                    insert: insert_cmd,
                                    tagName: getTag(tagName, tokens, i),
                                    status: _status(),
                                    specialAttribute: specialAttribute
                                };
                            for (var ii = 0; ii < this.helpers.length; ii++) {
                                var helper = this.helpers[ii];
                                if (helper.name.test(content)) {
                                    content = helper.fn(content, commands);
                                    if (helper.name.source === /^>[\s]*\w*/.source) {
                                        escaped = 0;
                                    }
                                    break;
                                }
                            }
                            if (typeof content === 'object') {
                                if (content.startTxt && content.end && specialAttribute) {
                                    buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.toStr( ', content.content, '() ) );');
                                } else {
                                    if (content.startTxt) {
                                        buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(\n' + (typeof _status() === 'string' || (content.escaped != null ? content.escaped : escaped)) + ',\n\'' + tagName + '\',\n' + _status() + ',\nthis,\n');
                                    } else if (content.startOnlyTxt) {
                                        buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.onlytxt(this,\n');
                                    }
                                    buff.push(content.content);
                                    if (content.end) {
                                        buff.push('));');
                                    }
                                }
                            } else if (specialAttribute) {
                                buff.push(insert_cmd, content, ');');
                            } else {
                                buff.push(insert_cmd, 'CAN_LEGACY_HELPERS.view.txt(\n' + (typeof _status() === 'string' || escaped) + ',\n\'' + tagName + '\',\n' + _status() + ',\nthis,\nfunction(){ ' + (this.text.escape || '') + 'return ', content, bracketCount ? startTxt : '}));\n');
                            }
                            if (rescan && rescan.after && rescan.after.length) {
                                put(rescan.after.length);
                                rescan = null;
                            }
                            break;
                        }
                        startTag = null;
                        content = '';
                        break;
                    case tmap.templateLeft:
                        content += tmap.left;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
                lastToken = token;
            }
            if (content.length) {
                put(content);
            }
            buff.push(';');
            var template = buff.join(''), out = { out: (this.text.outStart || '') + template + ' ' + finishTxt + (this.text.outEnd || '') };
            myEval.call(out, 'this.fn = (function(' + this.text.argNames + '){' + out.out + '});\r\n//# sourceURL=' + name + '.js');
            return out;
        }
    };
    view.pending = function (viewData) {
        var hooks = view.getHooks();
        return view.hook(function (el) {
            each(hooks, function (fn) {
                fn(el);
            });
            viewData.templateType = 'legacy';
            if (viewData.tagName) {
                viewCallbacks.tagHandler(el, viewData.tagName, viewData);
            }
            each(viewData && viewData.attrs || [], function (attributeName) {
                viewData.attributeName = attributeName;
                var callback = viewCallbacks.attr(attributeName);
                if (callback) {
                    callback(el, viewData);
                }
            });
        });
    };
    view.Scanner = Scanner;
    module.exports = Scanner;
});
/*can-legacy-view-helpers@1.0.0#can-legacy-view-helpers*/
define('can-legacy-view-helpers@1.0.0#can-legacy-view-helpers', [
    'require',
    'exports',
    'module',
    './src/render',
    './src/scanner',
    './src/view',
    './src/elements',
    './src/live',
    './src/node_list'
], function (require, exports, module) {
    var render = require('./src/render');
    var scanner = require('./src/scanner');
    var view = require('./src/view');
    var elements = require('./src/elements');
    var live = require('./src/live');
    var nodeLists = require('./src/node_list');
    var legacyHelpers = {
        render: render,
        Scanner: scanner,
        view: view,
        elements: elements,
        live: live,
        nodeLists: nodeLists
    };
    if (typeof window !== 'undefined') {
        window.CAN_LEGACY_HELPERS = legacyHelpers;
    }
    module.exports = legacyHelpers;
});
/*can-ejs@3.2.1#can-ejs*/
define('can-ejs@3.2.1#can-ejs', [
    'require',
    'exports',
    'module',
    'can-legacy-view-helpers',
    'can-util/js/assign/assign',
    'can-namespace',
    'can-util/js/each/each',
    'can-reflect',
    'can-stache-key',
    'can-globals/document/document'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var legacyHelpers = require('can-legacy-view-helpers');
        var extend = require('can-util/js/assign/assign');
        var namespace = require('can-namespace');
        var each = require('can-util/js/each/each');
        var canReflect = require('can-reflect');
        var observationReader = require('can-stache-key');
        var DOCUMENT = require('can-globals/document/document');
        var view = legacyHelpers.view;
        var templateId = 0;
        var EJS = function (options) {
            if (!this || this.constructor !== EJS) {
                var ejs = new EJS(options);
                var renderer = function (data, helpers) {
                    return legacyHelpers.view.frag(ejs.render(data, helpers));
                };
                renderer.renderType = 'fragment';
                renderer.renderAsString = function (data, helpers) {
                    return ejs.render(data, helpers);
                };
                renderer.renderAsString.renderType = 'string';
                return renderer;
            }
            if (typeof options === 'function') {
                this.template = { fn: options };
                return;
            }
            if (typeof options === 'string') {
                options = {
                    text: options,
                    name: '' + ++templateId
                };
            }
            extend(this, options);
            this.template = this.scanner.scan(this.text, this.name);
        };
        namespace.EJS = EJS;
        EJS.prototype.render = function (object, extraHelpers) {
            object = object || {};
            return this.template.fn.call(object, object, new EJS.Helpers(object, extraHelpers || {}));
        };
        extend(EJS.prototype, {
            scanner: new legacyHelpers.Scanner({
                text: {
                    outStart: 'with(_VIEW) { with (_CONTEXT) {',
                    outEnd: '}}',
                    argNames: '_CONTEXT,_VIEW',
                    context: 'this'
                },
                tokens: [
                    [
                        'templateLeft',
                        '<%%'
                    ],
                    [
                        'templateRight',
                        '%>'
                    ],
                    [
                        'returnLeft',
                        '<%=='
                    ],
                    [
                        'escapeLeft',
                        '<%='
                    ],
                    [
                        'commentLeft',
                        '<%#'
                    ],
                    [
                        'left',
                        '<%'
                    ],
                    [
                        'right',
                        '%>'
                    ],
                    [
                        'returnRight',
                        '%>'
                    ]
                ],
                helpers: [{
                        name: /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
                        fn: function (content) {
                            var quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/, parts = content.match(quickFunc);
                            return '(function(__){var ' + parts[1] + '=__;' + parts[2] + '}).bind(this);';
                        }
                    }],
                transform: function (source) {
                    return source.replace(/<%([\s\S]+?)%>/gm, function (whole, part) {
                        var brackets = [], foundBracketPair, i;
                        part.replace(/[{}]/gm, function (bracket, offset) {
                            brackets.push([
                                bracket,
                                offset
                            ]);
                        });
                        do {
                            foundBracketPair = false;
                            for (i = brackets.length - 2; i >= 0; i--) {
                                if (brackets[i][0] === '{' && brackets[i + 1][0] === '}') {
                                    brackets.splice(i, 2);
                                    foundBracketPair = true;
                                    break;
                                }
                            }
                        } while (foundBracketPair);
                        if (brackets.length >= 2) {
                            var result = ['<%'], bracket, last = 0;
                            for (i = 0; bracket = brackets[i]; i++) {
                                result.push(part.substring(last, last = bracket[1]));
                                if (bracket[0] === '{' && i < brackets.length - 1 || bracket[0] === '}' && i > 0) {
                                    result.push(bracket[0] === '{' ? '{ %><% ' : ' %><% }');
                                } else {
                                    result.push(bracket[0]);
                                }
                                ++last;
                            }
                            result.push(part.substring(last), '%>');
                            return result.join('');
                        } else {
                            return '<%' + part + '%>';
                        }
                    });
                }
            })
        });
        EJS.Helpers = function (data, extras) {
            this._data = data;
            this._extras = extras;
            this.can = namespace;
            extend(this, extras);
        };
        EJS.Helpers.prototype = {
            list: function (list, cb) {
                if (canReflect.isObservableLike(list) && canReflect.isListLike(list)) {
                    observationReader.get(list, 'length');
                }
                each(list, function (item, i) {
                    cb(item, i, list);
                });
            },
            each: function (list, cb) {
                if (Array.isArray(list)) {
                    this.list(list, cb);
                } else {
                    legacyHelpers.view.lists(list, cb);
                }
            }
        };
        var templates = {};
        EJS.from = function (id) {
            if (!templates[id]) {
                var el = DOCUMENT().getElementById(id);
                templates[id] = EJS(el.innerHTML);
            }
            return templates[id];
        };
        view.register({
            suffix: 'ejs',
            script: function (id, src) {
                return 'can.EJS(function(_CONTEXT,_VIEW) { ' + new EJS({
                    text: src,
                    name: id
                }).template.out + ' })';
            },
            renderer: function (id, text) {
                return EJS({
                    text: text,
                    name: id
                });
            }
        });
        module.exports = EJS;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-ejs@3.2.1#test/can-ejs_test*/
define('can-ejs@3.2.1#test/can-ejs_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-ejs',
    'can-map',
    'can-legacy-view-helpers',
    'can-util/dom/data/data',
    'can-list',
    'can-namespace',
    'can-compute',
    'can-util/dom/mutate/mutate',
    'can-legacy-view-helpers/deferred'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var EJS = require('can-ejs');
        var CanMap = require('can-map');
        var legacyHelpers = require('can-legacy-view-helpers');
        var domData = require('can-util/dom/data/data');
        var CanList = require('can-list');
        var can = require('can-namespace');
        var canCompute = require('can-compute');
        var domMutate = require('can-util/dom/mutate/mutate');
        var Deferred = require('can-legacy-view-helpers/deferred');
        QUnit.module('can-ejs, rendering', {
            setup: function () {
                this.animals = [
                    'sloth',
                    'bear',
                    'monkey'
                ];
                if (!this.animals.each) {
                    this.animals.each = function (func) {
                        for (var i = 0; i < this.length; i++) {
                            func(this[i]);
                        }
                    };
                }
                this.squareBrackets = '<ul><% this.animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
                this.squareBracketsNoThis = '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
                this.angleBracketsNoThis = '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            }
        });
        var getAttr = function (el, attrName) {
            return attrName === 'class' ? el.className : el.getAttribute(attrName);
        };
        test('render with left bracket', function () {
            var compiled = new EJS({
                text: this.squareBrackets,
                type: '['
            }).render({ animals: this.animals });
            equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'renders with bracket');
        });
        test('render with with', function () {
            var compiled = new EJS({
                text: this.squareBracketsNoThis,
                type: '['
            }).render({ animals: this.animals });
            equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'renders bracket with no this');
        });
        test('default carrot', function () {
            var compiled = new EJS({ text: this.angleBracketsNoThis }).render({ animals: this.animals });
            equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
        });
        test('render with double angle', function () {
            var text = '<%% replace_me %>' + '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            var compiled = new EJS({ text: text }).render({ animals: this.animals });
            equal(compiled, '<% replace_me %><ul><li>sloth</li><li>bear</li><li>monkey</li></ul>', 'works');
        });
        test('comments', function () {
            var text = '<%# replace_me %>' + '<ul><% animals.each(function(animal){%>' + '<li><%= animal %></li>' + '<%});%></ul>';
            var compiled = new EJS({ text: text }).render({ animals: this.animals });
            equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
        });
        test('multi line', function () {
            var text = 'a \n b \n c', result = new EJS({ text: text }).render({});
            equal(result, text);
        });
        test('multi line elements', function () {
            var text = '<img\n class="<%=myClass%>" />', result = new EJS({ text: text }).render({ myClass: 'a' });
            ok(result.indexOf('<img\n class="a"') !== -1, 'Multi-line elements render correctly.');
            legacyHelpers.view.hookups = {};
        });
        test('escapedContent', function () {
            var text = '<span><%= tags %></span><label>&amp;</label><strong><%= number %></strong><input value=\'<%= quotes %>\'/>';
            var compiled = new EJS({ text: text }).render({
                tags: 'foo < bar < car > zar > poo',
                quotes: 'I use \'quote\' fingers "a lot"',
                number: 123
            });
            var div = document.createElement('div');
            div.innerHTML = compiled;
            equal(div.getElementsByTagName('span')[0].firstChild.nodeValue, 'foo < bar < car > zar > poo');
            equal(div.getElementsByTagName('strong')[0].firstChild.nodeValue, 123);
            equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"');
            equal(div.getElementsByTagName('label')[0].innerHTML, '&amp;');
            legacyHelpers.view.hookups = {};
        });
        test('unescapedContent', function () {
            var text = '<span><%== tags %></span><div><%= tags %></div><input value=\'<%== quotes %>\'/>';
            var compiled = new EJS({ text: text }).render({
                tags: '<strong>foo</strong><strong>bar</strong>',
                quotes: 'I use \'quote\' fingers "a lot"'
            });
            var div = document.createElement('div');
            div.innerHTML = compiled;
            equal(div.getElementsByTagName('span')[0].firstChild.nodeType, 1);
            equal(div.getElementsByTagName('div')[0].firstChild.nodeValue.toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
            equal(div.getElementsByTagName('span')[0].innerHTML.toLowerCase(), '<strong>foo</strong><strong>bar</strong>');
            equal(div.getElementsByTagName('input')[0].value, 'I use \'quote\' fingers "a lot"', 'escapped no matter what');
            legacyHelpers.view.hookups = {};
        });
        test('returning blocks', function () {
            var somethingHelper = function (cb) {
                return cb([
                    1,
                    2,
                    3,
                    4
                ]);
            };
            var template = '<%# Test Something Produces Items%>' + '<%== something(function(items){ %>' + ' <%== items.length%> ' + '<% items.map( function(){ %><%# Test Something Produces Items%>' + '<%==  something(function(items){ %>ItemsLength<%== items.length %><% }) %>' + '<% }) %>' + '<% }) %>' + '<% for( var i =0; i < items.length; i++) { %>for <%= items[i] %><% } %>';
            var temp = new EJS(template);
            var res = temp.render({
                something: somethingHelper,
                items: [
                    'a',
                    'b'
                ]
            });
            ok(/\s4\s/.test(res), 'first block called');
            equal(res.match(/ItemsLength4/g).length, 4, 'innerBlock and each');
        });
        test('easy hookup', function () {
            var div = document.createElement('div');
            var templateStr = '<div <%= (el)-> el.className = text %>>';
            var template = EJS(templateStr);
            var res = template({ text: 'yes' });
            div.appendChild(res);
            ok(div.getElementsByTagName('div')[0].className.indexOf('yes') !== -1, 'has yes');
        });
        test('multiple function hookups in a tag', function () {
            var text = '<span <%= (el)-> domData.set.call(el,\'foo\',\'bar\') %>' + ' <%= (el)-> domData.set.call(el,\'baz\',\'qux\') %>>lorem ipsum</span>', compiled = new EJS({ text: text }).render({ domData: domData }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var span = div.getElementsByTagName('span')[0];
            equal(domData.get.call(span, 'foo'), 'bar', 'first hookup');
            equal(domData.get.call(span, 'baz'), 'qux', 'second hookup');
        });
        test('helpers', function () {
            EJS.Helpers.prototype.simpleHelper = function () {
                return 'Simple';
            };
            EJS.Helpers.prototype.elementHelper = function () {
                return function (el) {
                    el.innerHTML = 'Simple';
                };
            };
            var text = '<div><%= simpleHelper() %></div>';
            var compiled = new EJS({ text: text }).render();
            equal(compiled, '<div>Simple</div>');
            text = '<div id="hookup" <%= elementHelper() %>></div>';
            compiled = new EJS({ text: text }).render();
            var qF = document.getElementById('qunit-fixture');
            qF.appendChild(legacyHelpers.view.frag(compiled));
            var hookup = document.getElementById('hookup');
            equal(hookup.innerHTML, 'Simple');
        });
        test('list helper', function () {
            var text = '<% list(todos, function(todo){ %><div><%= todo.name %></div><% }) %>';
            var todos = new CanList([{
                        id: 1,
                        name: 'Dishes'
                    }]), compiled = new EJS({ text: text }).render({ todos: todos }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('div').length, 1, '1 item in list');
            todos.push({
                id: 2,
                name: 'Laundry'
            });
            equal(div.getElementsByTagName('div').length, 2, '2 items in list');
            todos.splice(0, 2);
            equal(div.getElementsByTagName('div').length, 0, '0 items in list');
            todos.push({
                id: 4,
                name: 'Pick up sticks'
            });
            equal(div.getElementsByTagName('div').length, 1, '1 item in list again');
        });
        test('attribute single unescaped, html single unescaped', function () {
            var text = '<div id=\'me\' class=\'<%== task.attr(\'completed\') ? \'complete\' : \'\'%>\'><%== task.attr(\'name\') %></div>';
            var task = new CanMap({ name: 'dishes' });
            var compiled = new EJS({ text: text }).render({ task: task });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('div')[0].innerHTML, 'dishes', 'html correctly dishes');
            equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
            task.attr('name', 'lawn');
            equal(div.getElementsByTagName('div')[0].innerHTML, 'lawn', 'html correctly lawn');
            equal(div.getElementsByTagName('div')[0].className, '', 'class empty');
            task.attr('completed', true);
            equal(div.getElementsByTagName('div')[0].className, 'complete', 'class changed to complete');
        });
        test('select live binding', function () {
            var text = '<select><% todos.each(function(todo){ %><option><%= todo.name %></option><% }) %></select>', Todos = new CanList([{
                        id: 1,
                        name: 'Dishes'
                    }]), compiled = new EJS({ text: text }).render({ todos: Todos }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('option').length, 1, '1 item in list');
            Todos.push({
                id: 2,
                name: 'Laundry'
            });
            equal(div.getElementsByTagName('option').length, 2, '2 items in list');
            Todos.splice(0, 2);
            equal(div.getElementsByTagName('option').length, 0, '0 items in list');
        });
        test('block live binding', function () {
            var text = '<div><% if( obs.attr(\'sex\') == \'male\' ){ %>' + '<span>Mr.</span>' + '<% } else { %>' + '<label>Ms.</label>' + '<% } %>' + '</div>';
            var obs = new CanMap({ sex: 'male' });
            var compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('div')[0].firstChild.nodeName.toUpperCase(), 'SPAN', 'initial span tag');
            equal(div.getElementsByTagName('div')[0].firstChild.innerHTML, 'Mr.', 'initial span content');
            obs.attr('sex', 'female');
            equal(div.getElementsByTagName('div')[0].firstChild.nodeName.toUpperCase(), 'LABEL', 'updated label tag');
            equal(div.getElementsByTagName('div')[0].firstChild.innerHTML, 'Ms.', 'updated label content');
        });
        test('hookups in tables', function () {
            var text = '<table><tbody><% if( obs.attr(\'sex\') == \'male\' ){ %>' + '<tr><td>Mr.</td></tr>' + '<% } else { %>' + '<tr><td>Ms.</td></tr>' + '<% } %>' + '</tbody></table>';
            var obs = new CanMap({ sex: 'male' });
            var compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.nodeName, 'TD', 'initial tag');
            equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.innerHTML.replace(/(\r|\n)+/g, ''), 'Mr.', 'initial content');
            obs.attr('sex', 'female');
            equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.nodeName, 'TD', 'updated tag');
            equal(div.getElementsByTagName('tbody')[0].firstChild.firstChild.innerHTML.replace(/(\r|\n)+/g, ''), 'Ms.', 'updated content');
        });
        test('multiple tbodies in table hookup', function () {
            var text = '<table>' + '<% list(people, function(person){ %>' + '<tbody><tr><td><%= person.name %></td></tr></tbody>' + '<% }) %>' + '</table>', people = new CanList([
                    { name: 'Steve' },
                    { name: 'Doug' }
                ]), compiled = new EJS({ text: text }).render({ people: people }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('tbody').length, 2, 'two tbodies');
        });
        test('multiple hookups in a single attribute', function () {
            var text = '<div class=\'<%= obs.attr("foo") %>a<%= obs.attr("bar") %>b<%= obs.attr("baz") %>\'></div>', obs = new CanMap({
                    foo: '1',
                    bar: '2',
                    baz: '3'
                }), compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var innerDiv = div.childNodes[0];
            equal(getAttr(innerDiv, 'class'), '1a2b3', 'initial render');
            obs.attr('bar', '4');
            equal(getAttr(innerDiv, 'class'), '1a4b3', 'initial render');
            obs.attr('bar', '5');
            equal(getAttr(innerDiv, 'class'), '1a5b3', 'initial render');
        });
        test('adding and removing multiple html content within a single element', function () {
            var text = '<div><%== obs.attr("a") %><%== obs.attr("b") %><%== obs.attr("c") %></div>', obs = new CanMap({
                    a: 'a',
                    b: 'b',
                    c: 'c'
                }), compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'initial render node name');
            equal(div.firstChild.innerHTML, 'abc', 'initial render text');
            obs.attr({
                a: '',
                b: '',
                c: ''
            });
            equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'updated render node name');
            equal(div.firstChild.innerHTML, '', 'updated render text');
            obs.attr({ c: 'c' });
            equal(div.firstChild.nodeName.toUpperCase(), 'DIV', 'updated render node name');
            equal(div.firstChild.innerHTML, 'c', 'updated render text');
        });
        test('live binding and removeAttr', function () {
            var text = '<% if(obs.attr("show")) { %>' + '<p <%== obs.attr("attributes") %> class="<%= obs.attr("className")%>"><span><%= obs.attr("message") %></span></p>' + '<% } %>', obs = new CanMap({
                    show: true,
                    className: 'myMessage',
                    attributes: 'some="myText"',
                    message: 'Live long and prosper'
                }), compiled = new EJS({ text: text }).render({ obs: obs }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var p = div.getElementsByTagName('p')[0], span = p.getElementsByTagName('span')[0];
            equal(p.getAttribute('some'), 'myText', 'initial render attr');
            equal(getAttr(p, 'class'), 'myMessage', 'initial render class');
            equal(span.innerHTML, 'Live long and prosper', 'initial render innerHTML');
            obs.removeAttr('className');
            equal(getAttr(p, 'class'), '', 'class is undefined');
            obs.attr('className', 'newClass');
            equal(getAttr(p, 'class'), 'newClass', 'class updated');
            obs.removeAttr('attributes');
            equal(p.getAttribute('some'), null, 'attribute is undefined');
            obs.attr('attributes', 'some="newText"');
            equal(p.getAttribute('some'), 'newText', 'attribute updated');
            obs.removeAttr('message');
            equal(span.innerHTML, '', 'text node value is empty');
            obs.attr('message', 'Warp drive, Mr. Sulu');
            equal(span.innerHTML, 'Warp drive, Mr. Sulu', 'text node updated');
            obs.removeAttr('show');
            equal(div.innerHTML, '', 'value in block statement is undefined');
            obs.attr('show', true);
            p = div.getElementsByTagName('p')[0];
            span = p.getElementsByTagName('span')[0];
            equal(p.getAttribute('some'), 'newText', 'value in block statement updated attr');
            equal(getAttr(p, 'class'), 'newClass', 'value in block statement updated class');
            equal(span.innerHTML, 'Warp drive, Mr. Sulu', 'value in block statement updated innerHTML');
        });
        test('hookup within a tag', function () {
            var text = '<div <%== obs.attr("foo") %> ' + '<%== obs.attr("baz") %>>lorem ipsum</div>', obs = new CanMap({
                    foo: 'class="a"',
                    baz: 'some=\'property\''
                }), compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var anchor = div.getElementsByTagName('div')[0];
            equal(getAttr(anchor, 'class'), 'a');
            equal(anchor.getAttribute('some'), 'property');
            obs.attr('foo', 'class="b"');
            equal(getAttr(anchor, 'class'), 'b');
            equal(anchor.getAttribute('some'), 'property');
            obs.attr('baz', 'some=\'new property\'');
            equal(getAttr(anchor, 'class'), 'b');
            equal(anchor.getAttribute('some'), 'new property');
            obs.attr('foo', 'class=""');
            obs.attr('baz', '');
            equal(getAttr(anchor, 'class'), '', 'anchor class blank');
            equal(anchor.getAttribute('some'), undefined, 'attribute "some" is undefined');
        });
        test('single escaped tag, removeAttr', function () {
            var text = '<div <%= obs.attr("foo") %>>lorem ipsum</div>', obs = new CanMap({ foo: 'data-bar="john doe\'s bar"' }), compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var anchor = div.getElementsByTagName('div')[0];
            equal(anchor.getAttribute('data-bar'), 'john doe\'s bar');
            obs.removeAttr('foo');
            equal(anchor.getAttribute('data-bar'), null);
            obs.attr('foo', 'data-bar="baz"');
            equal(anchor.getAttribute('data-bar'), 'baz');
        });
        test('html comments', function () {
            var text = '<!-- bind to changes in the todo list --> <div><%= obs.attr("foo") %></div>', obs = new CanMap({ foo: 'foo' }), compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('div')[0].innerHTML, 'foo', 'Element as expected');
        });
        test('hookup and live binding', function () {
            var text = '<div class=\'<%= task.attr(\'completed\') ? \'complete\' : \'\' %>\' <%= (el)-> domData.set.call(el,\'task\',task) %>>' + '<%== task.attr(\'name\') %>' + '</div>', task = new CanMap({
                    completed: false,
                    className: 'someTask',
                    name: 'My Name'
                }), compiled = new EJS({ text: text }).render({
                    task: task,
                    domData: domData
                }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var child = div.getElementsByTagName('div')[0];
            ok(child.className.indexOf('complete') === -1, 'is incomplete');
            ok(!!domData.get.call(child, 'task'), 'has data');
            equal(child.innerHTML, 'My Name', 'has name');
            task.attr({
                completed: true,
                name: 'New Name'
            });
            ok(child.className.indexOf('complete') !== -1, 'is complete');
            equal(child.innerHTML, 'New Name', 'has new name');
        });
        test('unescape bindings change', function () {
            var l = new CanList([
                { complete: true },
                { complete: false },
                { complete: true }
            ]);
            var completed = function () {
                l.attr('length');
                var num = 0;
                l.each(function (item) {
                    if (item.attr('complete')) {
                        num++;
                    }
                });
                return num;
            };
            var text = '<div><%== completed() %></div>', compiled = new EJS({ text: text }).render({ completed: completed });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var child = div.getElementsByTagName('div')[0];
            equal(child.innerHTML, '2', 'at first there are 2 true bindings');
            var item = new CanMap({
                complete: true,
                id: 'THIS ONE'
            });
            l.push(item);
            equal(child.innerHTML, '3', 'now there are 3 complete');
            item.attr('complete', false);
            equal(child.innerHTML, '2', 'now there are 2 complete');
            l.pop();
            item.attr('complete', true);
            equal(child.innerHTML, '2', 'there are still 2 complete');
        });
        test('escape bindings change', function () {
            var l = new CanList([
                { complete: true },
                { complete: false },
                { complete: true }
            ]);
            var completed = function () {
                l.attr('length');
                var num = 0;
                l.each(function (item) {
                    if (item.attr('complete')) {
                        num++;
                    }
                });
                return num;
            };
            var text = '<div><%= completed() %></div>', compiled = new EJS({ text: text }).render({ completed: completed });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var child = div.getElementsByTagName('div')[0];
            equal(child.innerHTML, '2', 'at first there are 2 true bindings');
            var item = new CanMap({ complete: true });
            l.push(item);
            equal(child.innerHTML, '3', 'now there are 3 complete');
            item.attr('complete', false);
            equal(child.innerHTML, '2', 'now there are 2 complete');
        });
        test('tag bindings change', function () {
            var l = new CanList([
                { complete: true },
                { complete: false },
                { complete: true }
            ]);
            var completed = function () {
                l.attr('length');
                var num = 0;
                l.each(function (item) {
                    if (item.attr('complete')) {
                        num++;
                    }
                });
                return 'items=\'' + num + '\'';
            };
            var text = '<div <%= completed() %>></div>', compiled = new EJS({ text: text }).render({ completed: completed });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var child = div.getElementsByTagName('div')[0];
            equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
            var item = new CanMap({ complete: true });
            l.push(item);
            equal(child.getAttribute('items'), '3', 'now there are 3 complete');
            item.attr('complete', false);
            equal(child.getAttribute('items'), '2', 'now there are 2 complete');
        });
        test('attribute value bindings change', function () {
            var l = new CanList([
                { complete: true },
                { complete: false },
                { complete: true }
            ]);
            var completed = function () {
                l.attr('length');
                var num = 0;
                l.each(function (item) {
                    if (item.attr('complete')) {
                        num++;
                    }
                });
                return num;
            };
            var text = '<div items="<%= completed() %>"></div>', compiled = new EJS({ text: text }).render({ completed: completed });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var child = div.getElementsByTagName('div')[0];
            equal(child.getAttribute('items'), '2', 'at first there are 2 true bindings');
            var item = new CanMap({ complete: true });
            l.push(item);
            equal(child.getAttribute('items'), '3', 'now there are 3 complete');
            item.attr('complete', false);
            equal(child.getAttribute('items'), '2', 'now there are 2 complete');
        });
        test('in tag toggling', function () {
            var text = '<div <%== obs.attr(\'val\') %>></div>';
            var obs = new CanMap({ val: 'foo="bar"' });
            var compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            obs.attr('val', 'bar=\'foo\'');
            obs.attr('val', 'foo="bar"');
            var d2 = div.getElementsByTagName('div')[0];
            equal(d2.getAttribute('foo'), 'bar', 'bar set');
            equal(d2.getAttribute('bar'), null, 'bar set');
        });
        test('parent is right with bock', function () {
            var text = '<ul><% if(!obs.attr("items").length) { %>' + '<li>No items</li>' + '<% } else { %> <%== obs.attr("content") %>' + '<% } %></ul>', obs = new CanMap({
                    content: '<li>Hello</li>',
                    items: [{ name: 'Justin' }]
                }), compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var ul = div.getElementsByTagName('ul')[0];
            var li = div.getElementsByTagName('li')[0];
            ok(ul, 'we have a ul');
            ok(li, 'we have a li');
        });
        test('nested properties', function () {
            var text = '<div><%= obs.attr(\'name.first\')%></div>';
            var obs = new CanMap({ name: { first: 'Justin' } });
            var compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            div = div.getElementsByTagName('div')[0];
            equal(div.innerHTML, 'Justin');
            obs.attr('name.first', 'Brian');
            equal(div.innerHTML, 'Brian');
        });
        test('tags without chidren or ending with /> do not change the state', function () {
            var text = '<table><tr><td></td><%== obs.attr(\'content\') %></tr></div>';
            var obs = new CanMap({ content: '<td>Justin</td>' });
            var compiled = new EJS({ text: text }).render({ obs: obs });
            var div = document.createElement('div');
            var html = legacyHelpers.view.frag(compiled);
            div.appendChild(html);
            equal(div.getElementsByTagName('span').length, 0, 'there are no spans');
            equal(div.getElementsByTagName('td').length, 2, 'there are 2 td');
        });
        test('trailing text', function () {
            var template = EJS('There are <%= this.attr(\'length\') %> todos');
            var div = document.createElement('div');
            div.appendChild(template(new CanList([
                {},
                {}
            ])));
            ok(/There are 2 todos/.test(div.innerHTML), 'got all text');
        });
        test('live binding select', function () {
            var text = '<select><% items.each(function(ob) { %>' + '<option value=\'<%= ob.attr(\'id\') %>\'><%= ob.attr(\'title\') %></option>' + '<% }); %></select>', items = new CanList([
                    {
                        title: 'Make bugs',
                        is_done: true,
                        id: 0
                    },
                    {
                        title: 'Find bugs',
                        is_done: false,
                        id: 1
                    },
                    {
                        title: 'Fix bugs',
                        is_done: false,
                        id: 2
                    }
                ]), compiled = new EJS({ text: text }).render({ items: items }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('option').length, 3, '3 items in list');
            var option = div.getElementsByTagName('option')[0];
            equal(option.value, '' + items[0].id, 'value attr set');
            equal(option.textContent || option.text, items[0].title, 'content of option');
            items.push({
                id: 3,
                name: 'Go to pub'
            });
            equal(div.getElementsByTagName('option').length, 4, '4 items in list');
        });
        test('live binding textarea', function () {
            var template = EJS('<textarea>Before<%= obs.attr(\'middle\') %>After</textarea>');
            var obs = new CanMap({ middle: 'yes' }), div = document.createElement('div');
            var node = template({ obs: obs });
            div.appendChild(node);
            var textarea = div.firstChild;
            equal(textarea.value, 'BeforeyesAfter');
            obs.attr('middle', 'Middle');
            equal(textarea.value, 'BeforeMiddleAfter');
        });
        test('reset on a live bound input', function () {
            var text = '<input type=\'text\' value=\'<%= person.attr(\'name\') %>\'><button type=\'reset\'>Reset</button>', person = new CanMap({ name: 'Bob' }), compiled = new EJS({ text: text }).render({ person: person }), form = document.createElement('form'), input;
            form.appendChild(legacyHelpers.view.frag(compiled));
            input = form.getElementsByTagName('input')[0];
            form.reset();
            equal(input.value, 'Bob', 'value is correct');
        });
        test('attribute unquoting', function () {
            var text = '<input type="radio" ' + '<%== facet.single ? \'name="facet-\' + facet.attr("id") + \'"\' : "" %> ' + 'value="<%= facet.single ? "facet-" + facet.attr("id") : "" %>" />', facet = new CanMap({
                    id: 1,
                    single: true
                }), compiled = new EJS({ text: text }).render({ facet: facet }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.children[0].name, 'facet-1');
            equal(div.children[0].value, 'facet-1');
        });
        test('empty element hooks work correctly', function () {
            var text = '<div <%= function(e){ e.innerHTML = "1 Will show"; } %>></div>' + '<div <%= function(e){ e.innerHTML = "2 Will not show"; } %>></div>' + '3 Will not show';
            var compiled = new EJS({ text: text }).render(), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.childNodes.length, 3, 'all three elements present');
        });
        test('live binding with parent dependent tags but without parent tag present in template', function () {
            var text = [
                '<tbody>',
                '<% if( person.attr("first") ){ %>',
                '<tr><td><%= person.first %></td></tr>',
                '<% }%>',
                '<% if( person.attr("last") ){ %>',
                '<tr><td><%= person.last %></td></tr>',
                '<% } %>',
                '</tbody>'
            ];
            var person = new CanMap({
                first: 'Austin',
                last: 'McDaniel'
            });
            var compiled = new EJS({ text: text.join('\n') }).render({ person: person });
            var table = document.createElement('table');
            table.appendChild(legacyHelpers.view.frag(compiled));
            equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
            equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'Austin');
            equal(table.getElementsByTagName('tr')[1].firstChild.nodeName.toUpperCase(), 'TD');
            equal(table.getElementsByTagName('tr')[1].firstChild.innerHTML, 'McDaniel');
            person.removeAttr('first');
            equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
            equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'McDaniel');
            person.removeAttr('last');
            equal(table.getElementsByTagName('tr').length, 0);
            person.attr('first', 'Justin');
            equal(table.getElementsByTagName('tr')[0].firstChild.nodeName.toUpperCase(), 'TD');
            equal(table.getElementsByTagName('tr')[0].firstChild.innerHTML, 'Justin');
        });
        test('spaces between attribute name and value', function () {
            var text = '<input type="text" value = "<%= test %>" />', compiled = new EJS({ text: text }).render({ test: 'testing' }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var input = div.getElementsByTagName('input')[0];
            equal(input.value, 'testing');
            equal(input.type, 'text');
        });
        test('live binding with computes', function () {
            var text = '<span><%= compute() %></span>', compute = canCompute(5), compiled = new EJS({ text: text }).render({ compute: compute }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var span = div.getElementsByTagName('span');
            equal(span.length, 1);
            span = span[0];
            equal(span.innerHTML, '5');
            compute(6);
            equal(span.innerHTML, '6');
            compute('Justin');
            equal(span.innerHTML, 'Justin');
            compute(true);
            equal(span.innerHTML, 'true');
        });
        test('testing for clean tables', function () {
            var templateStr = '<table cellpadding="0" cellspacing="0" border="0" class="display">' + '<thead>' + '<tr>' + '<th> Game Name </th>' + '<th> Rating </th>' + '</tr>' + '</thead>' + '<tbody>' + '<% games.each( function(game) { %>' + '<tr class="game">' + '<td> <%= game.attr(\'name\') %></td>' + '<td> <%= game.attr(\'rating\') %></td>' + '</tr>' + '<% }) %>' + '<% games.each( function(game) { %>' + '<tr class="game">' + '<td> <%= game.attr(\'name\') %></td>' + '<td> <%= game.attr(\'rating\') %></td>' + '</tr>' + '<% }) %>' + '</tbody>' + '</table>';
            var template = EJS(templateStr);
            var games = new CanList();
            games.push({
                name: 'The Legend of Zelda',
                rating: 10
            });
            games.push({
                name: 'The Adventures of Link',
                rating: 9
            });
            games.push({
                name: 'Dragon Warrior',
                rating: 9
            });
            games.push({
                name: 'A Dude Named Daffl',
                rating: 8.5
            });
            var res = template({ games: games }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(res));
            ok(!/@@!!@@/.test(div.innerHTML), 'no placeholders');
        });
        test('Observe with array attributes', function () {
            var template = EJS('<ul><% list(todos, function(todo, i) { %><li><%= todos.attr(""+i) %></li><% }) %></ul><div><%= this.attr("message") %></div>');
            var div = document.createElement('div');
            var data = new CanMap({
                todos: [
                    'Line #1',
                    'Line #2',
                    'Line #3'
                ],
                message: 'Hello',
                count: 2
            });
            div.appendChild(template(data));
            equal(div.getElementsByTagName('li')[1].innerHTML, 'Line #2', 'Check initial array');
            equal(div.getElementsByTagName('div')[0].innerHTML, 'Hello', 'Check initial message');
            data.attr('todos.1', 'Line #2 changed');
            data.attr('message', 'Hello again');
            equal(div.getElementsByTagName('li')[1].innerHTML, 'Line #2 changed', 'Check updated array');
            equal(div.getElementsByTagName('div')[0].innerHTML, 'Hello again', 'Check updated message');
        });
        test('hookup this correctly', function () {
            var obj = { from: 'cows' };
            var html = '<span <%== (el) -> domData.set.call(el, \'foo\', this.from) %>>tea</span>';
            var compiled = new EJS({ text: html }).render(obj, { domData: domData });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            var span = div.getElementsByTagName('span')[0];
            equal(domData.get.call(span, 'foo'), obj.from, 'object matches');
        });
        test('live binding with html comment', function () {
            var text = '<table><tr><th>Todo</th></tr><!-- do not bother with me -->' + '<% todos.each(function(todo){ %><tr><td><%= todo.name %></td></tr><% }) %></table>', Todos = new CanList([{
                        id: 1,
                        name: 'Dishes'
                    }]), compiled = new EJS({ text: text }).render({ todos: Todos }), div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 1, '1 item in list');
            Todos.push({
                id: 2,
                name: 'Laundry'
            });
            equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 2, '2 items in list');
            Todos.splice(0, 2);
            equal(div.getElementsByTagName('table')[0].getElementsByTagName('td').length, 0, '0 items in list');
        });
        test('HTML comment with element callback', function () {
            var text = [
                    '<ul>',
                    '<% todos.each(function(todo) { %>',
                    '<li<%= (el) -> domData.set.call(el,\'todo\',todo) %>>',
                    '<!-- html comment #1 -->',
                    '<%= todo.name %>',
                    '<!-- html comment #2 -->',
                    '</li>',
                    '<% }) %>',
                    '</ul>'
                ], Todos = new CanList([{
                        id: 1,
                        name: 'Dishes'
                    }]), compiled = new EJS({ text: text.join('\n') }).render({
                    todos: Todos,
                    domData: domData
                }), div = document.createElement('div'), li, comments;
            comments = function (el) {
                var count = 0;
                for (var i = 0; i < el.childNodes.length; i++) {
                    if (el.childNodes[i].nodeType === 8) {
                        ++count;
                    }
                }
                return count;
            };
            div.appendChild(legacyHelpers.view.frag(compiled));
            li = div.getElementsByTagName('ul')[0].getElementsByTagName('li');
            equal(li.length, 1, '1 item in list');
            equal(comments(li[0]), 2, '2 comments in item #1');
            Todos.push({
                id: 2,
                name: 'Laundry'
            });
            equal(li.length, 2, '2 items in list');
            equal(comments(li[0]), 2, '2 comments in item #1');
            equal(comments(li[1]), 2, '2 comments in item #2');
            Todos.splice(0, 2);
            equal(li.length, 0, '0 items in list');
        });
        test('correctness of data-view-id and only in tag opening', function () {
            var text = [
                    '<textarea><select><% list(this.items, function(item) { %>',
                    '<option<%= (el) -> el.data(\'item\', item) %>><%= item.title %></option>',
                    '<% }) %></select></textarea>'
                ], items = [
                    {
                        id: 1,
                        title: 'One'
                    },
                    {
                        id: 2,
                        title: 'Two'
                    }
                ], compiled = new EJS({ text: text.join('') }).render({ items: items }), expected = '^<textarea data-view-id=\'[0-9]+\'><select><option data-view-id=\'[0-9]+\'>One</option>' + '<option data-view-id=\'[0-9]+\'>Two</option></select></textarea>$';
            ok(compiled.search(expected) === 0, 'Rendered output is as expected');
            legacyHelpers.view.hookups = {};
        });
        test('return blocks within element tags', function () {
            var animals = new CanList([
                    'sloth',
                    'bear'
                ]), template = '<ul>' + '<%==lister(animals, function(animal){%>' + '<li><%=animal %></li>' + '<%})%>' + '</ul>';
            var renderer = EJS(template);
            var div = document.createElement('div');
            var frag = renderer({
                lister: function () {
                    return function (el) {
                        equal(el.nodeName.toLowerCase(), 'li', 'got the LI it created');
                    };
                },
                animals: animals
            });
            div.appendChild(frag);
        });
        test('Each does not redraw items', function () {
            var animals = new CanList([
                    'sloth',
                    'bear'
                ]), template = '<div>my<b>favorite</b>animals:' + '<%==each(animals, function(animal){%>' + '<label>Animal=</label> <span><%=animal %></span>' + '<%})%>' + '!</div>';
            var renderer = EJS(template);
            var div = document.createElement('div');
            var frag = renderer({ animals: animals });
            div.appendChild(frag);
            div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
            equal(div.getElementsByTagName('label').length, 2, 'There are 2 labels');
            animals.push('turtle');
            equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
            equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        });
        test('Each works with no elements', function () {
            var animals = new CanList([
                    'sloth',
                    'bear'
                ]), template = '<%==each(animals, function(animal){%>' + '<%=animal %> ' + '<%})%>';
            var renderer = EJS(template);
            var div = document.createElement('div');
            var frag = renderer({ animals: animals });
            div.appendChild(frag);
            animals.push('turtle');
            equal(div.innerHTML, 'sloth bear turtle ', 'turtle added');
        });
        test('Each does not redraw items (normal array)', function () {
            var animals = [
                    'sloth',
                    'bear',
                    'turtle'
                ], template = '<div>my<b>favorite</b>animals:' + '<%each(animals, function(animal){%>' + '<label>Animal=</label> <span><%=animal %></span>' + '<%})%>' + '!</div>';
            var renderer = EJS(template);
            var div = document.createElement('div');
            var frag = renderer({ animals: animals });
            div.appendChild(frag);
            div.getElementsByTagName('label')[0].myexpando = 'EXPANDO-ED';
            equal(div.getElementsByTagName('label').length, 3, 'There are 2 labels');
            equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
            equal(div.getElementsByTagName('label')[0].myexpando, 'EXPANDO-ED', 'same expando');
            equal(div.getElementsByTagName('span')[2].innerHTML, 'turtle', 'turtle added');
        });
        test('list works within another branch', function () {
            var animals = new CanList([]), template = '<div>Animals:' + '<% if( animals.attr(\'length\') ){ %>~' + '<% animals.each(function(animal){%>' + '<span><%=animal %></span>' + '<%})%>' + '<% } else { %>' + 'No animals' + '<% } %>' + '!</div>';
            var renderer = EJS(template);
            var div = document.createElement('div');
            var frag = renderer({ animals: animals });
            div.appendChild(frag);
            equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
            animals.push('sloth');
            equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
            animals.pop();
            equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
        });
        test('each works within another branch', function () {
            var animals = new CanList([]), template = '<div>Animals:' + '<% if( animals.attr(\'length\') ){ %>~' + '<%==each(animals, function(animal){%>' + '<span><%=animal %></span>' + '<%})%>' + '<% } else { %>' + 'No animals' + '<% } %>' + '!</div>';
            var renderer = EJS(template);
            var div = document.createElement('div');
            var frag = renderer({ animals: animals });
            div.appendChild(frag);
            equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
            animals.push('sloth');
            equal(div.getElementsByTagName('span').length, 1, 'There is 1 sloth');
            animals.pop();
            equal(div.getElementsByTagName('div')[0].innerHTML, 'Animals:No animals!');
        });
        test('Access .length with nested dot notation', function () {
            var template = '<span id="nested"><%= this.attr("list.length") %></span>' + '<span id="unnested"><%= this.list.attr("length") %></span>', obj = new CanMap({
                    list: [
                        0,
                        1,
                        2,
                        3
                    ]
                }), renderer = EJS(template), div = document.createElement('div');
            div.appendChild(renderer(obj));
            ok(div.getElementsByTagName('span')[0].innerHTML === '4', 'Nested dot notation.');
            ok(div.getElementsByTagName('span')[1].innerHTML === '4', 'Not-nested dot notation.');
        });
        test('attributes in truthy section', function () {
            var template = EJS('<p <% if(attribute) {%>data-test="<%=attribute%>"<% } %>></p>');
            var data1 = { attribute: 'test-value' };
            var frag1 = template(data1);
            var div1 = document.createElement('div');
            div1.appendChild(frag1);
            equal(div1.children[0].getAttribute('data-test'), 'test-value', 'hyphenated attribute value');
            var data2 = { attribute: 'test value' };
            var frag2 = template(data2);
            var div2 = document.createElement('div');
            div2.appendChild(frag2);
            equal(div2.children[0].getAttribute('data-test'), 'test value', 'whitespace in attribute value');
        });
        test('outputting array of attributes', function () {
            var template = EJS('<p <% for(var i = 0; i < attribute.length; i++) { %><%=attribute[i].name%>="<%=attribute[i].value%>"<%}%>></p>');
            var data = {
                attribute: [
                    {
                        'name': 'data-test1',
                        'value': 'value1'
                    },
                    {
                        'name': 'data-test2',
                        'value': 'value2'
                    },
                    {
                        'name': 'data-test3',
                        'value': 'value3'
                    }
                ]
            };
            var frag = template(data);
            var div = document.createElement('div');
            div.appendChild(frag);
            equal(div.children[0].getAttribute('data-test1'), 'value1', 'first value');
            equal(div.children[0].getAttribute('data-test2'), 'value2', 'second value');
            equal(div.children[0].getAttribute('data-test3'), 'value3', 'third value');
        });
        test('_bindings removed when element removed', function () {
            var template = EJS('<div id="game"><% if(game.attr("league")) { %><%= game.attr("name") %><% } %></div>'), game = new CanMap({
                    'name': 'Fantasy Baseball',
                    'league': 'Malamonsters'
                });
            var frag = template({ game: game });
            var div = document.getElementById('qunit-fixture');
            div.appendChild(frag);
            domMutate.removeChild.call(div, div.firstChild);
            stop();
            setTimeout(function () {
                start();
                equal(game.__bindEvents._lifecycleBindings, 0, 'No bindings left');
            }, 100);
        });
        test('can.view.render() returns string (existing render func)', function () {
            var compiled = can.view.render(new EJS({ text: this.angleBracketsNoThis }).template.fn, { animals: this.animals }, {});
            equal(compiled, '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
        });
        if (__dirname !== '/') {
            test('can.view.render() returns string (path)', function () {
                var compiled = can.view.render(__dirname + '/binding.ejs', {
                    task: {
                        attr(key) {
                            return {
                                completed: true,
                                name: 'foo'
                            }[key];
                        }
                    }
                });
                equal(typeof compiled, 'string', 'a string is returned (not hooked up)');
                ok(/<div[^>]+data-view-id/.test(compiled), 'String is awaiting hookup');
                var div = document.createElement('div');
                var frag = legacyHelpers.view.frag(compiled, div);
                div.appendChild(frag);
                equal(div.innerHTML, '<div class="complete">\n\tfoo\n</div>\n');
            });
        }
        test('can.view() creates and hooks up fragment correctly (EJS render func)', function () {
            var bindingEJS = EJS('<div class=\'<%= task.attr(\'completed\') ? "complete" : "" %>\'>\n' + '\t<%== task.attr(\'name\') %>\n' + '</div>\n');
            var compiled = can.view(bindingEJS, {
                task: {
                    attr(key) {
                        return {
                            completed: true,
                            name: 'foo'
                        }[key];
                    }
                }
            });
            var div = document.createElement('div');
            div.appendChild(compiled);
            equal(div.innerHTML, '<div class="complete">\n\tfoo\n</div>\n');
        });
        test('can.view.render() can be called from within EJS (renderer)', function () {
            var compiled = new EJS({ text: '<div class="outer"><%== can.view.render( subEJS, this ) %></div>' }).render({
                task: {
                    attr(key) {
                        return {
                            completed: true,
                            name: 'foo'
                        }[key];
                    }
                }
            }, { subEJS: EJS('<div class="complete"><%= task.attr("name") %></div>') });
            var div = document.createElement('div');
            div.appendChild(legacyHelpers.view.frag(compiled));
            equal(div.innerHTML, '<div class="outer"><div class="complete">foo</div></div>');
        });
        if (__dirname !== '/') {
            test('can.view.render() can be called from within EJS (path)', function () {
                var compiled = new EJS({ text: '<div class="outer"><%== can.view.render( "' + __dirname + '/binding.ejs", this ) %></div>' }).render({
                    task: {
                        attr(key) {
                            return {
                                completed: true,
                                name: 'foo'
                            }[key];
                        }
                    }
                });
                var div = document.createElement('div');
                div.appendChild(legacyHelpers.view.frag(compiled));
                equal(div.innerHTML, '<div class="outer"><div class="complete">\n\tfoo\n</div>\n</div>');
            });
        }
        test('can.view.render() with a deferred', function () {
            var compiled = can.view.render(new EJS({ text: this.angleBracketsNoThis }).template.fn, { animals: new Deferred().resolve(this.animals) }, {});
            ok(compiled instanceof Deferred, 'result is a deferred');
            equal(compiled.state(), 'resolved', 'deferral is sync (already resolved because the sources are resolved)');
            equal(compiled._resultArgs[0], '<ul><li>sloth</li><li>bear</li><li>monkey</li></ul>');
        });
    }('/', require, exports, module));
});
/*can@3.14.0#view/ejs/ejs_test*/
define('can@3.14.0#view/ejs/ejs_test', [
    'require',
    'exports',
    'module',
    'can-ejs/test/can-ejs_test'
], function (require, exports, module) {
    require('can-ejs/test/can-ejs_test');
});
/*can-fixture@1.2.2#helpers/getid*/
define('can-fixture@1.2.2#helpers/getid', function (require, exports, module) {
    module.exports = function (xhrSettings, fixtureSettings) {
        var id = xhrSettings.data.id;
        if (id === undefined && typeof xhrSettings.data === 'number') {
            id = xhrSettings.data;
        }
        if (id === undefined) {
            xhrSettings.url.replace(/\/(\d+)(\/|$|\.)/g, function (all, num) {
                id = num;
            });
        }
        if (id === undefined) {
            id = xhrSettings.url.replace(/\/(\w+)(\/|$|\.)/g, function (all, num) {
                if (num !== 'update') {
                    id = num;
                }
            });
        }
        if (id === undefined) {
            id = Math.round(Math.random() * 1000);
        }
        return id;
    };
});
/*can-fixture@1.2.2#helpers/legacyStore*/
define('can-fixture@1.2.2#helpers/legacyStore', [
    'require',
    'exports',
    'module',
    './getid',
    'can-set',
    'can-util/js/is-array-like/is-array-like',
    'can-util/js/each/each',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var getId = require('./getid');
    var canSet = require('can-set');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    function getStartingId(items) {
        var startingId = 0;
        each(items, function (item) {
            if (typeof item.id === 'number') {
                startingId = Math.max(startingId, item.id + 1);
            }
        });
        return startingId;
    }
    module.exports = function (count, make, filter) {
        var nextItemId;
        var getNextItemId = function () {
            return nextItemId++;
        };
        var items, findOne = function (id) {
                for (var i = 0; i < items.length; i++) {
                    if (id == items[i].id) {
                        return items[i];
                    }
                }
            }, methods = {}, types, reset;
        if (isArrayLike(count) && typeof count[0] === 'string') {
            types = count;
            count = make;
            make = filter;
            filter = arguments[3];
        } else if (typeof count === 'string') {
            types = [
                count + 's',
                count
            ];
            count = make;
            make = filter;
            filter = arguments[3];
        }
        if (typeof count === 'number') {
            nextItemId = 0;
            items = [];
            reset = function () {
                items = [];
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item.id) {
                        item.id = getNextItemId();
                    }
                    items.push(item);
                }
            };
        } else {
            filter = make;
            var initialItems = count;
            nextItemId = getStartingId(initialItems);
            reset = function () {
                items = initialItems.slice(0);
            };
        }
        assign(methods, {
            getListData: function (request) {
                request = request || {};
                var retArr = items.slice(0);
                request.data = request.data || {};
                each((request.data.order || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        if (split[1].toUpperCase() !== 'ASC') {
                            if (a[split[0]] < b[split[0]]) {
                                return 1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return -1;
                            }
                        } else {
                            if (a[split[0]] < b[split[0]]) {
                                return -1;
                            } else if (a[split[0]] === b[split[0]]) {
                                return 0;
                            } else {
                                return 1;
                            }
                        }
                    });
                });
                each((request.data.group || []).slice(0).reverse(), function (name) {
                    var split = name.split(' ');
                    retArr = retArr.sort(function (a, b) {
                        return a[split[0]] > b[split[0]];
                    });
                });
                var offset = parseInt(request.data.offset, 10) || 0, limit = parseInt(request.data.limit, 10) || items.length - offset, i = 0;
                for (var param in request.data) {
                    i = 0;
                    if (request.data[param] !== undefined && (param.indexOf('Id') !== -1 || param.indexOf('_id') !== -1)) {
                        while (i < retArr.length) {
                            if (request.data[param] != retArr[i][param]) {
                                retArr.splice(i, 1);
                            } else {
                                i++;
                            }
                        }
                    }
                }
                if (typeof filter === 'function') {
                    i = 0;
                    while (i < retArr.length) {
                        if (!filter(retArr[i], request)) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                } else if (typeof filter === 'object') {
                    i = 0;
                    while (i < retArr.length) {
                        var subset = canSet.subset(retArr[i], request.data, filter);
                        if (!subset) {
                            retArr.splice(i, 1);
                        } else {
                            i++;
                        }
                    }
                }
                var responseData = {
                    'count': retArr.length,
                    'data': retArr.slice(offset, offset + limit)
                };
                each([
                    'limit',
                    'offset'
                ], function (prop) {
                    if (prop in request.data) {
                        responseData[prop] = request.data[prop];
                    }
                });
                return responseData;
            },
            getData: function (request, response) {
                var item = findOne(getId(request));
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                response(item);
            },
            updateData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                assign(item, request.data);
                response({ id: id }, { location: request.url || '/' + getId(request) });
            },
            destroyData: function (request, response) {
                var id = getId(request), item = findOne(id);
                if (typeof item === 'undefined') {
                    return response(404, 'Requested resource not found');
                }
                for (var i = 0; i < items.length; i++) {
                    if (items[i].id == id) {
                        items.splice(i, 1);
                        break;
                    }
                }
                return {};
            },
            createData: function (settings, response) {
                var item = typeof make === 'function' ? make(items.length, items) : {};
                assign(item, settings.data);
                if (!item.id) {
                    item.id = getNextItemId();
                }
                items.push(item);
                response({ id: item.id }, { location: settings.url + '/' + item.id });
            }
        });
        reset();
        return assign({
            findAll: methods.getListData,
            findOne: methods.getData,
            create: methods.createData,
            update: methods.updateData,
            destroy: methods.destroyData,
            getId: getId,
            find: function (settings) {
                return findOne(getId(settings));
            },
            reset: reset
        }, methods);
    };
});
/*can-connect@1.5.18#helpers/get-items*/
define('can-connect@1.5.18#helpers/get-items', function (require, exports, module) {
    module.exports = function (data) {
        if (Array.isArray(data)) {
            return data;
        } else {
            return data.data;
        }
    };
});
/*can-connect@1.5.18#helpers/sorted-set-json*/
define('can-connect@1.5.18#helpers/sorted-set-json', function (require, exports, module) {
    var forEach = [].forEach;
    var keys = Object.keys;
    module.exports = function (set) {
        if (set == null) {
            return set;
        } else {
            var sorted = {};
            forEach.call(keys(set).sort(), function (prop) {
                sorted[prop] = set[prop];
            });
            return JSON.stringify(sorted);
        }
    };
});
/*can-connect@1.5.18#helpers/overwrite*/
define('can-connect@1.5.18#helpers/overwrite', function (require, exports, module) {
    module.exports = function (d, s, id) {
        for (var prop in d) {
            if (d.hasOwnProperty(prop) && !(prop.substr(0, 2) === '__') && prop !== id && !(prop in s)) {
                delete d[prop];
            }
        }
        for (prop in s) {
            d[prop] = s[prop];
        }
        return d;
    };
});
/*can-connect@1.5.18#helpers/set-add*/
define('can-connect@1.5.18#helpers/set-add', [
    'require',
    'exports',
    'module',
    'can-set'
], function (require, exports, module) {
    var canSet = require('can-set');
    module.exports = function (connection, setItems, items, item, algebra) {
        var index = canSet.index(setItems, items, item, algebra);
        if (index === undefined) {
            index = items.length;
        }
        var copy = items.slice(0);
        copy.splice(index, 0, item);
        return copy;
    };
});
/*can-connect@1.5.18#helpers/get-index-by-id*/
define('can-connect@1.5.18#helpers/get-index-by-id', function (require, exports, module) {
    module.exports = function (connection, props, items) {
        var id = connection.id(props);
        for (var i = 0; i < items.length; i++) {
            var connId = connection.id(items[i]);
            if (id == connId) {
                return i;
            }
        }
        return -1;
    };
});
/*can-connect@1.5.18#helpers/clone-data*/
define('can-connect@1.5.18#helpers/clone-data', [
    'require',
    'exports',
    'module',
    'can-util/js/deep-assign/deep-assign'
], function (require, exports, module) {
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    module.exports = function (data) {
        return Array.isArray(data) ? data.slice(0) : deepAssign({}, data);
    };
});
/*can-connect@1.5.18#data/memory-cache/memory-cache*/
define('can-connect@1.5.18#data/memory-cache/memory-cache', [
    'require',
    'exports',
    'module',
    'can-connect/helpers/get-items',
    'can-connect',
    'can-connect/helpers/sorted-set-json',
    'can-set',
    'can-connect/helpers/overwrite',
    'can-connect/helpers/set-add',
    'can-connect/helpers/get-index-by-id',
    'can-util/js/assign/assign',
    'can-connect/helpers/clone-data'
], function (require, exports, module) {
    var getItems = require('can-connect/helpers/get-items');
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canSet = require('can-set');
    var overwrite = require('can-connect/helpers/overwrite');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var assign = require('can-util/js/assign/assign');
    var cloneData = require('can-connect/helpers/clone-data');
    module.exports = connect.behavior('data/memory-cache', function (baseConnection) {
        var behavior = {
            _sets: {},
            getSetData: function () {
                return this._sets;
            },
            __getListData: function (set) {
                var setsData = this.getSetData();
                var setData = setsData[sortedSetJSON(set)];
                if (setData) {
                    return setData.items;
                }
            },
            _instances: {},
            getInstance: function (id) {
                return this._instances[id];
            },
            removeSet: function (setKey, noUpdate) {
                var sets = this.getSetData();
                delete sets[setKey];
                if (noUpdate !== true) {
                    this.updateSets();
                }
            },
            updateSets: function () {
            },
            updateInstance: function (props) {
                var id = this.id(props);
                if (!(id in this._instances)) {
                    this._instances[id] = props;
                } else {
                    overwrite(this._instances[id], props, this.idProp);
                }
                return this._instances[id];
            },
            updateSet: function (setDatum, items, newSet) {
                var newSetKey = newSet ? sortedSetJSON(newSet) : setDatum.setKey;
                if (newSet) {
                    if (newSetKey !== setDatum.setKey) {
                        var sets = this.getSetData();
                        var oldSetKey = setDatum.setKey;
                        sets[newSetKey] = setDatum;
                        setDatum.setKey = newSetKey;
                        setDatum.set = assign({}, newSet);
                        this.removeSet(oldSetKey);
                    }
                }
                setDatum.items = items;
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
            },
            addSet: function (set, data) {
                var items = getItems(data);
                var sets = this.getSetData();
                var setKey = sortedSetJSON(set);
                sets[setKey] = {
                    setKey: setKey,
                    items: items,
                    set: assign({}, set)
                };
                var self = this;
                items.forEach(function (item) {
                    self.updateInstance(item);
                });
                this.updateSets();
            },
            _eachSet: function (cb) {
                var sets = this.getSetData();
                var self = this;
                var loop = function (setDatum, setKey) {
                    return cb.call(self, setDatum, setKey, function () {
                        return setDatum.items;
                    });
                };
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var result = loop(setDatum, setKey);
                    if (result !== undefined) {
                        return result;
                    }
                }
            },
            _getSets: function () {
                var sets = [], setsData = this.getSetData();
                for (var prop in setsData) {
                    sets.push(setsData[prop].set);
                }
                return sets;
            },
            getSets: function () {
                return Promise.resolve(this._getSets());
            },
            clear: function () {
                this._instances = {};
                this._sets = {};
            },
            getListData: function (set) {
                set = set || {};
                var listData = this.getListDataSync(set);
                if (listData) {
                    return Promise.resolve(listData);
                }
                return Promise.reject({
                    message: 'no data',
                    error: 404
                });
            },
            getListDataSync: function (set) {
                var sets = this._getSets();
                for (var i = 0; i < sets.length; i++) {
                    var checkSet = sets[i];
                    if (canSet.subset(set, checkSet, this.algebra)) {
                        var source = this.__getListData(checkSet);
                        var items = canSet.getSubset(set, checkSet, source, this.algebra);
                        return {
                            data: items,
                            count: source.length
                        };
                    }
                }
            },
            _getListData: function (set) {
                return this.getListDataSync(set);
            },
            updateListData: function (data, set) {
                set = set || {};
                var clonedData = cloneData(data);
                var items = getItems(clonedData);
                var sets = this.getSetData();
                var self = this;
                for (var setKey in sets) {
                    var setDatum = sets[setKey];
                    var union = canSet.union(setDatum.set, set, this.algebra);
                    if (union) {
                        var getSet = assign({}, setDatum.set);
                        return this.getListData(getSet).then(function (setData) {
                            self.updateSet(setDatum, canSet.getUnion(getSet, set, getItems(setData), items, self.algebra), union);
                        });
                    }
                }
                this.addSet(set, clonedData);
                return Promise.resolve();
            },
            getData: function (params) {
                var id = this.id(params);
                var res = this.getInstance(id);
                if (res) {
                    return Promise.resolve(res);
                } else {
                    return Promise.reject({
                        message: 'no data',
                        error: 404
                    });
                }
            },
            createData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    if (canSet.has(setDatum.set, instance, this.algebra)) {
                        self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra), setDatum.set);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            updateData: function (props) {
                var self = this;
                var instance = this.updateInstance(props);
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, instance, items);
                    if (canSet.subset(instance, setDatum.set, this.algebra)) {
                        if (index === -1) {
                            self.updateSet(setDatum, setAdd(self, setDatum.set, getItems(), instance, self.algebra));
                        } else {
                            items.splice(index, 1, instance);
                            self.updateSet(setDatum, items);
                        }
                    } else if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                return Promise.resolve(assign({}, instance));
            },
            destroyData: function (props) {
                var self = this;
                this._eachSet(function (setDatum, setKey, getItems) {
                    var items = getItems();
                    var index = indexOf(self, props, items);
                    if (index !== -1) {
                        items.splice(index, 1);
                        self.updateSet(setDatum, items);
                    }
                });
                var id = this.id(props);
                delete this._instances[id];
                return Promise.resolve(assign({}, props));
            }
        };
        return behavior;
    });
});
/*can-fixture@1.2.2#store*/
define('can-fixture@1.2.2#store', [
    'require',
    'exports',
    'module',
    'can-set',
    'can-connect',
    './helpers/legacyStore',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-array-like/is-array-like',
    'can-connect/data/memory-cache/memory-cache'
], function (require, exports, module) {
    var canSet = require('can-set');
    var connect = require('can-connect');
    var legacyStore = require('./helpers/legacyStore');
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isArrayLike = require('can-util/js/is-array-like/is-array-like');
    var dataMemoryCache = require('can-connect/data/memory-cache/memory-cache');
    var firstProp = function (obj) {
        for (var prop in obj) {
            return prop;
        }
    };
    var connectToConnection = function (method) {
        return function (req, res) {
            this.connection[method](req.data).then(function (data) {
                res(data);
            }, function (err) {
                res(403, err);
            });
        };
    };
    var makeMakeItems = function (baseItems, idProp) {
        return function () {
            var items = [], maxId = 0;
            each(baseItems, function (item) {
                items.push(JSON.parse(JSON.stringify(item)));
                maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
            });
            return {
                maxId: maxId,
                items: items
            };
        };
    };
    var Store = function (connection, makeItems, idProp) {
        this.connection = connection;
        this.makeItems = makeItems;
        this.idProp = idProp;
        this.reset();
        for (var method in Store.prototype) {
            this[method] = this[method].bind(this);
        }
    };
    assign(Store.prototype, {
        getListData: connectToConnection('getListData'),
        getData: connectToConnection('getData'),
        createData: function (req, res) {
            var idProp = this.idProp;
            req.data[idProp] = ++this.maxId;
            this.connection.createData(req.data).then(function (data) {
                var responseData = {};
                responseData[idProp] = req.data[idProp];
                res(responseData);
            }, function (err) {
                res(403, err);
            });
        },
        updateData: connectToConnection('updateData'),
        destroyData: connectToConnection('destroyData'),
        reset: function (newItems) {
            if (newItems) {
                this.makeItems = makeMakeItems(newItems, this.idProp);
            }
            var itemData = this.makeItems();
            this.maxId = itemData.maxId;
            this.connection.addSet({}, { data: itemData.items });
        },
        get: function (params) {
            var id = this.connection.id(params);
            return this.connection.getInstance(id);
        },
        getList: function (set) {
            return this.connection._getListData(set);
        }
    });
    each({
        findAll: 'getListData',
        findOne: 'getData',
        create: 'createData',
        update: 'updateData',
        destroy: 'destroyData'
    }, function (method, prop) {
        Store.prototype[prop] = function () {
            return this[method].apply(this, arguments);
        };
    });
    Store.make = function (count, make, algebra) {
        var isNew = false;
        if (count instanceof canSet.Algebra || make instanceof canSet.Algebra || algebra instanceof canSet.Algebra) {
            isNew = true;
        }
        if (!isNew) {
            console.warn('can-fixture: This form ( `fixture(count, make, filter)` ) of making a store is deprecated.  Please use the algebra-based form.');
            return legacyStore.apply(this, arguments);
        }
        var makeItems, idProp;
        if (typeof count === 'number') {
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = function () {
                var items = [];
                var maxId = 0;
                for (var i = 0; i < count; i++) {
                    var item = make(i, items);
                    if (!item[idProp]) {
                        item[idProp] = i;
                    }
                    maxId = Math.max(item[idProp] + 1, maxId + 1) || items.length;
                    items.push(item);
                }
                return {
                    maxId: maxId,
                    items: items
                };
            };
        } else if (isArrayLike(count)) {
            algebra = make;
            idProp = firstProp(algebra.clauses.id || {}) || 'id';
            makeItems = makeMakeItems(count, idProp);
        }
        var connection = connect([dataMemoryCache], {
            algebra: algebra,
            idProp: idProp
        });
        return new Store(connection, makeItems, idProp);
    };
    module.exports = Store;
});
/*can-fixture@1.2.2#core*/
define('can-fixture@1.2.2#core', [
    'require',
    'exports',
    'module',
    'can-set',
    'can-util/js/string/string',
    'can-util/js/each/each',
    'can-util/js/assign/assign',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/is-plain-object/is-plain-object',
    'can-util/js/log/log',
    'can-util/js/dev/dev',
    './store'
], function (require, exports, module) {
    var canSet = require('can-set');
    var sub = require('can-util/js/string/string').sub;
    var each = require('can-util/js/each/each');
    var assign = require('can-util/js/assign/assign');
    var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var canLog = require('can-util/js/log/log');
    var canDev = require('can-util/js/dev/dev');
    require('./store');
    var fixtures = [];
    exports.fixtures = fixtures;
    function isStoreLike(fixture) {
        return fixture && (fixture.getData || fixture.getListData);
    }
    var methodMapping = {
        item: {
            'GET': 'getData',
            'PUT': 'updateData',
            'DELETE': 'destroyData'
        },
        list: {
            'GET': 'getListData',
            'POST': 'createData'
        }
    };
    function getMethodAndPath(route) {
        var matches = route.match(/(GET|POST|PUT|DELETE|PATCH) (.+)/i);
        if (!matches) {
            return [
                undefined,
                route
            ];
        }
        var method = matches[1];
        var path = matches[2];
        return [
            method,
            path
        ];
    }
    function inferIdProp(url) {
        var wrappedInBraces = /\{(.*)\}/;
        var matches = url.match(wrappedInBraces);
        var isUniqueMatch = matches && matches.length === 2;
        if (isUniqueMatch) {
            return matches[1];
        }
    }
    function getItemAndListUrls(url, idProp) {
        idProp = idProp || inferIdProp(url);
        if (!idProp) {
            return [
                undefined,
                url
            ];
        }
        var itemRegex = new RegExp('\\/\\{' + idProp + '\\}.*');
        var rootIsItemUrl = itemRegex.test(url);
        var listUrl = rootIsItemUrl ? url.replace(itemRegex, '') : url;
        var itemUrl = rootIsItemUrl ? url : url.trim() + '/{' + idProp + '}';
        return [
            itemUrl,
            listUrl
        ];
    }
    function addStoreFixture(root, store) {
        var settings = {};
        var typeAndUrl = getMethodAndPath(root);
        var type = typeAndUrl[0];
        var url = typeAndUrl[1];
        var itemAndListUrls = getItemAndListUrls(url, store.idProp);
        var itemUrl = itemAndListUrls[0];
        var listUrl = itemAndListUrls[1];
        if (type) {
            var warning = ['fixture("' + root + '", fixture) must use a store method, not a store directly.'];
            if (itemUrl) {
                var itemAction = methodMapping.item[type];
                if (itemAction) {
                    settings[type + ' ' + itemUrl] = store[itemAction];
                    var itemWarning = 'Replace with fixture("' + type + ' ' + itemUrl + '", fixture.' + itemAction + ') for items.';
                    warning.push(itemWarning);
                }
            }
            var listAction = methodMapping.list[type];
            if (listAction) {
                settings[type + ' ' + listUrl] = store[listAction];
                var listWarning = 'Replace with fixture("' + type + ' ' + listUrl + '", fixture.' + listAction + ') for lists.';
                warning.push(listWarning);
            }
            var message = warning.join(' ');
            canDev.warn(message);
        } else {
            var itemMapping = methodMapping.item;
            for (var itemMethod in itemMapping) {
                var storeItemMethod = itemMapping[itemMethod];
                settings[itemMethod + ' ' + itemUrl] = store[storeItemMethod];
            }
            var listMapping = methodMapping.list;
            for (var listMethod in listMapping) {
                var storeListMethod = listMapping[listMethod];
                settings[listMethod + ' ' + listUrl] = store[storeListMethod];
            }
        }
        return settings;
    }
    function getSettingsFromString(route) {
        var typeAndUrl = getMethodAndPath(route);
        var type = typeAndUrl[0];
        var url = typeAndUrl[1];
        if (type) {
            return {
                type: type,
                url: url
            };
        }
        return { url: url };
    }
    function upsertFixture(fixtureList, settings, fixture) {
        var index = exports.index(settings, true);
        if (index > -1) {
            fixtures.splice(index, 1);
        }
        if (fixture == null) {
            return;
        }
        if (typeof fixture === 'object') {
            var data = fixture;
            fixture = function () {
                return data;
            };
        }
        settings.fixture = fixture;
        fixtures.unshift(settings);
    }
    exports.add = function (settings, fixture) {
        if (fixture === undefined) {
            each(settings, function (fixture, url) {
                exports.add(url, fixture);
            });
            return;
        }
        if (isStoreLike(fixture)) {
            settings = addStoreFixture(settings, fixture);
            exports.add(settings);
            return;
        }
        if (typeof settings === 'string') {
            settings = getSettingsFromString(settings);
        }
        upsertFixture(fixtures, settings, fixture);
    };
    var $fixture = exports.add;
    $fixture.on = true;
    $fixture.delay = 10;
    exports.callDynamicFixture = function (xhrSettings, fixtureSettings, cb) {
        xhrSettings.data = fixtureSettings.data;
        var response = function () {
            var res = exports.extractResponse.apply(xhrSettings, arguments);
            return cb.apply(this, res);
        };
        var callFixture = function () {
            var result = fixtureSettings.fixture(xhrSettings, response, xhrSettings.headers, fixtureSettings);
            if (result !== undefined) {
                response(200, result);
            }
        };
        if (!xhrSettings.async) {
            callFixture();
            return null;
        } else {
            return setTimeout(callFixture, $fixture.delay);
        }
    };
    exports.index = function (settings, exact) {
        for (var i = 0; i < fixtures.length; i++) {
            if (exports.matches(settings, fixtures[i], exact)) {
                return i;
            }
        }
        return -1;
    };
    exports.get = function (xhrSettings) {
        if (!$fixture.on) {
            return;
        }
        var index = exports.index(xhrSettings, true);
        if (index === -1) {
            index = exports.index(xhrSettings, false);
        }
        var fixtureSettings = index >= 0 ? assign({}, fixtures[index]) : undefined;
        if (fixtureSettings) {
            var url = fixtureSettings.fixture, data = exports.dataFromUrl(fixtureSettings.url, xhrSettings.url);
            if (typeof fixtureSettings.fixture === 'string') {
                if (data) {
                    url = sub(url, data);
                }
                fixtureSettings.url = url;
                fixtureSettings.data = null;
                fixtureSettings.type = 'GET';
                if (!fixtureSettings.error) {
                    fixtureSettings.error = function (xhr, error, message) {
                        throw 'fixtures.js Error ' + error + ' ' + message;
                    };
                }
            } else if (isPlainObject(xhrSettings.data)) {
                var xhrData = assign({}, xhrSettings.data || {});
                fixtureSettings.data = assign(xhrData, data);
            } else {
                fixtureSettings.data = xhrSettings.data;
            }
        }
        return fixtureSettings;
    };
    exports.matches = function (settings, fixture, exact) {
        if (exact) {
            return canSet.equal(settings, fixture, {
                fixture: function () {
                    return true;
                }
            });
        } else {
            return canSet.subset(settings, fixture, exports.defaultCompare);
        }
    };
    var isEmptyOrNull = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.equal(a, b);
        }
    };
    var isEmptyOrSubset = function (a, b) {
        if (a == null && isEmptyObject(b)) {
            return true;
        } else if (b == null && isEmptyObject(a)) {
            return true;
        } else {
            return canSet.subset(a, b);
        }
    };
    exports.defaultCompare = {
        url: function (a, b) {
            return !!exports.dataFromUrl(b, a);
        },
        fixture: function () {
            return true;
        },
        xhr: function () {
            return true;
        },
        type: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        method: function (a, b) {
            return b && a ? a.toLowerCase() === b.toLowerCase() : b === a;
        },
        helpers: function () {
            return true;
        },
        headers: isEmptyOrNull,
        data: isEmptyOrSubset
    };
    var replacer = /\{([^\}]+)\}/g;
    exports.dataFromUrl = function (fixtureUrl, url) {
        if (!fixtureUrl) {
            return {};
        }
        var order = [], fixtureUrlAdjusted = fixtureUrl.replace('.', '\\.').replace('?', '\\?'), res = new RegExp(fixtureUrlAdjusted.replace(replacer, function (whole, part) {
                order.push(part);
                return '([^/]+)';
            }) + '$').exec(url), data = {};
        if (!res) {
            return null;
        }
        res.shift();
        each(order, function (name) {
            data[name] = res.shift();
        });
        return data;
    };
    exports.extractResponse = function (status, response, headers, statusText) {
        if (typeof status !== 'number') {
            headers = response;
            response = status;
            status = 200;
        }
        if (typeof headers === 'string') {
            statusText = headers;
            headers = {};
        }
        return [
            status,
            response,
            headers,
            statusText
        ];
    };
});
/*can-fixture@1.2.2#xhr*/
define('can-fixture@1.2.2#xhr', [
    'require',
    'exports',
    'module',
    './core',
    'can-deparam',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-util/js/log/log'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var fixtureCore = require('./core');
        var deparam = require('can-deparam');
        var assign = require('can-util/js/assign/assign');
        var each = require('can-util/js/each/each');
        var canLog = require('can-util/js/log/log');
        var XHR = XMLHttpRequest, GLOBAL = typeof global !== 'undefined' ? global : window;
        var props = [
            'type',
            'url',
            'async',
            'response',
            'responseText',
            'responseType',
            'responseXML',
            'responseURL',
            'status',
            'statusText',
            'readyState'
        ];
        var events = [
            'abort',
            'error',
            'load',
            'loadend',
            'loadstart',
            'progress',
            'readystatechange'
        ];
        (function () {
            var x = new XHR();
            for (var prop in x) {
                if (prop.indexOf('on') === 0) {
                    if (events.indexOf(prop.substr(2)) === -1) {
                        events.push(prop.substr(2));
                    }
                } else if (props.indexOf(prop) === -1 && typeof x[prop] !== 'function') {
                    props.push(prop);
                }
            }
        }());
        function callEvents(xhr, ev) {
            var evs = xhr.__events[ev] || [], fn;
            for (var i = 0, len = evs.length; i < len; i++) {
                fn = evs[i];
                fn.call(xhr);
            }
        }
        GLOBAL.XMLHttpRequest = function () {
            var mockXHR = this;
            var realXHR = new XHR();
            this._xhr = realXHR;
            this._requestHeaders = {};
            this.__events = {};
            each(events, function (eventName) {
                realXHR['on' + eventName] = function () {
                    callEvents(mockXHR, eventName);
                    if (mockXHR['on' + eventName]) {
                        return mockXHR['on' + eventName].apply(mockXHR, arguments);
                    }
                };
            });
            this.onload = null;
        };
        GLOBAL.XMLHttpRequest._XHR = XHR;
        assign(XMLHttpRequest.prototype, {
            setRequestHeader: function (name, value) {
                this._requestHeaders[name] = value;
            },
            open: function (type, url, async) {
                this.type = type;
                this.url = url;
                this.async = async === false ? false : true;
            },
            getAllResponseHeaders: function () {
                return this._xhr.getAllResponseHeaders.apply(this._xhr, arguments);
            },
            addEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                evs.push(fn);
            },
            removeEventListener: function (ev, fn) {
                var evs = this.__events[ev] = this.__events[ev] || [];
                var idx = evs.indexOf(fn);
                if (idx >= 0) {
                    evs.splice(idx, 1);
                }
            },
            setDisableHeaderCheck: function (val) {
                this._disableHeaderCheck = !!val;
            },
            getResponseHeader: function (key) {
                return this._xhr.getResponseHeader(key);
            },
            abort: function () {
                var xhr = this._xhr;
                if (this.timeoutId !== undefined) {
                    clearTimeout(this.timeoutId);
                    xhr.open(this.type, this.url, this.async === false ? false : true);
                    xhr.send();
                }
                return xhr.abort();
            },
            send: function (data) {
                var type = this.type.toLowerCase() || 'get';
                var xhrSettings = {
                    url: this.url,
                    data: data,
                    headers: this._requestHeaders,
                    type: type,
                    method: type,
                    async: this.async,
                    xhr: this
                };
                if (!xhrSettings.data && xhrSettings.type === 'get' || xhrSettings.type === 'delete') {
                    xhrSettings.data = deparam(xhrSettings.url.split('?')[1]);
                    xhrSettings.url = xhrSettings.url.split('?')[0];
                }
                if (typeof xhrSettings.data === 'string') {
                    try {
                        xhrSettings.data = JSON.parse(xhrSettings.data);
                    } catch (e) {
                        xhrSettings.data = deparam(xhrSettings.data);
                    }
                }
                var fixtureSettings = fixtureCore.get(xhrSettings);
                var mockXHR = this;
                if (fixtureSettings && typeof fixtureSettings.fixture === 'function') {
                    this.timeoutId = fixtureCore.callDynamicFixture(xhrSettings, fixtureSettings, function (status, body, headers, statusText) {
                        body = typeof body === 'string' ? body : JSON.stringify(body);
                        mockXHR._xhr = {
                            open: function () {
                            },
                            send: function () {
                            },
                            abort: function () {
                            },
                            getResponseHeader: function () {
                            }
                        };
                        assign(mockXHR, {
                            readyState: 4,
                            status: status
                        });
                        var success = status >= 200 && status < 300 || status === 304;
                        if (success) {
                            assign(mockXHR, {
                                statusText: statusText || 'OK',
                                responseText: body
                            });
                        } else {
                            assign(mockXHR, {
                                statusText: statusText || 'error',
                                responseText: body
                            });
                        }
                        mockXHR.getAllResponseHeaders = function () {
                            var ret = [];
                            each(headers || {}, function (value, name) {
                                Array.prototype.push.apply(ret, [
                                    name,
                                    ': ',
                                    value,
                                    '\r\n'
                                ]);
                            });
                            return ret.join('');
                        };
                        if (mockXHR.onreadystatechange) {
                            mockXHR.onreadystatechange({ target: mockXHR });
                        }
                        callEvents(mockXHR, 'progress');
                        if (mockXHR.onprogress) {
                            mockXHR.onprogress();
                        }
                        callEvents(mockXHR, 'load');
                        if (mockXHR.onload) {
                            mockXHR.onload();
                        }
                        callEvents(mockXHR, 'loadend');
                        if (mockXHR.onloadend) {
                            mockXHR.onloadend();
                        }
                    });
                    return;
                }
                var makeRequest = function () {
                    mockXHR._xhr.open(mockXHR._xhr.type, mockXHR._xhr.url, mockXHR._xhr.async);
                    if (mockXHR._requestHeaders) {
                        Object.keys(mockXHR._requestHeaders).forEach(function (key) {
                            mockXHR._xhr.setRequestHeader(key, mockXHR._requestHeaders[key]);
                        });
                    }
                    return mockXHR._xhr.send(data);
                };
                if (fixtureSettings && typeof fixtureSettings.fixture === 'number') {
                    canLog.log(xhrSettings.url + ' -> delay ' + fixtureSettings.fixture + 'ms');
                    this.timeoutId = setTimeout(makeRequest, fixtureSettings.fixture);
                    return;
                }
                if (fixtureSettings) {
                    canLog.log(xhrSettings.url + ' -> ' + fixtureSettings.url);
                    assign(mockXHR, fixtureSettings);
                }
                return makeRequest();
            }
        });
        each(props, function (prop) {
            Object.defineProperty(XMLHttpRequest.prototype, prop, {
                get: function () {
                    return this._xhr[prop];
                },
                set: function (newVal) {
                    try {
                        this._xhr[prop] = newVal;
                    } catch (e) {
                    }
                }
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-fixture@1.2.2#fixture*/
define('can-fixture@1.2.2#fixture', [
    'require',
    'exports',
    'module',
    './core',
    './store',
    './xhr',
    'can-util/js/assign/assign',
    'can-namespace'
], function (require, exports, module) {
    var core = require('./core');
    var fixture = core.add;
    var Store = require('./store');
    require('./xhr');
    var assign = require('can-util/js/assign/assign');
    var ns = require('can-namespace');
    var noop = function () {
    };
    assign(fixture, {
        rand: function randomize(arr, min, max) {
            if (typeof arr === 'number') {
                if (typeof min === 'number') {
                    return arr + Math.floor(Math.random() * (min - arr + 1));
                } else {
                    return Math.floor(Math.random() * (arr + 1));
                }
            }
            var choices = arr.slice(0);
            if (min === undefined) {
                min = 1;
                max = choices.length;
            } else if (max === undefined) {
                max = min;
            }
            var result = [];
            var selectedCount = min + Math.round(randomize(max - min));
            for (var i = 0; i < selectedCount; i++) {
                var selectedIndex = randomize(choices.length - 1), selected = choices.splice(selectedIndex, 1)[0];
                result.push(selected);
            }
            return result;
        },
        xhr: function (xhr) {
            return assign({}, {
                abort: noop,
                getAllResponseHeaders: function () {
                    return '';
                },
                getResponseHeader: function () {
                    return '';
                },
                open: noop,
                overrideMimeType: noop,
                readyState: 4,
                responseText: '',
                responseXML: null,
                send: noop,
                setRequestHeader: noop,
                status: 200,
                statusText: 'OK'
            }, xhr);
        },
        store: Store.make,
        fixtures: core.fixtures
    });
    if (typeof window !== 'undefined' && typeof require.resolve !== 'function') {
        window.fixture = fixture;
    }
    module.exports = ns.fixture = fixture;
});
/*can-fixture@1.2.2#test/fixture_test*/
define('can-fixture@1.2.2#test/fixture_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-fixture',
    '../core',
    'can-set',
    'jquery',
    'can-util/js/each/each',
    'can-util/js/is-empty-object/is-empty-object',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var fixture = require('can-fixture');
        var core = require('../core');
        var set = require('can-set');
        var $ = require('jquery');
        var each = require('can-util/js/each/each');
        var isEmptyObject = require('can-util/js/is-empty-object/is-empty-object');
        var canDev = require('can-util/js/dev/dev');
        var errorCallback = function (xhr, status, error) {
            ok(false, error);
            start();
        };
        var parseHeaders = function (str) {
            var lines = str.split(/\r?\n/);
            var fields = {};
            var index;
            var line;
            var field;
            var val;
            lines.pop();
            for (var i = 0, len = lines.length; i < len; ++i) {
                line = lines[i];
                index = line.indexOf(':');
                field = line.slice(0, index).toLowerCase();
                val = line.slice(index + 1).replace(/(^\s*|\s*$)/g, '');
                fields[field] = val;
            }
            return fields;
        };
        QUnit.module('can-fixture');
        if (__dirname !== '/') {
            test('static fixtures', function () {
                stop();
                fixture('GET something', __dirname + '/fixtures/test.json');
                fixture('POST something', __dirname + '/fixtures/test.json');
                fixture('PATCH something', __dirname + '/fixtures/test.json');
                $.ajax({
                    url: 'something',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.sweet, 'ness', 'can.get works');
                    $.ajax({
                        url: 'something',
                        method: 'POST',
                        dataType: 'json'
                    }).then(function (data) {
                        equal(data.sweet, 'ness', 'can.post works');
                        $.ajax({
                            url: 'something',
                            method: 'PATCH',
                            dataType: 'json'
                        }).then(function (data) {
                            equal(data.sweet, 'ness', 'can.patch works');
                            start();
                        }, errorCallback);
                    }, errorCallback);
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using method signature)', function () {
                stop();
                fixture({
                    method: 'get',
                    url: 'method/{id}'
                }, __dirname + '/fixtures/method.{id}.json');
                $.ajax({
                    url: 'method/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using method');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('static fixtures (using type signature)', function () {
                stop();
                fixture({
                    type: 'get',
                    url: 'type/{id}'
                }, __dirname + '/fixtures/type.{id}.json');
                $.ajax({
                    url: 'type/4',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 4, 'Got data with proper id using type');
                    start();
                }, errorCallback);
            });
        }
        if (__dirname !== '/') {
            test('templated static fixtures', function () {
                stop();
                fixture('GET some/{id}', __dirname + '/fixtures/stuff.{id}.json');
                $.ajax({
                    url: 'some/3',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 3, 'Got data with proper id');
                    start();
                }, errorCallback);
            });
        }
        test('dynamic fixtures', function () {
            stop();
            fixture.delay = 10;
            fixture('something', function () {
                return [{ sweet: 'ness' }];
            });
            $.ajax({
                url: 'something',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].sweet, 'ness', 'can.get works');
                start();
            });
        });
        if (__dirname !== '/') {
            test('fixture function', 3, function () {
                stop();
                var url = __dirname + '/fixtures/foo.json';
                fixture(url, __dirname + '/fixtures/foobar.json');
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (data) {
                    equal(data.sweet, 'ner', 'url passed works');
                    fixture(url, __dirname + '/fixtures/test.json');
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (data) {
                        equal(data.sweet, 'ness', 'replaced');
                        fixture(url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (data) {
                            equal(data.a, 'b', 'removed');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store fixtures', function () {
            stop();
            var store = fixture.store('thing', 1000, function (i) {
                return {
                    id: i,
                    name: 'thing ' + i
                };
            }, function (item, settings) {
                if (settings.data.searchText) {
                    var regex = new RegExp('^' + settings.data.searchText);
                    return regex.test(item.name);
                }
            });
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 100,
                    limit: 200,
                    order: ['name ASC'],
                    searchText: 'thing 2'
                },
                success: function (things) {
                    equal(things.data[0].name, 'thing 29', 'first item is correct');
                    equal(things.data.length, 11, 'there are 11 items');
                    start();
                }
            });
        });
        test('fixture.store fixtures should have unique IDs', function () {
            stop();
            var store = fixture.store('thing', 100, function (i) {
                return { name: 'Test ' + i };
            });
            fixture('things', store.findAll);
            $.ajax({
                url: 'things',
                dataType: 'json',
                data: {
                    offset: 0,
                    limit: 200,
                    order: ['name ASC'],
                    searchText: 'thing 2'
                },
                success: function (result) {
                    var seenIds = [];
                    var things = result.data;
                    for (var thingKey in things) {
                        var thing = things[thingKey];
                        ok(seenIds.indexOf(thing.id) === -1);
                        seenIds.push(thing.id);
                    }
                    start();
                }
            });
        });
        test('fixture.store should assign unique IDs when fixtures provide IDs', function () {
            var store = fixture.store([
                {
                    id: 0,
                    name: 'Object 0'
                },
                {
                    id: 1,
                    name: 'Object 1'
                },
                {
                    id: 2,
                    name: 'Object 2'
                }
            ]);
            fixture('POST /models', store.createData);
            function then(ajax, callback) {
                ajax.then(callback, function (error) {
                    ok(false, 'ajax failure: ' + error);
                    start();
                });
            }
            var request = $.ajax({
                url: '/models',
                dataType: 'json',
                type: 'post',
                data: { name: 'My test object' }
            });
            stop();
            then(request, function (response) {
                notEqual(response.id, 0);
                notEqual(response.id, 1);
                notEqual(response.id, 2);
                equal(response.id, 3);
                start();
            });
        });
        test('simulating an error', function () {
            fixture('/foo', function (request, response) {
                return response(401, { type: 'unauthorized' });
            });
            stop();
            $.ajax({
                url: '/foo',
                dataType: 'json'
            }).done(function () {
                ok(false, 'success called');
                start();
            }).fail(function (original, type) {
                ok(true, 'error called');
                deepEqual(JSON.parse(original.responseText), { type: 'unauthorized' }, 'Original text passed');
                start();
            });
        });
        test('rand', function () {
            var rand = fixture.rand;
            var num = rand(3);
            equal(typeof num, 'number');
            var matched = {};
            for (var i = 0; i < 100; i++) {
                num = rand(3);
                matched[num] = true;
            }
            for (i = 0; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
            }
            matched = {};
            var result, choices = [
                    'a',
                    'b',
                    'c'
                ];
            for (i = 0; i < 100; i++) {
                result = rand(choices);
                matched[result.length] = true;
                matched[result[0]] = true;
            }
            for (i = 1; i <= 3; i++) {
                ok(matched[i], 'has ' + i);
                delete matched[i];
            }
            each(choices, function (choice) {
                ok(matched[choice], 'has ' + choice);
                delete matched[choice];
            });
            ok(isEmptyObject(matched), 'nothing else unexpected');
        });
        test('core.dataFromUrl', function () {
            var data = core.dataFromUrl('/thingers/{id}', '/thingers/5');
            equal(data.id, 5, 'gets data');
            data = core.dataFromUrl('/thingers/5?hi.there', '/thingers/5?hi.there');
            deepEqual(data, {}, 'gets data');
        });
        test('core.dataFromUrl with double character value', function () {
            var data = core.dataFromUrl('/days/{id}/time_slots.json', '/days/17/time_slots.json');
            equal(data.id, 17, 'gets data');
        });
        test('core.defaultCompare', function () {
            var same = set.equal({ url: '/thingers/5' }, { url: '/thingers/{id}' }, core.defaultCompare);
            ok(same, 'they are similar');
            same = set.equal({ url: '/thingers/5' }, { url: '/thingers' }, core.defaultCompare);
            ok(!same, 'they are not the same');
        });
        test('core.matches', function () {
            var same = core.matches({ url: '/thingers/5' }, { url: '/thingers/{id}' });
            ok(same, 'similar');
            same = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' });
            ok(same, 'similar with extra pops on settings');
            var exact = core.matches({
                url: '/thingers/5',
                type: 'get'
            }, { url: '/thingers/{id}' }, true);
            ok(!exact, 'not exact');
            exact = core.matches({ url: '/thingers/5' }, { url: '/thingers/5' }, true);
            ok(exact, 'exact');
        });
        test('fixture function gets id', function () {
            fixture('/thingers/{id}', function (settings) {
                return {
                    id: settings.data.id,
                    name: 'justin'
                };
            });
            stop();
            $.ajax({
                url: '/thingers/5',
                dataType: 'json',
                data: { id: 5 }
            }).done(function (data) {
                ok(data.id);
                start();
            });
        });
        if (__dirname !== '/') {
            test('replacing and removing a fixture', function () {
                var url = __dirname + '/fixtures/remove.json';
                fixture('GET ' + url, function () {
                    return { weird: 'ness!' };
                });
                stop();
                $.ajax({
                    url: url,
                    dataType: 'json'
                }).done(function (json) {
                    equal(json.weird, 'ness!', 'fixture set right');
                    fixture('GET ' + url, function () {
                        return { weird: 'ness?' };
                    });
                    $.ajax({
                        url: url,
                        dataType: 'json'
                    }).done(function (json) {
                        equal(json.weird, 'ness?', 'fixture set right');
                        fixture('GET ' + url, null);
                        $.ajax({
                            url: url,
                            dataType: 'json'
                        }).done(function (json) {
                            equal(json.weird, 'ness', 'fixture set right');
                            start();
                        });
                    });
                });
            });
        }
        test('fixture.store with can.Model', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.getListData);
            fixture('GET /models/{id}', store.getData);
            fixture('POST /models', store.createData);
            fixture('PUT /models/{id}', store.updateData);
            fixture('DELETE /models/{id}', store.destroyData);
            stop();
            function errorAndStart(e) {
                ok(false, 'borked' + e);
                start();
            }
            var check100Updated = function () {
                return $.ajax({
                    url: '/models/100',
                    dataType: 'json'
                }).then(function (model) {
                    equal(model.name, 'Updated test object', 'Successfully updated object');
                });
            };
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (modelsData) {
                var models = modelsData.data;
                equal(models.length, 100, 'Got 100 models for findAll with no parameters');
                equal(models[95].name, 'Object 95', 'All models generated properly');
                return $.ajax({
                    url: '/models/51',
                    dataType: 'json'
                }).then(function (data) {
                    equal(data.id, 51, 'Got correct object id');
                    equal('Object 51', data.name, 'Object name generated correctly');
                    return $.ajax({
                        url: '/models',
                        dataType: 'json',
                        type: 'post',
                        data: { name: 'My test object' }
                    }).then(function (newmodel) {
                        equal(newmodel.id, 100, 'Id got incremented');
                        return $.ajax({
                            url: '/models/100',
                            dataType: 'json'
                        }).then(function (model) {
                            equal(model.id, 100, 'Loaded new object');
                            return $.ajax({
                                url: '/models/100',
                                dataType: 'json',
                                type: 'put',
                                data: { name: 'Updated test object' }
                            }).then(function (model) {
                                return check100Updated().then(function () {
                                    return $.ajax({
                                        url: '/models/100',
                                        dataType: 'json',
                                        type: 'delete'
                                    }).then(function (deleted) {
                                        start();
                                    }, errorAndStart);
                                }, errorAndStart);
                            }, errorAndStart);
                        }, errorAndStart);
                    }, errorAndStart);
                }, errorAndStart);
            }, errorAndStart);
        });
        test('fixture.store returns 404 on findOne with bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models/{id}', store.findOne);
            stop();
            $.ajax({
                url: '/models/3',
                dataType: 'json'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'statusText');
                equal(data.responseText, 'Requested resource not found', 'responseText');
                start();
            });
        });
        test('fixture.store returns 404 on update with a bad id (#803)', function () {
            var store = fixture.store(5, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('POST /models/{id}', store.update);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                data: { 'jedan': 'dva' },
                type: 'POST'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store returns 404 on destroy with a bad id (#803)', function () {
            var store = fixture.store(2, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            stop();
            fixture('DELETE /models/{id}', store.destroy);
            $.ajax({
                url: '/models/6',
                dataType: 'json',
                type: 'DELETE'
            }).then(function () {
            }, function (data) {
                equal(data.statusText, 'error', 'Got an error');
                equal(data.responseText, 'Requested resource not found', 'Got correct status message');
                start();
            });
        });
        test('fixture.store can use id of different type (#742)', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    parentId: i * 2,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store.findAll);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json',
                data: { parentId: '4' }
            }).then(function (models) {
                equal(models.data.length, 1, 'Got one model');
                deepEqual(models.data[0], {
                    id: 2,
                    parentId: 4,
                    name: 'Object 2'
                });
                start();
            });
        });
        test('fixture("METHOD /path", store) should use the right method', function () {
            var store = fixture.store(100, function (i) {
                return {
                    id: i,
                    name: 'Object ' + i
                };
            });
            fixture('GET /models', store);
            stop();
            $.ajax({
                url: '/models',
                dataType: 'json'
            }).then(function (models) {
                equal(models.data.length, 100, 'Gotta catch up all!');
                start();
            });
        });
        test('fixture with response callback', 4, function () {
            fixture.delay = 10;
            fixture('responseCb', function (orig, response) {
                response({ sweet: 'ness' });
            });
            fixture('responseErrorCb', function (orig, response) {
                response(404, 'This is an error from callback');
            });
            stop();
            $.ajax({
                url: 'responseCb',
                dataType: 'json'
            }).done(function (data) {
                equal(data.sweet, 'ness', 'can.get works');
                start();
            });
            stop();
            $.ajax({
                url: 'responseErrorCb',
                dataType: 'json'
            }).fail(function (orig, error, text) {
                equal(error, 'error', 'Got error status');
                equal(orig.responseText, 'This is an error from callback', 'Got error text');
                start();
            });
            stop();
            fixture('cbWithTimeout', function (orig, response) {
                setTimeout(function () {
                    response([{ epic: 'ness' }]);
                }, 10);
            });
            $.ajax({
                url: 'cbWithTimeout',
                dataType: 'json'
            }).done(function (data) {
                equal(data[0].epic, 'ness', 'Got responsen with timeout');
                start();
            });
        });
        test('store create works with an empty array of items', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
        });
        test('store creates sequential ids', function () {
            var store = fixture.store(0, function () {
                return {};
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 0, 'the first id is 0');
            });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 1, 'the second id is 1');
            });
            store.destroy({ data: { id: 0 } });
            store.create({ data: {} }, function (responseData, responseHeaders) {
                equal(responseData.id, 2, 'the third id is 2');
            });
        });
        test('fixture updates request.data with id', function () {
            expect(1);
            stop();
            fixture('foo/{id}', function (request) {
                equal(request.data.id, 5);
                start();
            });
            $.ajax({ url: 'foo/5' });
        });
        test('create a store with array and comparison object', function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 2,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 2,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 2,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ], {
                year: function (a, b) {
                    return a == b;
                },
                modelId: function (a, b) {
                    return a == b;
                }
            });
            fixture('GET /presetStore', store.findAll);
            stop();
            $.ajax({
                url: '/presetStore',
                method: 'get',
                data: {
                    year: 2013,
                    modelId: 1
                },
                dataType: 'json'
            }).then(function (response) {
                equal(response.data[0].id, 1, 'got the first item');
                equal(response.data.length, 1, 'only got one item');
                start();
            });
        });
        test('store with objects allows .create, .update and .destroy (#1471)', 4, function () {
            var store = fixture.store([
                {
                    id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2012/07/01-2013-ford-mustang-gt-review-585x388.jpg'
                },
                {
                    id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    thumb: 'http://mustangsdaily.com/blog/wp-content/uploads/2013/03/2014-roush-mustang.jpg'
                },
                {
                    id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    thumb: 'http://images.newcars.com/images/car-pictures/original/2013-Ford-Focus-Sedan-S-4dr-Sedan-Exterior.png'
                },
                {
                    id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    thumb: 'http://ipinvite.iperceptions.com/Invitations/survey705/images_V2/top4.jpg'
                },
                {
                    id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/04-2013-nissan-altima-1333416664.jpg'
                },
                {
                    id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/2012/04/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    thumb: 'http://www.blogcdn.com/www.autoblog.com/media/201204/01-2013-nissan-altima-ny.jpg'
                },
                {
                    id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    thumb: 'http://images.thecarconnection.com/med/2013-nissan-leaf_100414473_m.jpg'
                }
            ]);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{id}', store.update);
            fixture('DELETE /cars/{id}', store.destroy);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1].id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved.id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                start();
            });
        });
        test('filtering works', function () {
            var next;
            var store = fixture.store([
                {
                    state: 'CA',
                    name: 'Casadina'
                },
                {
                    state: 'NT',
                    name: 'Alberny'
                }
            ], {});
            fixture({ 'GET /api/cities': store.findAll });
            stop();
            $.getJSON('/api/cities?state=CA').then(function (data) {
                deepEqual(data, {
                    data: [{
                            state: 'CA',
                            name: 'Casadina'
                        }],
                    count: 1
                });
                next();
            }, function (e) {
                ok(false, '' + e);
                start();
            });
            next = function () {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {});
                fixture({ 'GET /restaurants': store.findAll });
                $.getJSON('/api/restaurants?address[city]=Alberny').then(function (responseData) {
                    deepEqual(responseData, {
                        count: 1,
                        data: [{
                                _id: 2,
                                name: 'Crab Barn',
                                slug: 'crab-barn',
                                address: {
                                    city: 'Alberny',
                                    state: 'NT'
                                }
                            }]
                    });
                    last();
                }, function (e) {
                    ok(false);
                    start();
                });
            };
            function last() {
                var store = fixture.store([
                    {
                        _id: 1,
                        name: 'Cheese City',
                        slug: 'cheese-city',
                        address: {
                            city: 'Casadina',
                            state: 'CA'
                        }
                    },
                    {
                        _id: 2,
                        name: 'Crab Barn',
                        slug: 'crab-barn',
                        address: {
                            city: 'Alberny',
                            state: 'NT'
                        }
                    }
                ], {
                    'address.city': function (restaurantValue, paramValue, restaurant, params) {
                        return restaurant.address.city === paramValue;
                    }
                });
                var responseData = store.findAll({ data: { 'address.city': 'Alberny' } });
                deepEqual(responseData, {
                    count: 1,
                    data: [{
                            _id: 2,
                            name: 'Crab Barn',
                            slug: 'crab-barn',
                            address: {
                                city: 'Alberny',
                                state: 'NT'
                            }
                        }]
                });
                start();
            }
        });
        QUnit.test('onreadystatechange, event is passed', function () {
            fixture('GET something', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                ok(ev.target != null, 'the event object passed to onreadystatechange');
                start();
            };
            xhr.send();
            stop();
        });
        if (__dirname !== '/') {
            asyncTest('doesn\'t break onreadystatechange (#3)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        ok(true, 'we made a successful request');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        QUnit.module('XHR Shim');
        test('Supports onload', function () {
            var xhr = new XMLHttpRequest();
            QUnit.ok('onload' in xhr, 'shim passes onload detection');
        });
        if (__dirname !== '/') {
            asyncTest('supports addEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports removeEventListener on XHR shim', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                var onload = function () {
                    ok(false, 'this should not be called');
                };
                xhr.addEventListener('load', onload);
                xhr.removeEventListener('load', onload);
                xhr.onload = function () {
                    setTimeout(function () {
                        ok(true, 'didn\'t call the event listener');
                        start();
                    });
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        test('supports setDisableHeaderCheck', function () {
            var xhr = new XMLHttpRequest();
            try {
                xhr.setDisableHeaderCheck(true);
                ok(true, 'did not throw');
            } catch (e) {
                ok(false, 'do not support setDisableHeaderCheck');
            }
        });
        if (__dirname !== '/') {
            asyncTest('supports setRequestHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        equal(xhr._requestHeaders.foo, 'bar', 'header was set');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('supports getResponseHeader', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        var header = xhr.getResponseHeader('Content-Type');
                        ok(header.indexOf('application/json') >= 0, 'got correct header back');
                        start();
                    }
                };
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('supports getAllResponseHeaders', function () {
            fixture('GET something', function (req, res) {
                res(200, { message: 'this is the body' }, { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var headers = xhr.getAllResponseHeaders();
                    var parsed = parseHeaders(headers);
                    ok(typeof headers === 'string', 'got headers back');
                    ok(parsed.foo === 'bar', 'got proper values');
                    start();
                }
            };
            xhr.open('GET', 'something');
            xhr.send();
        });
        asyncTest('pass data to response handler (#13)', function () {
            fixture('GET something', function (req, res) {
                res(403, { message: 'No bad guys' });
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { message: 'No bad guys' }, 'correct response');
                equal(this.status, 403, 'correct status');
                start();
            };
            xhr.send();
        });
        asyncTest('pass return value for fixture', function () {
            fixture('GET something', { foo: 'bar' });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'something');
            xhr.onreadystatechange = function (ev) {
                deepEqual(JSON.parse(this.responseText), { foo: 'bar' }, 'correct response');
                equal(this.status, 200, 'correct status');
                start();
            };
            xhr.send();
        });
        if (__dirname !== '/') {
            asyncTest('pass headers in fallthrough', function () {
                var url = __dirname + '/fixtures/foobar.json';
                var xhr = new XMLHttpRequest();
                expect(2);
                xhr.open('GET', url);
                xhr.setRequestHeader('foo', 'bar');
                xhr.onreadystatechange = function (ev) {
                    var originalXhr = ev.target;
                    if (originalXhr.readyState === 1) {
                        originalXhr.setRequestHeader = function (key, val) {
                            equal(key, 'foo');
                            equal(val, 'bar');
                        };
                    }
                    if (originalXhr.readyState === 4) {
                        start();
                    }
                };
                xhr.send();
            });
        }
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            fixture('POST /cars', store.create);
            fixture('PUT /cars/{_id}', store.update);
            fixture('DELETE /cars/{_id}', store.destroy);
            fixture('GET /cars/{_id}', store.findOne);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        test('set.Algebra CRUD works (#12)', 5, function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            stop();
            findAll().then(function (carsData) {
                equal(carsData.data.length, 8, 'Got all cars');
                return $.ajax({
                    url: '/cars/' + carsData.data[1]._id,
                    method: 'DELETE',
                    dataType: 'json'
                });
            }).then(function () {
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 7, 'One car less');
                equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
            }).then(function () {
                return $.ajax({
                    url: '/cars',
                    method: 'post',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Altima',
                        type: 'new'
                    }
                });
            }).then(function (saved) {
                return $.ajax({
                    url: '/cars/' + saved._id,
                    method: 'put',
                    dataType: 'json',
                    data: {
                        modelId: 3,
                        year: 2015,
                        name: '2015 Nissan Altima'
                    }
                });
            }).then(function (updated) {
                return findAll();
            }).then(function (cars) {
                equal(cars.data.length, 8, 'New car created');
                return $.ajax({
                    url: '/cars/5',
                    method: 'get',
                    dataType: 'json'
                });
            }).then(function (car) {
                equal(car.name, '2013 Altima', 'get a single car works');
                start();
            });
        });
        asyncTest('set.Algebra clauses work', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'), {
                year: function (a, b) {
                    if (a === b) {
                        return true;
                    }
                    if (a && b) {
                        return +a === +b;
                    }
                    return false;
                }
            });
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('GET /cars', store.findAll);
            $.ajax({
                url: '/cars?where[year]=2013',
                dataType: 'json'
            }).then(function (carsData) {
                equal(carsData.data.length, 4, 'Where clause works with numbers');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Altima',
                    '2013 Focus',
                    '2013 Leaf',
                    '2013 Mustang'
                ], 'sort works');
                return $.ajax({
                    url: '/cars?where[year]=2013&orderBy=name&start=1&end=2',
                    dataType: 'json'
                });
            }).then(function (carsData) {
                var names = carsData.data.map(function (c) {
                    return c.name;
                });
                deepEqual(names, [
                    '2013 Focus',
                    '2013 Leaf'
                ], 'pagination works');
                start();
            });
        });
        test('storeConnection reset', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                }
            ], algebra);
            fixture('GET /cars', store.getListData);
            fixture('POST /cars', store.createData);
            fixture('PUT /cars/{_id}', store.updateData);
            fixture('DELETE /cars/{_id}', store.destroyData);
            fixture('GET /cars/{_id}', store.getData);
            var findAll = function () {
                return $.ajax({
                    url: '/cars',
                    dataType: 'json'
                });
            };
            $.ajax({
                url: '/cars/1',
                method: 'DELETE',
                dataType: 'json'
            }).then(function () {
                store.reset();
                return findAll();
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got all cars');
                start();
            });
            stop();
        });
        function makeAlgebraTest(fixtureUrl) {
            return function () {
                var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                    'used',
                    'new',
                    'certified'
                ]), set.props.rangeInclusive('start', 'end'));
                var store = fixture.store([
                    {
                        _id: 1,
                        modelId: 1,
                        year: 2013,
                        name: '2013 Mustang',
                        type: 'used'
                    },
                    {
                        _id: 2,
                        modelId: 1,
                        year: 2014,
                        name: '2014 Mustang',
                        type: 'new'
                    },
                    {
                        _id: 3,
                        modelId: 2,
                        year: 2013,
                        name: '2013 Focus',
                        type: 'used'
                    },
                    {
                        _id: 4,
                        modelId: 2,
                        year: 2014,
                        name: '2014 Focus',
                        type: 'certified'
                    },
                    {
                        _id: 5,
                        modelId: 3,
                        year: 2013,
                        name: '2013 Altima',
                        type: 'used'
                    },
                    {
                        _id: 6,
                        modelId: 3,
                        year: 2014,
                        name: '2014 Altima',
                        type: 'certified'
                    },
                    {
                        _id: 7,
                        modelId: 4,
                        year: 2013,
                        name: '2013 Leaf',
                        type: 'used'
                    },
                    {
                        _id: 8,
                        modelId: 4,
                        year: 2014,
                        name: '2014 Leaf',
                        type: 'used'
                    }
                ], algebra);
                fixture(fixtureUrl, store);
                var findAll = function () {
                    return $.ajax({
                        url: '/cars',
                        dataType: 'json'
                    });
                };
                stop();
                findAll().then(function (carsData) {
                    equal(carsData.data.length, 8, 'Got all cars');
                    return $.ajax({
                        url: '/cars/' + carsData.data[1]._id,
                        method: 'DELETE',
                        dataType: 'json'
                    });
                }).then(function () {
                    return findAll();
                }).then(function (carsData) {
                    equal(carsData.data.length, 7, 'One car less');
                    equal(carsData.data[1].name, '2013 Focus', 'Car actually deleted');
                }).then(function () {
                    return $.ajax({
                        url: '/cars',
                        method: 'post',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Altima',
                            type: 'new'
                        }
                    });
                }).then(function (saved) {
                    return $.ajax({
                        url: '/cars/' + saved._id,
                        method: 'put',
                        dataType: 'json',
                        data: {
                            modelId: 3,
                            year: 2015,
                            name: '2015 Nissan Altima'
                        }
                    });
                }).then(function (updated) {
                    return findAll();
                }).then(function (cars) {
                    equal(cars.data.length, 8, 'New car created');
                    return $.ajax({
                        url: '/cars/5',
                        method: 'get',
                        dataType: 'json'
                    });
                }).then(function (car) {
                    equal(car.name, '2013 Altima', 'get a single car works');
                    start();
                });
            };
        }
        test('set.Algebra CRUD works with easy hookup (#12)', 5, makeAlgebraTest('/cars/{_id}'));
        test('set.Algebra CRUD works with easy hookup and list-style url (#52)', 5, makeAlgebraTest('/cars'));
        test('store.getList and store.get', function () {
            var algebra = new set.Algebra(set.props.id('_id'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            equal(store.getList({ year: 2013 }).data.length, 4, 'filtered');
            deepEqual(store.get({ _id: 5 }).name, '2013 Altima', 'get');
        });
        asyncTest('supports addEventListener on shim using fixture', function () {
            fixture('/addEventListener', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports addEventListener');
                start();
            });
            xhr.open('GET', '/addEventListener');
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync on XHR shim (#23)', function () {
                var url = __dirname + '/fixtures/test.json';
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports addEventListener');
                });
                xhr.open('GET', url, false);
                xhr.send();
            });
        }
        test('supports sync fixtures (#23)', function () {
            fixture('/sync', function () {
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'our shim supports sync');
            });
            xhr.open('GET', '/sync', false);
            xhr.send();
        });
        if (__dirname !== '/') {
            test('supports sync redirect fixtures (#23)', function () {
                fixture('/sync_redirect', __dirname + '/fixtures/test.json');
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    ok(true, 'our shim supports sync redirect');
                });
                xhr.open('GET', '/sync_redirect', false);
                xhr.send();
            });
        }
        if (__dirname !== '/') {
            asyncTest('slow mode works (#26)', function () {
                var url = __dirname + '/fixtures/test.json';
                fixture({ url: url }, 1000);
                var xhr = new XMLHttpRequest();
                var startTime = new Date();
                xhr.addEventListener('load', function () {
                    var delay = new Date() - startTime;
                    ok(delay >= 900, delay + 'ms >= 900ms');
                    fixture({ url: url }, null);
                    start();
                });
                xhr.open('GET', url);
                xhr.send();
            });
        }
        asyncTest('onload should be triggered for HTTP error responses (#36)', function () {
            fixture('/onload', function (req, res) {
                res(400);
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                ok(true, 'onload should be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.addEventListener('error', function () {
                ok(false, 'onerror should not be invoked');
                fixture('/onload', null);
                start();
            });
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('responseText & responseXML should not be set for arraybuffer types (#38)', function () {
            fixture('/onload', '/test/fixtures/foo.json');
            var oldError = window.onerror;
            window.onerror = function (msg, url, line) {
                ok(false, 'There should not be an error');
                start();
            };
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/onload', null);
                window.onerror = oldError;
                ok(true, 'Got here without an error');
                start();
            });
            xhr.responseType = 'arraybuffer';
            xhr.open('GET', '/onload');
            xhr.send();
        });
        asyncTest('fixture with timeout does not run if $.ajax timeout less than delay', function () {
            var delay = fixture.delay;
            fixture.delay = 1000;
            fixture('/onload', function () {
                fixture('/onload', null);
                ok(false, 'timed out xhr did not abort');
                start();
            });
            $.ajax({
                url: '/onload',
                timeout: 50,
                error: function (xhr) {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, 'timeout');
                    equal(xhr.status, '0');
                    start();
                }
            });
            fixture.delay = delay;
        });
        asyncTest('response headers are set', function () {
            fixture('GET /todos', function (request, response) {
                response(200, '{}', { foo: 'bar' });
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                var headers = parseHeaders(xhr.getAllResponseHeaders());
                ok(headers.foo === 'bar', 'header was set');
                start();
            });
            xhr.open('GET', '/todos');
            xhr.send();
        });
        asyncTest('match values in get data', function () {
            fixture({
                method: 'GET',
                url: '/data-value',
                data: { name: 'justin' }
            }, function (request, response) {
                QUnit.ok(true, 'got it');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
            });
            xhr.open('GET', '/data-value?name=justin&age=22');
            xhr.send();
        });
        asyncTest('universal match (#2000)', function () {
            fixture({}, function () {
                ok(true, 'got hit');
                return {};
            });
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                QUnit.start();
                fixture.fixtures.splice(0, fixture.fixtures.length);
            });
            xhr.open('GET', '/something-totally-unexpected-62');
            xhr.send();
        });
        test('set.Algebra stores provide a count (#58)', function () {
            var algebra = new set.Algebra(new set.Translate('where', 'where'), set.props.id('_id'), set.props.sort('orderBy'), set.props.enum('type', [
                'used',
                'new',
                'certified'
            ]), set.props.rangeInclusive('start', 'end'));
            var store = fixture.store([
                {
                    _id: 1,
                    modelId: 1,
                    year: 2013,
                    name: '2013 Mustang',
                    type: 'used'
                },
                {
                    _id: 2,
                    modelId: 1,
                    year: 2014,
                    name: '2014 Mustang',
                    type: 'new'
                },
                {
                    _id: 3,
                    modelId: 2,
                    year: 2013,
                    name: '2013 Focus',
                    type: 'used'
                },
                {
                    _id: 4,
                    modelId: 2,
                    year: 2014,
                    name: '2014 Focus',
                    type: 'certified'
                },
                {
                    _id: 5,
                    modelId: 3,
                    year: 2013,
                    name: '2013 Altima',
                    type: 'used'
                },
                {
                    _id: 6,
                    modelId: 3,
                    year: 2014,
                    name: '2014 Altima',
                    type: 'certified'
                },
                {
                    _id: 7,
                    modelId: 4,
                    year: 2013,
                    name: '2013 Leaf',
                    type: 'used'
                },
                {
                    _id: 8,
                    modelId: 4,
                    year: 2014,
                    name: '2014 Leaf',
                    type: 'used'
                }
            ], algebra);
            fixture('/cars/{_id}', store);
            stop();
            $.ajax({
                url: '/cars',
                dataType: 'json',
                data: {
                    start: 2,
                    end: 3
                }
            }).then(function (carsData) {
                equal(carsData.data.length, 2, 'Got 2 cars');
                equal(carsData.count, 8, 'got the count');
                QUnit.start();
            }, function () {
                QUnit.ok(false, 'borked');
                QUnit.start();
            });
        });
        asyncTest('should allow Arrays as data type (#133)', function () {
            fixture('/array-data', function (req, res) {
                ok(req.data instanceof Array, 'data returned should be instance of Array');
                return {};
            });
            var data = [];
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/array-data', null);
                ok(true, 'should not throw when sending Array');
                start();
            });
            xhr.open('GET', '/array-data');
            xhr.send(data);
        });
        asyncTest('should allow FormData as data type (#133)', function () {
            fixture('/upload', function (req, res) {
                ok(req.data instanceof FormData, 'data returned should be instance of formdata');
                res(400);
            });
            var data = new FormData();
            var xhr = new XMLHttpRequest();
            xhr.addEventListener('load', function () {
                fixture('/upload', null);
                ok(true, 'should not throw when sending FormData');
                start();
            });
            xhr.open('POST', '/upload', true);
            xhr.send(data);
        });
        if ('onabort' in XMLHttpRequest._XHR.prototype) {
            asyncTest('fixture with timeout aborts if xhr timeout less than delay', function () {
                fixture('/onload', 1000);
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                xhr.send();
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
            });
            asyncTest('dynamic fixture with timeout does not run if xhr timeout less than delay', function () {
                var delay = fixture.delay;
                fixture.delay = 1000;
                fixture('/onload', function () {
                    fixture('/onload', null);
                    ok(false, 'timed out xhr did not abort');
                    start();
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/onload');
                setTimeout(function () {
                    xhr.abort();
                }, 50);
                xhr.send();
                xhr.addEventListener('abort', function () {
                    fixture('/onload', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.statusText, '');
                    equal(xhr.status, 0);
                    start();
                });
                fixture.delay = delay;
            });
            test('abort() sets readyState correctly', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('abort', function () {
                    fixture('/foo', null);
                    ok(true, 'Got to the error handler');
                    equal(xhr.status, 0);
                    equal(xhr.statusText, '');
                    setTimeout(function () {
                        equal(xhr.readyState, 0);
                        start();
                    }, 50);
                });
                xhr.send();
                xhr.abort();
            });
            test('abort() of already completed fixture', function () {
                stop();
                fixture('/foo', function () {
                    return {};
                });
                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/foo');
                xhr.addEventListener('load', function () {
                    fixture('/foo', null);
                    equal(xhr.readyState, 4);
                    xhr.abort();
                    start();
                });
                xhr.send();
            });
            asyncTest('should be able to call getResponseHeader onload', function () {
                fixture('/onload', function (req, res) {
                    res(400);
                });
                var xhr = new XMLHttpRequest();
                xhr.addEventListener('load', function () {
                    fixture('/onload', null);
                    xhr.getResponseHeader('Set-Cookie');
                    ok(true, 'should not throw when calling getResponseHeader');
                    start();
                });
                xhr.open('GET', '/onload');
                xhr.send();
            });
        }
    }('/', require, exports, module));
});
/*can-connect@1.5.18#data/parse/parse*/
define('can-connect@1.5.18#data/parse/parse', [
    'require',
    'exports',
    'module',
    'can-connect',
    'can-util/js/each/each',
    'can-util/js/get/get'
], function (require, exports, module) {
    var connect = require('can-connect');
    var each = require('can-util/js/each/each');
    var getObject = require('can-util/js/get/get');
    module.exports = connect.behavior('data/parse', function (baseConnection) {
        var behavior = {
            parseListData: function (responseData) {
                if (baseConnection.parseListData) {
                    responseData = baseConnection.parseListData.apply(this, arguments);
                }
                var result;
                if (Array.isArray(responseData)) {
                    result = { data: responseData };
                } else {
                    var prop = this.parseListProp || 'data';
                    responseData.data = getObject(responseData, prop);
                    result = responseData;
                    if (prop !== 'data') {
                        delete responseData[prop];
                    }
                    if (!Array.isArray(result.data)) {
                        throw new Error('Could not get any raw data while converting using .parseListData');
                    }
                }
                var arr = [];
                for (var i = 0; i < result.data.length; i++) {
                    arr.push(this.parseInstanceData(result.data[i]));
                }
                result.data = arr;
                return result;
            },
            parseInstanceData: function (props) {
                if (baseConnection.parseInstanceData) {
                    props = baseConnection.parseInstanceData.apply(this, arguments) || props;
                }
                return this.parseInstanceProp ? getObject(props, this.parseInstanceProp) || props : props;
            }
        };
        each(pairs, function (parseFunction, name) {
            behavior[name] = function (params) {
                var self = this;
                return baseConnection[name].call(this, params).then(function () {
                    return self[parseFunction].apply(self, arguments);
                });
            };
        });
        return behavior;
    });
    var pairs = {
        getListData: 'parseListData',
        getData: 'parseInstanceData',
        createData: 'parseInstanceData',
        updateData: 'parseInstanceData',
        destroyData: 'parseInstanceData'
    };
});
/*can-connect@1.5.18#helpers/weak-reference-map*/
define('can-connect@1.5.18#helpers/weak-reference-map', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var WeakReferenceMap = function () {
        this.set = {};
    };
    assign(WeakReferenceMap.prototype, {
        has: function (key) {
            return !!this.set[key];
        },
        addReference: function (key, item, referenceCount) {
            if (typeof key === 'undefined') {
                throw new Error('can-connect: You must provide a key to store a value in a WeakReferenceMap');
            }
            var data = this.set[key];
            if (!data) {
                data = this.set[key] = {
                    item: item,
                    referenceCount: 0,
                    key: key
                };
            }
            data.referenceCount += referenceCount || 1;
        },
        referenceCount: function (key) {
            var data = this.set[key];
            if (data) {
                return data.referenceCount;
            }
        },
        deleteReference: function (key) {
            var data = this.set[key];
            if (data) {
                data.referenceCount--;
                if (data.referenceCount === 0) {
                    delete this.set[key];
                }
            }
        },
        get: function (key) {
            var data = this.set[key];
            if (data) {
                return data.item;
            }
        },
        forEach: function (cb) {
            for (var id in this.set) {
                cb(this.set[id].item, id);
            }
        }
    });
    module.exports = WeakReferenceMap;
});
/*can-connect@1.5.18#helpers/id-merge*/
define('can-connect@1.5.18#helpers/id-merge', function (require, exports, module) {
    var map = [].map;
    module.exports = function (list, update, id, make) {
        var listIndex = 0, updateIndex = 0;
        while (listIndex < list.length && updateIndex < update.length) {
            var listItem = list[listIndex], updateItem = update[updateIndex], lID = id(listItem), uID = id(updateItem);
            if (id(listItem) === id(updateItem)) {
                listIndex++;
                updateIndex++;
                continue;
            }
            if (updateIndex + 1 < update.length && id(update[updateIndex + 1]) === lID) {
                list.splice(listIndex, 0, make(update[updateIndex]));
                listIndex++;
                updateIndex++;
                continue;
            } else if (listIndex + 1 < list.length && id(list[listIndex + 1]) === uID) {
                list.splice(listIndex, 1);
                listIndex++;
                updateIndex++;
                continue;
            } else {
                list.splice.apply(list, [
                    listIndex,
                    list.length - listIndex
                ].concat(map.call(update.slice(updateIndex), make)));
                return list;
            }
        }
        if (updateIndex === update.length && listIndex === list.length) {
            return;
        }
        list.splice.apply(list, [
            listIndex,
            list.length - listIndex
        ].concat(map.call(update.slice(updateIndex), make)));
        return;
    };
});
/*can-connect@1.5.18#constructor/constructor*/
define('can-connect@1.5.18#constructor/constructor', [
    'require',
    'exports',
    'module',
    'can-util/js/make-array/make-array',
    'can-util/js/assign/assign',
    'can-connect',
    'can-connect/helpers/weak-reference-map',
    'can-connect/helpers/overwrite',
    'can-connect/helpers/id-merge'
], function (require, exports, module) {
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var connect = require('can-connect');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var overwrite = require('can-connect/helpers/overwrite');
    var idMerge = require('can-connect/helpers/id-merge');
    module.exports = connect.behavior('constructor', function (baseConnection) {
        var behavior = {
            cidStore: new WeakReferenceMap(),
            _cid: 0,
            get: function (params) {
                var self = this;
                return this.getData(params).then(function (data) {
                    return self.hydrateInstance(data);
                });
            },
            getList: function (set) {
                set = set || {};
                var self = this;
                return this.getListData(set).then(function (data) {
                    return self.hydrateList(data, set);
                });
            },
            hydrateList: function (listData, set) {
                if (Array.isArray(listData)) {
                    listData = { data: listData };
                }
                var arr = [];
                for (var i = 0; i < listData.data.length; i++) {
                    arr.push(this.hydrateInstance(listData.data[i]));
                }
                listData.data = arr;
                if (this.list) {
                    return this.list(listData, set);
                } else {
                    var list = listData.data.slice(0);
                    list[this.listSetProp || '__listSet'] = set;
                    copyMetadata(listData, list);
                    return list;
                }
            },
            hydrateInstance: function (props) {
                if (this.instance) {
                    return this.instance(props);
                } else {
                    return assign({}, props);
                }
            },
            save: function (instance) {
                var serialized = this.serializeInstance(instance);
                var id = this.id(instance);
                var self = this;
                if (id === undefined) {
                    var cid = this._cid++;
                    this.cidStore.addReference(cid, instance);
                    return this.createData(serialized, cid).then(function (data) {
                        if (data !== undefined) {
                            self.createdInstance(instance, data);
                        }
                        self.cidStore.deleteReference(cid, instance);
                        return instance;
                    });
                } else {
                    return this.updateData(serialized).then(function (data) {
                        if (data !== undefined) {
                            self.updatedInstance(instance, data);
                        }
                        return instance;
                    });
                }
            },
            destroy: function (instance) {
                var serialized = this.serializeInstance(instance), self = this;
                return this.destroyData(serialized).then(function (data) {
                    if (data !== undefined) {
                        self.destroyedInstance(instance, data);
                    }
                    return instance;
                });
            },
            createdInstance: function (instance, props) {
                assign(instance, props);
            },
            updatedInstance: function (instance, data) {
                overwrite(instance, data, this.idProp);
            },
            updatedList: function (list, listData, set) {
                var instanceList = [];
                for (var i = 0; i < listData.data.length; i++) {
                    instanceList.push(this.hydrateInstance(listData.data[i]));
                }
                idMerge(list, instanceList, this.id.bind(this), this.hydrateInstance.bind(this));
                copyMetadata(listData, list);
            },
            destroyedInstance: function (instance, data) {
                overwrite(instance, data, this.idProp);
            },
            serializeInstance: function (instance) {
                return assign({}, instance);
            },
            serializeList: function (list) {
                var self = this;
                return makeArray(list).map(function (instance) {
                    return self.serializeInstance(instance);
                });
            },
            isNew: function (instance) {
                var id = this.id(instance);
                return !(id || id === 0);
            }
        };
        return behavior;
    });
    function copyMetadata(listData, list) {
        for (var prop in listData) {
            if (prop !== 'data') {
                if (typeof list.set === 'function') {
                    list.set(prop, listData[prop]);
                } else if (typeof list.attr === 'function') {
                    list.attr(prop, listData[prop]);
                } else {
                    list[prop] = listData[prop];
                }
            }
        }
    }
});
/*can-connect@1.5.18#helpers/weak-reference-set*/
define('can-connect@1.5.18#helpers/weak-reference-set', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var WeakReferenceSet = function () {
        this.set = [];
    };
    assign(WeakReferenceSet.prototype, {
        has: function (item) {
            return this._getIndex(item) !== -1;
        },
        addReference: function (item, referenceCount) {
            var index = this._getIndex(item);
            var data = this.set[index];
            if (!data) {
                data = {
                    item: item,
                    referenceCount: 0
                };
                this.set.push(data);
            }
            data.referenceCount += referenceCount || 1;
        },
        deleteReference: function (item) {
            var index = this._getIndex(item);
            var data = this.set[index];
            if (data) {
                data.referenceCount--;
                if (data.referenceCount === 0) {
                    this.set.splice(index, 1);
                }
            }
        },
        delete: function (item) {
            var index = this._getIndex(item);
            if (index !== -1) {
                this.set.splice(index, 1);
            }
        },
        get: function (item) {
            var data = this.set[this._getIndex(item)];
            if (data) {
                return data.item;
            }
        },
        referenceCount: function (item) {
            var data = this.set[this._getIndex(item)];
            if (data) {
                return data.referenceCount;
            }
        },
        _getIndex: function (item) {
            var index;
            this.set.every(function (data, i) {
                if (data.item === item) {
                    index = i;
                    return false;
                }
            });
            return index !== undefined ? index : -1;
        },
        forEach: function (cb) {
            return this.set.forEach(cb);
        }
    });
    module.exports = WeakReferenceSet;
});
/*can-connect@1.5.18#helpers/validate*/
define('can-connect@1.5.18#helpers/validate', [
    'require',
    'exports',
    'module',
    'can-validate-interface'
], function (require, exports, module) {
    var makeInterfaceValidator = require('can-validate-interface');
    module.exports = function (extendingBehavior, interfaces) {
        var validatedBehaviour = validateArgumentInterface(extendingBehavior, 0, interfaces, function (errors, baseBehavior) {
            throw new BehaviorInterfaceError(baseBehavior, extendingBehavior, errors);
        });
        Object.keys(extendingBehavior).forEach(function (k) {
            validatedBehaviour[k] = extendingBehavior[k];
        });
        validatedBehaviour.__interfaces = interfaces;
        return validatedBehaviour;
    };
    function validateArgumentInterface(func, argIndex, interfaces, errorHandler) {
        return function () {
            var errors = makeInterfaceValidator(interfaces)(arguments[argIndex]);
            if (errors && errorHandler) {
                errorHandler(errors, arguments[argIndex]);
            }
            return func.apply(this, arguments);
        };
    }
    function BehaviorInterfaceError(baseBehavior, extendingBehavior, missingProps) {
        var extendingName = extendingBehavior.behaviorName || 'anonymous behavior', baseName = baseBehavior.__behaviorName || 'anonymous behavior', message = 'can-connect: Extending behavior "' + extendingName + '" found base behavior "' + baseName + '" was missing required properties: ' + JSON.stringify(missingProps.related), instance = new Error(message);
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
        }
        return instance;
    }
    BehaviorInterfaceError.prototype = Object.create(Error.prototype, { constructor: { value: Error } });
    if (Object.setPrototypeOf) {
        Object.setPrototypeOf(BehaviorInterfaceError, Error);
    } else {
        BehaviorInterfaceError.__proto__ = Error;
    }
});
/*can-connect@1.5.18#constructor/store/store*/
define('can-connect@1.5.18#constructor/store/store', [
    'require',
    'exports',
    'module',
    'can-connect',
    'can-connect/helpers/weak-reference-map',
    'can-connect/helpers/weak-reference-set',
    'can-connect/helpers/sorted-set-json',
    'can-event',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var connect = require('can-connect');
    var WeakReferenceMap = require('can-connect/helpers/weak-reference-map');
    var WeakReferenceSet = require('can-connect/helpers/weak-reference-set');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var canEvent = require('can-event');
    var assign = require('can-util/js/assign/assign');
    var pendingRequests = 0;
    var noRequestsTimer = null;
    var requests = {
        increment: function (connection) {
            pendingRequests++;
            clearTimeout(noRequestsTimer);
        },
        decrement: function (connection) {
            pendingRequests--;
            if (pendingRequests === 0) {
                noRequestsTimer = setTimeout(function () {
                    requests.dispatch('end');
                }, module.exports.requestCleanupDelay);
            }
            if (pendingRequests < 0) {
                pendingRequests = 0;
            }
        },
        count: function () {
            return pendingRequests;
        }
    };
    assign(requests, canEvent);
    var constructorStore = connect.behavior('constructor/store', function (baseConnection) {
        var behavior = {
            instanceStore: new WeakReferenceMap(),
            newInstanceStore: new WeakReferenceSet(),
            listStore: new WeakReferenceMap(),
            init: function () {
                if (baseConnection.init) {
                    baseConnection.init.apply(this, arguments);
                }
                if (!this.hasOwnProperty('_requestInstances')) {
                    this._requestInstances = {};
                }
                if (!this.hasOwnProperty('_requestLists')) {
                    this._requestLists = {};
                }
                requests.on('end', function () {
                    var id;
                    for (id in this._requestInstances) {
                        this.instanceStore.deleteReference(id);
                    }
                    this._requestInstances = {};
                    for (id in this._requestLists) {
                        this.listStore.deleteReference(id);
                        this._requestLists[id].forEach(this.deleteInstanceReference.bind(this));
                    }
                    this._requestLists = {};
                }.bind(this));
            },
            _finishedRequest: function () {
                requests.decrement(this);
            },
            addInstanceReference: function (instance, id) {
                var ID = id || this.id(instance);
                if (ID === undefined) {
                    this.newInstanceStore.addReference(instance);
                } else {
                    this.instanceStore.addReference(ID, instance);
                }
            },
            createdInstance: function (instance, props) {
                baseConnection.createdInstance.apply(this, arguments);
                this.moveCreatedInstanceToInstanceStore(instance);
            },
            moveCreatedInstanceToInstanceStore: function (instance) {
                var ID = this.id(instance);
                if (this.newInstanceStore.has(instance) && ID !== undefined) {
                    var referenceCount = this.newInstanceStore.referenceCount(instance);
                    this.newInstanceStore.delete(instance);
                    this.instanceStore.addReference(ID, instance, referenceCount);
                }
            },
            addInstanceMetaData: function (instance, name, value) {
                var data = this.instanceStore.set[this.id(instance)];
                if (data) {
                    data[name] = value;
                }
            },
            getInstanceMetaData: function (instance, name) {
                var data = this.instanceStore.set[this.id(instance)];
                if (data) {
                    return data[name];
                }
            },
            deleteInstanceMetaData: function (instance, name) {
                var data = this.instanceStore.set[this.id(instance)];
                delete data[name];
            },
            deleteInstanceReference: function (instance) {
                var ID = this.id(instance);
                if (ID === undefined) {
                    this.newInstanceStore.deleteReference(instance);
                } else {
                    this.instanceStore.deleteReference(this.id(instance), instance);
                }
            },
            addListReference: function (list, set) {
                var id = sortedSetJSON(set || this.listSet(list));
                if (id) {
                    this.listStore.addReference(id, list);
                    list.forEach(function (instance) {
                        this.addInstanceReference(instance);
                    }.bind(this));
                }
            },
            deleteListReference: function (list, set) {
                var id = sortedSetJSON(set || this.listSet(list));
                if (id) {
                    this.listStore.deleteReference(id, list);
                    list.forEach(this.deleteInstanceReference.bind(this));
                }
            },
            hydratedInstance: function (instance) {
                if (requests.count() > 0) {
                    var id = this.id(instance);
                    if (!this._requestInstances[id]) {
                        this.addInstanceReference(instance);
                        this._requestInstances[id] = instance;
                    }
                }
            },
            hydrateInstance: function (props) {
                var id = this.id(props);
                if ((id || id === 0) && this.instanceStore.has(id)) {
                    var storeInstance = this.instanceStore.get(id);
                    this.updatedInstance(storeInstance, props);
                    return storeInstance;
                }
                var instance = baseConnection.hydrateInstance.call(this, props);
                this.hydratedInstance(instance);
                return instance;
            },
            hydratedList: function (list, set) {
                if (requests.count() > 0) {
                    var id = sortedSetJSON(set || this.listSet(list));
                    if (id) {
                        if (!this._requestLists[id]) {
                            this.addListReference(list, set);
                            this._requestLists[id] = list;
                        }
                    }
                }
            },
            hydrateList: function (listData, set) {
                set = set || this.listSet(listData);
                var id = sortedSetJSON(set);
                if (id && this.listStore.has(id)) {
                    var storeList = this.listStore.get(id);
                    this.updatedList(storeList, listData, set);
                    return storeList;
                }
                var list = baseConnection.hydrateList.call(this, listData, set);
                this.hydratedList(list, set);
                return list;
            },
            getList: function (listSet) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.getList.call(this, listSet);
                promise.then(function (instances) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            get: function (params) {
                var self = this;
                requests.increment(this);
                var promise = baseConnection.get.call(this, params);
                promise.then(function (instance) {
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            save: function (instance) {
                var self = this;
                requests.increment(this);
                var updating = !this.isNew(instance);
                if (updating) {
                    this.addInstanceReference(instance);
                }
                var promise = baseConnection.save.call(this, instance);
                promise.then(function (instances) {
                    if (updating) {
                        self.deleteInstanceReference(instance);
                    }
                    self._finishedRequest();
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            destroy: function (instance) {
                var self = this;
                this.addInstanceReference(instance);
                requests.increment(this);
                var promise = baseConnection.destroy.call(this, instance);
                promise.then(function (instance) {
                    self._finishedRequest();
                    self.deleteInstanceReference(instance);
                }, function () {
                    self._finishedRequest();
                });
                return promise;
            },
            updatedList: function (list, listData, set) {
                var oldList = list.slice(0);
                if (!listData.data && typeof listData.length === 'number') {
                    listData = { data: listData };
                }
                if (baseConnection.updatedList) {
                    baseConnection.updatedList.call(this, list, listData, set);
                    list.forEach(function (instance) {
                        this.addInstanceReference(instance);
                    }.bind(this));
                } else if (listData.data) {
                    listData.data.forEach(function (instance) {
                        this.addInstanceReference(instance);
                    }.bind(this));
                }
                oldList.forEach(this.deleteInstanceReference.bind(this));
            }
        };
        return behavior;
    });
    constructorStore.requests = requests;
    constructorStore.requestCleanupDelay = 10;
    module.exports = constructorStore;
});
/*can-connect@1.5.18#can/map/map*/
define('can-connect@1.5.18#can/map/map', [
    'require',
    'exports',
    'module',
    'can-util/js/each/each',
    'can-connect',
    'can-event/batch/batch',
    'can-event',
    'can-observation',
    'can-util/js/is-plain-object/is-plain-object',
    'can-types',
    'can-util/js/each/each',
    'can-util/js/is-function/is-function',
    'can-util/js/dev/dev',
    'can-reflect'
], function (require, exports, module) {
    'use strict';
    var each = require('can-util/js/each/each');
    var connect = require('can-connect');
    var canBatch = require('can-event/batch/batch');
    var canEvent = require('can-event');
    var Observation = require('can-observation');
    var isPlainObject = require('can-util/js/is-plain-object/is-plain-object');
    var types = require('can-types');
    var each = require('can-util/js/each/each');
    var isFunction = require('can-util/js/is-function/is-function');
    var dev = require('can-util/js/dev/dev');
    var canReflect = require('can-reflect');
    var setExpando = function (map, prop, value) {
        if ('attr' in map) {
            map[prop] = value;
        } else {
            map._data[prop] = value;
        }
    };
    var getExpando = function (map, prop) {
        if ('attr' in map) {
            return map[prop];
        } else {
            return map._data[prop];
        }
    };
    var canMapBehavior = connect.behavior('can/map', function (baseConnection) {
        var behavior = {
            init: function () {
                this.Map = this.Map || types.DefaultMap.extend({});
                this.List = this.List || types.DefaultList.extend({});
                overwrite(this, this.Map, mapOverwrites, mapStaticOverwrites);
                overwrite(this, this.List, listPrototypeOverwrites, listStaticOverwrites);
                baseConnection.init.apply(this, arguments);
            },
            id: function (instance) {
                if (!isPlainObject(instance)) {
                    var ids = [], algebra = this.algebra;
                    if (algebra && algebra.clauses && algebra.clauses.id) {
                        for (var prop in algebra.clauses.id) {
                            ids.push(readObservable(instance, prop));
                        }
                    }
                    if (this.idProp && !ids.length) {
                        ids.push(readObservable(instance, this.idProp));
                    }
                    if (!ids.length) {
                        ids.push(readObservable(instance, 'id'));
                    }
                    return ids.length > 1 ? ids.join('@|@') : ids[0];
                } else {
                    return baseConnection.id(instance);
                }
            },
            serializeInstance: function (instance) {
                return instance.serialize();
            },
            serializeList: function (list) {
                return list.serialize();
            },
            instance: function (props) {
                var _Map = this.Map || types.DefaultMap;
                return new _Map(props);
            },
            list: function (listData, set) {
                var _List = this.List || this.Map && this.Map.List || types.DefaultList;
                var list = new _List(listData.data);
                each(listData, function (val, prop) {
                    if (prop !== 'data') {
                        list[list.set ? 'set' : 'attr'](prop, val);
                    }
                });
                list.__listSet = set;
                return list;
            },
            updatedList: function () {
                canBatch.start();
                var res = baseConnection.updatedList.apply(this, arguments);
                canBatch.stop();
                return res;
            },
            save: function (instance) {
                setExpando(instance, '_saving', true);
                canEvent.dispatch.call(instance, '_saving', [
                    true,
                    false
                ]);
                var done = function () {
                    setExpando(instance, '_saving', false);
                    canEvent.dispatch.call(instance, '_saving', [
                        false,
                        true
                    ]);
                };
                var base = baseConnection.save.apply(this, arguments);
                base.then(done, done);
                return base;
            },
            destroy: function (instance) {
                setExpando(instance, '_destroying', true);
                canEvent.dispatch.call(instance, '_destroying', [
                    true,
                    false
                ]);
                var done = function () {
                    setExpando(instance, '_destroying', false);
                    canEvent.dispatch.call(instance, '_destroying', [
                        false,
                        true
                    ]);
                };
                var base = baseConnection.destroy.apply(this, arguments);
                base.then(done, done);
                return base;
            }
        };
        each([
            'created',
            'updated',
            'destroyed'
        ], function (funcName) {
            behavior[funcName + 'Instance'] = function (instance, props) {
                if (props && typeof props === 'object') {
                    if (this.constructor.removeAttr) {
                        canReflect.updateDeep(instance, props);
                    } else {
                        canReflect.assignDeep(instance, props);
                    }
                }
                if (funcName === 'created' && this.moveCreatedInstanceToInstanceStore) {
                    this.moveCreatedInstanceToInstanceStore(instance);
                }
                canMapBehavior.callbackInstanceEvents(funcName, instance);
            };
        });
        return behavior;
    });
    canMapBehavior.callbackInstanceEvents = function (funcName, instance) {
        var constructor = instance.constructor;
        canBatch.start();
        canEvent.dispatch.call(instance, {
            type: funcName,
            target: instance
        });
        canEvent.dispatch.call(constructor, funcName, [instance]);
        canBatch.stop();
    };
    var callCanReadingOnIdRead = true;
    var mapStaticOverwrites = {
        getList: function (base, connection) {
            return function (set) {
                return connection.getList(set);
            };
        },
        findAll: function (base, connection) {
            return function (set) {
                return connection.getList(set);
            };
        },
        get: function (base, connection) {
            return function (params) {
                return connection.get(params);
            };
        },
        findOne: function (base, connection) {
            return function (params) {
                return connection.get(params);
            };
        }
    };
    var mapOverwrites = {
        _eventSetup: function (base, connection) {
            return function () {
                callCanReadingOnIdRead = false;
                if (connection.addInstanceReference) {
                    connection.addInstanceReference(this);
                }
                callCanReadingOnIdRead = true;
                return base.apply(this, arguments);
            };
        },
        _eventTeardown: function (base, connection) {
            return function () {
                callCanReadingOnIdRead = false;
                if (connection.deleteInstanceReference) {
                    connection.deleteInstanceReference(this);
                }
                callCanReadingOnIdRead = true;
                return base.apply(this, arguments);
            };
        },
        ___set: function (base, connection) {
            return function (prop, val) {
                base.apply(this, arguments);
                if (prop === connection.idProp && this.__bindEvents && this.__bindEvents._lifecycleBindings) {
                    connection.addInstanceReference(this);
                }
            };
        },
        isNew: function (base, connection) {
            return function () {
                return connection.isNew(this);
            };
        },
        isSaving: function (base, connection) {
            return function () {
                Observation.add(this, '_saving');
                return !!getExpando(this, '_saving');
            };
        },
        isDestroying: function (base, connection) {
            return function () {
                Observation.add(this, '_destroying');
                return !!getExpando(this, '_destroying');
            };
        },
        save: function (base, connection) {
            return function (success, error) {
                var promise = connection.save(this);
                promise.then(success, error);
                return promise;
            };
        },
        destroy: function (base, connection) {
            return function (success, error) {
                var promise;
                if (this.isNew()) {
                    promise = Promise.resolve(this);
                    connection.destroyedInstance(this, {});
                } else {
                    promise = connection.destroy(this);
                }
                promise.then(success, error);
                return promise;
            };
        }
    };
    var listPrototypeOverwrites = {
        setup: function (base, connection) {
            return function (params) {
                if (isPlainObject(params) && !Array.isArray(params)) {
                    this.__listSet = params;
                    base.apply(this);
                    this.replace(canReflect.isPromise(params) ? params : connection.getList(params));
                } else {
                    base.apply(this, arguments);
                }
            };
        },
        _eventSetup: function (base, connection) {
            return function () {
                if (connection.addListReference) {
                    connection.addListReference(this);
                }
                if (base) {
                    return base.apply(this, arguments);
                }
            };
        },
        _eventTeardown: function (base, connection) {
            return function () {
                if (connection.deleteListReference) {
                    connection.deleteListReference(this);
                }
                if (base) {
                    return base.apply(this, arguments);
                }
            };
        }
    };
    var listStaticOverwrites = {
        _bubbleRule: function (base, connection) {
            return function (eventName, list) {
                var bubbleRules = base(eventName, list);
                bubbleRules.push('destroyed');
                return bubbleRules;
            };
        }
    };
    var readObservable = function (instance, prop) {
        if ('__get' in instance) {
            if (callCanReadingOnIdRead) {
                Observation.add(instance, prop);
            }
            return instance.__get(prop);
        } else {
            if (callCanReadingOnIdRead) {
                return instance[prop];
            } else {
                return Observation.ignore(function () {
                    return instance[prop];
                })();
            }
        }
    };
    var overwrite = function (connection, Constructor, prototype, statics) {
        var prop;
        for (prop in prototype) {
            Constructor.prototype[prop] = prototype[prop](Constructor.prototype[prop], connection);
        }
        if (statics) {
            for (prop in statics) {
                Constructor[prop] = statics[prop](Constructor[prop], connection);
            }
        }
    };
    module.exports = canMapBehavior;
});
/*can-connect@1.5.18#data/callbacks/callbacks*/
define('can-connect@1.5.18#data/callbacks/callbacks', [
    'require',
    'exports',
    'module',
    'can-connect',
    'can-util/js/each/each'
], function (require, exports, module) {
    var connect = require('can-connect');
    var each = require('can-util/js/each/each');
    var pairs = {
        getListData: 'gotListData',
        createData: 'createdData',
        updateData: 'updatedData',
        destroyData: 'destroyedData'
    };
    var dataCallbackBehavior = connect.behavior('data/callbacks', function (baseConnection) {
        var behavior = {};
        each(pairs, function (callbackName, name) {
            behavior[name] = function (params, cid) {
                var self = this;
                return baseConnection[name].call(this, params).then(function (data) {
                    if (self[callbackName]) {
                        return self[callbackName].call(self, data, params, cid);
                    } else {
                        return data;
                    }
                });
            };
        });
        return behavior;
    });
    module.exports = dataCallbackBehavior;
});
/*can-connect@1.5.18#real-time/real-time*/
define('can-connect@1.5.18#real-time/real-time', [
    'require',
    'exports',
    'module',
    '../can-connect',
    'can-set',
    'can-connect/helpers/set-add',
    'can-connect/helpers/get-index-by-id',
    'can-util/js/dev/dev'
], function (require, exports, module) {
    var connect = require('../can-connect');
    var canSet = require('can-set');
    var setAdd = require('can-connect/helpers/set-add');
    var indexOf = require('can-connect/helpers/get-index-by-id');
    var canDev = require('can-util/js/dev/dev');
    module.exports = connect.behavior('real-time', function (baseConnection) {
        var createPromise = Promise.resolve();
        return {
            createData: function () {
                var promise = baseConnection.createData.apply(this, arguments);
                var cleanPromise = promise.catch(function () {
                    return '';
                });
                createPromise = Promise.all([
                    createPromise,
                    cleanPromise
                ]);
                return promise;
            },
            createInstance: function (props) {
                var self = this;
                return new Promise(function (resolve, reject) {
                    createPromise.then(function () {
                        setTimeout(function () {
                            var id = self.id(props);
                            var instance = self.instanceStore.get(id);
                            var serialized;
                            if (instance) {
                                resolve(self.updateInstance(props));
                            } else {
                                instance = self.hydrateInstance(props);
                                serialized = self.serializeInstance(instance);
                                self.addInstanceReference(instance);
                                Promise.resolve(self.createdData(props, serialized)).then(function () {
                                    self.deleteInstanceReference(instance);
                                    resolve(instance);
                                });
                            }
                        }, 1);
                    });
                });
            },
            createdData: function (props, params, cid) {
                var instance;
                if (cid !== undefined) {
                    instance = this.cidStore.get(cid);
                } else {
                    instance = this.instanceStore.get(this.id(props));
                }
                this.addInstanceReference(instance, this.id(props));
                this.createdInstance(instance, props);
                create.call(this, this.serializeInstance(instance));
                this.deleteInstanceReference(instance);
                return undefined;
            },
            updatedData: function (props, params) {
                var instance = this.instanceStore.get(this.id(params));
                this.updatedInstance(instance, props);
                update.call(this, this.serializeInstance(instance));
                return undefined;
            },
            updateInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                this.addInstanceReference(instance);
                var serialized = this.serializeInstance(instance), self = this;
                return Promise.resolve(this.updatedData(props, serialized)).then(function () {
                    self.deleteInstanceReference(instance);
                    return instance;
                });
            },
            destroyedData: function (props, params) {
                var id = this.id(params || props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                var serialized = this.serializeInstance(instance);
                this.destroyedInstance(instance, props);
                destroy.call(this, serialized);
                return undefined;
            },
            destroyInstance: function (props) {
                var id = this.id(props);
                var instance = this.instanceStore.get(id);
                if (!instance) {
                    instance = this.hydrateInstance(props);
                }
                this.addInstanceReference(instance);
                var serialized = this.serializeInstance(instance), self = this;
                return Promise.resolve(this.destroyedData(props, serialized)).then(function () {
                    self.deleteInstanceReference(instance);
                    return instance;
                });
            }
        };
    });
    var create = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (canSet.has(set, props, self.algebra)) {
                if (index === -1) {
                    var items = self.serializeList(list);
                    self.updatedList(list, { data: setAdd(self, set, items, props, self.algebra) }, set);
                } else {
                }
            }
        });
    };
    var update = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var items;
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (canSet.has(set, props, self.algebra)) {
                items = self.serializeList(list);
                if (index === -1) {
                    self.updatedList(list, { data: setAdd(self, set, items, props, self.algebra) }, set);
                } else {
                    var sortedIndex = canSet.index(set, items, props, self.algebra);
                    if (sortedIndex !== undefined && sortedIndex !== index) {
                        var copy = items.slice(0);
                        if (index < sortedIndex) {
                            copy.splice(sortedIndex, 0, props);
                            copy.splice(index, 1);
                        } else {
                            copy.splice(index, 1);
                            copy.splice(sortedIndex, 0, props);
                        }
                        self.updatedList(list, { data: copy }, set);
                    }
                }
            } else if (index !== -1) {
                items = self.serializeList(list);
                items.splice(index, 1);
                self.updatedList(list, { data: items }, set);
            }
        });
    };
    var destroy = function (props) {
        var self = this;
        this.listStore.forEach(function (list, id) {
            var set = JSON.parse(id);
            var index = indexOf(self, props, list);
            if (index !== -1) {
                var items = self.serializeList(list);
                items.splice(index, 1);
                self.updatedList(list, { data: items }, set);
            }
        });
    };
});
/*can-connect@1.5.18#constructor/callbacks-once/callbacks-once*/
define('can-connect@1.5.18#constructor/callbacks-once/callbacks-once', [
    'require',
    'exports',
    'module',
    'can-connect',
    'can-connect/helpers/sorted-set-json'
], function (require, exports, module) {
    var connect = require('can-connect');
    var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
    var forEach = [].forEach;
    var callbacks = [
        'createdInstance',
        'updatedInstance',
        'destroyedInstance'
    ];
    var callbacksOnceBehavior = connect.behavior('constructor/callbacks-once', function (baseConnection) {
        var behavior = {};
        forEach.call(callbacks, function (name) {
            behavior[name] = function (instance, data) {
                var lastSerialized = this.getInstanceMetaData(instance, 'last-data-' + name);
                var serialize = sortedSetJSON(data);
                if (lastSerialized !== serialize) {
                    var result = baseConnection[name].apply(this, arguments);
                    this.addInstanceMetaData(instance, 'last-data-' + name, serialize);
                    return result;
                }
            };
        });
        return behavior;
    });
    module.exports = callbacksOnceBehavior;
});
/*ms-signalr-client@2.2.7#jquery.signalR*/
define('ms-signalr-client@2.2.7#jquery.signalR', [
    'module',
    '@loader',
    'require'
], function (module, loader, require) {
    loader.get('@@global-helpers').prepareGlobal({
        require: require,
        name: module.id,
        deps: []
    });
    var define = loader.global.define;
    var require = loader.global.require;
    var source = '/* jquery.signalR.core.js */\r\n/*global window:false */\r\n/*!\r\n * ASP.NET SignalR JavaScript Library v2.2.2-pre\r\n * http://signalr.net/\r\n *\r\n * Copyright (c) .NET Foundation. All rights reserved.\r\n * Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n *\r\n */\r\n\r\n/// <reference path="Scripts/jquery-1.6.4.js" />\r\n/// <reference path="jquery.signalR.version.js" />\r\n(function ($, window, undefined) {\r\n\r\n    var resources = {\r\n        nojQuery: "jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.",\r\n        noTransportOnInit: "No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.",\r\n        errorOnNegotiate: "Error during negotiation request.",\r\n        stoppedWhileLoading: "The connection was stopped during page load.",\r\n        stoppedWhileNegotiating: "The connection was stopped during the negotiate request.",\r\n        errorParsingNegotiateResponse: "Error parsing negotiate response.",\r\n        errorDuringStartRequest: "Error during start request. Stopping the connection.",\r\n        stoppedDuringStartRequest: "The connection was stopped during the start request.",\r\n        errorParsingStartResponse: "Error parsing start response: \'{0}\'. Stopping the connection.",\r\n        invalidStartResponse: "Invalid start response: \'{0}\'. Stopping the connection.",\r\n        protocolIncompatible: "You are using a version of the client that isn\'t compatible with the server. Client version {0}, server version {1}.",\r\n        sendFailed: "Send failed.",\r\n        parseFailed: "Failed at parsing response: {0}",\r\n        longPollFailed: "Long polling request failed.",\r\n        eventSourceFailedToConnect: "EventSource failed to connect.",\r\n        eventSourceError: "Error raised by EventSource",\r\n        webSocketClosed: "WebSocket closed.",\r\n        pingServerFailedInvalidResponse: "Invalid ping response when pinging server: \'{0}\'.",\r\n        pingServerFailed: "Failed to ping server.",\r\n        pingServerFailedStatusCode: "Failed to ping server.  Server responded with status code {0}, stopping the connection.",\r\n        pingServerFailedParse: "Failed to parse ping server response, stopping the connection.",\r\n        noConnectionTransport: "Connection is in an invalid state, there is no transport active.",\r\n        webSocketsInvalidState: "The Web Socket transport is in an invalid state, transitioning into reconnecting.",\r\n        reconnectTimeout: "Couldn\'t reconnect within the configured timeout of {0} ms, disconnecting.",\r\n        reconnectWindowTimeout: "The client has been inactive since {0} and it has exceeded the inactivity timeout of {1} ms. Stopping the connection."\r\n    };\r\n\r\n    if (typeof ($) !== "function") {\r\n        // no jQuery!\r\n        throw new Error(resources.nojQuery);\r\n    }\r\n\r\n    var signalR,\r\n        _connection,\r\n        _pageLoaded = (window.document.readyState === "complete"),\r\n        _pageWindow = $(window),\r\n        _negotiateAbortText = "__Negotiate Aborted__",\r\n        events = {\r\n            onStart: "onStart",\r\n            onStarting: "onStarting",\r\n            onReceived: "onReceived",\r\n            onError: "onError",\r\n            onConnectionSlow: "onConnectionSlow",\r\n            onReconnecting: "onReconnecting",\r\n            onReconnect: "onReconnect",\r\n            onStateChanged: "onStateChanged",\r\n            onDisconnect: "onDisconnect"\r\n        },\r\n        ajaxDefaults = {\r\n            processData: true,\r\n            timeout: null,\r\n            async: true,\r\n            global: false,\r\n            cache: false\r\n        },\r\n        log = function (msg, logging) {\r\n            if (logging === false) {\r\n                return;\r\n            }\r\n            var m;\r\n            if (typeof (window.console) === "undefined") {\r\n                return;\r\n            }\r\n            m = "[" + new Date().toTimeString() + "] SignalR: " + msg;\r\n            if (window.console.debug) {\r\n                window.console.debug(m);\r\n            } else if (window.console.log) {\r\n                window.console.log(m);\r\n            }\r\n        },\r\n\r\n        changeState = function (connection, expectedState, newState) {\r\n            if (expectedState === connection.state) {\r\n                connection.state = newState;\r\n\r\n                $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isDisconnecting = function (connection) {\r\n            return connection.state === signalR.connectionState.disconnected;\r\n        },\r\n\r\n        supportsKeepAlive = function (connection) {\r\n            return connection._.keepAliveData.activated &&\r\n                   connection.transport.supportsKeepAlive(connection);\r\n        },\r\n\r\n        configureStopReconnectingTimeout = function (connection) {\r\n            var stopReconnectingTimeout,\r\n                onReconnectTimeout;\r\n\r\n            // Check if this connection has already been configured to stop reconnecting after a specified timeout.\r\n            // Without this check if a connection is stopped then started events will be bound multiple times.\r\n            if (!connection._.configuredStopReconnectingTimeout) {\r\n                onReconnectTimeout = function (connection) {\r\n                    var message = signalR._.format(signalR.resources.reconnectTimeout, connection.disconnectTimeout);\r\n                    connection.log(message);\r\n                    $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */ "TimeoutException")]);\r\n                    connection.stop(/* async */ false, /* notifyServer */ false);\r\n                };\r\n\r\n                connection.reconnecting(function () {\r\n                    var connection = this;\r\n\r\n                    // Guard against state changing in a previous user defined even handler\r\n                    if (connection.state === signalR.connectionState.reconnecting) {\r\n                        stopReconnectingTimeout = window.setTimeout(function () { onReconnectTimeout(connection); }, connection.disconnectTimeout);\r\n                    }\r\n                });\r\n\r\n                connection.stateChanged(function (data) {\r\n                    if (data.oldState === signalR.connectionState.reconnecting) {\r\n                        // Clear the pending reconnect timeout check\r\n                        window.clearTimeout(stopReconnectingTimeout);\r\n                    }\r\n                });\r\n\r\n                connection._.configuredStopReconnectingTimeout = true;\r\n            }\r\n        };\r\n\r\n    signalR = function (url, qs, logging) {\r\n        /// <summary>Creates a new SignalR connection for the given url</summary>\r\n        /// <param name="url" type="String">The URL of the long polling endpoint</param>\r\n        /// <param name="qs" type="Object">\r\n        ///     [Optional] Custom querystring parameters to add to the connection URL.\r\n        ///     If an object, every non-function member will be added to the querystring.\r\n        ///     If a string, it\'s added to the QS as specified.\r\n        /// </param>\r\n        /// <param name="logging" type="Boolean">\r\n        ///     [Optional] A flag indicating whether connection logging is enabled to the browser\r\n        ///     console/log. Defaults to false.\r\n        /// </param>\r\n\r\n        return new signalR.fn.init(url, qs, logging);\r\n    };\r\n\r\n    signalR._ = {\r\n        defaultContentType: "application/x-www-form-urlencoded; charset=UTF-8",\r\n\r\n        ieVersion: (function () {\r\n            var version,\r\n                matches;\r\n\r\n            if (window.navigator.appName === \'Microsoft Internet Explorer\') {\r\n                // Check if the user agent has the pattern "MSIE (one or more numbers).(one or more numbers)";\r\n                matches = /MSIE ([0-9]+\\.[0-9]+)/.exec(window.navigator.userAgent);\r\n\r\n                if (matches) {\r\n                    version = window.parseFloat(matches[1]);\r\n                }\r\n            }\r\n\r\n            // undefined value means not IE\r\n            return version;\r\n        })(),\r\n\r\n        error: function (message, source, context) {\r\n            var e = new Error(message);\r\n            e.source = source;\r\n\r\n            if (typeof context !== "undefined") {\r\n                e.context = context;\r\n            }\r\n\r\n            return e;\r\n        },\r\n\r\n        transportError: function (message, transport, source, context) {\r\n            var e = this.error(message, source, context);\r\n            e.transport = transport ? transport.name : undefined;\r\n            return e;\r\n        },\r\n\r\n        format: function () {\r\n            /// <summary>Usage: format("Hi {0}, you are {1}!", "Foo", 100) </summary>\r\n            var s = arguments[0];\r\n            for (var i = 0; i < arguments.length - 1; i++) {\r\n                s = s.replace("{" + i + "}", arguments[i + 1]);\r\n            }\r\n            return s;\r\n        },\r\n\r\n        firefoxMajorVersion: function (userAgent) {\r\n            // Firefox user agents: http://useragentstring.com/pages/Firefox/\r\n            var matches = userAgent.match(/Firefox\\/(\\d+)/);\r\n            if (!matches || !matches.length || matches.length < 2) {\r\n                return 0;\r\n            }\r\n            return parseInt(matches[1], 10 /* radix */);\r\n        },\r\n\r\n        configurePingInterval: function (connection) {\r\n            var config = connection._.config,\r\n                onFail = function (error) {\r\n                    $(connection).triggerHandler(events.onError, [error]);\r\n                };\r\n\r\n            if (config && !connection._.pingIntervalId && config.pingInterval) {\r\n                connection._.pingIntervalId = window.setInterval(function () {\r\n                    signalR.transports._logic.pingServer(connection).fail(onFail);\r\n                }, config.pingInterval);\r\n            }\r\n        }\r\n    };\r\n\r\n    signalR.events = events;\r\n\r\n    signalR.resources = resources;\r\n\r\n    signalR.ajaxDefaults = ajaxDefaults;\r\n\r\n    signalR.changeState = changeState;\r\n\r\n    signalR.isDisconnecting = isDisconnecting;\r\n\r\n    signalR.connectionState = {\r\n        connecting: 0,\r\n        connected: 1,\r\n        reconnecting: 2,\r\n        disconnected: 4\r\n    };\r\n\r\n    signalR.hub = {\r\n        start: function () {\r\n            // This will get replaced with the real hub connection start method when hubs is referenced correctly\r\n            throw new Error("SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src=\'/signalr/js\'></script>.");\r\n        }\r\n    };\r\n\r\n    // .on() was added in version 1.7.0, .load() was removed in version 3.0.0 so we fallback to .load() if .on() does\r\n    // not exist to not break existing applications\r\n    if (typeof _pageWindow.on == "function") {\r\n        _pageWindow.on("load", function () { _pageLoaded = true; });\r\n    }\r\n    else {\r\n        _pageWindow.load(function () { _pageLoaded = true; });\r\n    }\r\n\r\n    function validateTransport(requestedTransport, connection) {\r\n        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>\r\n        /// <param name="requestedTransport" type="Object">The designated transports that the user has specified.</param>\r\n        /// <param name="connection" type="signalR">The connection that will be using the requested transports.  Used for logging purposes.</param>\r\n        /// <returns type="Object" />\r\n\r\n        if ($.isArray(requestedTransport)) {\r\n            // Go through transport array and remove an "invalid" tranports\r\n            for (var i = requestedTransport.length - 1; i >= 0; i--) {\r\n                var transport = requestedTransport[i];\r\n                if ($.type(transport) !== "string" || !signalR.transports[transport]) {\r\n                    connection.log("Invalid transport: " + transport + ", removing it from the transports list.");\r\n                    requestedTransport.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Verify we still have transports left, if we dont then we have invalid transports\r\n            if (requestedTransport.length === 0) {\r\n                connection.log("No transports remain within the specified transport array.");\r\n                requestedTransport = null;\r\n            }\r\n        } else if (!signalR.transports[requestedTransport] && requestedTransport !== "auto") {\r\n            connection.log("Invalid transport: " + requestedTransport.toString() + ".");\r\n            requestedTransport = null;\r\n        } else if (requestedTransport === "auto" && signalR._.ieVersion <= 8) {\r\n            // If we\'re doing an auto transport and we\'re IE8 then force longPolling, #1764\r\n            return ["longPolling"];\r\n\r\n        }\r\n\r\n        return requestedTransport;\r\n    }\r\n\r\n    function getDefaultPort(protocol) {\r\n        if (protocol === "http:") {\r\n            return 80;\r\n        } else if (protocol === "https:") {\r\n            return 443;\r\n        }\r\n    }\r\n\r\n    function addDefaultPort(protocol, url) {\r\n        // Remove ports  from url.  We have to check if there\'s a / or end of line\r\n        // following the port in order to avoid removing ports such as 8080.\r\n        if (url.match(/:\\d+$/)) {\r\n            return url;\r\n        } else {\r\n            return url + ":" + getDefaultPort(protocol);\r\n        }\r\n    }\r\n\r\n    function ConnectingMessageBuffer(connection, drainCallback) {\r\n        var that = this,\r\n            buffer = [];\r\n\r\n        that.tryBuffer = function (message) {\r\n            if (connection.state === $.signalR.connectionState.connecting) {\r\n                buffer.push(message);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        that.drain = function () {\r\n            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                while (buffer.length > 0) {\r\n                    drainCallback(buffer.shift());\r\n                }\r\n            }\r\n        };\r\n\r\n        that.clear = function () {\r\n            buffer = [];\r\n        };\r\n    }\r\n\r\n    signalR.fn = signalR.prototype = {\r\n        init: function (url, qs, logging) {\r\n            var $connection = $(this);\r\n\r\n            this.url = url;\r\n            this.qs = qs;\r\n            this.lastError = null;\r\n            this._ = {\r\n                keepAliveData: {},\r\n                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {\r\n                    $connection.triggerHandler(events.onReceived, [message]);\r\n                }),\r\n                lastMessageAt: new Date().getTime(),\r\n                lastActiveAt: new Date().getTime(),\r\n                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,\r\n                beatHandle: null,\r\n                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout\r\n            };\r\n            if (typeof (logging) === "boolean") {\r\n                this.logging = logging;\r\n            }\r\n        },\r\n\r\n        _parseResponse: function (response) {\r\n            var that = this;\r\n\r\n            if (!response) {\r\n                return response;\r\n            } else if (typeof response === "string") {\r\n                return that.json.parse(response);\r\n            } else {\r\n                return response;\r\n            }\r\n        },\r\n\r\n        _originalJson: window.JSON,\r\n\r\n        json: window.JSON,\r\n\r\n        isCrossDomain: function (url, against) {\r\n            /// <summary>Checks if url is cross domain</summary>\r\n            /// <param name="url" type="String">The base URL</param>\r\n            /// <param name="against" type="Object">\r\n            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.\r\n            ///     If specified it must contain a protocol and a host property.\r\n            /// </param>\r\n            var link;\r\n\r\n            url = $.trim(url);\r\n\r\n            against = against || window.location;\r\n\r\n            if (url.indexOf("http") !== 0) {\r\n                return false;\r\n            }\r\n\r\n            // Create an anchor tag.\r\n            link = window.document.createElement("a");\r\n            link.href = url;\r\n\r\n            // When checking for cross domain we have to special case port 80 because the window.location will remove the\r\n            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);\r\n        },\r\n\r\n        ajaxDataType: "text",\r\n\r\n        contentType: "application/json; charset=UTF-8",\r\n\r\n        logging: false,\r\n\r\n        state: signalR.connectionState.disconnected,\r\n\r\n        clientProtocol: "1.5",\r\n\r\n        reconnectDelay: 2000,\r\n\r\n        transportConnectTimeout: 0,\r\n\r\n        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)\r\n\r\n        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request\r\n\r\n        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout\r\n\r\n        start: function (options, callback) {\r\n            /// <summary>Starts the connection</summary>\r\n            /// <param name="options" type="Object">Options map</param>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection has started</param>\r\n            var connection = this,\r\n                config = {\r\n                    pingInterval: 300000,\r\n                    waitForPageLoad: true,\r\n                    transport: "auto",\r\n                    jsonp: false\r\n                },\r\n                initialize,\r\n                deferred = connection._deferral || $.Deferred(), // Check to see if there is a pre-existing deferral that\'s being built on, if so we want to keep using it\r\n                parser = window.document.createElement("a");\r\n\r\n            connection.lastError = null;\r\n\r\n            // Persist the deferral so that if start is called multiple times the same deferral is used.\r\n            connection._deferral = deferred;\r\n\r\n            if (!connection.json) {\r\n                // no JSON!\r\n                throw new Error("SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.");\r\n            }\r\n\r\n            if ($.type(options) === "function") {\r\n                // Support calling with single callback parameter\r\n                callback = options;\r\n            } else if ($.type(options) === "object") {\r\n                $.extend(config, options);\r\n                if ($.type(config.callback) === "function") {\r\n                    callback = config.callback;\r\n                }\r\n            }\r\n\r\n            config.transport = validateTransport(config.transport, connection);\r\n\r\n            // If the transport is invalid throw an error and abort start\r\n            if (!config.transport) {\r\n                throw new Error("SignalR: Invalid transport(s) specified, aborting start.");\r\n            }\r\n\r\n            connection._.config = config;\r\n\r\n            // Check to see if start is being called prior to page load\r\n            // If waitForPageLoad is true we then want to re-direct function call to the window load event\r\n            if (!_pageLoaded && config.waitForPageLoad === true) {\r\n                connection._.deferredStartHandler = function () {\r\n                    connection.start(options, callback);\r\n                };\r\n                _pageWindow.bind("load", connection._.deferredStartHandler);\r\n\r\n                return deferred.promise();\r\n            }\r\n\r\n            // If we\'re already connecting just return the same deferral as the original connection start\r\n            if (connection.state === signalR.connectionState.connecting) {\r\n                return deferred.promise();\r\n            } else if (changeState(connection,\r\n                            signalR.connectionState.disconnected,\r\n                            signalR.connectionState.connecting) === false) {\r\n                // We\'re not connecting so try and transition into connecting.\r\n                // If we fail to transition then we\'re either in connected or reconnecting.\r\n\r\n                deferred.resolve(connection);\r\n                return deferred.promise();\r\n            }\r\n\r\n            configureStopReconnectingTimeout(connection);\r\n\r\n            // Resolve the full url\r\n            parser.href = connection.url;\r\n            if (!parser.protocol || parser.protocol === ":") {\r\n                connection.protocol = window.document.location.protocol;\r\n                connection.host = parser.host || window.document.location.host;\r\n            } else {\r\n                connection.protocol = parser.protocol;\r\n                connection.host = parser.host;\r\n            }\r\n\r\n            connection.baseUrl = connection.protocol + "//" + connection.host;\r\n\r\n            // Set the websocket protocol\r\n            connection.wsProtocol = connection.protocol === "https:" ? "wss://" : "ws://";\r\n\r\n            // If jsonp with no/auto transport is specified, then set the transport to long polling\r\n            // since that is the only transport for which jsonp really makes sense.\r\n            // Some developers might actually choose to specify jsonp for same origin requests\r\n            // as demonstrated by Issue #623.\r\n            if (config.transport === "auto" && config.jsonp === true) {\r\n                config.transport = "longPolling";\r\n            }\r\n\r\n            // If the url is protocol relative, prepend the current windows protocol to the url.\r\n            if (connection.url.indexOf("//") === 0) {\r\n                connection.url = window.location.protocol + connection.url;\r\n                connection.log("Protocol relative URL detected, normalizing it to \'" + connection.url + "\'.");\r\n            }\r\n\r\n            if (this.isCrossDomain(connection.url)) {\r\n                connection.log("Auto detected cross domain url.");\r\n\r\n                if (config.transport === "auto") {\r\n                    // TODO: Support XDM with foreverFrame\r\n                    config.transport = ["webSockets", "serverSentEvents", "longPolling"];\r\n                }\r\n\r\n                if (typeof (config.withCredentials) === "undefined") {\r\n                    config.withCredentials = true;\r\n                }\r\n\r\n                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.\r\n                // i.e. if the browser doesn\'t supports CORS\r\n                // If it is, ignore any preference to the contrary, and switch to jsonp.\r\n                if (!config.jsonp) {\r\n                    config.jsonp = !$.support.cors;\r\n\r\n                    if (config.jsonp) {\r\n                        connection.log("Using jsonp because this browser doesn\'t support CORS.");\r\n                    }\r\n                }\r\n\r\n                connection.contentType = signalR._.defaultContentType;\r\n            }\r\n\r\n            connection.withCredentials = config.withCredentials;\r\n\r\n            connection.ajaxDataType = config.jsonp ? "jsonp" : "text";\r\n\r\n            $(connection).bind(events.onStart, function (e, data) {\r\n                if ($.type(callback) === "function") {\r\n                    callback.call(connection);\r\n                }\r\n                deferred.resolve(connection);\r\n            });\r\n\r\n            connection._.initHandler = signalR.transports._logic.initHandler(connection);\r\n\r\n            initialize = function (transports, index) {\r\n                var noTransportError = signalR._.error(resources.noTransportOnInit);\r\n\r\n                index = index || 0;\r\n                if (index >= transports.length) {\r\n                    if (index === 0) {\r\n                        connection.log("No transports supported by the server were selected.");\r\n                    } else if (index === 1) {\r\n                        connection.log("No fallback transports were selected.");\r\n                    } else {\r\n                        connection.log("Fallback transports exhausted.");\r\n                    }\r\n\r\n                    // No transport initialized successfully\r\n                    $(connection).triggerHandler(events.onError, [noTransportError]);\r\n                    deferred.reject(noTransportError);\r\n                    // Stop the connection if it has connected and move it into the disconnected state\r\n                    connection.stop();\r\n                    return;\r\n                }\r\n\r\n                // The connection was aborted\r\n                if (connection.state === signalR.connectionState.disconnected) {\r\n                    return;\r\n                }\r\n\r\n                var transportName = transports[index],\r\n                    transport = signalR.transports[transportName],\r\n                    onFallback = function () {\r\n                        initialize(transports, index + 1);\r\n                    };\r\n\r\n                connection.transport = transport;\r\n\r\n                try {\r\n                    connection._.initHandler.start(transport, function () { // success\r\n                        // Firefox 11+ doesn\'t allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials\r\n                        var isFirefox11OrGreater = signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,\r\n                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;\r\n\r\n                        connection.log("The start request succeeded. Transitioning to the connected state.");\r\n\r\n                        if (supportsKeepAlive(connection)) {\r\n                            signalR.transports._logic.monitorKeepAlive(connection);\r\n                        }\r\n\r\n                        signalR.transports._logic.startHeartbeat(connection);\r\n\r\n                        // Used to ensure low activity clients maintain their authentication.\r\n                        // Must be configured once a transport has been decided to perform valid ping requests.\r\n                        signalR._.configurePingInterval(connection);\r\n\r\n                        if (!changeState(connection,\r\n                                            signalR.connectionState.connecting,\r\n                                            signalR.connectionState.connected)) {\r\n                            connection.log("WARNING! The connection was not in the connecting state.");\r\n                        }\r\n\r\n                        // Drain any incoming buffered messages (messages that came in prior to connect)\r\n                        connection._.connectingMessageBuffer.drain();\r\n\r\n                        $(connection).triggerHandler(events.onStart);\r\n\r\n                        // wire the stop handler for when the user leaves the page\r\n                        _pageWindow.bind("unload", function () {\r\n                            connection.log("Window unloading, stopping the connection.");\r\n\r\n                            connection.stop(asyncAbort);\r\n                        });\r\n\r\n                        if (isFirefox11OrGreater) {\r\n                            // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.\r\n                            // #2400\r\n                            _pageWindow.bind("beforeunload", function () {\r\n                                // If connection.stop() runs runs in beforeunload and fails, it will also fail\r\n                                // in unload unless connection.stop() runs after a timeout.\r\n                                window.setTimeout(function () {\r\n                                    connection.stop(asyncAbort);\r\n                                }, 0);\r\n                            });\r\n                        }\r\n                    }, onFallback);\r\n                }\r\n                catch (error) {\r\n                    connection.log(transport.name + " transport threw \'" + error.message + "\' when attempting to start.");\r\n                    onFallback();\r\n                }\r\n            };\r\n\r\n            var url = connection.url + "/negotiate",\r\n                onFailed = function (error, connection) {\r\n                    var err = signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);\r\n\r\n                    $(connection).triggerHandler(events.onError, err);\r\n                    deferred.reject(err);\r\n                    // Stop the connection if negotiate failed\r\n                    connection.stop();\r\n                };\r\n\r\n            $(connection).triggerHandler(events.onStarting);\r\n\r\n            url = signalR.transports._logic.prepareQueryString(connection, url);\r\n\r\n            connection.log("Negotiating with \'" + url + "\'.");\r\n\r\n            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.\r\n            connection._.negotiateRequest = signalR.transports._logic.ajax(connection, {\r\n                url: url,\r\n                error: function (error, statusText) {\r\n                    // We don\'t want to cause any errors if we\'re aborting our own negotiate request.\r\n                    if (statusText !== _negotiateAbortText) {\r\n                        onFailed(error, connection);\r\n                    } else {\r\n                        // This rejection will noop if the deferred has already been resolved or rejected.\r\n                        deferred.reject(signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));\r\n                    }\r\n                },\r\n                success: function (result) {\r\n                    var res,\r\n                        keepAliveData,\r\n                        protocolError,\r\n                        transports = [],\r\n                        supportedTransports = [];\r\n\r\n                    try {\r\n                        res = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        onFailed(signalR._.error(resources.errorParsingNegotiateResponse, error), connection);\r\n                        return;\r\n                    }\r\n\r\n                    keepAliveData = connection._.keepAliveData;\r\n                    connection.appRelativeUrl = res.Url;\r\n                    connection.id = res.ConnectionId;\r\n                    connection.token = res.ConnectionToken;\r\n                    connection.webSocketServerUrl = res.WebSocketServerUrl;\r\n\r\n                    // The long poll timeout is the ConnectionTimeout plus 10 seconds\r\n                    connection._.pollTimeout = res.ConnectionTimeout * 1000 + 10000; // in ms\r\n\r\n                    // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect\r\n                    // after res.DisconnectTimeout seconds.\r\n                    connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms\r\n\r\n                    // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout\r\n                    connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;\r\n\r\n                    // If we have a keep alive\r\n                    if (res.KeepAliveTimeout) {\r\n                        // Register the keep alive data as activated\r\n                        keepAliveData.activated = true;\r\n\r\n                        // Timeout to designate when to force the connection into reconnecting converted to milliseconds\r\n                        keepAliveData.timeout = res.KeepAliveTimeout * 1000;\r\n\r\n                        // Timeout to designate when to warn the developer that the connection may be dead or is not responding.\r\n                        keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;\r\n\r\n                        // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes\r\n                        connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;\r\n                    } else {\r\n                        keepAliveData.activated = false;\r\n                    }\r\n\r\n                    connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);\r\n\r\n                    if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {\r\n                        protocolError = signalR._.error(signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));\r\n                        $(connection).triggerHandler(events.onError, [protocolError]);\r\n                        deferred.reject(protocolError);\r\n\r\n                        return;\r\n                    }\r\n\r\n                    $.each(signalR.transports, function (key) {\r\n                        if ((key.indexOf("_") === 0) || (key === "webSockets" && !res.TryWebSockets)) {\r\n                            return true;\r\n                        }\r\n                        supportedTransports.push(key);\r\n                    });\r\n\r\n                    if ($.isArray(config.transport)) {\r\n                        $.each(config.transport, function (_, transport) {\r\n                            if ($.inArray(transport, supportedTransports) >= 0) {\r\n                                transports.push(transport);\r\n                            }\r\n                        });\r\n                    } else if (config.transport === "auto") {\r\n                        transports = supportedTransports;\r\n                    } else if ($.inArray(config.transport, supportedTransports) >= 0) {\r\n                        transports.push(config.transport);\r\n                    }\r\n\r\n                    initialize(transports);\r\n                }\r\n            });\r\n\r\n            return deferred.promise();\r\n        },\r\n\r\n        starting: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute before the connection is fully instantiated.</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStarting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        send: function (data) {\r\n            /// <summary>Sends data over the connection</summary>\r\n            /// <param name="data" type="String">The data to send over the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n\r\n            if (connection.state === signalR.connectionState.disconnected) {\r\n                // Connection hasn\'t been started yet\r\n                throw new Error("SignalR: Connection must be started before data can be sent. Call .start() before .send()");\r\n            }\r\n\r\n            if (connection.state === signalR.connectionState.connecting) {\r\n                // Connection hasn\'t been started yet\r\n                throw new Error("SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.");\r\n            }\r\n\r\n            connection.transport.send(connection, data);\r\n            // REVIEW: Should we return deferred here?\r\n            return connection;\r\n        },\r\n\r\n        received: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when any data is received on the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReceived, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stateChanged: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection state changes</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStateChanged, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        error: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when an error occurs on the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onError, function (e, errorData, sendData) {\r\n                connection.lastError = errorData;\r\n                // In practice \'errorData\' is the SignalR built error object.\r\n                // In practice \'sendData\' is undefined for all error events except those triggered by\r\n                // \'ajaxSend\' and \'webSockets.send\'.\'sendData\' is the original send payload.\r\n                callback.call(connection, errorData, sendData);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        disconnected: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection is broken</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onDisconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        connectionSlow: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection is slow</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onConnectionSlow, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n\r\n            return connection;\r\n        },\r\n\r\n        reconnecting: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection enters a reconnecting state</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnecting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        reconnected: function (callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>\r\n            /// <param name="callback" type="Function">A callback function to execute when the connection is restored</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stop: function (async, notifyServer) {\r\n            /// <summary>Stops listening</summary>\r\n            /// <param name="async" type="Boolean">Whether or not to asynchronously abort the connection</param>\r\n            /// <param name="notifyServer" type="Boolean">Whether we want to notify the server that we are aborting the connection</param>\r\n            /// <returns type="signalR" />\r\n            var connection = this,\r\n                // Save deferral because this is always cleaned up\r\n                deferral = connection._deferral;\r\n\r\n            // Verify that we\'ve bound a load event.\r\n            if (connection._.deferredStartHandler) {\r\n                // Unbind the event.\r\n                _pageWindow.unbind("load", connection._.deferredStartHandler);\r\n            }\r\n\r\n            // Always clean up private non-timeout based state.\r\n            delete connection._.config;\r\n            delete connection._.deferredStartHandler;\r\n\r\n            // This needs to be checked despite the connection state because a connection start can be deferred until page load.\r\n            // If we\'ve deferred the start due to a page load we need to unbind the "onLoad" -> start event.\r\n            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {\r\n                connection.log("Stopping connection prior to negotiate.");\r\n\r\n                // If we have a deferral we should reject it\r\n                if (deferral) {\r\n                    deferral.reject(signalR._.error(resources.stoppedWhileLoading));\r\n                }\r\n\r\n                // Short-circuit because the start has not been fully started.\r\n                return;\r\n            }\r\n\r\n            if (connection.state === signalR.connectionState.disconnected) {\r\n                return;\r\n            }\r\n\r\n            connection.log("Stopping connection.");\r\n\r\n            // Clear this no matter what\r\n            window.clearTimeout(connection._.beatHandle);\r\n            window.clearInterval(connection._.pingIntervalId);\r\n\r\n            if (connection.transport) {\r\n                connection.transport.stop(connection);\r\n\r\n                if (notifyServer !== false) {\r\n                    connection.transport.abort(connection, async);\r\n                }\r\n\r\n                if (supportsKeepAlive(connection)) {\r\n                    signalR.transports._logic.stopMonitoringKeepAlive(connection);\r\n                }\r\n\r\n                connection.transport = null;\r\n            }\r\n\r\n            if (connection._.negotiateRequest) {\r\n                // If the negotiation request has already completed this will noop.\r\n                connection._.negotiateRequest.abort(_negotiateAbortText);\r\n                delete connection._.negotiateRequest;\r\n            }\r\n\r\n            // Ensure that initHandler.stop() is called before connection._deferral is deleted\r\n            if (connection._.initHandler) {\r\n                connection._.initHandler.stop();\r\n            }\r\n\r\n            delete connection._deferral;\r\n            delete connection.messageId;\r\n            delete connection.groupsToken;\r\n            delete connection.id;\r\n            delete connection._.pingIntervalId;\r\n            delete connection._.lastMessageAt;\r\n            delete connection._.lastActiveAt;\r\n\r\n            // Clear out our message buffer\r\n            connection._.connectingMessageBuffer.clear();\r\n            \r\n            // Clean up this event\r\n            $(connection).unbind(events.onStart);\r\n\r\n            // Trigger the disconnect event\r\n            changeState(connection, connection.state, signalR.connectionState.disconnected);\r\n            $(connection).triggerHandler(events.onDisconnect);\r\n\r\n            return connection;\r\n        },\r\n\r\n        log: function (msg) {\r\n            log(msg, this.logging);\r\n        }\r\n    };\r\n\r\n    signalR.fn.init.prototype = signalR.fn;\r\n\r\n    signalR.noConflict = function () {\r\n        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>\r\n        /// <returns type="signalR" />\r\n        if ($.connection === signalR) {\r\n            $.connection = _connection;\r\n        }\r\n        return signalR;\r\n    };\r\n\r\n    if ($.connection) {\r\n        _connection = $.connection;\r\n    }\r\n\r\n    $.connection = $.signalR = signalR;\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.common.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.core.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        startAbortText = "__Start Aborted__",\r\n        transportLogic;\r\n\r\n    signalR.transports = {};\r\n\r\n    function beat(connection) {\r\n        if (connection._.keepAliveData.monitoring) {\r\n            checkIfAlive(connection);\r\n        }\r\n\r\n        // Ensure that we successfully marked active before continuing the heartbeat.\r\n        if (transportLogic.markActive(connection)) {\r\n            connection._.beatHandle = window.setTimeout(function () {\r\n                beat(connection);\r\n            }, connection._.beatInterval);\r\n        }\r\n    }\r\n\r\n    function checkIfAlive(connection) {\r\n        var keepAliveData = connection._.keepAliveData,\r\n            timeElapsed;\r\n\r\n        // Only check if we\'re connected\r\n        if (connection.state === signalR.connectionState.connected) {\r\n            timeElapsed = new Date().getTime() - connection._.lastMessageAt;\r\n\r\n            // Check if the keep alive has completely timed out\r\n            if (timeElapsed >= keepAliveData.timeout) {\r\n                connection.log("Keep alive timed out.  Notifying transport that connection has been lost.");\r\n\r\n                // Notify transport that the connection has been lost\r\n                connection.transport.lostConnection(connection);\r\n            } else if (timeElapsed >= keepAliveData.timeoutWarning) {\r\n                // This is to assure that the user only gets a single warning\r\n                if (!keepAliveData.userNotified) {\r\n                    connection.log("Keep alive has been missed, connection may be dead/slow.");\r\n                    $(connection).triggerHandler(events.onConnectionSlow);\r\n                    keepAliveData.userNotified = true;\r\n                }\r\n            } else {\r\n                keepAliveData.userNotified = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAjaxUrl(connection, path) {\r\n        var url = connection.url + path;\r\n\r\n        if (connection.transport) {\r\n            url += "?transport=" + connection.transport.name;\r\n        }\r\n\r\n        return transportLogic.prepareQueryString(connection, url);\r\n    }\r\n\r\n    function InitHandler(connection) {\r\n        this.connection = connection;\r\n\r\n        this.startRequested = false;\r\n        this.startCompleted = false;\r\n        this.connectionStopped = false;\r\n    }\r\n\r\n    InitHandler.prototype = {\r\n        start: function (transport, onSuccess, onFallback) {\r\n            var that = this,\r\n                connection = that.connection,\r\n                failCalled = false;\r\n\r\n            if (that.startRequested || that.connectionStopped) {\r\n                connection.log("WARNING! " + transport.name + " transport cannot be started. Initialization ongoing or completed.");\r\n                return;\r\n            }\r\n\r\n            connection.log(transport.name + " transport starting.");\r\n\r\n            transport.start(connection, function () {\r\n                if (!failCalled) {\r\n                    that.initReceived(transport, onSuccess);\r\n                }\r\n            }, function (error) {\r\n                // Don\'t allow the same transport to cause onFallback to be called twice\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    that.transportFailed(transport, error, onFallback);\r\n                }\r\n\r\n                // Returns true if the transport should stop;\r\n                // false if it should attempt to reconnect\r\n                return !that.startCompleted || that.connectionStopped;\r\n            });\r\n\r\n            that.transportTimeoutHandle = window.setTimeout(function () {\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    connection.log(transport.name + " transport timed out when trying to connect.");\r\n                    that.transportFailed(transport, undefined, onFallback);\r\n                }\r\n            }, connection._.totalTransportConnectTimeout);\r\n        },\r\n\r\n        stop: function () {\r\n            this.connectionStopped = true;\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n            signalR.transports._logic.tryAbortStartRequest(this.connection);\r\n        },\r\n\r\n        initReceived: function (transport, onSuccess) {\r\n            var that = this,\r\n                connection = that.connection;\r\n\r\n            if (that.startRequested) {\r\n                connection.log("WARNING! The client received multiple init messages.");\r\n                return;\r\n            }\r\n\r\n            if (that.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            that.startRequested = true;\r\n            window.clearTimeout(that.transportTimeoutHandle);\r\n\r\n            connection.log(transport.name + " transport connected. Initiating start request.");\r\n            signalR.transports._logic.ajaxStart(connection, function () {\r\n                that.startCompleted = true;\r\n                onSuccess();\r\n            });\r\n        },\r\n\r\n        transportFailed: function (transport, error, onFallback) {\r\n            var connection = this.connection,\r\n                deferred = connection._deferral,\r\n                wrappedError;\r\n\r\n            if (this.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n\r\n            if (!this.startRequested) {\r\n                transport.stop(connection);\r\n\r\n                connection.log(transport.name + " transport failed to connect. Attempting to fall back.");\r\n                onFallback();\r\n            } else if (!this.startCompleted) {\r\n                // Do not attempt to fall back if a start request is ongoing during a transport failure.\r\n                // Instead, trigger an error and stop the connection.\r\n                wrappedError = signalR._.error(signalR.resources.errorDuringStartRequest, error);\r\n\r\n                connection.log(transport.name + " transport failed during the start request. Stopping the connection.");\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                if (deferred) {\r\n                    deferred.reject(wrappedError);\r\n                }\r\n\r\n                connection.stop();\r\n            } else {\r\n                // The start request has completed, but the connection has not stopped.\r\n                // No need to do anything here. The transport should attempt its normal reconnect logic.\r\n            }\r\n        }\r\n    };\r\n\r\n    transportLogic = signalR.transports._logic = {\r\n        ajax: function (connection, options) {\r\n            return $.ajax(\r\n                $.extend(/*deep copy*/ true, {}, $.signalR.ajaxDefaults, {\r\n                    type: "GET",\r\n                    data: {},\r\n                    xhrFields: { withCredentials: connection.withCredentials },\r\n                    contentType: connection.contentType,\r\n                    dataType: connection.ajaxDataType\r\n                }, options));\r\n        },\r\n\r\n        pingServer: function (connection) {\r\n            /// <summary>Pings the server</summary>\r\n            /// <param name="connection" type="signalr">Connection associated with the server ping</param>\r\n            /// <returns type="signalR" />\r\n            var url,\r\n                xhr,\r\n                deferral = $.Deferred();\r\n\r\n            if (connection.transport) {\r\n                url = connection.url + "/ping";\r\n\r\n                url = transportLogic.addQs(url, connection.qs);\r\n\r\n                xhr = transportLogic.ajax(connection, {\r\n                    url: url,\r\n                    success: function (result) {\r\n                        var data;\r\n\r\n                        try {\r\n                            data = connection._parseResponse(result);\r\n                        }\r\n                        catch (error) {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR.resources.pingServerFailedParse,\r\n                                    connection.transport,\r\n                                    error,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        if (data.Response === "pong") {\r\n                            deferral.resolve();\r\n                        }\r\n                        else {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result),\r\n                                    connection.transport,\r\n                                    null /* error */,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                        }\r\n                    },\r\n                    error: function (error) {\r\n                        if (error.status === 401 || error.status === 403) {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR._.format(signalR.resources.pingServerFailedStatusCode, error.status),\r\n                                    connection.transport,\r\n                                    error,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                            connection.stop();\r\n                        }\r\n                        else {\r\n                            deferral.reject(\r\n                                signalR._.transportError(\r\n                                    signalR.resources.pingServerFailed,\r\n                                    connection.transport,\r\n                                    error,\r\n                                    xhr\r\n                                )\r\n                            );\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                deferral.reject(\r\n                    signalR._.transportError(\r\n                        signalR.resources.noConnectionTransport,\r\n                        connection.transport\r\n                    )\r\n                );\r\n            }\r\n\r\n            return deferral.promise();\r\n        },\r\n\r\n        prepareQueryString: function (connection, url) {\r\n            var preparedUrl;\r\n\r\n            // Use addQs to start since it handles the ?/& prefix for us\r\n            preparedUrl = transportLogic.addQs(url, "clientProtocol=" + connection.clientProtocol);\r\n\r\n            // Add the user-specified query string params if any\r\n            preparedUrl = transportLogic.addQs(preparedUrl, connection.qs);\r\n\r\n            if (connection.token) {\r\n                preparedUrl += "&connectionToken=" + window.encodeURIComponent(connection.token);\r\n            }\r\n\r\n            if (connection.data) {\r\n                preparedUrl += "&connectionData=" + window.encodeURIComponent(connection.data);\r\n            }\r\n\r\n            return preparedUrl;\r\n        },\r\n\r\n        addQs: function (url, qs) {\r\n            var appender = url.indexOf("?") !== -1 ? "&" : "?",\r\n                firstChar;\r\n\r\n            if (!qs) {\r\n                return url;\r\n            }\r\n\r\n            if (typeof (qs) === "object") {\r\n                return url + appender + $.param(qs);\r\n            }\r\n\r\n            if (typeof (qs) === "string") {\r\n                firstChar = qs.charAt(0);\r\n\r\n                if (firstChar === "?" || firstChar === "&") {\r\n                    appender = "";\r\n                }\r\n\r\n                return url + appender + qs;\r\n            }\r\n\r\n            throw new Error("Query string property must be either a string or object.");\r\n        },\r\n\r\n        // BUG #2953: The url needs to be same otherwise it will cause a memory leak\r\n        getUrl: function (connection, transport, reconnecting, poll, ajaxPost) {\r\n            /// <summary>Gets the url for making a GET based connect request</summary>\r\n            var baseUrl = transport === "webSockets" ? "" : connection.baseUrl,\r\n                url = baseUrl + connection.appRelativeUrl,\r\n                qs = "transport=" + transport;\r\n\r\n            if (!ajaxPost && connection.groupsToken) {\r\n                qs += "&groupsToken=" + window.encodeURIComponent(connection.groupsToken);\r\n            }\r\n\r\n            if (!reconnecting) {\r\n                url += "/connect";\r\n            } else {\r\n                if (poll) {\r\n                    // longPolling transport specific\r\n                    url += "/poll";\r\n                } else {\r\n                    url += "/reconnect";\r\n                }\r\n\r\n                if (!ajaxPost && connection.messageId) {\r\n                    qs += "&messageId=" + window.encodeURIComponent(connection.messageId);\r\n                }\r\n            }\r\n            url += "?" + qs;\r\n            url = transportLogic.prepareQueryString(connection, url);\r\n\r\n            if (!ajaxPost) {\r\n                url += "&tid=" + Math.floor(Math.random() * 11);\r\n            }\r\n\r\n            return url;\r\n        },\r\n\r\n        maximizePersistentResponse: function (minPersistentResponse) {\r\n            return {\r\n                MessageId: minPersistentResponse.C,\r\n                Messages: minPersistentResponse.M,\r\n                Initialized: typeof (minPersistentResponse.S) !== "undefined" ? true : false,\r\n                ShouldReconnect: typeof (minPersistentResponse.T) !== "undefined" ? true : false,\r\n                LongPollDelay: minPersistentResponse.L,\r\n                GroupsToken: minPersistentResponse.G\r\n            };\r\n        },\r\n\r\n        updateGroups: function (connection, groupsToken) {\r\n            if (groupsToken) {\r\n                connection.groupsToken = groupsToken;\r\n            }\r\n        },\r\n\r\n        stringifySend: function (connection, message) {\r\n            if (typeof (message) === "string" || typeof (message) === "undefined" || message === null) {\r\n                return message;\r\n            }\r\n            return connection.json.stringify(message);\r\n        },\r\n\r\n        ajaxSend: function (connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data),\r\n                url = getAjaxUrl(connection, "/send"),\r\n                xhr,\r\n                onFail = function (error, connection) {\r\n                    $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);\r\n                };\r\n\r\n\r\n            xhr = transportLogic.ajax(connection, {\r\n                url: url,\r\n                type: connection.ajaxDataType === "jsonp" ? "GET" : "POST",\r\n                contentType: signalR._.defaultContentType,\r\n                data: {\r\n                    data: payload\r\n                },\r\n                success: function (result) {\r\n                    var res;\r\n\r\n                    if (result) {\r\n                        try {\r\n                            res = connection._parseResponse(result);\r\n                        }\r\n                        catch (error) {\r\n                            onFail(error, connection);\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        transportLogic.triggerReceived(connection, res);\r\n                    }\r\n                },\r\n                error: function (error, textStatus) {\r\n                    if (textStatus === "abort" || textStatus === "parsererror") {\r\n                        // The parsererror happens for sends that don\'t return any data, and hence\r\n                        // don\'t write the jsonp callback to the response. This is harder to fix on the server\r\n                        // so just hack around it on the client for now.\r\n                        return;\r\n                    }\r\n\r\n                    onFail(error, connection);\r\n                }\r\n            });\r\n\r\n            return xhr;\r\n        },\r\n\r\n        ajaxAbort: function (connection, async) {\r\n            if (typeof (connection.transport) === "undefined") {\r\n                return;\r\n            }\r\n\r\n            // Async by default unless explicitly overidden\r\n            async = typeof async === "undefined" ? true : async;\r\n\r\n            var url = getAjaxUrl(connection, "/abort");\r\n\r\n            transportLogic.ajax(connection, {\r\n                url: url,\r\n                async: async,\r\n                timeout: 1000,\r\n                type: "POST"\r\n            });\r\n\r\n            connection.log("Fired ajax abort async = " + async + ".");\r\n        },\r\n\r\n        ajaxStart: function (connection, onSuccess) {\r\n            var rejectDeferred = function (error) {\r\n                    var deferred = connection._deferral;\r\n                    if (deferred) {\r\n                        deferred.reject(error);\r\n                    }\r\n                },\r\n                triggerStartError = function (error) {\r\n                    connection.log("The start request failed. Stopping the connection.");\r\n                    $(connection).triggerHandler(events.onError, [error]);\r\n                    rejectDeferred(error);\r\n                    connection.stop();\r\n                };\r\n\r\n            connection._.startRequest = transportLogic.ajax(connection, {\r\n                url: getAjaxUrl(connection, "/start"),\r\n                success: function (result, statusText, xhr) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        triggerStartError(signalR._.error(\r\n                            signalR._.format(signalR.resources.errorParsingStartResponse, result),\r\n                            error, xhr));\r\n                        return;\r\n                    }\r\n\r\n                    if (data.Response === "started") {\r\n                        onSuccess();\r\n                    } else {\r\n                        triggerStartError(signalR._.error(\r\n                            signalR._.format(signalR.resources.invalidStartResponse, result),\r\n                            null /* error */, xhr));\r\n                    }\r\n                },\r\n                error: function (xhr, statusText, error) {\r\n                    if (statusText !== startAbortText) {\r\n                        triggerStartError(signalR._.error(\r\n                            signalR.resources.errorDuringStartRequest,\r\n                            error, xhr));\r\n                    } else {\r\n                        // Stop has been called, no need to trigger the error handler\r\n                        // or stop the connection again with onStartError\r\n                        connection.log("The start request aborted because connection.stop() was called.");\r\n                        rejectDeferred(signalR._.error(\r\n                            signalR.resources.stoppedDuringStartRequest,\r\n                            null /* error */, xhr));\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        tryAbortStartRequest: function (connection) {\r\n            if (connection._.startRequest) {\r\n                // If the start request has already completed this will noop.\r\n                connection._.startRequest.abort(startAbortText);\r\n                delete connection._.startRequest;\r\n            }\r\n        },\r\n\r\n        tryInitialize: function (connection, persistentResponse, onInitialized) {\r\n            if (persistentResponse.Initialized && onInitialized) {\r\n                onInitialized();\r\n            } else if (persistentResponse.Initialized) {\r\n                connection.log("WARNING! The client received an init message after reconnecting.");\r\n            }\r\n\r\n        },\r\n\r\n        triggerReceived: function (connection, data) {\r\n            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {\r\n                $(connection).triggerHandler(events.onReceived, [data]);\r\n            }\r\n        },\r\n\r\n        processMessages: function (connection, minData, onInitialized) {\r\n            var data;\r\n\r\n            // Update the last message time stamp\r\n            transportLogic.markLastMessage(connection);\r\n\r\n            if (minData) {\r\n                data = transportLogic.maximizePersistentResponse(minData);\r\n\r\n                transportLogic.updateGroups(connection, data.GroupsToken);\r\n\r\n                if (data.MessageId) {\r\n                    connection.messageId = data.MessageId;\r\n                }\r\n\r\n                if (data.Messages) {\r\n                    $.each(data.Messages, function (index, message) {\r\n                        transportLogic.triggerReceived(connection, message);\r\n                    });\r\n\r\n                    transportLogic.tryInitialize(connection, data, onInitialized);\r\n                }\r\n            }\r\n        },\r\n\r\n        monitorKeepAlive: function (connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // If we haven\'t initiated the keep alive timeouts then we need to\r\n            if (!keepAliveData.monitoring) {\r\n                keepAliveData.monitoring = true;\r\n\r\n                transportLogic.markLastMessage(connection);\r\n\r\n                // Save the function so we can unbind it on stop\r\n                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {\r\n                    // Mark a new message so that keep alive doesn\'t time out connections\r\n                    transportLogic.markLastMessage(connection);\r\n                };\r\n\r\n                // Update Keep alive on reconnect\r\n                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                connection.log("Now monitoring keep alive with a warning timeout of " + keepAliveData.timeoutWarning + ", keep alive timeout of " + keepAliveData.timeout + " and disconnecting timeout of " + connection.disconnectTimeout);\r\n            } else {\r\n                connection.log("Tried to monitor keep alive but it\'s already being monitored.");\r\n            }\r\n        },\r\n\r\n        stopMonitoringKeepAlive: function (connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // Only attempt to stop the keep alive monitoring if its being monitored\r\n            if (keepAliveData.monitoring) {\r\n                // Stop monitoring\r\n                keepAliveData.monitoring = false;\r\n\r\n                // Remove the updateKeepAlive function from the reconnect event\r\n                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                // Clear all the keep alive data\r\n                connection._.keepAliveData = {};\r\n                connection.log("Stopping the monitoring of the keep alive.");\r\n            }\r\n        },\r\n\r\n        startHeartbeat: function (connection) {\r\n            connection._.lastActiveAt = new Date().getTime();\r\n            beat(connection);\r\n        },\r\n\r\n        markLastMessage: function (connection) {\r\n            connection._.lastMessageAt = new Date().getTime();\r\n        },\r\n\r\n        markActive: function (connection) {\r\n            if (transportLogic.verifyLastActive(connection)) {\r\n                connection._.lastActiveAt = new Date().getTime();\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isConnectedOrReconnecting: function (connection) {\r\n            return connection.state === signalR.connectionState.connected ||\r\n                   connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        ensureReconnectingState: function (connection) {\r\n            if (changeState(connection,\r\n                        signalR.connectionState.connected,\r\n                        signalR.connectionState.reconnecting) === true) {\r\n                $(connection).triggerHandler(events.onReconnecting);\r\n            }\r\n            return connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        clearReconnectTimeout: function (connection) {\r\n            if (connection && connection._.reconnectTimeout) {\r\n                window.clearTimeout(connection._.reconnectTimeout);\r\n                delete connection._.reconnectTimeout;\r\n            }\r\n        },\r\n\r\n        verifyLastActive: function (connection) {\r\n            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {\r\n                var message = signalR._.format(signalR.resources.reconnectWindowTimeout, new Date(connection._.lastActiveAt), connection.reconnectWindow);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */ "TimeoutException")]);\r\n                connection.stop(/* async */ false, /* notifyServer */ false);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        reconnect: function (connection, transportName) {\r\n            var transport = signalR.transports[transportName];\r\n\r\n            // We should only set a reconnectTimeout if we are currently connected\r\n            // and a reconnectTimeout isn\'t already set.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {\r\n                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n                if (!transportLogic.verifyLastActive(connection)) {\r\n                    return;\r\n                }\r\n\r\n                connection._.reconnectTimeout = window.setTimeout(function () {\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    transport.stop(connection);\r\n\r\n                    if (transportLogic.ensureReconnectingState(connection)) {\r\n                        connection.log(transportName + " reconnecting.");\r\n                        transport.start(connection);\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        handleParseFailure: function (connection, result, error, onFailed, context) {\r\n            var wrappedError = signalR._.transportError(\r\n                signalR._.format(signalR.resources.parseFailed, result),\r\n                connection.transport,\r\n                error,\r\n                context);\r\n\r\n            // If we\'re in the initialization phase trigger onFailed, otherwise stop the connection.\r\n            if (onFailed && onFailed(wrappedError)) {\r\n                connection.log("Failed to parse server response while attempting to connect.");\r\n            } else {\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                connection.stop();\r\n            }\r\n        },\r\n\r\n        initHandler: function (connection) {\r\n            return new InitHandler(connection);\r\n        },\r\n\r\n        foreverFrame: {\r\n            count: 0,\r\n            connections: {}\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.webSockets.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.webSockets = {\r\n        name: "webSockets",\r\n\r\n        supportsKeepAlive: function () {\r\n            return true;\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data);\r\n\r\n            try {\r\n                connection.socket.send(payload);\r\n            } catch (ex) {\r\n                $(connection).triggerHandler(events.onError,\r\n                    [signalR._.transportError(\r\n                        signalR.resources.webSocketsInvalidState,\r\n                        connection.transport,\r\n                        ex,\r\n                        connection.socket\r\n                    ),\r\n                    data]);\r\n            }\r\n        },\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            var url,\r\n                opened = false,\r\n                that = this,\r\n                reconnecting = !onSuccess,\r\n                $connection = $(connection);\r\n\r\n            if (!window.WebSocket) {\r\n                onFailed();\r\n                return;\r\n            }\r\n\r\n            if (!connection.socket) {\r\n                if (connection.webSocketServerUrl) {\r\n                    url = connection.webSocketServerUrl;\r\n                } else {\r\n                    url = connection.wsProtocol + connection.host;\r\n                }\r\n\r\n                url += transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n                connection.log("Connecting to websocket endpoint \'" + url + "\'.");\r\n                connection.socket = new window.WebSocket(url);\r\n\r\n                connection.socket.onopen = function () {\r\n                    opened = true;\r\n                    connection.log("Websocket opened.");\r\n\r\n                    transportLogic.clearReconnectTimeout(connection);\r\n\r\n                    if (changeState(connection,\r\n                                    signalR.connectionState.reconnecting,\r\n                                    signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                };\r\n\r\n                connection.socket.onclose = function (event) {\r\n                    var error;\r\n\r\n                    // Only handle a socket close if the close is from the current socket.\r\n                    // Sometimes on disconnect the server will push down an onclose event\r\n                    // to an expired socket.\r\n\r\n                    if (this === connection.socket) {\r\n                        if (opened && typeof event.wasClean !== "undefined" && event.wasClean === false) {\r\n                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but\r\n                            // I found in some circumstances Chrome won\'t call onerror. This implementation seems to work on all browsers.\r\n                            error = signalR._.transportError(\r\n                                signalR.resources.webSocketClosed,\r\n                                connection.transport,\r\n                                event);\r\n\r\n                            connection.log("Unclean disconnect from websocket: " + (event.reason || "[no reason given]."));\r\n                        } else {\r\n                            connection.log("Websocket closed.");\r\n                        }\r\n\r\n                        if (!onFailed || !onFailed(error)) {\r\n                            if (error) {\r\n                                $(connection).triggerHandler(events.onError, [error]);\r\n                            }\r\n\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                connection.socket.onmessage = function (event) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(event.data);\r\n                    }\r\n                    catch (error) {\r\n                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);\r\n                        return;\r\n                    }\r\n\r\n                    if (data) {\r\n                        // data.M is PersistentResponse.Messages\r\n                        if ($.isEmptyObject(data) || data.M) {\r\n                            transportLogic.processMessages(connection, data, onSuccess);\r\n                        } else {\r\n                            // For websockets we need to trigger onReceived\r\n                            // for callbacks to outgoing hub calls.\r\n                            transportLogic.triggerReceived(connection, data);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function (connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        stop: function (connection) {\r\n            // Don\'t trigger a reconnect after stopping\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection.socket) {\r\n                connection.log("Closing the Websocket.");\r\n                connection.socket.close();\r\n                connection.socket = null;\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.serverSentEvents.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        clearReconnectAttemptTimeout = function (connection) {\r\n            window.clearTimeout(connection._.reconnectAttemptTimeoutHandle);\r\n            delete connection._.reconnectAttemptTimeoutHandle;\r\n        };\r\n\r\n    signalR.transports.serverSentEvents = {\r\n        name: "serverSentEvents",\r\n\r\n        supportsKeepAlive: function () {\r\n            return true;\r\n        },\r\n\r\n        timeOut: 3000,\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                opened = false,\r\n                $connection = $(connection),\r\n                reconnecting = !onSuccess,\r\n                url;\r\n\r\n            if (connection.eventSource) {\r\n                connection.log("The connection already has an event source. Stopping it.");\r\n                connection.stop();\r\n            }\r\n\r\n            if (!window.EventSource) {\r\n                if (onFailed) {\r\n                    connection.log("This browser doesn\'t support SSE.");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            url = transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n            try {\r\n                connection.log("Attempting to connect to SSE endpoint \'" + url + "\'.");\r\n                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });\r\n            }\r\n            catch (e) {\r\n                connection.log("EventSource failed trying to connect with error " + e.Message + ".");\r\n                if (onFailed) {\r\n                    // The connection failed, call the failed callback\r\n                    onFailed();\r\n                } else {\r\n                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);\r\n                    if (reconnecting) {\r\n                        // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                        that.reconnect(connection);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (reconnecting) {\r\n                connection._.reconnectAttemptTimeoutHandle = window.setTimeout(function () {\r\n                    if (opened === false) {\r\n                        // If we\'re reconnecting and the event source is attempting to connect,\r\n                        // don\'t keep retrying. This causes duplicate connections to spawn.\r\n                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {\r\n                            // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                },\r\n                that.timeOut);\r\n            }\r\n\r\n            connection.eventSource.addEventListener("open", function (e) {\r\n                connection.log("EventSource connected.");\r\n\r\n                clearReconnectAttemptTimeout(connection);\r\n                transportLogic.clearReconnectTimeout(connection);\r\n\r\n                if (opened === false) {\r\n                    opened = true;\r\n\r\n                    if (changeState(connection,\r\n                                         signalR.connectionState.reconnecting,\r\n                                         signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                }\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener("message", function (e) {\r\n                var res;\r\n\r\n                // process messages\r\n                if (e.data === "initialized") {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    res = connection._parseResponse(e.data);\r\n                }\r\n                catch (error) {\r\n                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);\r\n                    return;\r\n                }\r\n\r\n                transportLogic.processMessages(connection, res, onSuccess);\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener("error", function (e) {\r\n                var error = signalR._.transportError(\r\n                    signalR.resources.eventSourceError,\r\n                    connection.transport,\r\n                    e);\r\n\r\n                // Only handle an error if the error is from the current Event Source.\r\n                // Sometimes on disconnect the server will push down an error event\r\n                // to an expired Event Source.\r\n                if (this !== connection.eventSource) {\r\n                    return;\r\n                }\r\n\r\n                if (onFailed && onFailed(error)) {\r\n                    return;\r\n                }\r\n\r\n                connection.log("EventSource readyState: " + connection.eventSource.readyState + ".");\r\n\r\n                if (e.eventPhase === window.EventSource.CLOSED) {\r\n                    // We don\'t use the EventSource\'s native reconnect function as it\r\n                    // doesn\'t allow us to change the URL when reconnecting. We need\r\n                    // to change the URL to not include the /connect suffix, and pass\r\n                    // the last message id we received.\r\n                    connection.log("EventSource reconnecting due to the server connection ending.");\r\n                    that.reconnect(connection);\r\n                } else {\r\n                    // connection error\r\n                    connection.log("EventSource error.");\r\n                    $connection.triggerHandler(events.onError, [error]);\r\n                }\r\n            }, false);\r\n        },\r\n\r\n        reconnect: function (connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function (connection) {\r\n            // Don\'t trigger a reconnect after stopping\r\n            clearReconnectAttemptTimeout(connection);\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection && connection.eventSource) {\r\n                connection.log("EventSource calling close().");\r\n                connection.eventSource.close();\r\n                connection.eventSource = null;\r\n                delete connection.eventSource;\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.foreverFrame.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        createFrame = function () {\r\n            var frame = window.document.createElement("iframe");\r\n            frame.setAttribute("style", "position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;");\r\n            return frame;\r\n        },\r\n        // Used to prevent infinite loading icon spins in older versions of ie\r\n        // We build this object inside a closure so we don\'t pollute the rest of\r\n        // the foreverFrame transport with unnecessary functions/utilities.\r\n        loadPreventer = (function () {\r\n            var loadingFixIntervalId = null,\r\n                loadingFixInterval = 1000,\r\n                attachedTo = 0;\r\n\r\n            return {\r\n                prevent: function () {\r\n                    // Prevent additional iframe removal procedures from newer browsers\r\n                    if (signalR._.ieVersion <= 8) {\r\n                        // We only ever want to set the interval one time, so on the first attachedTo\r\n                        if (attachedTo === 0) {\r\n                            // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky\r\n                            loadingFixIntervalId = window.setInterval(function () {\r\n                                var tempFrame = createFrame();\r\n\r\n                                window.document.body.appendChild(tempFrame);\r\n                                window.document.body.removeChild(tempFrame);\r\n\r\n                                tempFrame = null;\r\n                            }, loadingFixInterval);\r\n                        }\r\n\r\n                        attachedTo++;\r\n                    }\r\n                },\r\n                cancel: function () {\r\n                    // Only clear the interval if there\'s only one more object that the loadPreventer is attachedTo\r\n                    if (attachedTo === 1) {\r\n                        window.clearInterval(loadingFixIntervalId);\r\n                    }\r\n\r\n                    if (attachedTo > 0) {\r\n                        attachedTo--;\r\n                    }\r\n                }\r\n            };\r\n        })();\r\n\r\n    signalR.transports.foreverFrame = {\r\n        name: "foreverFrame",\r\n\r\n        supportsKeepAlive: function () {\r\n            return true;\r\n        },\r\n\r\n        // Added as a value here so we can create tests to verify functionality\r\n        iframeClearThreshold: 50,\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                frameId = (transportLogic.foreverFrame.count += 1),\r\n                url,\r\n                frame = createFrame(),\r\n                frameLoadHandler = function () {\r\n                    connection.log("Forever frame iframe finished loading and is no longer receiving messages.");\r\n                    if (!onFailed || !onFailed()) {\r\n                        that.reconnect(connection);\r\n                    }\r\n                };\r\n\r\n            if (window.EventSource) {\r\n                // If the browser supports SSE, don\'t use Forever Frame\r\n                if (onFailed) {\r\n                    connection.log("Forever Frame is not supported by SignalR on browsers with SSE support.");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            frame.setAttribute("data-signalr-connection-id", connection.id);\r\n\r\n            // Start preventing loading icon\r\n            // This will only perform work if the loadPreventer is not attached to another connection.\r\n            loadPreventer.prevent();\r\n\r\n            // Build the url\r\n            url = transportLogic.getUrl(connection, this.name);\r\n            url += "&frameId=" + frameId;\r\n\r\n            // add frame to the document prior to setting URL to avoid caching issues.\r\n            window.document.documentElement.appendChild(frame);\r\n\r\n            connection.log("Binding to iframe\'s load event.");\r\n\r\n            if (frame.addEventListener) {\r\n                frame.addEventListener("load", frameLoadHandler, false);\r\n            } else if (frame.attachEvent) {\r\n                frame.attachEvent("onload", frameLoadHandler);\r\n            }\r\n\r\n            frame.src = url;\r\n            transportLogic.foreverFrame.connections[frameId] = connection;\r\n\r\n            connection.frame = frame;\r\n            connection.frameId = frameId;\r\n\r\n            if (onSuccess) {\r\n                connection.onSuccess = function () {\r\n                    connection.log("Iframe transport started.");\r\n                    onSuccess();\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function (connection) {\r\n            var that = this;\r\n\r\n            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {\r\n                window.setTimeout(function () {\r\n                    // Verify that we\'re ok to reconnect.\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {\r\n                        var frame = connection.frame,\r\n                            src = transportLogic.getUrl(connection, that.name, true) + "&frameId=" + connection.frameId;\r\n                        connection.log("Updating iframe src to \'" + src + "\'.");\r\n                        frame.src = src;\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        receive: function (connection, data) {\r\n            var cw,\r\n                body,\r\n                response;\r\n\r\n            if (connection.json !== connection._originalJson) {\r\n                // If there\'s a custom JSON parser configured then serialize the object\r\n                // using the original (browser) JSON parser and then deserialize it using\r\n                // the custom parser (connection._parseResponse does that). This is so we\r\n                // can easily send the response from the server as "raw" JSON but still\r\n                // support custom JSON deserialization in the browser.\r\n                data = connection._originalJson.stringify(data);\r\n            }\r\n\r\n            response = connection._parseResponse(data);\r\n\r\n            transportLogic.processMessages(connection, response, connection.onSuccess);\r\n\r\n            // Protect against connection stopping from a callback trigger within the processMessages above.\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                // Delete the script & div elements\r\n                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;\r\n                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {\r\n                    connection.frameMessageCount = 0;\r\n                    cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                    if (cw && cw.document && cw.document.body) {\r\n                        body = cw.document.body;\r\n\r\n                        // Remove all the child elements from the iframe\'s body to conserver memory\r\n                        while (body.firstChild) {\r\n                            body.removeChild(body.firstChild);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        stop: function (connection) {\r\n            var cw = null;\r\n\r\n            // Stop attempting to prevent loading icon\r\n            loadPreventer.cancel();\r\n\r\n            if (connection.frame) {\r\n                if (connection.frame.stop) {\r\n                    connection.frame.stop();\r\n                } else {\r\n                    try {\r\n                        cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                        if (cw.document && cw.document.execCommand) {\r\n                            cw.document.execCommand("Stop");\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        connection.log("Error occurred when stopping foreverFrame transport. Message = " + e.message + ".");\r\n                    }\r\n                }\r\n\r\n                // Ensure the iframe is where we left it\r\n                if (connection.frame.parentNode === window.document.documentElement) {\r\n                    window.document.documentElement.removeChild(connection.frame);\r\n                }\r\n\r\n                delete transportLogic.foreverFrame.connections[connection.frameId];\r\n                connection.frame = null;\r\n                connection.frameId = null;\r\n                delete connection.frame;\r\n                delete connection.frameId;\r\n                delete connection.onSuccess;\r\n                delete connection.frameMessageCount;\r\n                connection.log("Stopping forever frame.");\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        },\r\n\r\n        getConnection: function (id) {\r\n            return transportLogic.foreverFrame.connections[id];\r\n        },\r\n\r\n        started: function (connection) {\r\n            if (changeState(connection,\r\n                signalR.connectionState.reconnecting,\r\n                signalR.connectionState.connected) === true) {\r\n\r\n                $(connection).triggerHandler(events.onReconnect);\r\n            }\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.transports.longPolling.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.transports.common.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        isDisconnecting = $.signalR.isDisconnecting,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.longPolling = {\r\n        name: "longPolling",\r\n\r\n        supportsKeepAlive: function () {\r\n            return false;\r\n        },\r\n\r\n        reconnectDelay: 3000,\r\n\r\n        start: function (connection, onSuccess, onFailed) {\r\n            /// <summary>Starts the long polling connection</summary>\r\n            /// <param name="connection" type="signalR">The SignalR connection to start</param>\r\n            var that = this,\r\n                fireConnect = function () {\r\n                    fireConnect = $.noop;\r\n\r\n                    connection.log("LongPolling connected.");\r\n\r\n                    if (onSuccess) {\r\n                        onSuccess();\r\n                    } else {\r\n                        connection.log("WARNING! The client received an init message after reconnecting.");\r\n                    }\r\n                },\r\n                tryFailConnect = function (error) {\r\n                    if (onFailed(error)) {\r\n                        connection.log("LongPolling failed to connect.");\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                },\r\n                privateData = connection._,\r\n                reconnectErrors = 0,\r\n                fireReconnected = function (instance) {\r\n                    window.clearTimeout(privateData.reconnectTimeoutId);\r\n                    privateData.reconnectTimeoutId = null;\r\n\r\n                    if (changeState(instance,\r\n                                    signalR.connectionState.reconnecting,\r\n                                    signalR.connectionState.connected) === true) {\r\n                        // Successfully reconnected!\r\n                        instance.log("Raising the reconnect event");\r\n                        $(instance).triggerHandler(events.onReconnect);\r\n                    }\r\n                },\r\n                // 1 hour\r\n                maxFireReconnectedTimeout = 3600000;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.log("Polling xhr requests already exists, aborting.");\r\n                connection.stop();\r\n            }\r\n\r\n            connection.messageId = null;\r\n\r\n            privateData.reconnectTimeoutId = null;\r\n\r\n            privateData.pollTimeoutId = window.setTimeout(function () {\r\n                (function poll(instance, raiseReconnect) {\r\n                    var messageId = instance.messageId,\r\n                        connect = (messageId === null),\r\n                        reconnecting = !connect,\r\n                        polling = !raiseReconnect,\r\n                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling, true /* use Post for longPolling */),\r\n                        postData = {};\r\n\r\n                    if (instance.messageId) {\r\n                        postData.messageId = instance.messageId;\r\n                    }\r\n\r\n                    if (instance.groupsToken) {\r\n                        postData.groupsToken = instance.groupsToken;\r\n                    }\r\n\r\n                    // If we\'ve disconnected during the time we\'ve tried to re-instantiate the poll then stop.\r\n                    if (isDisconnecting(instance) === true) {\r\n                        return;\r\n                    }\r\n\r\n                    connection.log("Opening long polling request to \'" + url + "\'.");\r\n                    instance.pollXhr = transportLogic.ajax(connection, {\r\n                        xhrFields: {\r\n                            onprogress: function () {\r\n                                transportLogic.markLastMessage(connection);\r\n                            }\r\n                        },\r\n                        url: url,\r\n                        type: "POST",\r\n                        contentType: signalR._.defaultContentType,\r\n                        data: postData,\r\n                        timeout: connection._.pollTimeout,\r\n                        success: function (result) {\r\n                            var minData,\r\n                                delay = 0,\r\n                                data,\r\n                                shouldReconnect;\r\n\r\n                            connection.log("Long poll complete.");\r\n\r\n                            // Reset our reconnect errors so if we transition into a reconnecting state again we trigger\r\n                            // reconnected quickly\r\n                            reconnectErrors = 0;\r\n\r\n                            try {\r\n                                // Remove any keep-alives from the beginning of the result\r\n                                minData = connection._parseResponse(result);\r\n                            }\r\n                            catch (error) {\r\n                                transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);\r\n                                return;\r\n                            }\r\n\r\n                            // If there\'s currently a timeout to trigger reconnect, fire it now before processing messages\r\n                            if (privateData.reconnectTimeoutId !== null) {\r\n                                fireReconnected(instance);\r\n                            }\r\n\r\n                            if (minData) {\r\n                                data = transportLogic.maximizePersistentResponse(minData);\r\n                            }\r\n\r\n                            transportLogic.processMessages(instance, minData, fireConnect);\r\n\r\n                            if (data &&\r\n                                $.type(data.LongPollDelay) === "number") {\r\n                                delay = data.LongPollDelay;\r\n                            }\r\n\r\n                            if (isDisconnecting(instance) === true) {\r\n                                return;\r\n                            }\r\n\r\n                            shouldReconnect = data && data.ShouldReconnect;\r\n                            if (shouldReconnect) {\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function\r\n                            if (delay > 0) {\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, shouldReconnect);\r\n                                }, delay);\r\n                            } else {\r\n                                poll(instance, shouldReconnect);\r\n                            }\r\n                        },\r\n\r\n                        error: function (data, textStatus) {\r\n                            var error = signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr);\r\n\r\n                            // Stop trying to trigger reconnect, connection is in an error state\r\n                            // If we\'re not in the reconnect state this will noop\r\n                            window.clearTimeout(privateData.reconnectTimeoutId);\r\n                            privateData.reconnectTimeoutId = null;\r\n\r\n                            if (textStatus === "abort") {\r\n                                connection.log("Aborted xhr request.");\r\n                                return;\r\n                            }\r\n\r\n                            if (!tryFailConnect(error)) {\r\n\r\n                                // Increment our reconnect errors, we assume all errors to be reconnect errors\r\n                                // In the case that it\'s our first error this will cause Reconnect to be fired\r\n                                // after 1 second due to reconnectErrors being = 1.\r\n                                reconnectErrors++;\r\n\r\n                                if (connection.state !== signalR.connectionState.reconnecting) {\r\n                                    connection.log("An error occurred using longPolling. Status = " + textStatus + ".  Response = " + data.responseText + ".");\r\n                                    $(instance).triggerHandler(events.onError, [error]);\r\n                                }\r\n\r\n                                // We check the state here to verify that we\'re not in an invalid state prior to verifying Reconnect.\r\n                                // If we\'re not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.\r\n                                // Therefore we don\'t want to change that failure code path.\r\n                                if ((connection.state === signalR.connectionState.connected ||\r\n                                    connection.state === signalR.connectionState.reconnecting) &&\r\n                                    !transportLogic.verifyLastActive(connection)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Call poll with the raiseReconnect flag as true after the reconnect delay\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, true);\r\n                                }, that.reconnectDelay);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // This will only ever pass after an error has occurred via the poll ajax procedure.\r\n                    if (reconnecting && raiseReconnect === true) {\r\n                        // We wait to reconnect depending on how many times we\'ve failed to reconnect.\r\n                        // This is essentially a heuristic that will exponentially increase in wait time before\r\n                        // triggering reconnected.  This depends on the "error" handler of Poll to cancel this\r\n                        // timeout if it triggers before the Reconnected event fires.\r\n                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.\r\n                        privateData.reconnectTimeoutId = window.setTimeout(function () { fireReconnected(instance); }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));\r\n                    }\r\n                }(connection));\r\n            }, 250); // Have to delay initial poll so Chrome doesn\'t show loader spinner in tab\r\n        },\r\n\r\n        lostConnection: function (connection) {\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort("lostConnection");\r\n            }\r\n        },\r\n\r\n        send: function (connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function (connection) {\r\n            /// <summary>Stops the long polling connection</summary>\r\n            /// <param name="connection" type="signalR">The SignalR connection to stop</param>\r\n\r\n            window.clearTimeout(connection._.pollTimeoutId);\r\n            window.clearTimeout(connection._.reconnectTimeoutId);\r\n\r\n            delete connection._.pollTimeoutId;\r\n            delete connection._.reconnectTimeoutId;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort();\r\n                connection.pollXhr = null;\r\n                delete connection.pollXhr;\r\n            }\r\n        },\r\n\r\n        abort: function (connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.hubs.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.core.js" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var eventNamespace = ".hubProxy",\r\n        signalR = $.signalR;\r\n\r\n    function makeEventName(event) {\r\n        return event + eventNamespace;\r\n    }\r\n\r\n    // Equivalent to Array.prototype.map\r\n    function map(arr, fun, thisp) {\r\n        var i,\r\n            length = arr.length,\r\n            result = [];\r\n        for (i = 0; i < length; i += 1) {\r\n            if (arr.hasOwnProperty(i)) {\r\n                result[i] = fun.call(thisp, arr[i], i, arr);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getArgValue(a) {\r\n        return $.isFunction(a) ? null : ($.type(a) === "undefined" ? null : a);\r\n    }\r\n\r\n    function hasMembers(obj) {\r\n        for (var key in obj) {\r\n            // If we have any properties in our callback map then we have callbacks and can exit the loop via return\r\n            if (obj.hasOwnProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function clearInvocationCallbacks(connection, error) {\r\n        /// <param name="connection" type="hubConnection" />\r\n        var callbacks = connection._.invocationCallbacks,\r\n            callback;\r\n\r\n        if (hasMembers(callbacks)) {\r\n            connection.log("Clearing hub invocation callbacks with error: " + error + ".");\r\n        }\r\n\r\n        // Reset the callback cache now as we have a local var referencing it\r\n        connection._.invocationCallbackId = 0;\r\n        delete connection._.invocationCallbacks;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Loop over the callbacks and invoke them.\r\n        // We do this using a local var reference and *after* we\'ve cleared the cache\r\n        // so that if a fail callback itself tries to invoke another method we don\'t\r\n        // end up with its callback in the list we\'re looping over.\r\n        for (var callbackId in callbacks) {\r\n            callback = callbacks[callbackId];\r\n            callback.method.call(callback.scope, { E: error });\r\n        }\r\n    }\r\n\r\n    // hubProxy\r\n    function hubProxy(hubConnection, hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        return new hubProxy.fn.init(hubConnection, hubName);\r\n    }\r\n\r\n    hubProxy.fn = hubProxy.prototype = {\r\n        init: function (connection, hubName) {\r\n            this.state = {};\r\n            this.connection = connection;\r\n            this.hubName = hubName;\r\n            this._ = {\r\n                callbackMap: {}\r\n            };\r\n        },\r\n\r\n        constructor: hubProxy,\r\n\r\n        hasSubscriptions: function () {\r\n            return hasMembers(this._.callbackMap);\r\n        },\r\n\r\n        on: function (eventName, callback) {\r\n            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>\r\n            /// <param name="eventName" type="String">The name of the hub event to register the callback for.</param>\r\n            /// <param name="callback" type="Function">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            // If there is not an event registered for this callback yet we want to create its event space in the callback map.\r\n            if (!callbackMap[eventName]) {\r\n                callbackMap[eventName] = {};\r\n            }\r\n\r\n            // Map the callback to our encompassed function\r\n            callbackMap[eventName][callback] = function (e, data) {\r\n                callback.apply(that, data);\r\n            };\r\n\r\n            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);\r\n\r\n            return that;\r\n        },\r\n\r\n        off: function (eventName, callback) {\r\n            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>\r\n            /// <param name="eventName" type="String">The name of the hub event to unregister the callback for.</param>\r\n            /// <param name="callback" type="Function">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap,\r\n                callbackSpace;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            callbackSpace = callbackMap[eventName];\r\n\r\n            // Verify that there is an event space to unbind\r\n            if (callbackSpace) {\r\n                // Only unbind if there\'s an event bound with eventName and a callback with the specified callback\r\n                if (callbackSpace[callback]) {\r\n                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);\r\n\r\n                    // Remove the callback from the callback map\r\n                    delete callbackSpace[callback];\r\n\r\n                    // Check if there are any members left on the event, if not we need to destroy it.\r\n                    if (!hasMembers(callbackSpace)) {\r\n                        delete callbackMap[eventName];\r\n                    }\r\n                } else if (!callback) { // Check if we\'re removing the whole event and we didn\'t error because of an invalid callback\r\n                    $(that).unbind(makeEventName(eventName));\r\n\r\n                    delete callbackMap[eventName];\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        invoke: function (methodName) {\r\n            /// <summary>Invokes a server hub method with the given arguments.</summary>\r\n            /// <param name="methodName" type="String">The name of the server hub method.</param>\r\n\r\n            var that = this,\r\n                connection = that.connection,\r\n                args = $.makeArray(arguments).slice(1),\r\n                argValues = map(args, getArgValue),\r\n                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },\r\n                d = $.Deferred(),\r\n                callback = function (minResult) {\r\n                    var result = that._maximizeHubResponse(minResult),\r\n                        source,\r\n                        error;\r\n\r\n                    // Update the hub state\r\n                    $.extend(that.state, result.State);\r\n\r\n                    if (result.Progress) {\r\n                        if (d.notifyWith) {\r\n                            // Progress is only supported in jQuery 1.7+\r\n                            d.notifyWith(that, [result.Progress.Data]);\r\n                        } else if(!connection._.progressjQueryVersionLogged) {\r\n                            connection.log("A hub method invocation progress update was received but the version of jQuery in use (" + $.prototype.jquery + ") does not support progress updates. Upgrade to jQuery 1.7+ to receive progress notifications.");\r\n                            connection._.progressjQueryVersionLogged = true;\r\n                        }\r\n                    } else if (result.Error) {\r\n                        // Server hub method threw an exception, log it & reject the deferred\r\n                        if (result.StackTrace) {\r\n                            connection.log(result.Error + "\\n" + result.StackTrace + ".");\r\n                        }\r\n\r\n                        // result.ErrorData is only set if a HubException was thrown\r\n                        source = result.IsHubException ? "HubException" : "Exception";\r\n                        error = signalR._.error(result.Error, source);\r\n                        error.data = result.ErrorData;\r\n\r\n                        connection.log(that.hubName + "." + methodName + " failed to execute. Error: " + error.message);\r\n                        d.rejectWith(that, [error]);\r\n                    } else {\r\n                        // Server invocation succeeded, resolve the deferred\r\n                        connection.log("Invoked " + that.hubName + "." + methodName);\r\n                        d.resolveWith(that, [result.Result]);\r\n                    }\r\n                };\r\n\r\n            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };\r\n            connection._.invocationCallbackId += 1;\r\n\r\n            if (!$.isEmptyObject(that.state)) {\r\n                data.S = that.state;\r\n            }\r\n\r\n            connection.log("Invoking " + that.hubName + "." + methodName);\r\n            connection.send(data);\r\n\r\n            return d.promise();\r\n        },\r\n\r\n        _maximizeHubResponse: function (minHubResponse) {\r\n            return {\r\n                State: minHubResponse.S,\r\n                Result: minHubResponse.R,\r\n                Progress: minHubResponse.P ? {\r\n                    Id: minHubResponse.P.I,\r\n                    Data: minHubResponse.P.D\r\n                } : null,\r\n                Id: minHubResponse.I,\r\n                IsHubException: minHubResponse.H,\r\n                Error: minHubResponse.E,\r\n                StackTrace: minHubResponse.T,\r\n                ErrorData: minHubResponse.D\r\n            };\r\n        }\r\n    };\r\n\r\n    hubProxy.fn.init.prototype = hubProxy.fn;\r\n\r\n    // hubConnection\r\n    function hubConnection(url, options) {\r\n        /// <summary>Creates a new hub connection.</summary>\r\n        /// <param name="url" type="String">[Optional] The hub route url, defaults to "/signalr".</param>\r\n        /// <param name="options" type="Object">[Optional] Settings to use when creating the hubConnection.</param>\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        };\r\n\r\n        $.extend(settings, options);\r\n\r\n        if (!url || settings.useDefaultPath) {\r\n            url = (url || "") + "/signalr";\r\n        }\r\n        return new hubConnection.fn.init(url, settings);\r\n    }\r\n\r\n    hubConnection.fn = hubConnection.prototype = $.connection();\r\n\r\n    hubConnection.fn.init = function (url, options) {\r\n        var settings = {\r\n                qs: null,\r\n                logging: false,\r\n                useDefaultPath: true\r\n            },\r\n            connection = this;\r\n\r\n        $.extend(settings, options);\r\n\r\n        // Call the base constructor\r\n        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);\r\n\r\n        // Object to store hub proxies for this connection\r\n        connection.proxies = {};\r\n\r\n        connection._.invocationCallbackId = 0;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Wire up the received handler\r\n        connection.received(function (minData) {\r\n            var data, proxy, dataCallbackId, callback, hubName, eventName;\r\n            if (!minData) {\r\n                return;\r\n            }\r\n\r\n            // We have to handle progress updates first in order to ensure old clients that receive\r\n            // progress updates enter the return value branch and then no-op when they can\'t find\r\n            // the callback in the map (because the minData.I value will not be a valid callback ID)\r\n            if (typeof (minData.P) !== "undefined") {\r\n                // Process progress notification\r\n                dataCallbackId = minData.P.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else if (typeof (minData.I) !== "undefined") {\r\n                // We received the return value from a server method invocation, look up callback by id and call it\r\n                dataCallbackId = minData.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    // Delete the callback from the proxy\r\n                    connection._.invocationCallbacks[dataCallbackId] = null;\r\n                    delete connection._.invocationCallbacks[dataCallbackId];\r\n\r\n                    // Invoke the callback\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else {\r\n                data = this._maximizeClientHubInvocation(minData);\r\n\r\n                // We received a client invocation request, i.e. broadcast from server hub\r\n                connection.log("Triggering client hub event \'" + data.Method + "\' on hub \'" + data.Hub + "\'.");\r\n\r\n                // Normalize the names to lowercase\r\n                hubName = data.Hub.toLowerCase();\r\n                eventName = data.Method.toLowerCase();\r\n\r\n                // Trigger the local invocation event\r\n                proxy = this.proxies[hubName];\r\n\r\n                // Update the hub state\r\n                $.extend(proxy.state, data.State);\r\n                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);\r\n            }\r\n        });\r\n\r\n        connection.error(function (errData, origData) {\r\n            var callbackId, callback;\r\n\r\n            if (!origData) {\r\n                // No original data passed so this is not a send error\r\n                return;\r\n            }\r\n\r\n            callbackId = origData.I;\r\n            callback = connection._.invocationCallbacks[callbackId];\r\n\r\n            // Verify that there is a callback bound (could have been cleared)\r\n            if (callback) {\r\n                // Delete the callback\r\n                connection._.invocationCallbacks[callbackId] = null;\r\n                delete connection._.invocationCallbacks[callbackId];\r\n\r\n                // Invoke the callback with an error to reject the promise\r\n                callback.method.call(callback.scope, { E: errData });\r\n            }\r\n        });\r\n\r\n        connection.reconnecting(function () {\r\n            if (connection.transport && connection.transport.name === "webSockets") {\r\n                clearInvocationCallbacks(connection, "Connection started reconnecting before invocation result was received.");\r\n            }\r\n        });\r\n\r\n        connection.disconnected(function () {\r\n            clearInvocationCallbacks(connection, "Connection was disconnected before invocation result was received.");\r\n        });\r\n    };\r\n\r\n    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {\r\n        return {\r\n            Hub: minClientHubInvocation.H,\r\n            Method: minClientHubInvocation.M,\r\n            Args: minClientHubInvocation.A,\r\n            State: minClientHubInvocation.S\r\n        };\r\n    };\r\n\r\n    hubConnection.fn._registerSubscribedHubs = function () {\r\n        /// <summary>\r\n        ///     Sets the starting event to loop through the known hubs and register any new hubs\r\n        ///     that have been added to the proxy.\r\n        /// </summary>\r\n        var connection = this;\r\n\r\n        if (!connection._subscribedToHubs) {\r\n            connection._subscribedToHubs = true;\r\n            connection.starting(function () {\r\n                // Set the connection\'s data object with all the hub proxies with active subscriptions.\r\n                // These proxies will receive notifications from the server.\r\n                var subscribedHubs = [];\r\n\r\n                $.each(connection.proxies, function (key) {\r\n                    if (this.hasSubscriptions()) {\r\n                        subscribedHubs.push({ name: key });\r\n                        connection.log("Client subscribed to hub \'" + key + "\'.");\r\n                    }\r\n                });\r\n\r\n                if (subscribedHubs.length === 0) {\r\n                    connection.log("No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.");\r\n                }\r\n\r\n                connection.data = connection.json.stringify(subscribedHubs);\r\n            });\r\n        }\r\n    };\r\n\r\n    hubConnection.fn.createHubProxy = function (hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        /// <param name="hubName" type="String">\r\n        ///     The name of the hub on the server to create the proxy for.\r\n        /// </param>\r\n\r\n        // Normalize the name to lowercase\r\n        hubName = hubName.toLowerCase();\r\n\r\n        var proxy = this.proxies[hubName];\r\n        if (!proxy) {\r\n            proxy = hubProxy(this, hubName);\r\n            this.proxies[hubName] = proxy;\r\n        }\r\n\r\n        this._registerSubscribedHubs();\r\n\r\n        return proxy;\r\n    };\r\n\r\n    hubConnection.fn.init.prototype = hubConnection.fn;\r\n\r\n    $.hubConnection = hubConnection;\r\n\r\n}(window.jQuery, window));\r\n/* jquery.signalR.version.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path="jquery.signalR.core.js" />\r\n(function ($, undefined) {\r\n    $.signalR.version = "2.2.2-pre";\r\n}(window.jQuery));\r\n';
    loader.global.define = undefined;
    loader.global.module = undefined;
    loader.global.exports = undefined;
    loader.__exec({
        'source': source,
        'address': module.uri
    });
    loader.global.require = require;
    loader.global.define = define;
    return loader.get('@@global-helpers').retrieveGlobal(module.id, undefined);
});
/*can-connect-signalr@0.2.3#can-connect-signalr*/
define('can-connect-signalr@0.2.3#can-connect-signalr', [
    'require',
    'exports',
    'module',
    'can-connect',
    'jquery',
    'ms-signalr-client'
], function (require, exports, module) {
    var connect = require('can-connect');
    var $ = require('jquery');
    require('ms-signalr-client');
    var camelCase = function (str) {
        return str[0].toLowerCase() + str.substr(1);
    };
    module.exports = connect.behavior('can-connect-signalr', function signalR(baseConnection) {
        return {
            init: function () {
                if (!this.signalR.url) {
                    throw new Error('Invalid SignalR Hub URL. URL cannot be blank.');
                }
                if (!this.signalR.name) {
                    throw new Error('Invalid SignalR Hub name. Hub name cannot be blank.');
                }
                baseConnection.init.apply(this, arguments);
                var context = this;
                this.signalR.ready = new Promise(function (resolve, reject) {
                    var signalR = context.signalR;
                    var name = signalR.name.toLowerCase();
                    signalR.connection = $.hubConnection(signalR.url);
                    signalR.proxy = signalR.connection.createHubProxy(signalR.name);
                    signalR.proxy.on(signalR.createdName || name + 'Created', function (item) {
                        context.createInstance(item);
                    });
                    signalR.proxy.on(signalR.updatedName || name + 'Updated', function (item) {
                        context.updateInstance(item);
                    });
                    signalR.proxy.on(signalR.destroyedName || name + 'Destroyed', function (item) {
                        context.destroyInstance(item);
                    });
                    signalR.connection.start().done(function () {
                        resolve(signalR);
                    }).fail(reject);
                });
            },
            createData: function (props) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.createName || camelCase(signalR.name) + 'Create', props);
                });
            },
            updateData: function (props) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.updateName || camelCase(signalR.name) + 'Update', props);
                });
            },
            destroyData: function (props) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.destroyName || camelCase(signalR.name) + 'Destroy', props);
                });
            },
            getListData: function (set) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.getListDataName || camelCase(signalR.name) + 'GetListData', set);
                });
            },
            get: function (set) {
                return this.signalR.ready.then(function (signalR) {
                    return signalR.proxy.invoke(signalR.getDataName || camelCase(signalR.name) + 'GetData', set);
                });
            }
        };
    });
});
/*can-connect-signalr@0.2.3#test*/
define('can-connect-signalr@0.2.3#test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-connect',
    'can-connect/data/parse/parse',
    'can-connect/constructor/constructor',
    'can-connect/constructor/store/store',
    'can-connect/can/map/map',
    'can-connect/data/callbacks/callbacks',
    'can-connect/real-time/real-time',
    'can-connect/constructor/callbacks-once/callbacks-once',
    'can-define/map/map',
    'can-define/list/list',
    './can-connect-signalr',
    'jquery'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var connect = require('can-connect');
    var dataParse = require('can-connect/data/parse/parse');
    var constructor = require('can-connect/constructor/constructor');
    var constructorStore = require('can-connect/constructor/store/store');
    var canMap = require('can-connect/can/map/map');
    var dataCallbacks = require('can-connect/data/callbacks/callbacks');
    var realTime = require('can-connect/real-time/real-time');
    var constructorCallbacksOnce = require('can-connect/constructor/callbacks-once/callbacks-once');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var signalR = require('./can-connect-signalr');
    var $ = require('jquery');
    $.hubConnection = function () {
        return {
            id: 2228271782,
            createHubProxy: function createHubProxy() {
                return {
                    on: function on() {
                    },
                    invoke: function invoke(methodName) {
                        var promise;
                        switch (methodName) {
                        case 'messageGetListData':
                            promise = new Promise(function (resolve, reject) {
                                resolve([{ data: [testData] }]);
                            });
                            break;
                        case 'messageGetData':
                            promise = new Promise(function (resolve, reject) {
                                resolve(testData);
                            });
                            break;
                        case 'messageUpdate':
                            promise = new Promise(function (resolve, reject) {
                                testData.text = 'Hello!';
                                resolve(testData);
                            });
                            break;
                        default:
                            promise = new Promise(function (resolve, reject) {
                                resolve(testData);
                            });
                            break;
                        }
                        return promise;
                    }
                };
            },
            start: function start() {
                return {
                    done: function done(fn) {
                        fn();
                    }
                };
            }
        };
    };
    var Message = DefineMap.extend({
        text: 'string',
        id: 'number'
    });
    Message.List = DefineList.extend({ '#': Message });
    var testData = {
        'text': 'this',
        'id': 1
    };
    QUnit.module('can-connect-signalr', {
        beforeEach: function () {
            var behaviors = [
                dataParse,
                constructor,
                constructorStore,
                canMap,
                dataCallbacks,
                realTime,
                constructorCallbacksOnce,
                signalR
            ];
            Message.connection = connect(behaviors, {
                Map: Message,
                List: Message.List,
                signalR: {
                    url: 'http://test.com',
                    name: 'Message'
                }
            });
        }
    });
    QUnit.test('Plugin initializes correctly', function () {
        QUnit.equal(Message.connection.__behaviorName, 'can-connect-signalr');
    });
    QUnit.test('getList', function (assert) {
        var done = assert.async();
        Message.getList({}).then(function (messages) {
            assert.ok(messages, 'Got a response from findAll');
            assert.equal(messages instanceof Message.List, true, 'got a Message.List back');
            done();
        });
    });
    QUnit.test('get', function (assert) {
        var done = assert.async();
        Message.get().then(function (messages) {
            assert.ok(messages, 'Got a response from findOne');
            done();
        });
    });
    QUnit.test('create', function (assert) {
        var done = assert.async();
        var message = new Message({ text: 'Hi there!' });
        message.save().then(function (msg) {
            assert.ok(msg);
            done();
        });
    });
    QUnit.test('update', function (assert) {
        var done = assert.async();
        var message = new Message({ text: 'Hi there!' });
        message.save().then(function (msg) {
            msg.text = 'Hello!';
            msg.save().then(function (saveResponse) {
                assert.equal(saveResponse.text, 'Hello!', 'message text updated correctly');
                done();
            });
        });
    });
    QUnit.test('destroy', function (assert) {
        var done = assert.async();
        var message = new Message({ text: 'Hi there!' });
        message.save().then(function (msg) {
            var id = msg._id;
            msg.destroy().then(function (res) {
                assert.equal(res._id, id, 'deleted the instance');
                done();
            });
        });
    });
});
/*can-connect@1.5.18#helpers/get-id-props*/
define('can-connect@1.5.18#helpers/get-id-props', function (require, exports, module) {
    module.exports = function (connection) {
        var ids = [], algebra = connection.algebra;
        if (algebra && algebra.clauses && algebra.clauses.id) {
            for (var prop in algebra.clauses.id) {
                ids.push(prop);
            }
        }
        if (connection.idProp && !ids.length) {
            ids.push(connection.idProp);
        }
        if (!ids.length) {
            ids.push('id');
        }
        return ids;
    };
});
/*can-connect-cloneable@0.2.4#can-connect-cloneable*/
define('can-connect-cloneable@0.2.4#can-connect-cloneable', [
    'require',
    'exports',
    'module',
    'can-util/js/each/each',
    'can-util/js/deep-assign/deep-assign',
    'can-util/js/assign/assign',
    'can-connect/helpers/get-id-props'
], function (require, exports, module) {
    var each = require('can-util/js/each/each');
    var deepAssign = require('can-util/js/deep-assign/deep-assign');
    var assign = require('can-util/js/assign/assign');
    var getIdProps = require('can-connect/helpers/get-id-props');
    module.exports = function makeClone(Type) {
        var idProp = getIdProps(Type.connection)[0];
        var definition = {
            save: function () {
                var data = this.serialize();
                delete data._original;
                if (this._original[idProp]) {
                    data[idProp] = this._original[idProp];
                    return this._original.constructor.connection.updateData(data).then(function () {
                        Type.connection.updatedInstance(this._original, data);
                    }.bind(this));
                } else {
                    return this._original.constructor.connection.createData(data).then(function (res) {
                        Type.connection.createdInstance(this._original, deepAssign({}, data, res));
                    }.bind(this));
                }
            }
        };
        if (Type.prototype.hasOwnProperty('_define')) {
            each(Type.prototype._define.definitions, function (def, prop) {
                definition[prop] = assign(assign({}, def), {
                    get: def.get || function (lastSet) {
                        return lastSet !== undefined ? lastSet : this._original[prop];
                    },
                    serialize: def.serialize === undefined ? def.get ? false : true : def.serialize
                });
            });
            deepAssign(definition, { _original: { Type: Type } });
        } else {
            definition.define = {};
            each(Type.prototype.define, function (def, prop) {
                definition.define[prop] = assign(assign({}, def), {
                    get: def.get || function (lastSet) {
                        return lastSet !== undefined ? lastSet : this._original[prop];
                    },
                    serialize: def.serialize === undefined ? def.get ? false : true : def.serialize
                });
            });
            deepAssign(definition, { define: { _original: { Type: Type } } });
        }
        delete definition[idProp];
        var Clone = Type.extend(definition);
        Type.prototype.clone = function clone() {
            var props = {};
            props._original = this;
            return new Clone(props);
        };
    };
});
/*can-make-rest@0.1.3#can-make-rest*/
define('can-make-rest@0.1.3#can-make-rest', [
    'require',
    'exports',
    'module',
    'can-util/js/each/each'
], function (require, exports, module) {
    var each = require('can-util/js/each/each');
    var methodMapping = {
        item: {
            'GET': 'getData',
            'PUT': 'updateData',
            'DELETE': 'destroyData'
        },
        list: {
            'GET': 'getListData',
            'POST': 'createData'
        }
    };
    function inferIdProp(url) {
        var wrappedInBraces = /\{(.*)\}/;
        var matches = url.match(wrappedInBraces);
        var isUniqueMatch = matches && matches.length === 2;
        if (isUniqueMatch) {
            return matches[1];
        }
    }
    function getItemAndListUrls(url, idProp) {
        idProp = idProp || inferIdProp(url) || 'id';
        var itemRegex = new RegExp('\\/\\{' + idProp + '\\}.*');
        var rootIsItemUrl = itemRegex.test(url);
        var listUrl = rootIsItemUrl ? url.replace(itemRegex, '') : url;
        var itemUrl = rootIsItemUrl ? url : url.trim() + '/{' + idProp + '}';
        return {
            item: itemUrl,
            list: listUrl
        };
    }
    module.exports = function (url, idProp) {
        var data = {};
        each(getItemAndListUrls(url, idProp), function (url, type) {
            each(methodMapping[type], function (interfaceMethod, method) {
                data[interfaceMethod] = {
                    method: method,
                    url: url
                };
            });
        });
        return data;
    };
});
/*can-connect@1.5.18#data/url/url*/
define('can-connect@1.5.18#data/url/url', [
    'require',
    'exports',
    'module',
    'can-util/js/assign/assign',
    'can-util/js/each/each',
    'can-ajax',
    'can-util/js/string/string',
    '../../helpers/get-id-props',
    'can-util/js/dev/dev',
    'can-connect',
    'can-make-rest',
    'can-util/js/make-promise/make-promise'
], function (require, exports, module) {
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    var ajax = require('can-ajax');
    var string = require('can-util/js/string/string');
    var getIdProps = require('../../helpers/get-id-props');
    var dev = require('can-util/js/dev/dev');
    var connect = require('can-connect');
    var makeRest = require('can-make-rest');
    var defaultRest = makeRest('/resource/{id}');
    var makePromise = require('can-util/js/make-promise/make-promise');
    var urlBehavior = connect.behavior('data/url', function (baseConnection) {
        var behavior = {};
        each(defaultRest, function (defaultData, dataInterfaceName) {
            behavior[dataInterfaceName] = function (params) {
                var meta = methodMetaData[dataInterfaceName];
                if (typeof this.url === 'object') {
                    if (typeof this.url[dataInterfaceName] === 'function') {
                        return makePromise(this.url[dataInterfaceName](params));
                    } else if (this.url[dataInterfaceName]) {
                        var promise = makeAjax(this.url[dataInterfaceName], params, defaultData.method, this.ajax || ajax, findContentType(this.url, defaultData.method), meta);
                        return makePromise(promise);
                    }
                }
                var resource = typeof this.url === 'string' ? this.url : this.url.resource;
                if (resource) {
                    var idProps = getIdProps(this);
                    var resourceWithoutTrailingSlashes = resource.replace(/\/+$/, '');
                    var result = makeRest(resourceWithoutTrailingSlashes, idProps[0])[dataInterfaceName];
                    return makePromise(makeAjax(result.url, params, result.method, this.ajax || ajax, findContentType(this.url, result.method), meta));
                }
                return baseConnection[name].call(this, params);
            };
        });
        return behavior;
    });
    var methodMetaData = {
        getListData: {},
        getData: {},
        createData: {},
        updateData: {},
        destroyData: { includeData: false }
    };
    var findContentType = function (url, method) {
        if (typeof url === 'object' && url.contentType) {
            var acceptableType = url.contentType === 'application/x-www-form-urlencoded' || url.contentType === 'application/json';
            if (acceptableType) {
                return url.contentType;
            } else {
            }
        }
        return method === 'GET' ? 'application/x-www-form-urlencoded' : 'application/json';
    };
    function urlParamEncoder(key, value) {
        return encodeURIComponent(value);
    }
    var makeAjax = function (ajaxOb, data, type, ajax, contentType, reqOptions) {
        var params = {};
        if (typeof ajaxOb === 'string') {
            var parts = ajaxOb.split(/\s+/);
            params.url = parts.pop();
            if (parts.length) {
                params.type = parts.pop();
            }
        } else {
            assign(params, ajaxOb);
        }
        params.data = typeof data === 'object' && !Array.isArray(data) ? assign(params.data || {}, data) : data;
        params.url = string.replaceWith(params.url, params.data, urlParamEncoder, true);
        params.contentType = contentType;
        if (reqOptions.includeData === false) {
            delete params.data;
        }
        return ajax(assign({
            type: type || 'post',
            dataType: 'json'
        }, params));
    };
    module.exports = urlBehavior;
});
/*can-connect-cloneable@0.2.4#can-connect-cloneable_test*/
define('can-connect-cloneable@0.2.4#can-connect-cloneable_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-connect-cloneable',
    'can-define/map/map',
    'can-define/list/list',
    'can-map',
    'can-map-define',
    'can-list',
    'can-fixture',
    'can-connect',
    'can-connect/data/url/url',
    'can-connect/constructor/constructor',
    'can-connect/can/map/map'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var makeCloneable = require('can-connect-cloneable');
    var DefineMap = require('can-define/map/map');
    require('can-define/list/list');
    var CanMap = require('can-map');
    require('can-map-define');
    require('can-list');
    var fixture = require('can-fixture');
    var connect = require('can-connect');
    var ConnectDataUrl = require('can-connect/data/url/url');
    var ConnectConstructor = require('can-connect/constructor/constructor');
    var ConnectCanMap = require('can-connect/can/map/map');
    QUnit.module('can-connect-cloneable');
    QUnit.test('Initialized the plugin', function () {
        QUnit.equal(typeof makeCloneable, 'function');
    });
    QUnit.module('can-connect-cloneable with DefineMap', {
        beforeEach: function (assert) {
            fixture('POST /test', { id: 1 });
            fixture('PUT /test/1', {});
            this.runSetterAssertions = false;
            var self = this;
            this.CloneableDefineMap = DefineMap.extend({
                info: {
                    get: function () {
                        return this.name + ' is ' + this.age;
                    }
                },
                age: {
                    value: 30,
                    type: 'number',
                    set: function (age) {
                        if (self.runSetterAssertions) {
                            assert.ok(true, 'setter ran');
                        }
                        return age;
                    }
                },
                name: {},
                id: {}
            });
            var connection = connect([
                ConnectDataUrl,
                ConnectConstructor,
                ConnectCanMap
            ], {
                idProp: 'id',
                Map: this.CloneableDefineMap,
                url: '/test'
            });
            this.CloneableDefineMap.connection = connection;
            makeCloneable(this.CloneableDefineMap);
        }
    });
    QUnit.test('Initialization', function () {
        var noncloneableMap = new DefineMap({});
        var cloneableMap = new this.CloneableDefineMap({});
        var clone = cloneableMap.clone();
        QUnit.ok(!noncloneableMap.constructor.prototype.hasOwnProperty('clone'), 'base Map does not have a clone method');
        QUnit.ok(cloneableMap.constructor.prototype.hasOwnProperty('clone'), 'cloneableMap has a clone method');
        QUnit.notEqual(cloneableMap, clone, 'Clone is not the same instance');
    });
    QUnit.test('Saving an original without an ID does a create', function (assert) {
        var done = assert.async();
        var map = new this.CloneableDefineMap({ name: 'Kyle' });
        var clone = map.clone();
        clone.name = 'Justin';
        QUnit.equal(map.name, 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.name, 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.name, 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.name, 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            QUnit.equal(map.id, 1, 'original receives an ID');
            QUnit.equal(clone.id, undefined, 'clone still does not have an ID until saving');
            done();
        });
    });
    QUnit.test('Saving updates the original', function (assert) {
        var done = assert.async();
        var map = new this.CloneableDefineMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        clone.name = 'Justin';
        QUnit.equal(map.name, 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.name, 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.name, 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.name, 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            done();
        });
    });
    QUnit.test('Property changes from the original push to the clone', function () {
        var map = new this.CloneableDefineMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        QUnit.equal(clone.name, 'Kyle', 'clone\'s name has the value of original');
        map.name = 'Justin';
        QUnit.equal(clone.name, 'Justin', 'clone\'s name changes when original\'s name changes');
    });
    QUnit.test('Getters/Setters/type transfers to the clone', 5, function (assert) {
        this.runSetterAssertions = true;
        var map = new this.CloneableDefineMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        assert.equal(clone.info, 'Kyle is 30');
        clone.age = '32';
        assert.ok(clone.age === 32, 'type applied');
        assert.equal(clone.info, 'Kyle is 32', 'getter applied');
    });
    QUnit.module('can-connect-cloneable with CanMap', {
        beforeEach: function (assert) {
            fixture('POST /test', { id: 1 });
            fixture('PUT /test/1', {});
            this.runSetterAssertions = false;
            var self = this;
            this.CloneableCanMap = CanMap.extend({
                define: {
                    info: {
                        get: function () {
                            return this.attr('name') + ' is ' + this.attr('age');
                        }
                    },
                    age: {
                        value: 30,
                        type: 'number',
                        set: function (age) {
                            if (self.runSetterAssertions) {
                                assert.ok(true, 'setter ran');
                            }
                            return age;
                        }
                    },
                    name: {}
                }
            });
            var connection = connect([
                ConnectDataUrl,
                ConnectConstructor,
                ConnectCanMap
            ], {
                idProp: 'id',
                Map: this.CloneableCanMap,
                url: '/test'
            });
            this.CloneableCanMap.connection = connection;
            makeCloneable(this.CloneableCanMap);
        }
    });
    QUnit.test('Initialization', function () {
        var noncloneableMap = new CanMap({});
        var cloneableMap = new this.CloneableCanMap({});
        var clone = cloneableMap.clone();
        QUnit.ok(!noncloneableMap.constructor.prototype.hasOwnProperty('clone'), 'base Map does not have a clone method');
        QUnit.ok(cloneableMap.constructor.prototype.hasOwnProperty('clone'), 'cloneableMap has a clone method');
        QUnit.notEqual(cloneableMap, clone, 'Clone is not the same instance');
    });
    QUnit.test('Cloning an original without an ID does a create', function (assert) {
        var done = assert.async();
        var map = new this.CloneableCanMap({ name: 'Kyle' });
        var clone = map.clone();
        clone.attr('name', 'Justin');
        QUnit.equal(map.attr('name'), 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.attr('name'), 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            QUnit.equal(map.attr('id'), 1, 'original receives an ID');
            QUnit.equal(clone.attr('id'), undefined, 'clone still does not have an ID until saving');
            done();
        });
    });
    QUnit.test('Saving updates the original', function (assert) {
        var done = assert.async();
        var map = new this.CloneableCanMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        clone.attr('name', 'Justin');
        QUnit.equal(map.attr('name'), 'Kyle', 'original\'s name is still Kyle');
        QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is now Justin');
        clone.save().then(function () {
            QUnit.equal(map.attr('name'), 'Justin', 'original\'s name changed to Justin');
            QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name is still Justin');
            QUnit.ok(!map.hasOwnProperty('_original'), 'original does not have the _original attribute');
            done();
        });
    });
    QUnit.test('Property changes from the original push to the clone', function () {
        var map = new this.CloneableCanMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        QUnit.equal(clone.attr('name'), 'Kyle', 'clone\'s name has the value of original');
        map.attr('name', 'Justin');
        QUnit.equal(clone.attr('name'), 'Justin', 'clone\'s name changes when original\'s name changes');
    });
    QUnit.test('Define plugin configuration transfers to the clone', 5, function (assert) {
        this.runSetterAssertions = true;
        var map = new this.CloneableCanMap({
            name: 'Kyle',
            id: 1
        });
        var clone = map.clone();
        clone.attr('age', '32');
        assert.ok(clone.attr('age') === 32, 'type applied');
        assert.equal(clone.attr('info'), 'Kyle is 32', 'getter applied');
    });
});
/*can-connect-cloneable@0.2.4#test/test*/
define('can-connect-cloneable@0.2.4#test/test', ['../can-connect-cloneable_test'], function () {
    'use strict';
});
/*kefir@3.8.6#dist/kefir*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define('kefir@3.8.6#dist/kefir', ['exports'], factory) : factory(global.Kefir = global.Kefir || {});
}(this, function (exports) {
    'use strict';
    function createObj(proto) {
        var F = function () {
        };
        F.prototype = proto;
        return new F();
    }
    function extend(target) {
        var length = arguments.length, i = void 0, prop = void 0;
        for (i = 1; i < length; i++) {
            for (prop in arguments[i]) {
                target[prop] = arguments[i][prop];
            }
        }
        return target;
    }
    function inherit(Child, Parent) {
        var length = arguments.length, i = void 0;
        Child.prototype = createObj(Parent.prototype);
        Child.prototype.constructor = Child;
        for (i = 2; i < length; i++) {
            extend(Child.prototype, arguments[i]);
        }
        return Child;
    }
    var NOTHING = ['<nothing>'];
    var END = 'end';
    var VALUE = 'value';
    var ERROR = 'error';
    var ANY = 'any';
    function concat(a, b) {
        var result = void 0, length = void 0, i = void 0, j = void 0;
        if (a.length === 0) {
            return b;
        }
        if (b.length === 0) {
            return a;
        }
        j = 0;
        result = new Array(a.length + b.length);
        length = a.length;
        for (i = 0; i < length; i++, j++) {
            result[j] = a[i];
        }
        length = b.length;
        for (i = 0; i < length; i++, j++) {
            result[j] = b[i];
        }
        return result;
    }
    function find(arr, value) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            if (arr[i] === value) {
                return i;
            }
        }
        return -1;
    }
    function findByPred(arr, pred) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            if (pred(arr[i])) {
                return i;
            }
        }
        return -1;
    }
    function cloneArray(input) {
        var length = input.length, result = new Array(length), i = void 0;
        for (i = 0; i < length; i++) {
            result[i] = input[i];
        }
        return result;
    }
    function remove(input, index) {
        var length = input.length, result = void 0, i = void 0, j = void 0;
        if (index >= 0 && index < length) {
            if (length === 1) {
                return [];
            } else {
                result = new Array(length - 1);
                for (i = 0, j = 0; i < length; i++) {
                    if (i !== index) {
                        result[j] = input[i];
                        j++;
                    }
                }
                return result;
            }
        } else {
            return input;
        }
    }
    function map(input, fn) {
        var length = input.length, result = new Array(length), i = void 0;
        for (i = 0; i < length; i++) {
            result[i] = fn(input[i]);
        }
        return result;
    }
    function forEach(arr, fn) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            fn(arr[i]);
        }
    }
    function fillArray(arr, value) {
        var length = arr.length, i = void 0;
        for (i = 0; i < length; i++) {
            arr[i] = value;
        }
    }
    function contains(arr, value) {
        return find(arr, value) !== -1;
    }
    function slide(cur, next, max) {
        var length = Math.min(max, cur.length + 1), offset = cur.length - length + 1, result = new Array(length), i = void 0;
        for (i = offset; i < length; i++) {
            result[i - offset] = cur[i];
        }
        result[length - 1] = next;
        return result;
    }
    function callSubscriber(type, fn, event) {
        if (type === ANY) {
            fn(event);
        } else if (type === event.type) {
            if (type === VALUE || type === ERROR) {
                fn(event.value);
            } else {
                fn();
            }
        }
    }
    function Dispatcher() {
        this._items = [];
        this._spies = [];
        this._inLoop = 0;
        this._removedItems = null;
    }
    extend(Dispatcher.prototype, {
        add: function (type, fn) {
            this._items = concat(this._items, [{
                    type: type,
                    fn: fn
                }]);
            return this._items.length;
        },
        remove: function (type, fn) {
            var index = findByPred(this._items, function (x) {
                return x.type === type && x.fn === fn;
            });
            if (this._inLoop !== 0 && index !== -1) {
                if (this._removedItems === null) {
                    this._removedItems = [];
                }
                this._removedItems.push(this._items[index]);
            }
            this._items = remove(this._items, index);
            return this._items.length;
        },
        addSpy: function (fn) {
            this._spies = concat(this._spies, [fn]);
            return this._spies.length;
        },
        removeSpy: function (fn) {
            this._spies = remove(this._spies, this._spies.indexOf(fn));
            return this._spies.length;
        },
        dispatch: function (event) {
            this._inLoop++;
            for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {
                spies[i](event);
            }
            for (var _i = 0, items = this._items; _i < items.length; _i++) {
                if (this._items === null) {
                    break;
                }
                if (this._removedItems !== null && contains(this._removedItems, items[_i])) {
                    continue;
                }
                callSubscriber(items[_i].type, items[_i].fn, event);
            }
            this._inLoop--;
            if (this._inLoop === 0) {
                this._removedItems = null;
            }
        },
        cleanup: function () {
            this._items = null;
            this._spies = null;
        }
    });
    function Observable() {
        this._dispatcher = new Dispatcher();
        this._active = false;
        this._alive = true;
        this._activating = false;
        this._logHandlers = null;
        this._spyHandlers = null;
    }
    extend(Observable.prototype, {
        _name: 'observable',
        _onActivation: function () {
        },
        _onDeactivation: function () {
        },
        _setActive: function (active) {
            if (this._active !== active) {
                this._active = active;
                if (active) {
                    this._activating = true;
                    this._onActivation();
                    this._activating = false;
                } else {
                    this._onDeactivation();
                }
            }
        },
        _clear: function () {
            this._setActive(false);
            this._dispatcher.cleanup();
            this._dispatcher = null;
            this._logHandlers = null;
        },
        _emit: function (type, x) {
            switch (type) {
            case VALUE:
                return this._emitValue(x);
            case ERROR:
                return this._emitError(x);
            case END:
                return this._emitEnd();
            }
        },
        _emitValue: function (value) {
            if (this._alive) {
                this._dispatcher.dispatch({
                    type: VALUE,
                    value: value
                });
            }
        },
        _emitError: function (value) {
            if (this._alive) {
                this._dispatcher.dispatch({
                    type: ERROR,
                    value: value
                });
            }
        },
        _emitEnd: function () {
            if (this._alive) {
                this._alive = false;
                this._dispatcher.dispatch({ type: END });
                this._clear();
            }
        },
        _on: function (type, fn) {
            if (this._alive) {
                this._dispatcher.add(type, fn);
                this._setActive(true);
            } else {
                callSubscriber(type, fn, { type: END });
            }
            return this;
        },
        _off: function (type, fn) {
            if (this._alive) {
                var count = this._dispatcher.remove(type, fn);
                if (count === 0) {
                    this._setActive(false);
                }
            }
            return this;
        },
        onValue: function (fn) {
            return this._on(VALUE, fn);
        },
        onError: function (fn) {
            return this._on(ERROR, fn);
        },
        onEnd: function (fn) {
            return this._on(END, fn);
        },
        onAny: function (fn) {
            return this._on(ANY, fn);
        },
        offValue: function (fn) {
            return this._off(VALUE, fn);
        },
        offError: function (fn) {
            return this._off(ERROR, fn);
        },
        offEnd: function (fn) {
            return this._off(END, fn);
        },
        offAny: function (fn) {
            return this._off(ANY, fn);
        },
        observe: function (observerOrOnValue, onError, onEnd) {
            var _this = this;
            var closed = false;
            var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? {
                value: observerOrOnValue,
                error: onError,
                end: onEnd
            } : observerOrOnValue;
            var handler = function (event) {
                if (event.type === END) {
                    closed = true;
                }
                if (event.type === VALUE && observer.value) {
                    observer.value(event.value);
                } else if (event.type === ERROR && observer.error) {
                    observer.error(event.value);
                } else if (event.type === END && observer.end) {
                    observer.end(event.value);
                }
            };
            this.onAny(handler);
            return {
                unsubscribe: function () {
                    if (!closed) {
                        _this.offAny(handler);
                        closed = true;
                    }
                },
                get closed() {
                    return closed;
                }
            };
        },
        _ofSameType: function (A, B) {
            return A.prototype.getType() === this.getType() ? A : B;
        },
        setName: function (sourceObs, selfName) {
            this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;
            return this;
        },
        log: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            var isCurrent = void 0;
            var handler = function (event) {
                var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';
                if (event.type === END) {
                    console.log(name, type);
                } else {
                    console.log(name, type, event.value);
                }
            };
            if (this._alive) {
                if (!this._logHandlers) {
                    this._logHandlers = [];
                }
                this._logHandlers.push({
                    name: name,
                    handler: handler
                });
            }
            isCurrent = true;
            this.onAny(handler);
            isCurrent = false;
            return this;
        },
        offLog: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            if (this._logHandlers) {
                var handlerIndex = findByPred(this._logHandlers, function (obj) {
                    return obj.name === name;
                });
                if (handlerIndex !== -1) {
                    this.offAny(this._logHandlers[handlerIndex].handler);
                    this._logHandlers.splice(handlerIndex, 1);
                }
            }
            return this;
        },
        spy: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            var handler = function (event) {
                var type = '<' + event.type + '>';
                if (event.type === END) {
                    console.log(name, type);
                } else {
                    console.log(name, type, event.value);
                }
            };
            if (this._alive) {
                if (!this._spyHandlers) {
                    this._spyHandlers = [];
                }
                this._spyHandlers.push({
                    name: name,
                    handler: handler
                });
                this._dispatcher.addSpy(handler);
            }
            return this;
        },
        offSpy: function () {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();
            if (this._spyHandlers) {
                var handlerIndex = findByPred(this._spyHandlers, function (obj) {
                    return obj.name === name;
                });
                if (handlerIndex !== -1) {
                    this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);
                    this._spyHandlers.splice(handlerIndex, 1);
                }
            }
            return this;
        }
    });
    Observable.prototype.toString = function () {
        return '[' + this._name + ']';
    };
    function Stream() {
        Observable.call(this);
    }
    inherit(Stream, Observable, {
        _name: 'stream',
        getType: function () {
            return 'stream';
        }
    });
    function Property() {
        Observable.call(this);
        this._currentEvent = null;
    }
    inherit(Property, Observable, {
        _name: 'property',
        _emitValue: function (value) {
            if (this._alive) {
                this._currentEvent = {
                    type: VALUE,
                    value: value
                };
                if (!this._activating) {
                    this._dispatcher.dispatch({
                        type: VALUE,
                        value: value
                    });
                }
            }
        },
        _emitError: function (value) {
            if (this._alive) {
                this._currentEvent = {
                    type: ERROR,
                    value: value
                };
                if (!this._activating) {
                    this._dispatcher.dispatch({
                        type: ERROR,
                        value: value
                    });
                }
            }
        },
        _emitEnd: function () {
            if (this._alive) {
                this._alive = false;
                if (!this._activating) {
                    this._dispatcher.dispatch({ type: END });
                }
                this._clear();
            }
        },
        _on: function (type, fn) {
            if (this._alive) {
                this._dispatcher.add(type, fn);
                this._setActive(true);
            }
            if (this._currentEvent !== null) {
                callSubscriber(type, fn, this._currentEvent);
            }
            if (!this._alive) {
                callSubscriber(type, fn, { type: END });
            }
            return this;
        },
        getType: function () {
            return 'property';
        }
    });
    var neverS = new Stream();
    neverS._emitEnd();
    neverS._name = 'never';
    function never() {
        return neverS;
    }
    function timeBased(mixin) {
        function AnonymousStream(wait, options) {
            var _this = this;
            Stream.call(this);
            this._wait = wait;
            this._intervalId = null;
            this._$onTick = function () {
                return _this._onTick();
            };
            this._init(options);
        }
        inherit(AnonymousStream, Stream, {
            _init: function () {
            },
            _free: function () {
            },
            _onTick: function () {
            },
            _onActivation: function () {
                this._intervalId = setInterval(this._$onTick, this._wait);
            },
            _onDeactivation: function () {
                if (this._intervalId !== null) {
                    clearInterval(this._intervalId);
                    this._intervalId = null;
                }
            },
            _clear: function () {
                Stream.prototype._clear.call(this);
                this._$onTick = null;
                this._free();
            }
        }, mixin);
        return AnonymousStream;
    }
    var S = timeBased({
        _name: 'later',
        _init: function (_ref) {
            var x = _ref.x;
            this._x = x;
        },
        _free: function () {
            this._x = null;
        },
        _onTick: function () {
            this._emitValue(this._x);
            this._emitEnd();
        }
    });
    function later(wait, x) {
        return new S(wait, { x: x });
    }
    var S$1 = timeBased({
        _name: 'interval',
        _init: function (_ref) {
            var x = _ref.x;
            this._x = x;
        },
        _free: function () {
            this._x = null;
        },
        _onTick: function () {
            this._emitValue(this._x);
        }
    });
    function interval(wait, x) {
        return new S$1(wait, { x: x });
    }
    var S$2 = timeBased({
        _name: 'sequentially',
        _init: function (_ref) {
            var xs = _ref.xs;
            this._xs = cloneArray(xs);
        },
        _free: function () {
            this._xs = null;
        },
        _onTick: function () {
            if (this._xs.length === 1) {
                this._emitValue(this._xs[0]);
                this._emitEnd();
            } else {
                this._emitValue(this._xs.shift());
            }
        }
    });
    function sequentially(wait, xs) {
        return xs.length === 0 ? never() : new S$2(wait, { xs: xs });
    }
    var S$3 = timeBased({
        _name: 'fromPoll',
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _onTick: function () {
            var fn = this._fn;
            this._emitValue(fn());
        }
    });
    function fromPoll(wait, fn) {
        return new S$3(wait, { fn: fn });
    }
    function emitter(obs) {
        function value(x) {
            obs._emitValue(x);
            return obs._active;
        }
        function error(x) {
            obs._emitError(x);
            return obs._active;
        }
        function end() {
            obs._emitEnd();
            return obs._active;
        }
        function event(e) {
            obs._emit(e.type, e.value);
            return obs._active;
        }
        return {
            value: value,
            error: error,
            end: end,
            event: event,
            emit: value,
            emitEvent: event
        };
    }
    var S$4 = timeBased({
        _name: 'withInterval',
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
            this._emitter = emitter(this);
        },
        _free: function () {
            this._fn = null;
            this._emitter = null;
        },
        _onTick: function () {
            var fn = this._fn;
            fn(this._emitter);
        }
    });
    function withInterval(wait, fn) {
        return new S$4(wait, { fn: fn });
    }
    function S$5(fn) {
        Stream.call(this);
        this._fn = fn;
        this._unsubscribe = null;
    }
    inherit(S$5, Stream, {
        _name: 'stream',
        _onActivation: function () {
            var fn = this._fn;
            var unsubscribe = fn(emitter(this));
            this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;
            if (!this._active) {
                this._callUnsubscribe();
            }
        },
        _callUnsubscribe: function () {
            if (this._unsubscribe !== null) {
                this._unsubscribe();
                this._unsubscribe = null;
            }
        },
        _onDeactivation: function () {
            this._callUnsubscribe();
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._fn = null;
        }
    });
    function stream(fn) {
        return new S$5(fn);
    }
    function fromCallback(callbackConsumer) {
        var called = false;
        return stream(function (emitter) {
            if (!called) {
                callbackConsumer(function (x) {
                    emitter.emit(x);
                    emitter.end();
                });
                called = true;
            }
        }).setName('fromCallback');
    }
    function fromNodeCallback(callbackConsumer) {
        var called = false;
        return stream(function (emitter) {
            if (!called) {
                callbackConsumer(function (error, x) {
                    if (error) {
                        emitter.error(error);
                    } else {
                        emitter.emit(x);
                    }
                    emitter.end();
                });
                called = true;
            }
        }).setName('fromNodeCallback');
    }
    function spread(fn, length) {
        switch (length) {
        case 0:
            return function () {
                return fn();
            };
        case 1:
            return function (a) {
                return fn(a[0]);
            };
        case 2:
            return function (a) {
                return fn(a[0], a[1]);
            };
        case 3:
            return function (a) {
                return fn(a[0], a[1], a[2]);
            };
        case 4:
            return function (a) {
                return fn(a[0], a[1], a[2], a[3]);
            };
        default:
            return function (a) {
                return fn.apply(null, a);
            };
        }
    }
    function apply(fn, c, a) {
        var aLength = a ? a.length : 0;
        if (c == null) {
            switch (aLength) {
            case 0:
                return fn();
            case 1:
                return fn(a[0]);
            case 2:
                return fn(a[0], a[1]);
            case 3:
                return fn(a[0], a[1], a[2]);
            case 4:
                return fn(a[0], a[1], a[2], a[3]);
            default:
                return fn.apply(null, a);
            }
        } else {
            switch (aLength) {
            case 0:
                return fn.call(c);
            default:
                return fn.apply(c, a);
            }
        }
    }
    function fromSubUnsub(sub, unsub, transformer) {
        return stream(function (emitter) {
            var handler = transformer ? function () {
                emitter.emit(apply(transformer, this, arguments));
            } : function (x) {
                emitter.emit(x);
            };
            sub(handler);
            return function () {
                return unsub(handler);
            };
        }).setName('fromSubUnsub');
    }
    var pairs = [
        [
            'addEventListener',
            'removeEventListener'
        ],
        [
            'addListener',
            'removeListener'
        ],
        [
            'on',
            'off'
        ]
    ];
    function fromEvents(target, eventName, transformer) {
        var sub = void 0, unsub = void 0;
        for (var i = 0; i < pairs.length; i++) {
            if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {
                sub = pairs[i][0];
                unsub = pairs[i][1];
                break;
            }
        }
        if (sub === undefined) {
            throw new Error('target don\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');
        }
        return fromSubUnsub(function (handler) {
            return target[sub](eventName, handler);
        }, function (handler) {
            return target[unsub](eventName, handler);
        }, transformer).setName('fromEvents');
    }
    function P(value) {
        this._currentEvent = {
            type: 'value',
            value: value,
            current: true
        };
    }
    inherit(P, Property, {
        _name: 'constant',
        _active: false,
        _activating: false,
        _alive: false,
        _dispatcher: null,
        _logHandlers: null
    });
    function constant(x) {
        return new P(x);
    }
    function P$1(value) {
        this._currentEvent = {
            type: 'error',
            value: value,
            current: true
        };
    }
    inherit(P$1, Property, {
        _name: 'constantError',
        _active: false,
        _activating: false,
        _alive: false,
        _dispatcher: null,
        _logHandlers: null
    });
    function constantError(x) {
        return new P$1(x);
    }
    function createConstructor(BaseClass, name) {
        return function AnonymousObservable(source, options) {
            var _this = this;
            BaseClass.call(this);
            this._source = source;
            this._name = source._name + '.' + name;
            this._init(options);
            this._$handleAny = function (event) {
                return _this._handleAny(event);
            };
        };
    }
    function createClassMethods(BaseClass) {
        return {
            _init: function () {
            },
            _free: function () {
            },
            _handleValue: function (x) {
                this._emitValue(x);
            },
            _handleError: function (x) {
                this._emitError(x);
            },
            _handleEnd: function () {
                this._emitEnd();
            },
            _handleAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handleValue(event.value);
                case ERROR:
                    return this._handleError(event.value);
                case END:
                    return this._handleEnd();
                }
            },
            _onActivation: function () {
                this._source.onAny(this._$handleAny);
            },
            _onDeactivation: function () {
                this._source.offAny(this._$handleAny);
            },
            _clear: function () {
                BaseClass.prototype._clear.call(this);
                this._source = null;
                this._$handleAny = null;
                this._free();
            }
        };
    }
    function createStream(name, mixin) {
        var S = createConstructor(Stream, name);
        inherit(S, Stream, createClassMethods(Stream), mixin);
        return S;
    }
    function createProperty(name, mixin) {
        var P = createConstructor(Property, name);
        inherit(P, Property, createClassMethods(Property), mixin);
        return P;
    }
    var P$2 = createProperty('toProperty', {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._getInitialCurrent = fn;
        },
        _onActivation: function () {
            if (this._getInitialCurrent !== null) {
                var getInitial = this._getInitialCurrent;
                this._emitValue(getInitial());
            }
            this._source.onAny(this._$handleAny);
        }
    });
    function toProperty(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (fn !== null && typeof fn !== 'function') {
            throw new Error('You should call toProperty() with a function or no arguments.');
        }
        return new P$2(obs, { fn: fn });
    }
    var S$6 = createStream('changes', {
        _handleValue: function (x) {
            if (!this._activating) {
                this._emitValue(x);
            }
        },
        _handleError: function (x) {
            if (!this._activating) {
                this._emitError(x);
            }
        }
    });
    function changes(obs) {
        return new S$6(obs);
    }
    function fromPromise(promise) {
        var called = false;
        var result = stream(function (emitter) {
            if (!called) {
                var onValue = function (x) {
                    emitter.emit(x);
                    emitter.end();
                };
                var onError = function (x) {
                    emitter.error(x);
                    emitter.end();
                };
                var _promise = promise.then(onValue, onError);
                if (_promise && typeof _promise.done === 'function') {
                    _promise.done();
                }
                called = true;
            }
        });
        return toProperty(result, null).setName('fromPromise');
    }
    function getGlodalPromise() {
        if (typeof Promise === 'function') {
            return Promise;
        } else {
            throw new Error('There isn\'t default Promise, use shim or parameter');
        }
    }
    var toPromise = function (obs) {
        var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();
        var last = null;
        return new Promise(function (resolve, reject) {
            obs.onAny(function (event) {
                if (event.type === END && last !== null) {
                    (last.type === VALUE ? resolve : reject)(last.value);
                    last = null;
                } else {
                    last = event;
                }
            });
        });
    };
    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    function createCommonjsModule(fn, module) {
        return module = { exports: {} }, fn(module, module.exports), module.exports;
    }
    var ponyfill = createCommonjsModule(function (module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        exports['default'] = symbolObservablePonyfill;
        function symbolObservablePonyfill(root) {
            var result;
            var _Symbol = root.Symbol;
            if (typeof _Symbol === 'function') {
                if (_Symbol.observable) {
                    result = _Symbol.observable;
                } else {
                    result = _Symbol('observable');
                    _Symbol.observable = result;
                }
            } else {
                result = '@@observable';
            }
            return result;
        }
    });
    var index$1 = createCommonjsModule(function (module, exports) {
        'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _ponyfill2 = _interopRequireDefault(ponyfill);
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
        }
        var root;
        if (typeof self !== 'undefined') {
            root = self;
        } else if (typeof window !== 'undefined') {
            root = window;
        } else if (typeof commonjsGlobal !== 'undefined') {
            root = commonjsGlobal;
        } else {
            root = module;
        }
        var result = (0, _ponyfill2['default'])(root);
        exports['default'] = result;
    });
    var index = index$1;
    var $$observable = index.default ? index.default : index;
    function fromESObservable(_observable) {
        var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;
        return stream(function (emitter) {
            var unsub = observable.subscribe({
                error: function (error) {
                    emitter.error(error);
                    emitter.end();
                },
                next: function (value) {
                    emitter.emit(value);
                },
                complete: function () {
                    emitter.end();
                }
            });
            if (unsub.unsubscribe) {
                return function () {
                    unsub.unsubscribe();
                };
            } else {
                return unsub;
            }
        }).setName('fromESObservable');
    }
    function ESObservable(observable) {
        this._observable = observable.takeErrors(1);
    }
    extend(ESObservable.prototype, {
        subscribe: function (observerOrOnNext, onError, onComplete) {
            var _this = this;
            var observer = typeof observerOrOnNext === 'function' ? {
                next: observerOrOnNext,
                error: onError,
                complete: onComplete
            } : observerOrOnNext;
            var fn = function (event) {
                if (event.type === END) {
                    closed = true;
                }
                if (event.type === VALUE && observer.next) {
                    observer.next(event.value);
                } else if (event.type === ERROR && observer.error) {
                    observer.error(event.value);
                } else if (event.type === END && observer.complete) {
                    observer.complete(event.value);
                }
            };
            this._observable.onAny(fn);
            var closed = false;
            var subscription = {
                unsubscribe: function () {
                    closed = true;
                    _this._observable.offAny(fn);
                },
                get closed() {
                    return closed;
                }
            };
            return subscription;
        }
    });
    ESObservable.prototype[$$observable] = function () {
        return this;
    };
    function toESObservable() {
        return new ESObservable(this);
    }
    function collect(source, keys, values) {
        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                keys.push(prop);
                values.push(source[prop]);
            }
        }
    }
    function defaultErrorsCombinator(errors) {
        var latestError = void 0;
        for (var i = 0; i < errors.length; i++) {
            if (errors[i] !== undefined) {
                if (latestError === undefined || latestError.index < errors[i].index) {
                    latestError = errors[i];
                }
            }
        }
        return latestError.error;
    }
    function Combine(active, passive, combinator) {
        var _this = this;
        Stream.call(this);
        this._activeCount = active.length;
        this._sources = concat(active, passive);
        this._combinator = combinator;
        this._aliveCount = 0;
        this._latestValues = new Array(this._sources.length);
        this._latestErrors = new Array(this._sources.length);
        fillArray(this._latestValues, NOTHING);
        this._emitAfterActivation = false;
        this._endAfterActivation = false;
        this._latestErrorIndex = 0;
        this._$handlers = [];
        var _loop = function (i) {
            _this._$handlers.push(function (event) {
                return _this._handleAny(i, event);
            });
        };
        for (var i = 0; i < this._sources.length; i++) {
            _loop(i);
        }
    }
    inherit(Combine, Stream, {
        _name: 'combine',
        _onActivation: function () {
            this._aliveCount = this._activeCount;
            for (var i = this._activeCount; i < this._sources.length; i++) {
                this._sources[i].onAny(this._$handlers[i]);
            }
            for (var _i = 0; _i < this._activeCount; _i++) {
                this._sources[_i].onAny(this._$handlers[_i]);
            }
            if (this._emitAfterActivation) {
                this._emitAfterActivation = false;
                this._emitIfFull();
            }
            if (this._endAfterActivation) {
                this._emitEnd();
            }
        },
        _onDeactivation: function () {
            var length = this._sources.length, i = void 0;
            for (i = 0; i < length; i++) {
                this._sources[i].offAny(this._$handlers[i]);
            }
        },
        _emitIfFull: function () {
            var hasAllValues = true;
            var hasErrors = false;
            var length = this._latestValues.length;
            var valuesCopy = new Array(length);
            var errorsCopy = new Array(length);
            for (var i = 0; i < length; i++) {
                valuesCopy[i] = this._latestValues[i];
                errorsCopy[i] = this._latestErrors[i];
                if (valuesCopy[i] === NOTHING) {
                    hasAllValues = false;
                }
                if (errorsCopy[i] !== undefined) {
                    hasErrors = true;
                }
            }
            if (hasAllValues) {
                var combinator = this._combinator;
                this._emitValue(combinator(valuesCopy));
            }
            if (hasErrors) {
                this._emitError(defaultErrorsCombinator(errorsCopy));
            }
        },
        _handleAny: function (i, event) {
            if (event.type === VALUE || event.type === ERROR) {
                if (event.type === VALUE) {
                    this._latestValues[i] = event.value;
                    this._latestErrors[i] = undefined;
                }
                if (event.type === ERROR) {
                    this._latestValues[i] = NOTHING;
                    this._latestErrors[i] = {
                        index: this._latestErrorIndex++,
                        error: event.value
                    };
                }
                if (i < this._activeCount) {
                    if (this._activating) {
                        this._emitAfterActivation = true;
                    } else {
                        this._emitIfFull();
                    }
                }
            } else {
                if (i < this._activeCount) {
                    this._aliveCount--;
                    if (this._aliveCount === 0) {
                        if (this._activating) {
                            this._endAfterActivation = true;
                        } else {
                            this._emitEnd();
                        }
                    }
                }
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._sources = null;
            this._latestValues = null;
            this._latestErrors = null;
            this._combinator = null;
            this._$handlers = null;
        }
    });
    function combineAsArray(active) {
        var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var combinator = arguments[2];
        if (!Array.isArray(passive)) {
            throw new Error('Combine can only combine active and passive collections of the same type.');
        }
        combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {
            return x;
        };
        return active.length === 0 ? never() : new Combine(active, passive, combinator);
    }
    function combineAsObject(active) {
        var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var combinator = arguments[2];
        if (typeof passive !== 'object' || Array.isArray(passive)) {
            throw new Error('Combine can only combine active and passive collections of the same type.');
        }
        var keys = [], activeObservables = [], passiveObservables = [];
        collect(active, keys, activeObservables);
        collect(passive, keys, passiveObservables);
        var objectify = function (values) {
            var event = {};
            for (var i = values.length - 1; 0 <= i; i--) {
                event[keys[i]] = values[i];
            }
            return combinator ? combinator(event) : event;
        };
        return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);
    }
    function combine(active, passive, combinator) {
        if (typeof passive === 'function') {
            combinator = passive;
            passive = undefined;
        }
        return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);
    }
    var Observable$2 = {
        empty: function () {
            return never();
        },
        concat: function (a, b) {
            return a.merge(b);
        },
        of: function (x) {
            return constant(x);
        },
        map: function (fn, obs) {
            return obs.map(fn);
        },
        bimap: function (fnErr, fnVal, obs) {
            return obs.mapErrors(fnErr).map(fnVal);
        },
        ap: function (obsFn, obsVal) {
            return combine([
                obsFn,
                obsVal
            ], function (fn, val) {
                return fn(val);
            });
        },
        chain: function (fn, obs) {
            return obs.flatMap(fn);
        }
    };
    var staticLand = Object.freeze({ Observable: Observable$2 });
    var mixin = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            this._emitValue(fn(x));
        }
    };
    var S$7 = createStream('map', mixin);
    var P$3 = createProperty('map', mixin);
    var id = function (x) {
        return x;
    };
    function map$1(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;
        return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });
    }
    var mixin$1 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitValue(x);
            }
        }
    };
    var S$8 = createStream('filter', mixin$1);
    var P$4 = createProperty('filter', mixin$1);
    var id$1 = function (x) {
        return x;
    };
    function filter(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;
        return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });
    }
    var mixin$2 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = n;
            if (n <= 0) {
                this._emitEnd();
            }
        },
        _handleValue: function (x) {
            if (this._n === 0) {
                return;
            }
            this._n--;
            this._emitValue(x);
            if (this._n === 0) {
                this._emitEnd();
            }
        }
    };
    var S$9 = createStream('take', mixin$2);
    var P$5 = createProperty('take', mixin$2);
    function take(obs, n) {
        return new (obs._ofSameType(S$9, P$5))(obs, { n: n });
    }
    var mixin$3 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = n;
            if (n <= 0) {
                this._emitEnd();
            }
        },
        _handleError: function (x) {
            if (this._n === 0) {
                return;
            }
            this._n--;
            this._emitError(x);
            if (this._n === 0) {
                this._emitEnd();
            }
        }
    };
    var S$10 = createStream('takeErrors', mixin$3);
    var P$6 = createProperty('takeErrors', mixin$3);
    function takeErrors(obs, n) {
        return new (obs._ofSameType(S$10, P$6))(obs, { n: n });
    }
    var mixin$4 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitValue(x);
            } else {
                this._emitEnd();
            }
        }
    };
    var S$11 = createStream('takeWhile', mixin$4);
    var P$7 = createProperty('takeWhile', mixin$4);
    var id$2 = function (x) {
        return x;
    };
    function takeWhile(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;
        return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });
    }
    var mixin$5 = {
        _init: function () {
            this._lastValue = NOTHING;
        },
        _free: function () {
            this._lastValue = null;
        },
        _handleValue: function (x) {
            this._lastValue = x;
        },
        _handleEnd: function () {
            if (this._lastValue !== NOTHING) {
                this._emitValue(this._lastValue);
            }
            this._emitEnd();
        }
    };
    var S$12 = createStream('last', mixin$5);
    var P$8 = createProperty('last', mixin$5);
    function last(obs) {
        return new (obs._ofSameType(S$12, P$8))(obs);
    }
    var mixin$6 = {
        _init: function (_ref) {
            var n = _ref.n;
            this._n = Math.max(0, n);
        },
        _handleValue: function (x) {
            if (this._n === 0) {
                this._emitValue(x);
            } else {
                this._n--;
            }
        }
    };
    var S$13 = createStream('skip', mixin$6);
    var P$9 = createProperty('skip', mixin$6);
    function skip(obs, n) {
        return new (obs._ofSameType(S$13, P$9))(obs, { n: n });
    }
    var mixin$7 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._fn !== null && !fn(x)) {
                this._fn = null;
            }
            if (this._fn === null) {
                this._emitValue(x);
            }
        }
    };
    var S$14 = createStream('skipWhile', mixin$7);
    var P$10 = createProperty('skipWhile', mixin$7);
    var id$3 = function (x) {
        return x;
    };
    function skipWhile(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;
        return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });
    }
    var mixin$8 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
            this._prev = NOTHING;
        },
        _free: function () {
            this._fn = null;
            this._prev = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._prev === NOTHING || !fn(this._prev, x)) {
                this._prev = x;
                this._emitValue(x);
            }
        }
    };
    var S$15 = createStream('skipDuplicates', mixin$8);
    var P$11 = createProperty('skipDuplicates', mixin$8);
    var eq = function (a, b) {
        return a === b;
    };
    function skipDuplicates(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;
        return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });
    }
    var mixin$9 = {
        _init: function (_ref) {
            var fn = _ref.fn, seed = _ref.seed;
            this._fn = fn;
            this._prev = seed;
        },
        _free: function () {
            this._prev = null;
            this._fn = null;
        },
        _handleValue: function (x) {
            if (this._prev !== NOTHING) {
                var fn = this._fn;
                this._emitValue(fn(this._prev, x));
            }
            this._prev = x;
        }
    };
    var S$16 = createStream('diff', mixin$9);
    var P$12 = createProperty('diff', mixin$9);
    function defaultFn(a, b) {
        return [
            a,
            b
        ];
    }
    function diff(obs, fn) {
        var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;
        return new (obs._ofSameType(S$16, P$12))(obs, {
            fn: fn || defaultFn,
            seed: seed
        });
    }
    var P$13 = createProperty('scan', {
        _init: function (_ref) {
            var fn = _ref.fn, seed = _ref.seed;
            this._fn = fn;
            this._seed = seed;
            if (seed !== NOTHING) {
                this._emitValue(seed);
            }
        },
        _free: function () {
            this._fn = null;
            this._seed = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            if (this._currentEvent === null || this._currentEvent.type === ERROR) {
                this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));
            } else {
                this._emitValue(fn(this._currentEvent.value, x));
            }
        }
    });
    function scan(obs, fn) {
        var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;
        return new P$13(obs, {
            fn: fn,
            seed: seed
        });
    }
    var mixin$10 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            var xs = fn(x);
            for (var i = 0; i < xs.length; i++) {
                this._emitValue(xs[i]);
            }
        }
    };
    var S$17 = createStream('flatten', mixin$10);
    var id$4 = function (x) {
        return x;
    };
    function flatten(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;
        return new S$17(obs, { fn: fn });
    }
    var END_MARKER = {};
    var mixin$11 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait;
            this._wait = Math.max(0, wait);
            this._buff = [];
            this._$shiftBuff = function () {
                var value = _this._buff.shift();
                if (value === END_MARKER) {
                    _this._emitEnd();
                } else {
                    _this._emitValue(value);
                }
            };
        },
        _free: function () {
            this._buff = null;
            this._$shiftBuff = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                this._buff.push(x);
                setTimeout(this._$shiftBuff, this._wait);
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                this._buff.push(END_MARKER);
                setTimeout(this._$shiftBuff, this._wait);
            }
        }
    };
    var S$18 = createStream('delay', mixin$11);
    var P$14 = createProperty('delay', mixin$11);
    function delay(obs, wait) {
        return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });
    }
    var now = Date.now ? function () {
        return Date.now();
    } : function () {
        return new Date().getTime();
    };
    var mixin$12 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, leading = _ref.leading, trailing = _ref.trailing;
            this._wait = Math.max(0, wait);
            this._leading = leading;
            this._trailing = trailing;
            this._trailingValue = null;
            this._timeoutId = null;
            this._endLater = false;
            this._lastCallTime = 0;
            this._$trailingCall = function () {
                return _this._trailingCall();
            };
        },
        _free: function () {
            this._trailingValue = null;
            this._$trailingCall = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                var curTime = now();
                if (this._lastCallTime === 0 && !this._leading) {
                    this._lastCallTime = curTime;
                }
                var remaining = this._wait - (curTime - this._lastCallTime);
                if (remaining <= 0) {
                    this._cancelTrailing();
                    this._lastCallTime = curTime;
                    this._emitValue(x);
                } else if (this._trailing) {
                    this._cancelTrailing();
                    this._trailingValue = x;
                    this._timeoutId = setTimeout(this._$trailingCall, remaining);
                }
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                if (this._timeoutId) {
                    this._endLater = true;
                } else {
                    this._emitEnd();
                }
            }
        },
        _cancelTrailing: function () {
            if (this._timeoutId !== null) {
                clearTimeout(this._timeoutId);
                this._timeoutId = null;
            }
        },
        _trailingCall: function () {
            this._emitValue(this._trailingValue);
            this._timeoutId = null;
            this._trailingValue = null;
            this._lastCallTime = !this._leading ? 0 : now();
            if (this._endLater) {
                this._emitEnd();
            }
        }
    };
    var S$19 = createStream('throttle', mixin$12);
    var P$15 = createProperty('throttle', mixin$12);
    function throttle(obs, wait) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$leading = _ref2.leading, leading = _ref2$leading === undefined ? true : _ref2$leading, _ref2$trailing = _ref2.trailing, trailing = _ref2$trailing === undefined ? true : _ref2$trailing;
        return new (obs._ofSameType(S$19, P$15))(obs, {
            wait: wait,
            leading: leading,
            trailing: trailing
        });
    }
    var mixin$13 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, immediate = _ref.immediate;
            this._wait = Math.max(0, wait);
            this._immediate = immediate;
            this._lastAttempt = 0;
            this._timeoutId = null;
            this._laterValue = null;
            this._endLater = false;
            this._$later = function () {
                return _this._later();
            };
        },
        _free: function () {
            this._laterValue = null;
            this._$later = null;
        },
        _handleValue: function (x) {
            if (this._activating) {
                this._emitValue(x);
            } else {
                this._lastAttempt = now();
                if (this._immediate && !this._timeoutId) {
                    this._emitValue(x);
                }
                if (!this._timeoutId) {
                    this._timeoutId = setTimeout(this._$later, this._wait);
                }
                if (!this._immediate) {
                    this._laterValue = x;
                }
            }
        },
        _handleEnd: function () {
            if (this._activating) {
                this._emitEnd();
            } else {
                if (this._timeoutId && !this._immediate) {
                    this._endLater = true;
                } else {
                    this._emitEnd();
                }
            }
        },
        _later: function () {
            var last = now() - this._lastAttempt;
            if (last < this._wait && last >= 0) {
                this._timeoutId = setTimeout(this._$later, this._wait - last);
            } else {
                this._timeoutId = null;
                if (!this._immediate) {
                    this._emitValue(this._laterValue);
                    this._laterValue = null;
                }
                if (this._endLater) {
                    this._emitEnd();
                }
            }
        }
    };
    var S$20 = createStream('debounce', mixin$13);
    var P$16 = createProperty('debounce', mixin$13);
    function debounce(obs, wait) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$immediate = _ref2.immediate, immediate = _ref2$immediate === undefined ? false : _ref2$immediate;
        return new (obs._ofSameType(S$20, P$16))(obs, {
            wait: wait,
            immediate: immediate
        });
    }
    var mixin$14 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            this._emitError(fn(x));
        }
    };
    var S$21 = createStream('mapErrors', mixin$14);
    var P$17 = createProperty('mapErrors', mixin$14);
    var id$5 = function (x) {
        return x;
    };
    function mapErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;
        return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });
    }
    var mixin$15 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            if (fn(x)) {
                this._emitError(x);
            }
        }
    };
    var S$22 = createStream('filterErrors', mixin$15);
    var P$18 = createProperty('filterErrors', mixin$15);
    var id$6 = function (x) {
        return x;
    };
    function filterErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;
        return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });
    }
    var mixin$16 = {
        _handleValue: function () {
        }
    };
    var S$23 = createStream('ignoreValues', mixin$16);
    var P$19 = createProperty('ignoreValues', mixin$16);
    function ignoreValues(obs) {
        return new (obs._ofSameType(S$23, P$19))(obs);
    }
    var mixin$17 = {
        _handleError: function () {
        }
    };
    var S$24 = createStream('ignoreErrors', mixin$17);
    var P$20 = createProperty('ignoreErrors', mixin$17);
    function ignoreErrors(obs) {
        return new (obs._ofSameType(S$24, P$20))(obs);
    }
    var mixin$18 = {
        _handleEnd: function () {
        }
    };
    var S$25 = createStream('ignoreEnd', mixin$18);
    var P$21 = createProperty('ignoreEnd', mixin$18);
    function ignoreEnd(obs) {
        return new (obs._ofSameType(S$25, P$21))(obs);
    }
    var mixin$19 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleEnd: function () {
            var fn = this._fn;
            this._emitValue(fn());
            this._emitEnd();
        }
    };
    var S$26 = createStream('beforeEnd', mixin$19);
    var P$22 = createProperty('beforeEnd', mixin$19);
    function beforeEnd(obs, fn) {
        return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });
    }
    var mixin$20 = {
        _init: function (_ref) {
            var min = _ref.min, max = _ref.max;
            this._max = max;
            this._min = min;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _handleValue: function (x) {
            this._buff = slide(this._buff, x, this._max);
            if (this._buff.length >= this._min) {
                this._emitValue(this._buff);
            }
        }
    };
    var S$27 = createStream('slidingWindow', mixin$20);
    var P$23 = createProperty('slidingWindow', mixin$20);
    function slidingWindow(obs, max) {
        var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return new (obs._ofSameType(S$27, P$23))(obs, {
            min: min,
            max: max
        });
    }
    var mixin$21 = {
        _init: function (_ref) {
            var fn = _ref.fn, flushOnEnd = _ref.flushOnEnd;
            this._fn = fn;
            this._flushOnEnd = flushOnEnd;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null && this._buff.length !== 0) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            var fn = this._fn;
            if (!fn(x)) {
                this._flush();
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        }
    };
    var S$28 = createStream('bufferWhile', mixin$21);
    var P$24 = createProperty('bufferWhile', mixin$21);
    var id$7 = function (x) {
        return x;
    };
    function bufferWhile(obs, fn) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$28, P$24))(obs, {
            fn: fn || id$7,
            flushOnEnd: flushOnEnd
        });
    }
    var mixin$22 = {
        _init: function (_ref) {
            var count = _ref.count, flushOnEnd = _ref.flushOnEnd;
            this._count = count;
            this._flushOnEnd = flushOnEnd;
            this._buff = [];
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null && this._buff.length !== 0) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            if (this._buff.length >= this._count) {
                this._flush();
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        }
    };
    var S$29 = createStream('bufferWithCount', mixin$22);
    var P$25 = createProperty('bufferWithCount', mixin$22);
    function bufferWhile$1(obs, count) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$29, P$25))(obs, {
            count: count,
            flushOnEnd: flushOnEnd
        });
    }
    var mixin$23 = {
        _init: function (_ref) {
            var _this = this;
            var wait = _ref.wait, count = _ref.count, flushOnEnd = _ref.flushOnEnd;
            this._wait = wait;
            this._count = count;
            this._flushOnEnd = flushOnEnd;
            this._intervalId = null;
            this._$onTick = function () {
                return _this._flush();
            };
            this._buff = [];
        },
        _free: function () {
            this._$onTick = null;
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handleValue: function (x) {
            this._buff.push(x);
            if (this._buff.length >= this._count) {
                clearInterval(this._intervalId);
                this._flush();
                this._intervalId = setInterval(this._$onTick, this._wait);
            }
        },
        _handleEnd: function () {
            if (this._flushOnEnd && this._buff.length !== 0) {
                this._flush();
            }
            this._emitEnd();
        },
        _onActivation: function () {
            this._intervalId = setInterval(this._$onTick, this._wait);
            this._source.onAny(this._$handleAny);
        },
        _onDeactivation: function () {
            if (this._intervalId !== null) {
                clearInterval(this._intervalId);
                this._intervalId = null;
            }
            this._source.offAny(this._$handleAny);
        }
    };
    var S$30 = createStream('bufferWithTimeOrCount', mixin$23);
    var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);
    function bufferWithTimeOrCount(obs, wait, count) {
        var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {}, _ref2$flushOnEnd = _ref2.flushOnEnd, flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;
        return new (obs._ofSameType(S$30, P$26))(obs, {
            wait: wait,
            count: count,
            flushOnEnd: flushOnEnd
        });
    }
    function xformForObs(obs) {
        return {
            '@@transducer/step': function (res, input) {
                obs._emitValue(input);
                return null;
            },
            '@@transducer/result': function () {
                obs._emitEnd();
                return null;
            }
        };
    }
    var mixin$24 = {
        _init: function (_ref) {
            var transducer = _ref.transducer;
            this._xform = transducer(xformForObs(this));
        },
        _free: function () {
            this._xform = null;
        },
        _handleValue: function (x) {
            if (this._xform['@@transducer/step'](null, x) !== null) {
                this._xform['@@transducer/result'](null);
            }
        },
        _handleEnd: function () {
            this._xform['@@transducer/result'](null);
        }
    };
    var S$31 = createStream('transduce', mixin$24);
    var P$27 = createProperty('transduce', mixin$24);
    function transduce(obs, transducer) {
        return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });
    }
    var mixin$25 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._handler = fn;
            this._emitter = emitter(this);
        },
        _free: function () {
            this._handler = null;
            this._emitter = null;
        },
        _handleAny: function (event) {
            this._handler(this._emitter, event);
        }
    };
    var S$32 = createStream('withHandler', mixin$25);
    var P$28 = createProperty('withHandler', mixin$25);
    function withHandler(obs, fn) {
        return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });
    }
    var isArray = Array.isArray || function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]';
    };
    function Zip(sources, combinator) {
        var _this = this;
        Stream.call(this);
        this._buffers = map(sources, function (source) {
            return isArray(source) ? cloneArray(source) : [];
        });
        this._sources = map(sources, function (source) {
            return isArray(source) ? never() : source;
        });
        this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {
            return x;
        };
        this._aliveCount = 0;
        this._$handlers = [];
        var _loop = function (i) {
            _this._$handlers.push(function (event) {
                return _this._handleAny(i, event);
            });
        };
        for (var i = 0; i < this._sources.length; i++) {
            _loop(i);
        }
    }
    inherit(Zip, Stream, {
        _name: 'zip',
        _onActivation: function () {
            while (this._isFull()) {
                this._emit();
            }
            var length = this._sources.length;
            this._aliveCount = length;
            for (var i = 0; i < length && this._active; i++) {
                this._sources[i].onAny(this._$handlers[i]);
            }
        },
        _onDeactivation: function () {
            for (var i = 0; i < this._sources.length; i++) {
                this._sources[i].offAny(this._$handlers[i]);
            }
        },
        _emit: function () {
            var values = new Array(this._buffers.length);
            for (var i = 0; i < this._buffers.length; i++) {
                values[i] = this._buffers[i].shift();
            }
            var combinator = this._combinator;
            this._emitValue(combinator(values));
        },
        _isFull: function () {
            for (var i = 0; i < this._buffers.length; i++) {
                if (this._buffers[i].length === 0) {
                    return false;
                }
            }
            return true;
        },
        _handleAny: function (i, event) {
            if (event.type === VALUE) {
                this._buffers[i].push(event.value);
                if (this._isFull()) {
                    this._emit();
                }
            }
            if (event.type === ERROR) {
                this._emitError(event.value);
            }
            if (event.type === END) {
                this._aliveCount--;
                if (this._aliveCount === 0) {
                    this._emitEnd();
                }
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._sources = null;
            this._buffers = null;
            this._combinator = null;
            this._$handlers = null;
        }
    });
    function zip(observables, combinator) {
        return observables.length === 0 ? never() : new Zip(observables, combinator);
    }
    var id$8 = function (x) {
        return x;
    };
    function AbstractPool() {
        var _this = this;
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$queueLim = _ref.queueLim, queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim, _ref$concurLim = _ref.concurLim, concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim, _ref$drop = _ref.drop, drop = _ref$drop === undefined ? 'new' : _ref$drop;
        Stream.call(this);
        this._queueLim = queueLim < 0 ? -1 : queueLim;
        this._concurLim = concurLim < 0 ? -1 : concurLim;
        this._drop = drop;
        this._queue = [];
        this._curSources = [];
        this._$handleSubAny = function (event) {
            return _this._handleSubAny(event);
        };
        this._$endHandlers = [];
        this._currentlyAdding = null;
        if (this._concurLim === 0) {
            this._emitEnd();
        }
    }
    inherit(AbstractPool, Stream, {
        _name: 'abstractPool',
        _add: function (obj, toObs) {
            toObs = toObs || id$8;
            if (this._concurLim === -1 || this._curSources.length < this._concurLim) {
                this._addToCur(toObs(obj));
            } else {
                if (this._queueLim === -1 || this._queue.length < this._queueLim) {
                    this._addToQueue(toObs(obj));
                } else if (this._drop === 'old') {
                    this._removeOldest();
                    this._add(obj, toObs);
                }
            }
        },
        _addAll: function (obss) {
            var _this2 = this;
            forEach(obss, function (obs) {
                return _this2._add(obs);
            });
        },
        _remove: function (obs) {
            if (this._removeCur(obs) === -1) {
                this._removeQueue(obs);
            }
        },
        _addToQueue: function (obs) {
            this._queue = concat(this._queue, [obs]);
        },
        _addToCur: function (obs) {
            if (this._active) {
                if (!obs._alive) {
                    if (obs._currentEvent) {
                        this._emit(obs._currentEvent.type, obs._currentEvent.value);
                    }
                    if (this._active) {
                        if (this._queue.length !== 0) {
                            this._pullQueue();
                        } else if (this._curSources.length === 0) {
                            this._onEmpty();
                        }
                    }
                    return;
                }
                this._currentlyAdding = obs;
                obs.onAny(this._$handleSubAny);
                this._currentlyAdding = null;
                if (obs._alive) {
                    this._curSources = concat(this._curSources, [obs]);
                    if (this._active) {
                        this._subToEnd(obs);
                    }
                }
            } else {
                this._curSources = concat(this._curSources, [obs]);
            }
        },
        _subToEnd: function (obs) {
            var _this3 = this;
            var onEnd = function () {
                return _this3._removeCur(obs);
            };
            this._$endHandlers.push({
                obs: obs,
                handler: onEnd
            });
            obs.onEnd(onEnd);
        },
        _subscribe: function (obs) {
            obs.onAny(this._$handleSubAny);
            if (this._active) {
                this._subToEnd(obs);
            }
        },
        _unsubscribe: function (obs) {
            obs.offAny(this._$handleSubAny);
            var onEndI = findByPred(this._$endHandlers, function (obj) {
                return obj.obs === obs;
            });
            if (onEndI !== -1) {
                obs.offEnd(this._$endHandlers[onEndI].handler);
                this._$endHandlers.splice(onEndI, 1);
            }
        },
        _handleSubAny: function (event) {
            if (event.type === VALUE) {
                this._emitValue(event.value);
            } else if (event.type === ERROR) {
                this._emitError(event.value);
            }
        },
        _removeQueue: function (obs) {
            var index = find(this._queue, obs);
            this._queue = remove(this._queue, index);
            return index;
        },
        _removeCur: function (obs) {
            if (this._active) {
                this._unsubscribe(obs);
            }
            var index = find(this._curSources, obs);
            this._curSources = remove(this._curSources, index);
            if (index !== -1) {
                if (this._queue.length !== 0) {
                    this._pullQueue();
                } else if (this._curSources.length === 0) {
                    this._onEmpty();
                }
            }
            return index;
        },
        _removeOldest: function () {
            this._removeCur(this._curSources[0]);
        },
        _pullQueue: function () {
            if (this._queue.length !== 0) {
                this._queue = cloneArray(this._queue);
                this._addToCur(this._queue.shift());
            }
        },
        _onActivation: function () {
            for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {
                this._subscribe(sources[i]);
            }
        },
        _onDeactivation: function () {
            for (var i = 0, sources = this._curSources; i < sources.length; i++) {
                this._unsubscribe(sources[i]);
            }
            if (this._currentlyAdding !== null) {
                this._unsubscribe(this._currentlyAdding);
            }
        },
        _isEmpty: function () {
            return this._curSources.length === 0;
        },
        _onEmpty: function () {
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._queue = null;
            this._curSources = null;
            this._$handleSubAny = null;
            this._$endHandlers = null;
        }
    });
    function Merge(sources) {
        AbstractPool.call(this);
        this._addAll(sources);
        this._initialised = true;
    }
    inherit(Merge, AbstractPool, {
        _name: 'merge',
        _onEmpty: function () {
            if (this._initialised) {
                this._emitEnd();
            }
        }
    });
    function merge(observables) {
        return observables.length === 0 ? never() : new Merge(observables);
    }
    function S$33(generator) {
        var _this = this;
        Stream.call(this);
        this._generator = generator;
        this._source = null;
        this._inLoop = false;
        this._iteration = 0;
        this._$handleAny = function (event) {
            return _this._handleAny(event);
        };
    }
    inherit(S$33, Stream, {
        _name: 'repeat',
        _handleAny: function (event) {
            if (event.type === END) {
                this._source = null;
                this._getSource();
            } else {
                this._emit(event.type, event.value);
            }
        },
        _getSource: function () {
            if (!this._inLoop) {
                this._inLoop = true;
                var generator = this._generator;
                while (this._source === null && this._alive && this._active) {
                    this._source = generator(this._iteration++);
                    if (this._source) {
                        this._source.onAny(this._$handleAny);
                    } else {
                        this._emitEnd();
                    }
                }
                this._inLoop = false;
            }
        },
        _onActivation: function () {
            if (this._source) {
                this._source.onAny(this._$handleAny);
            } else {
                this._getSource();
            }
        },
        _onDeactivation: function () {
            if (this._source) {
                this._source.offAny(this._$handleAny);
            }
        },
        _clear: function () {
            Stream.prototype._clear.call(this);
            this._generator = null;
            this._source = null;
            this._$handleAny = null;
        }
    });
    var repeat = function (generator) {
        return new S$33(generator);
    };
    function concat$1(observables) {
        return repeat(function (index) {
            return observables.length > index ? observables[index] : false;
        }).setName('concat');
    }
    function Pool() {
        AbstractPool.call(this);
    }
    inherit(Pool, AbstractPool, {
        _name: 'pool',
        plug: function (obs) {
            this._add(obs);
            return this;
        },
        unplug: function (obs) {
            this._remove(obs);
            return this;
        }
    });
    function FlatMap(source, fn, options) {
        var _this = this;
        AbstractPool.call(this, options);
        this._source = source;
        this._fn = fn;
        this._mainEnded = false;
        this._lastCurrent = null;
        this._$handleMain = function (event) {
            return _this._handleMain(event);
        };
    }
    inherit(FlatMap, AbstractPool, {
        _onActivation: function () {
            AbstractPool.prototype._onActivation.call(this);
            if (this._active) {
                this._source.onAny(this._$handleMain);
            }
        },
        _onDeactivation: function () {
            AbstractPool.prototype._onDeactivation.call(this);
            this._source.offAny(this._$handleMain);
            this._hadNoEvSinceDeact = true;
        },
        _handleMain: function (event) {
            if (event.type === VALUE) {
                var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
                if (!sameCurr) {
                    this._add(event.value, this._fn);
                }
                this._lastCurrent = event.value;
                this._hadNoEvSinceDeact = false;
            }
            if (event.type === ERROR) {
                this._emitError(event.value);
            }
            if (event.type === END) {
                if (this._isEmpty()) {
                    this._emitEnd();
                } else {
                    this._mainEnded = true;
                }
            }
        },
        _onEmpty: function () {
            if (this._mainEnded) {
                this._emitEnd();
            }
        },
        _clear: function () {
            AbstractPool.prototype._clear.call(this);
            this._source = null;
            this._lastCurrent = null;
            this._$handleMain = null;
        }
    });
    function FlatMapErrors(source, fn) {
        FlatMap.call(this, source, fn);
    }
    inherit(FlatMapErrors, FlatMap, {
        _handleMain: function (event) {
            if (event.type === ERROR) {
                var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;
                if (!sameCurr) {
                    this._add(event.value, this._fn);
                }
                this._lastCurrent = event.value;
                this._hadNoEvSinceDeact = false;
            }
            if (event.type === VALUE) {
                this._emitValue(event.value);
            }
            if (event.type === END) {
                if (this._isEmpty()) {
                    this._emitEnd();
                } else {
                    this._mainEnded = true;
                }
            }
        }
    });
    function createConstructor$1(BaseClass, name) {
        return function AnonymousObservable(primary, secondary, options) {
            var _this = this;
            BaseClass.call(this);
            this._primary = primary;
            this._secondary = secondary;
            this._name = primary._name + '.' + name;
            this._lastSecondary = NOTHING;
            this._$handleSecondaryAny = function (event) {
                return _this._handleSecondaryAny(event);
            };
            this._$handlePrimaryAny = function (event) {
                return _this._handlePrimaryAny(event);
            };
            this._init(options);
        };
    }
    function createClassMethods$1(BaseClass) {
        return {
            _init: function () {
            },
            _free: function () {
            },
            _handlePrimaryValue: function (x) {
                this._emitValue(x);
            },
            _handlePrimaryError: function (x) {
                this._emitError(x);
            },
            _handlePrimaryEnd: function () {
                this._emitEnd();
            },
            _handleSecondaryValue: function (x) {
                this._lastSecondary = x;
            },
            _handleSecondaryError: function (x) {
                this._emitError(x);
            },
            _handleSecondaryEnd: function () {
            },
            _handlePrimaryAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handlePrimaryValue(event.value);
                case ERROR:
                    return this._handlePrimaryError(event.value);
                case END:
                    return this._handlePrimaryEnd(event.value);
                }
            },
            _handleSecondaryAny: function (event) {
                switch (event.type) {
                case VALUE:
                    return this._handleSecondaryValue(event.value);
                case ERROR:
                    return this._handleSecondaryError(event.value);
                case END:
                    this._handleSecondaryEnd(event.value);
                    this._removeSecondary();
                }
            },
            _removeSecondary: function () {
                if (this._secondary !== null) {
                    this._secondary.offAny(this._$handleSecondaryAny);
                    this._$handleSecondaryAny = null;
                    this._secondary = null;
                }
            },
            _onActivation: function () {
                if (this._secondary !== null) {
                    this._secondary.onAny(this._$handleSecondaryAny);
                }
                if (this._active) {
                    this._primary.onAny(this._$handlePrimaryAny);
                }
            },
            _onDeactivation: function () {
                if (this._secondary !== null) {
                    this._secondary.offAny(this._$handleSecondaryAny);
                }
                this._primary.offAny(this._$handlePrimaryAny);
            },
            _clear: function () {
                BaseClass.prototype._clear.call(this);
                this._primary = null;
                this._secondary = null;
                this._lastSecondary = null;
                this._$handleSecondaryAny = null;
                this._$handlePrimaryAny = null;
                this._free();
            }
        };
    }
    function createStream$1(name, mixin) {
        var S = createConstructor$1(Stream, name);
        inherit(S, Stream, createClassMethods$1(Stream), mixin);
        return S;
    }
    function createProperty$1(name, mixin) {
        var P = createConstructor$1(Property, name);
        inherit(P, Property, createClassMethods$1(Property), mixin);
        return P;
    }
    var mixin$26 = {
        _handlePrimaryValue: function (x) {
            if (this._lastSecondary !== NOTHING && this._lastSecondary) {
                this._emitValue(x);
            }
        },
        _handleSecondaryEnd: function () {
            if (this._lastSecondary === NOTHING || !this._lastSecondary) {
                this._emitEnd();
            }
        }
    };
    var S$34 = createStream$1('filterBy', mixin$26);
    var P$29 = createProperty$1('filterBy', mixin$26);
    function filterBy(primary, secondary) {
        return new (primary._ofSameType(S$34, P$29))(primary, secondary);
    }
    var id2 = function (_, x) {
        return x;
    };
    function sampledBy(passive, active, combinator) {
        var _combinator = combinator ? function (a, b) {
            return combinator(b, a);
        } : id2;
        return combine([active], [passive], _combinator).setName(passive, 'sampledBy');
    }
    var mixin$27 = {
        _handlePrimaryValue: function (x) {
            if (this._lastSecondary !== NOTHING) {
                this._emitValue(x);
            }
        },
        _handleSecondaryEnd: function () {
            if (this._lastSecondary === NOTHING) {
                this._emitEnd();
            }
        }
    };
    var S$35 = createStream$1('skipUntilBy', mixin$27);
    var P$30 = createProperty$1('skipUntilBy', mixin$27);
    function skipUntilBy(primary, secondary) {
        return new (primary._ofSameType(S$35, P$30))(primary, secondary);
    }
    var mixin$28 = {
        _handleSecondaryValue: function () {
            this._emitEnd();
        }
    };
    var S$36 = createStream$1('takeUntilBy', mixin$28);
    var P$31 = createProperty$1('takeUntilBy', mixin$28);
    function takeUntilBy(primary, secondary) {
        return new (primary._ofSameType(S$36, P$31))(primary, secondary);
    }
    var mixin$29 = {
        _init: function () {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$flushOnEnd = _ref.flushOnEnd, flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;
            this._buff = [];
            this._flushOnEnd = flushOnEnd;
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handlePrimaryEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        },
        _onActivation: function () {
            this._primary.onAny(this._$handlePrimaryAny);
            if (this._alive && this._secondary !== null) {
                this._secondary.onAny(this._$handleSecondaryAny);
            }
        },
        _handlePrimaryValue: function (x) {
            this._buff.push(x);
        },
        _handleSecondaryValue: function () {
            this._flush();
        },
        _handleSecondaryEnd: function () {
            if (!this._flushOnEnd) {
                this._emitEnd();
            }
        }
    };
    var S$37 = createStream$1('bufferBy', mixin$29);
    var P$32 = createProperty$1('bufferBy', mixin$29);
    function bufferBy(primary, secondary, options) {
        return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);
    }
    var mixin$30 = {
        _init: function () {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$flushOnEnd = _ref.flushOnEnd, flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd, _ref$flushOnChange = _ref.flushOnChange, flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;
            this._buff = [];
            this._flushOnEnd = flushOnEnd;
            this._flushOnChange = flushOnChange;
        },
        _free: function () {
            this._buff = null;
        },
        _flush: function () {
            if (this._buff !== null) {
                this._emitValue(this._buff);
                this._buff = [];
            }
        },
        _handlePrimaryEnd: function () {
            if (this._flushOnEnd) {
                this._flush();
            }
            this._emitEnd();
        },
        _handlePrimaryValue: function (x) {
            this._buff.push(x);
            if (this._lastSecondary !== NOTHING && !this._lastSecondary) {
                this._flush();
            }
        },
        _handleSecondaryEnd: function () {
            if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {
                this._emitEnd();
            }
        },
        _handleSecondaryValue: function (x) {
            if (this._flushOnChange && !x) {
                this._flush();
            }
            this._lastSecondary = x;
        }
    };
    var S$38 = createStream$1('bufferWhileBy', mixin$30);
    var P$33 = createProperty$1('bufferWhileBy', mixin$30);
    function bufferWhileBy(primary, secondary, options) {
        return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);
    }
    var f = function () {
        return false;
    };
    var t = function () {
        return true;
    };
    function awaiting(a, b) {
        var result = merge([
            map$1(a, t),
            map$1(b, f)
        ]);
        result = skipDuplicates(result);
        result = toProperty(result, f);
        return result.setName(a, 'awaiting');
    }
    var mixin$31 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleValue: function (x) {
            var fn = this._fn;
            var result = fn(x);
            if (result.convert) {
                this._emitError(result.error);
            } else {
                this._emitValue(x);
            }
        }
    };
    var S$39 = createStream('valuesToErrors', mixin$31);
    var P$34 = createProperty('valuesToErrors', mixin$31);
    var defFn = function (x) {
        return {
            convert: true,
            error: x
        };
    };
    function valuesToErrors(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;
        return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });
    }
    var mixin$32 = {
        _init: function (_ref) {
            var fn = _ref.fn;
            this._fn = fn;
        },
        _free: function () {
            this._fn = null;
        },
        _handleError: function (x) {
            var fn = this._fn;
            var result = fn(x);
            if (result.convert) {
                this._emitValue(result.value);
            } else {
                this._emitError(x);
            }
        }
    };
    var S$40 = createStream('errorsToValues', mixin$32);
    var P$35 = createProperty('errorsToValues', mixin$32);
    var defFn$1 = function (x) {
        return {
            convert: true,
            value: x
        };
    };
    function errorsToValues(obs) {
        var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;
        return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });
    }
    var mixin$33 = {
        _handleError: function (x) {
            this._emitError(x);
            this._emitEnd();
        }
    };
    var S$41 = createStream('endOnError', mixin$33);
    var P$36 = createProperty('endOnError', mixin$33);
    function endOnError(obs) {
        return new (obs._ofSameType(S$41, P$36))(obs);
    }
    Observable.prototype.toProperty = function (fn) {
        return toProperty(this, fn);
    };
    Observable.prototype.changes = function () {
        return changes(this);
    };
    Observable.prototype.toPromise = function (Promise) {
        return toPromise(this, Promise);
    };
    Observable.prototype.toESObservable = toESObservable;
    Observable.prototype[$$observable] = toESObservable;
    Observable.prototype.map = function (fn) {
        return map$1(this, fn);
    };
    Observable.prototype.filter = function (fn) {
        return filter(this, fn);
    };
    Observable.prototype.take = function (n) {
        return take(this, n);
    };
    Observable.prototype.takeErrors = function (n) {
        return takeErrors(this, n);
    };
    Observable.prototype.takeWhile = function (fn) {
        return takeWhile(this, fn);
    };
    Observable.prototype.last = function () {
        return last(this);
    };
    Observable.prototype.skip = function (n) {
        return skip(this, n);
    };
    Observable.prototype.skipWhile = function (fn) {
        return skipWhile(this, fn);
    };
    Observable.prototype.skipDuplicates = function (fn) {
        return skipDuplicates(this, fn);
    };
    Observable.prototype.diff = function (fn, seed) {
        return diff(this, fn, seed);
    };
    Observable.prototype.scan = function (fn, seed) {
        return scan(this, fn, seed);
    };
    Observable.prototype.flatten = function (fn) {
        return flatten(this, fn);
    };
    Observable.prototype.delay = function (wait) {
        return delay(this, wait);
    };
    Observable.prototype.throttle = function (wait, options) {
        return throttle(this, wait, options);
    };
    Observable.prototype.debounce = function (wait, options) {
        return debounce(this, wait, options);
    };
    Observable.prototype.mapErrors = function (fn) {
        return mapErrors(this, fn);
    };
    Observable.prototype.filterErrors = function (fn) {
        return filterErrors(this, fn);
    };
    Observable.prototype.ignoreValues = function () {
        return ignoreValues(this);
    };
    Observable.prototype.ignoreErrors = function () {
        return ignoreErrors(this);
    };
    Observable.prototype.ignoreEnd = function () {
        return ignoreEnd(this);
    };
    Observable.prototype.beforeEnd = function (fn) {
        return beforeEnd(this, fn);
    };
    Observable.prototype.slidingWindow = function (max, min) {
        return slidingWindow(this, max, min);
    };
    Observable.prototype.bufferWhile = function (fn, options) {
        return bufferWhile(this, fn, options);
    };
    Observable.prototype.bufferWithCount = function (count, options) {
        return bufferWhile$1(this, count, options);
    };
    Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {
        return bufferWithTimeOrCount(this, wait, count, options);
    };
    Observable.prototype.transduce = function (transducer) {
        return transduce(this, transducer);
    };
    Observable.prototype.withHandler = function (fn) {
        return withHandler(this, fn);
    };
    Observable.prototype.thru = function (fn) {
        return fn(this);
    };
    Observable.prototype.combine = function (other, combinator) {
        return combine([
            this,
            other
        ], combinator);
    };
    Observable.prototype.zip = function (other, combinator) {
        return zip([
            this,
            other
        ], combinator);
    };
    Observable.prototype.merge = function (other) {
        return merge([
            this,
            other
        ]);
    };
    Observable.prototype.concat = function (other) {
        return concat$1([
            this,
            other
        ]);
    };
    var pool = function () {
        return new Pool();
    };
    Observable.prototype.flatMap = function (fn) {
        return new FlatMap(this, fn).setName(this, 'flatMap');
    };
    Observable.prototype.flatMapLatest = function (fn) {
        return new FlatMap(this, fn, {
            concurLim: 1,
            drop: 'old'
        }).setName(this, 'flatMapLatest');
    };
    Observable.prototype.flatMapFirst = function (fn) {
        return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');
    };
    Observable.prototype.flatMapConcat = function (fn) {
        return new FlatMap(this, fn, {
            queueLim: -1,
            concurLim: 1
        }).setName(this, 'flatMapConcat');
    };
    Observable.prototype.flatMapConcurLimit = function (fn, limit) {
        return new FlatMap(this, fn, {
            queueLim: -1,
            concurLim: limit
        }).setName(this, 'flatMapConcurLimit');
    };
    Observable.prototype.flatMapErrors = function (fn) {
        return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');
    };
    Observable.prototype.filterBy = function (other) {
        return filterBy(this, other);
    };
    Observable.prototype.sampledBy = function (other, combinator) {
        return sampledBy(this, other, combinator);
    };
    Observable.prototype.skipUntilBy = function (other) {
        return skipUntilBy(this, other);
    };
    Observable.prototype.takeUntilBy = function (other) {
        return takeUntilBy(this, other);
    };
    Observable.prototype.bufferBy = function (other, options) {
        return bufferBy(this, other, options);
    };
    Observable.prototype.bufferWhileBy = function (other, options) {
        return bufferWhileBy(this, other, options);
    };
    var DEPRECATION_WARNINGS = true;
    function dissableDeprecationWarnings() {
        DEPRECATION_WARNINGS = false;
    }
    function warn(msg) {
        if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {
            var msg2 = '\nHere is an Error object for you containing the call stack:';
            console.warn(msg, msg2, new Error());
        }
    }
    Observable.prototype.awaiting = function (other) {
        warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');
        return awaiting(this, other);
    };
    Observable.prototype.valuesToErrors = function (fn) {
        warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');
        return valuesToErrors(this, fn);
    };
    Observable.prototype.errorsToValues = function (fn) {
        warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');
        return errorsToValues(this, fn);
    };
    Observable.prototype.endOnError = function () {
        warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');
        return endOnError(this);
    };
    var Kefir = {
        Observable: Observable,
        Stream: Stream,
        Property: Property,
        never: never,
        later: later,
        interval: interval,
        sequentially: sequentially,
        fromPoll: fromPoll,
        withInterval: withInterval,
        fromCallback: fromCallback,
        fromNodeCallback: fromNodeCallback,
        fromEvents: fromEvents,
        stream: stream,
        constant: constant,
        constantError: constantError,
        fromPromise: fromPromise,
        fromESObservable: fromESObservable,
        combine: combine,
        zip: zip,
        merge: merge,
        concat: concat$1,
        Pool: Pool,
        pool: pool,
        repeat: repeat,
        staticLand: staticLand
    };
    Kefir.Kefir = Kefir;
    exports.dissableDeprecationWarnings = dissableDeprecationWarnings;
    exports.Kefir = Kefir;
    exports.Observable = Observable;
    exports.Stream = Stream;
    exports.Property = Property;
    exports.never = never;
    exports.later = later;
    exports.interval = interval;
    exports.sequentially = sequentially;
    exports.fromPoll = fromPoll;
    exports.withInterval = withInterval;
    exports.fromCallback = fromCallback;
    exports.fromNodeCallback = fromNodeCallback;
    exports.fromEvents = fromEvents;
    exports.stream = stream;
    exports.constant = constant;
    exports.constantError = constantError;
    exports.fromPromise = fromPromise;
    exports.fromESObservable = fromESObservable;
    exports.combine = combine;
    exports.zip = zip;
    exports.merge = merge;
    exports.concat = concat$1;
    exports.Pool = Pool;
    exports.pool = pool;
    exports.repeat = repeat;
    exports.staticLand = staticLand;
    exports['default'] = Kefir;
    Object.defineProperty(exports, '__esModule', { value: true });
}));
/*can-kefir@0.2.3#can-kefir*/
define('can-kefir@0.2.3#can-kefir', [
    'require',
    'exports',
    'module',
    'can-reflect',
    'can-symbol',
    'can-util/js/dev/dev',
    'kefir',
    'can-observation',
    'can-cid',
    'can-event/batch/batch',
    'can-define-lazy-value'
], function (require, exports, module) {
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var dev = require('can-util/js/dev/dev');
    var Kefir = require('kefir');
    var Observation = require('can-observation');
    var CID = require('can-cid');
    var canBatch = require('can-event/batch/batch');
    var defineLazyValue = require('can-define-lazy-value');
    var observeDataSymbol = canSymbol.for('can.observeData');
    function getObserveData(stream) {
        var observeData = stream[observeDataSymbol];
        if (!observeData) {
            observeData = Object.create(null);
            observeData.onValueHandlers = [];
            observeData.onErrorHandlers = [];
            Object.defineProperty(stream, observeDataSymbol, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: observeData
            });
        }
        return observeData;
    }
    var keyNames = {
        'value': {
            on: 'onValue',
            handlers: 'onValueHandlers',
            off: 'offValue',
            handler: 'onValueHandler'
        },
        'error': {
            on: 'onError',
            handlers: 'onErrorHandlers',
            off: 'offError',
            handler: 'onErrorHandler'
        }
    };
    function getCurrentValue(stream, key) {
        if (stream._currentEvent && stream._currentEvent.type === key) {
            return stream._currentEvent.value;
        } else {
            var names = keyNames[key];
            if (!names) {
                return stream[key];
            }
            var VALUE, valueHandler = function (value) {
                    VALUE = value;
                };
            stream[names.on](valueHandler);
            stream[names.off](valueHandler);
            return VALUE;
        }
    }
    if (Kefir) {
        defineLazyValue(Kefir.Observable.prototype, '_cid', function () {
            return CID({});
        });
        canReflect.assignSymbols(Kefir.Observable.prototype, {
            'can.onKeyValue': function (key, handler) {
                var names = keyNames[key];
                var observeData = getObserveData(this);
                var handlers = observeData[names.handlers];
                if (handlers.length === 0) {
                    var stream = this;
                    var onHandler = observeData[names.handler] = function (value) {
                        if (value !== observeData[key]) {
                            observeData[key] = value;
                            handlers.forEach(function (handler) {
                                canBatch.queue([
                                    handler,
                                    stream,
                                    [value]
                                ]);
                            });
                        }
                    };
                    handlers.push(handler);
                    this[names.on](onHandler);
                } else {
                    handlers.push(handler);
                }
            },
            'can.offKeyValue': function (key, handler) {
                var names = keyNames[key];
                var observeData = getObserveData(this);
                var handlers = observeData[names.handlers];
                var index = handlers.indexOf(handler);
                if (index !== -1) {
                    handlers.splice(index, 1);
                    if (handlers.length === 0) {
                        this[names.off](observeData[names.handler]);
                        delete this[observeDataSymbol];
                    }
                }
            },
            'can.getKeyValue': function (key) {
                if (!keyNames[key]) {
                    return this[key];
                }
                Observation.add(this, key);
                if (!this[observeDataSymbol]) {
                    var observeData = getObserveData(this);
                    var currentValue = getCurrentValue(this, key);
                    return observeData[key] = currentValue;
                }
                return getObserveData(this)[key];
            }
        });
        Kefir.emitterProperty = function () {
            var emitter;
            var setLastValue = false;
            var lastValue, lastError;
            var stream = Kefir.stream(function (EMITTER) {
                emitter = EMITTER;
                if (setLastValue) {
                    emitter.value(lastValue);
                }
                return function () {
                    emitter = undefined;
                };
            });
            var property = stream.toProperty(function () {
                return lastValue;
            });
            property.emitter = {
                value: function (newValue) {
                    if (emitter) {
                        return emitter.emit(newValue);
                    } else {
                        setLastValue = true;
                        lastValue = newValue;
                    }
                },
                error: function (error) {
                    if (emitter) {
                        return emitter.error(error);
                    } else {
                        lastError = error;
                    }
                }
            };
            property.emitter.emit = property.emitter.value;
            canReflect.assignSymbols(property, {
                'can.setKeyValue': function (key, value) {
                    this.emitter[key](value);
                }
            });
            return property;
        };
    }
    module.exports = Kefir;
});
/*can-kefir@0.2.3#can-kefir-test*/
define('can-kefir@0.2.3#can-kefir-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-kefir',
    'can-reflect',
    'can-event/batch/batch'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var Kefir = require('can-kefir');
    var canReflect = require('can-reflect');
    var batch = require('can-event/batch/batch');
    QUnit.module('can-kefir', {});
    QUnit.test('basics', 5, function () {
        var EMITTER;
        var stream = Kefir.stream(function (emitter) {
            EMITTER = emitter;
        });
        var valueEventCount = 0;
        function valueHandler(value) {
            valueEventCount++;
            if (valueEventCount === 1) {
                QUnit.equal(value, 1, 'produced a value');
            } else if (valueEventCount === 2) {
                QUnit.equal(value, 2, 'produced a value');
            } else {
                QUnit.ok(false, 'should not be called');
            }
        }
        canReflect.onKeyValue(stream, 'value', valueHandler);
        EMITTER.value(1);
        QUnit.equal(canReflect.getKeyValue(stream, 'value'), 1, 'got initial value');
        EMITTER.value(2);
        canReflect.offKeyValue(stream, 'value', valueHandler);
        EMITTER.value(3);
        var errorEventCount = 0;
        function errorHandler(value) {
            errorEventCount++;
            if (errorEventCount === 1) {
                QUnit.equal(value, 'a', 'produced an error');
            } else {
                QUnit.ok(false, 'no more errors');
            }
        }
        canReflect.onKeyValue(stream, 'error', errorHandler);
        EMITTER.error('a');
        QUnit.equal(canReflect.getKeyValue(stream, 'error'), 'a', 'got initial value');
        canReflect.offKeyValue(stream, 'error', errorHandler);
        EMITTER.error('b');
    });
    QUnit.test('streams have a cid', function () {
        var stream = Kefir.stream(function () {
        });
        QUnit.ok(stream._cid, 'streams have a cid');
    });
    QUnit.test('callbacks are within a batch', function () {
        var EMITTER;
        var stream = Kefir.stream(function (emitter) {
            EMITTER = emitter;
        });
        function valueHandler() {
            QUnit.ok(batch.batchNum, 'batchNum exists');
        }
        canReflect.onKeyValue(stream, 'value', valueHandler);
        EMITTER.value(1);
    });
    QUnit.test('properties can be read without binding', function () {
        var EMITTER;
        var property = Kefir.stream(function (emitter) {
            EMITTER = emitter;
        }).toProperty();
        property.onValue(function () {
        });
        EMITTER.value(10);
        QUnit.equal(canReflect.getKeyValue(property, 'value'), 10, 'got property value');
    });
    QUnit.test('Kefir.emitterProperty', function () {
        var stream = new Kefir.emitterProperty();
        var valueEventCount = 0;
        function valueHandler(value) {
            valueEventCount++;
            if (valueEventCount === 1) {
                QUnit.equal(value, 1, 'produced a value');
            } else if (valueEventCount === 2) {
                QUnit.equal(value, 2, 'produced a value');
            } else {
                QUnit.ok(false, 'should not be called');
            }
        }
        canReflect.onKeyValue(stream, 'value', valueHandler);
        stream.emitter.emit(1);
        QUnit.equal(canReflect.getKeyValue(stream, 'value'), 1, 'got initial value');
        canReflect.setKeyValue(stream, 'value', 2);
        canReflect.offKeyValue(stream, 'value', valueHandler);
        stream.emitter.value(3);
        var errorEventCount = 0;
        function errorHandler(value) {
            errorEventCount++;
            if (errorEventCount === 1) {
                QUnit.equal(value, 'a', 'produced an error');
            } else {
                QUnit.ok(false, 'no more errors');
            }
        }
        canReflect.onKeyValue(stream, 'error', errorHandler);
        stream.emitter.error('a');
        QUnit.equal(canReflect.getKeyValue(stream, 'error'), 'a', 'got initial value');
        canReflect.offKeyValue(stream, 'error', errorHandler);
        stream.emitter.error('b');
    });
    QUnit.test('get behavior with constant stream', function () {
        var stream = Kefir.stream(function (emit) {
            emit.value(1);
        });
        canReflect.onKeyValue(stream, 'value', function (newVal) {
            QUnit.equal(newVal, 1, 'got new Value');
        });
        QUnit.equal(canReflect.getKeyValue(stream, 'value'), 1, 'undefined');
    });
    QUnit.test('read emitter', function () {
        var stream = new Kefir.emitterProperty();
        QUnit.equal(canReflect.getKeyValue(stream, 'emitter'), stream.emitter, 'got the emitter');
    });
});
/*can-util@3.14.0#namespace*/
define('can-util@3.14.0#namespace', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    'use strict';
    module.exports = require('can-namespace');
});
/*can-stream@0.3.2#can-stream*/
define('can-stream@0.3.2#can-stream', [
    'require',
    'exports',
    'module',
    'can-util/namespace',
    'can-compute',
    'can-util/js/make-array/make-array',
    'can-util/js/assign/assign'
], function (require, exports, module) {
    var namespace = require('can-util/namespace');
    var compute = require('can-compute');
    var makeArray = require('can-util/js/make-array/make-array');
    var assign = require('can-util/js/assign/assign');
    var toComputeFromEvent = function (observable, eventName) {
        var handler, lastSet;
        return compute(undefined, {
            on: function (updated) {
                handler = function (ev, val) {
                    lastSet = assign({ args: [].slice.call(arguments, 1) }, ev);
                    updated();
                };
                observable.on(eventName, handler);
            },
            off: function (updated) {
                observable.off(eventName, handler);
                lastSet = undefined;
            },
            get: function () {
                return lastSet;
            }
        });
    };
    var STREAM = function (canStreamInterface) {
        var canStream;
        var toStreamFromProperty = function (obs, propName) {
            return canStreamInterface.toStream(compute(obs, propName));
        };
        var toStreamFromEvent = function () {
            var obs = arguments[0];
            var eventName, propName, lastValue, internalCompute;
            if (arguments.length === 2) {
                internalCompute = toComputeFromEvent(obs, arguments[1]);
                return canStreamInterface.toStream(internalCompute);
            } else {
                propName = arguments[1];
                eventName = arguments[2];
                lastValue = obs[propName];
                var valuePropCompute = compute(obs, propName);
                var eventHandler;
                var propChangeHandler;
                internalCompute = compute(undefined, {
                    on: function (updater) {
                        eventHandler = function (ev, newVal, oldVal) {
                            lastValue = newVal;
                            updater(lastValue);
                        };
                        propChangeHandler = function (ev, newVal, oldVal) {
                            oldVal.off(eventName, eventHandler);
                            newVal.on(eventName, eventHandler);
                        };
                        valuePropCompute.on('change', propChangeHandler);
                        valuePropCompute().on(eventName, eventHandler);
                    },
                    off: function () {
                        valuePropCompute().off(eventName, eventHandler);
                        valuePropCompute.off('change', propChangeHandler);
                    },
                    get: function () {
                        return lastValue;
                    },
                    set: function (val) {
                        throw new Error('can-stream: you can\'t set this type of compute');
                    }
                });
                var stream = canStreamInterface.toStream(internalCompute);
                return stream;
            }
        };
        var toStream = function () {
            if (arguments.length === 1) {
                return canStreamInterface.toStream(arguments[0]);
            } else if (arguments.length > 1) {
                var obs = arguments[0];
                var eventNameOrPropName = arguments[1].trim();
                if (eventNameOrPropName.indexOf(' ') === -1) {
                    if (eventNameOrPropName.indexOf('.') === 0) {
                        return canStream.toStreamFromProperty(obs, eventNameOrPropName.slice(1));
                    } else {
                        return canStream.toStreamFromEvent(obs, eventNameOrPropName);
                    }
                } else {
                    var splitEventNameAndProperty = eventNameOrPropName.split(' ');
                    return canStream.toStreamFromEvent(obs, splitEventNameAndProperty[0].slice(1), splitEventNameAndProperty[1]);
                }
            }
            return undefined;
        };
        var toCompute = function (makeStream, context) {
            var args = makeArray(arguments);
            return canStreamInterface.toCompute.apply(this, args);
        };
        canStream = toStream;
        canStream.toStream = canStream;
        canStream.toStreamFromProperty = toStreamFromProperty;
        canStream.toStreamFromEvent = toStreamFromEvent;
        canStream.toCompute = toCompute;
        return canStream;
    };
    STREAM.toComputeFromEvent = toComputeFromEvent;
    module.exports = namespace.stream = STREAM;
});
/*can-stream@0.3.2#can-stream_test*/
define('can-stream@0.3.2#can-stream_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-compute',
    'can-define/map/map',
    'can-define/list/list',
    'can-stream'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var compute = require('can-compute');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var canStream = require('can-stream');
    QUnit.module('can-stream');
    test('Resolves to "toStream" function', function () {
        var c = compute(0);
        var obj;
        var streamInterface;
        var streamImplementation = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        streamInterface = canStream(streamImplementation);
        var stream = streamInterface(c);
        QUnit.equal(obj, stream);
    });
    test('Compute changes can be streamed', function () {
        var c = compute(0);
        var obj;
        var canStreaming;
        var canStreamInterface = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(c);
        QUnit.equal(obj, stream);
        var computeVal;
        stream.onValue(function (newVal) {
            computeVal = newVal;
        });
        QUnit.equal(computeVal, 0);
        c(1);
        QUnit.equal(computeVal, 1);
        c(2);
        QUnit.equal(computeVal, 2);
        c(3);
        QUnit.equal(computeVal, 3);
    });
    test('Compute streams do not bind to the compute unless activated', function () {
        var c = compute(0);
        var canStreamInterface = {
            toStream: function (observable, propOrEvent) {
                QUnit.equal(c, observable);
                var obj;
                return obj = {
                    onValue: function (callback) {
                        c.on('change', function (evnt, newVal, oldVal) {
                            callback(newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(c);
        QUnit.equal(c.computeInstance.__bindEvents, undefined);
        stream.onValue(function () {
        });
        QUnit.equal(c.computeInstance.__bindEvents._lifecycleBindings, 1);
    });
    test('Stream on a property val - toStreamFromEvent', function () {
        var expected = 'bar';
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.foo');
        stream.onValue(function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expected);
        });
        expected = 'foobar';
        map.foo = 'foobar';
    });
    test('Stream on a property val - toStreamFromProperty', function () {
        var expected = 'bar';
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.foo');
        stream.onValue(function (ev, val) {
            QUnit.equal(val, expected);
        });
        expected = 'foobar';
        map.foo = 'foobar';
    });
    test('Event streams fire change events', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newValue) {
                            callback.call(null, newValue);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map.fooList, 'length');
        stream.onValue(function (lengthEvent) {
            QUnit.equal(lengthEvent.type, 'length');
            QUnit.deepEqual(lengthEvent.args, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = [1];
        map.fooList.push(1);
        expected = [0];
        map.fooList.pop();
    });
    test('Event streams fire change event on a property', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var map = new MyMap();
        var stream = canStreaming.toStream(map, '.fooList add');
        stream.onValue(function (ev, length, oldLength) {
            QUnit.equal(length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Stream on a property val - toStreamFromEvent', function () {
        var MyMap = DefineMap.extend({ foo: { value: 'bar' } });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newVal) {
                            callback.call(null, newVal);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, 'foo');
        stream.onValue(function (fooEvent) {
            QUnit.equal(fooEvent.type, 'foo');
            QUnit.deepEqual(fooEvent.args, [
                'foobar',
                'bar'
            ]);
        });
        map.foo = 'foobar';
    });
    test('Convert an observable nested property into an event stream #2b', 2, function () {
        var MyMap = DefineMap.extend({
            foo: {
                value: function () {
                    return { bar: 1 };
                }
            }
        });
        var obs = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function (ev, newVal) {
                            callback.call(null, newVal);
                        });
                        callback(c());
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(obs, '.foo.bar');
        var expected = 1;
        stream.onValue(function (barValue) {
            QUnit.equal(barValue, expected, 'value was ' + barValue);
        });
        expected = 2;
        obs.foo.bar = 2;
    });
    test('observable nested property event', 1, function () {
        var MyMap = DefineMap.extend({
            foo: {
                value: function () {
                    return { bar: 1 };
                }
            }
        });
        var obs = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                var handler;
                return {
                    onValue: function (callback) {
                        handler = function () {
                            callback.apply(null, arguments);
                        };
                        c.on('change', handler);
                    },
                    offValue: function (callback) {
                        c.off('change', handler);
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(obs, '.foo bar');
        var expected = 1;
        stream.onValue(function (barEvent, barValue) {
            QUnit.equal(barValue, expected, 'value was ' + barValue);
        });
        expected = 2;
        obs.foo.bar = 2;
    });
    test('Event streams fire change events on a property', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                var handler;
                return {
                    onValue: function (callback) {
                        handler = function () {
                            callback.apply(null, arguments);
                        };
                        c.on('change', handler);
                    },
                    offValue: function (callback) {
                        c.off('change', handler);
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList length');
        var handler = function (ev, length, lastLength) {
            QUnit.equal(length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        };
        stream.onValue(handler);
        expected = 1;
        map.fooList.push(1);
        expected = 2;
        map.fooList.push(2);
        expected = 1;
        map.fooList.pop();
        expected = 0;
        map.fooList = new DefineList([]);
        stream.offValue(handler);
    });
    test('Create a stream from a observable and event with shorthand method: toStream', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map.fooList, 'length');
        stream.onValue(function (ev) {
            QUnit.equal(map.fooList.length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Create a stream from a observable and event on property with shorthand method: toStream', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList length');
        stream.onValue(function (ev) {
            QUnit.equal(map.fooList.length, expected, 'Event stream was updated with length: ' + map.fooList.length);
        });
        expected = 1;
        map.fooList.push(1);
        expected = 0;
        map.fooList.pop();
    });
    test('Update the list to undefined', function () {
        var expected = 0;
        var MyMap = DefineMap.extend({
            fooList: {
                Type: DefineList.List,
                value: []
            }
        });
        var map = new MyMap();
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        var stream = canStreaming.toStream(map, '.fooList.length');
        stream.onValue(function (ev, newVal) {
            QUnit.equal(newVal, expected, 'Setting fooList to null');
        });
        expected = undefined;
        map.fooList = null;
    });
    test('toStreamFromEvent passes event and other arguments', 3, function () {
        var myMap = new DefineMap({ prop: 'value' });
        var c = canStream.toComputeFromEvent(myMap, 'prop');
        c.on('change', function (ev, newVal) {
            QUnit.equal(newVal.type, 'prop');
            QUnit.deepEqual(newVal.args, [
                'VALUE',
                'value'
            ]);
        });
        QUnit.equal(c(), undefined, 'no value');
        myMap.prop = 'VALUE';
    });
});
/*can-stream-kefir@0.3.3#can-stream-kefir*/
define('can-stream-kefir@0.3.3#can-stream-kefir', [
    'require',
    'exports',
    'module',
    'kefir',
    'can-compute',
    'can-stream',
    'can-namespace'
], function (require, exports, module) {
    var Kefir = require('kefir');
    var compute = require('can-compute');
    var canStream = require('can-stream');
    var namespace = require('can-namespace');
    var canStreamKefir = {};
    canStreamKefir.toStream = function (compute) {
        return Kefir.stream(function (emitter) {
            var changeHandler = function (ev, newVal) {
                emitter.emit(newVal);
            };
            compute.on('change', changeHandler);
            var currentValue = compute();
            if (currentValue !== undefined) {
                emitter.emit(currentValue);
            }
            return function () {
                compute.off('change', changeHandler);
            };
        });
    };
    canStreamKefir.toCompute = function (makeStream, context) {
        var emitter, lastValue, streamHandler, lastSetValue;
        var setterStream = Kefir.stream(function (e) {
                emitter = e;
                if (lastSetValue !== undefined) {
                    emitter.emit(lastSetValue);
                }
            }), valueStream = makeStream.call(context, setterStream);
        return compute(undefined, {
            get: function () {
                return lastValue;
            },
            set: function (val) {
                if (emitter) {
                    emitter.emit(val);
                } else {
                    lastSetValue = val;
                }
                return val;
            },
            on: function (updated) {
                streamHandler = function (val) {
                    lastValue = val;
                    updated();
                };
                valueStream.onValue(streamHandler);
            },
            off: function () {
                valueStream.offValue(streamHandler);
            }
        });
    };
    if (!namespace.streamKefir) {
        module.exports = namespace.streamKefir = canStream(canStreamKefir);
    }
});
/*can-stream-kefir@0.3.3#can-stream-kefir_test*/
define('can-stream-kefir@0.3.3#can-stream-kefir_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-stream-kefir',
    'can-compute',
    'can-define/list/list'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var canStream = require('can-stream-kefir');
    var compute = require('can-compute');
    var DefineList = require('can-define/list/list');
    QUnit.module('can-stream-kefir');
    test('Compute changes can be streamed', function () {
        var c = compute(0);
        var stream = canStream.toStream(c);
        var computeVal;
        stream.onValue(function (newVal) {
            computeVal = newVal;
        });
        QUnit.equal(computeVal, 0);
        c(1);
        QUnit.equal(computeVal, 1);
        c(2);
        QUnit.equal(computeVal, 2);
        c(3);
        QUnit.equal(computeVal, 3);
    });
    test('Compute streams do not bind to the compute unless activated', function () {
        var c = compute(0);
        var stream = canStream.toStream(c);
        QUnit.equal(c.computeInstance.__bindEvents, undefined);
        stream.onValue(function () {
        });
        QUnit.equal(c.computeInstance.__bindEvents._lifecycleBindings, 1);
    });
    test('Compute stream values can be piped into a compute', function () {
        var expected = 0;
        var c1 = compute(0);
        var c2 = compute(0);
        var resultCompute = canStream.toStream(c1).merge(canStream.toStream(c2));
        resultCompute.onValue(function (val) {
            QUnit.equal(val, expected);
        });
        expected = 1;
        c1(1);
        expected = 2;
        c2(2);
        expected = 3;
        c1(3);
    });
    test('Computed streams fire change events', function () {
        var expected = 0;
        var c1 = compute(expected);
        var c2 = compute(expected);
        var resultCompute = canStream.toStream(c1).merge(canStream.toStream(c2));
        resultCompute.onValue(function (newVal) {
            QUnit.equal(expected, newVal);
        });
        expected = 1;
        c1(expected);
        expected = 2;
        c2(expected);
        expected = 3;
        c1(expected);
    });
    test('Create a stream from a compute with shorthand method: toStream', function () {
        var expected = 0;
        var c1 = compute(0);
        var resultCompute = canStream.toStream(c1);
        resultCompute.onValue(function (val) {
            QUnit.equal(val, expected);
        });
        expected = 1;
        c1(1);
    });
    test('toCompute(streamMaker) can-define-stream#17', function () {
        var c = compute('a');
        var letterStream = canStream.toStream(c);
        var streamedCompute = canStream.toCompute(function (setStream) {
            return setStream.merge(letterStream);
        });
        streamedCompute.on('change', function (ev, newVal) {
        });
        QUnit.deepEqual(streamedCompute(), 'a');
        c(1);
        QUnit.deepEqual(streamedCompute(), 1);
        c('b');
        QUnit.deepEqual(streamedCompute(), 'b');
    });
    test('setting test', function () {
        var c = canStream.toCompute(function (setStream) {
            return setStream;
        });
        c(5);
        c.on('change', function () {
        });
        QUnit.equal(c(), 5);
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var people = new DefineList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = canStream.toStream(people, '.length');
        expectedLength = 2;
        stream.onValue(function (newLength) {
            QUnit.equal(newLength, expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    test('Computes with an initial value of undefined do not emit', function () {
        var expectedLength;
        var people = new DefineList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = canStream.toStream(people, 'length');
        expectedLength = 2;
        stream.onValue(function (event) {
            QUnit.equal(event.args[0], expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
});
/*can-ndjson-stream@0.1.8#can-ndjson-stream*/
define('can-ndjson-stream@0.1.8#can-ndjson-stream', [
    'require',
    'exports',
    'module',
    'can-namespace'
], function (require, exports, module) {
    var namespace = require('can-namespace');
    var ndjsonStream = function (response) {
        var is_reader, cancellationRequest = false;
        return new ReadableStream({
            start: function (controller) {
                var reader = response.getReader();
                is_reader = reader;
                var decoder = new TextDecoder();
                var data_buf = '';
                reader.read().then(function processResult(result) {
                    if (result.done) {
                        if (cancellationRequest) {
                            return;
                        }
                        data_buf = data_buf.trim();
                        if (data_buf.length !== 0) {
                            try {
                                var data_l = JSON.parse(data_buf);
                                controller.enqueue(data_l);
                            } catch (e) {
                                controller.error(e);
                                return;
                            }
                        }
                        controller.close();
                        return;
                    }
                    var data = decoder.decode(result.value, { stream: true });
                    data_buf += data;
                    var lines = data_buf.split('\n');
                    for (var i = 0; i < lines.length - 1; ++i) {
                        var l = lines[i].trim();
                        if (l.length > 0) {
                            try {
                                var data_line = JSON.parse(l);
                                controller.enqueue(data_line);
                            } catch (e) {
                                controller.error(e);
                                cancellationRequest = true;
                                reader.cancel();
                                return;
                            }
                        }
                    }
                    data_buf = lines[lines.length - 1];
                    return reader.read().then(processResult);
                });
            },
            cancel: function (reason) {
                console.log('Cancel registered due to ', reason);
                cancellationRequest = true;
                is_reader.cancel();
            }
        });
    };
    module.exports = namespace.ndjsonStream = ndjsonStream;
});
/*can-ndjson-stream@0.1.8#can-ndjson-stream-test*/
define('can-ndjson-stream@0.1.8#can-ndjson-stream-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-ndjson-stream'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var ndjsonStream = require('can-ndjson-stream');
    var isReadStreamSupported = true;
    try {
        new ReadableStream();
    } catch (err) {
        isReadStreamSupported = false;
    }
    var conditionalTest = isReadStreamSupported ? QUnit.test : QUnit.skip;
    var conditionalAsyncTest = isReadStreamSupported ? QUnit.asyncTest : QUnit.skip;
    function readableStreamFromString(s) {
        return new ReadableStream({
            start: function (controller) {
                var encoder = new TextEncoder();
                var pos = 0;
                var chunkSize = 1;
                function push() {
                    if (pos >= s.length) {
                        controller.close();
                        return;
                    }
                    controller.enqueue(encoder.encode(s.slice(pos, pos + chunkSize)));
                    pos += chunkSize;
                    push();
                }
                push();
            },
            cancel: function () {
            }
        });
    }
    function inputStream(objArray) {
        var jsons = objArray.map(function (obj) {
            return JSON.stringify(obj);
        });
        return readableStreamFromString(jsons.join('\n'));
    }
    QUnit.module('can-ndjson-stream');
    conditionalTest('Initialized the plugin', function () {
        QUnit.equal(typeof ndjsonStream, 'function');
    });
    conditionalAsyncTest('simple_test_from_stream', function (assert) {
        var testObject = [
            {
                'date': '2017-02-24 03:07:45',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '134'
            },
            {
                'date': '2017-02-22 04:40:13',
                'user': '21109850',
                'fuel': '37',
                'ammo': '2',
                'steel': '13',
                'baux': '5',
                'seaweed': '0',
                'type': 'LOOT',
                'product': '75'
            },
            {
                'date': '2017-02-21 20:47:51',
                'user': '26464462',
                'fuel': '37',
                'ammo': '3',
                'steel': '19',
                'baux': '5',
                'seaweed': '1',
                'type': 'LOOT',
                'product': '81'
            }
        ];
        var readObjects = [];
        var todoStream = ndjsonStream(inputStream(testObject));
        function test(todosStream) {
            var reader = todosStream.getReader();
            reader.read().then(function read(result) {
                if (result.done) {
                    assert.deepEqual(readObjects, testObject, 'Two arrays should be the same in value');
                    QUnit.start();
                    return;
                }
                readObjects.push(result.value);
                reader.read().then(read);
            });
        }
        test(todoStream);
    });
    conditionalAsyncTest('malformed json', function (assert) {
        var malformed_string = '{"1":2}\n{sss: 2}';
        var readObjects = [];
        var todoStream = ndjsonStream(readableStreamFromString(malformed_string));
        var reader = todoStream.getReader();
        var errorCaught = false;
        function errCheck() {
            errorCaught = true;
        }
        var allDone = reader.read().then(function read(result) {
            if (result.done) {
                return;
            }
            readObjects.push(result.value);
            return reader.read().then(read, errCheck);
        }, errCheck);
        allDone.then(function () {
            assert.strictEqual(errorCaught, true, 'malformed json string should cause an error');
            QUnit.start();
        }, function () {
            assert.strictEqual(errorCaught, true, 'rejected: malformed json string should cause an error');
            QUnit.start();
        });
    });
});
/*can-connect-ndjson@0.1.3#can-connect-ndjson*/
define('can-connect-ndjson@0.1.3#can-connect-ndjson', [
    'require',
    'exports',
    'module',
    'can-connect',
    'can-connect/helpers/sorted-set-json',
    'can-ndjson-stream',
    'can-reflect',
    'can-namespace'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var connect = require('can-connect');
        var sortedSetJSON = require('can-connect/helpers/sorted-set-json');
        var ndJSONStream = require('can-ndjson-stream');
        var canReflect = require('can-reflect');
        var namespace = require('can-namespace');
        var connectNdjson = connect.behavior('data-ndjson', function (baseConnection) {
            try {
                new ReadableStream();
                window.fetch();
            } catch (err) {
                return {};
            }
            return {
                hydrateList: function (listData, set) {
                    set = set || this.listSet(listData);
                    var id = sortedSetJSON(set);
                    var list = baseConnection.hydrateList.call(this, listData, set);
                    if (this._getHydrateListCallbacks[id]) {
                        this._getHydrateListCallbacks[id].shift()(list);
                        if (!this._getHydrateListCallbacks[id].length) {
                            delete this._getHydrateListCallbacks[id];
                        }
                    }
                    return list;
                },
                _getHydrateListCallbacks: {},
                _getHydrateList: function (set, callback) {
                    var id = sortedSetJSON(set);
                    if (!this._getHydrateListCallbacks[id]) {
                        this._getHydrateListCallbacks[id] = [];
                    }
                    this._getHydrateListCallbacks[id].push(callback);
                },
                getListData: function (set) {
                    var fetchPromise = fetch(this.ndjson || this.url);
                    this._getHydrateList(set, function (list) {
                        function streamerr(e) {
                            canReflect.setKeyValue(list, 'isStreaming', false);
                            canReflect.setKeyValue(list, 'streamError', e);
                        }
                        fetchPromise.then(function (response) {
                            canReflect.setKeyValue(list, 'isStreaming', true);
                            return ndJSONStream(response.body);
                        }).then(function (itemStream) {
                            var reader = itemStream.getReader();
                            reader.read().then(function read(result) {
                                if (result.done) {
                                    canReflect.setKeyValue(list, 'isStreaming', false);
                                    return;
                                }
                                list.push(result.value);
                                reader.read().then(read, streamerr);
                            }, streamerr);
                        });
                    });
                    return fetchPromise.then(function () {
                        return { data: [] };
                    });
                }
            };
        });
        module.exports = namespace.connectNdjson = connectNdjson;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-connect-ndjson@0.1.3#test/can-connect-ndjson-test*/
define('can-connect-ndjson@0.1.3#test/can-connect-ndjson-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    '../can-connect-ndjson',
    'can-connect',
    'can-define/list/list',
    'can-define/map/map',
    'can-connect/data/url/url',
    'can-connect/constructor/constructor',
    'can-connect/constructor/store/store',
    'can-connect/can/map/map',
    'can-connect-ndjson'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var plugin = require('../can-connect-ndjson');
    var ReadableStream = window.ReadableStream;
    var connect = require('can-connect');
    var DefineList = require('can-define/list/list');
    var DefineMap = require('can-define/map/map');
    var originalFetch = window.fetch;
    var isReadStreamSupported = true;
    try {
        new ReadableStream();
    } catch (err) {
        isReadStreamSupported = false;
    }
    var conditionalTest = isReadStreamSupported ? QUnit.test : QUnit.skip;
    var conditionalAsyncTest = isReadStreamSupported ? QUnit.asyncTest : QUnit.skip;
    QUnit.module('can-connect-ndjson');
    conditionalTest('Initialized the plugin', function (assert) {
        assert.equal(typeof plugin, 'function');
    });
    conditionalTest('Replace fetch with custom version', function (assert) {
        window.fetch = function (url) {
            if (url == 'test') {
                return 'success';
            }
            return Promise.resolve().then(function () {
                return {
                    body: new ReadableStream({
                        start: function (controller) {
                            window.fetch_push = function (data) {
                                var encoder = new TextEncoder();
                                controller.enqueue(encoder.encode(data));
                            };
                            window.fetch_halt = function (reason) {
                                controller.error(reason);
                            };
                            window.fetch_close = function () {
                                controller.close();
                            };
                        }
                    })
                };
            });
        };
        assert.ok(fetch('test') == 'success', 'Fetch replaced.');
    });
    conditionalAsyncTest('Reading a multiline NDJSON', function (assert) {
        var Todo = DefineMap.extend('Todo', {
            id: 'number',
            name: 'string'
        });
        Todo.List = DefineList.extend({ '#': Todo });
        Todo.connection = connect([
            require('can-connect/data/url/url'),
            require('can-connect/constructor/constructor'),
            require('can-connect/constructor/store/store'),
            require('can-connect/can/map/map'),
            require('can-connect-ndjson')
        ], {
            Map: Todo,
            List: Todo.List,
            url: 'foo/bar',
            ndjson: 'foo/bar'
        });
        Todo.getList({}).then(function (oblist) {
            assert.ok(oblist, 'Observable list created.');
            assert.ok(oblist.isStreaming, 'Status is streaming');
            var idata = [
                '{"a":1,"b":2}\n',
                '{"c":3,"d":4}\n\n{"e',
                '":[5]}'
            ];
            var answers = [
                {
                    a: 1,
                    b: 2
                },
                {
                    c: 3,
                    d: 4
                },
                { e: [5] }
            ];
            var timeout = 0;
            var onAdd = function (event, added) {
                clearTimeout(timeout);
                assert.equal(added.length, 1, 'Added exactly 1 object');
                assert.deepEqual(added[0].get(), answers.shift(), 'Gave correct answer');
                var next = idata.shift();
                if (next) {
                    assert.ok(oblist.isStreaming, 'Status is streaming');
                    fetch_push(next);
                    if (idata.length == 0) {
                        fetch_close();
                    }
                    timeout = setTimeout(function () {
                        assert.notOk(true, 'Processing exceeds 1s');
                    }, 1000);
                } else {
                    assert.notOk(oblist.streamError, 'No error should occur');
                    assert.ok(true, 'Reached end of testing');
                    setTimeout(function () {
                        assert.notOk(oblist.isStreaming, 'Status is not streaming');
                    }, 500);
                    QUnit.start();
                }
            };
            var onRemove = function () {
                assert.notOk(true, 'Items are being removed!');
            };
            oblist.on('add', onAdd);
            oblist.on('remove', onRemove);
            fetch_push(idata.shift());
            timeout = setTimeout(function () {
                assert.notOk(true, 'Processing exceeds 1s');
            }, 1000);
        });
    });
    window.fetch = originalFetch;
});
/*can-observe@1.0.1#can-observe*/
define('can-observe@1.0.1#can-observe', [
    'require',
    'exports',
    'module',
    'can-cid',
    'can-event/batch/batch',
    'can-observation',
    'can-symbol',
    'can-reflect',
    'can-namespace',
    'can-event'
], function (require, exports, module) {
    var cid = require('can-cid');
    var canBatch = require('can-event/batch/batch');
    var Observation = require('can-observation');
    var canSymbol = require('can-symbol');
    var canReflect = require('can-reflect');
    var namespace = require('can-namespace');
    var canEvent = require('can-event');
    var observableSymbol = canSymbol.for('can.meta');
    var hasOwn = Object.prototype.hasOwnProperty;
    function isIntegerIndex(prop) {
        return prop && +prop === +prop && +prop % 1 === 0;
    }
    var proxyOnly = Object.create(null);
    canReflect.assignSymbols(proxyOnly, {
        'can.onKeyValue': function (key, handler) {
            var handlers = this[observableSymbol].handlers;
            var keyHandlers = handlers[key];
            if (!keyHandlers) {
                keyHandlers = handlers[key] = [];
            }
            keyHandlers.push(handler);
        },
        'can.offKeyValue': function (key, handler) {
            var handlers = this[observableSymbol].handlers;
            var keyHandlers = handlers[key];
            if (keyHandlers) {
                var index = keyHandlers.indexOf(handler);
                if (index >= 0) {
                    keyHandlers.splice(index, 1);
                }
            }
        }
    });
    Object.assign(proxyOnly, canEvent);
    var arrayMethodInterceptors = Object.create(null);
    var mutateMethods = {
        'push': {
            add: function (arr, args, retVal) {
                return [
                    args,
                    arr.length - args.length
                ];
            }
        },
        'pop': {
            remove: function (arr, args, retVal) {
                return [
                    [retVal],
                    arr.length
                ];
            }
        },
        'shift': {
            remove: function (arr, args, retVal) {
                return [
                    [retVal],
                    0
                ];
            }
        },
        'unshift': {
            add: function (arr, args, retVal) {
                return [
                    args,
                    0
                ];
            }
        },
        'splice': {
            remove: function (arr, args, retVal) {
                return [
                    retVal,
                    args[0]
                ];
            },
            add: function (arr, args, retVal) {
                return [
                    args.slice(2),
                    args[0]
                ];
            }
        },
        'sort': {
            remove: function (arr, args, retVal, old) {
                return [
                    old,
                    0
                ];
            },
            add: function (arr, args, retVal) {
                return [
                    arr,
                    0
                ];
            }
        },
        'reverse': {
            remove: function (arr, args, retVal, old) {
                return [
                    old,
                    0
                ];
            },
            add: function (arr, args, retVal) {
                return [
                    arr,
                    0
                ];
            }
        }
    };
    var proxiableFunctions = [
        'map',
        'filter',
        'slice',
        'concat',
        'reduce',
        'reduceRight'
    ];
    Object.keys(mutateMethods).forEach(function (prop) {
        var changeEvents = mutateMethods[prop];
        var protoFn = Array.prototype[prop];
        arrayMethodInterceptors[prop] = function () {
            var handlers = this[observableSymbol].handlers;
            handlers.length = handlers.length || [];
            var old = [].slice.call(this, 0);
            var args = Array.from(arguments);
            var ret = protoFn.apply(this, arguments);
            canBatch.start();
            Object.keys(changeEvents).forEach(function (event) {
                var makeArgs = changeEvents[event];
                var handlerArgs = makeArgs(this, args, ret, old);
                canEvent.dispatch.call(this, event, handlerArgs);
            }.bind(this));
            handlers.length.forEach(function (handler) {
                canBatch.queue([
                    handler,
                    this,
                    [
                        this.length,
                        old.length
                    ]
                ]);
            }, this);
            canBatch.stop();
            return ret;
        };
    });
    function proxyIntercept(fn) {
        return function () {
            var ret = fn.apply(this, arguments);
            if (ret && typeof ret === 'object') {
                ret = observe(ret);
            }
            return ret;
        };
    }
    proxiableFunctions.forEach(function (prop) {
        arrayMethodInterceptors[prop] = proxyIntercept(Array.prototype[prop]);
    });
    var observe = function (obj) {
        if (obj[observableSymbol]) {
            return obj[observableSymbol].proxy;
        } else {
            Object.defineProperty(obj, '_cid', {
                value: cid({}),
                enumerable: false
            });
        }
        var isArray = obj instanceof Array;
        var p = new Proxy(obj, {
            get: function (target, key, receiver) {
                if (proxyOnly[key]) {
                    return proxyOnly[key];
                }
                var symbolLike = canReflect.isSymbolLike(key);
                var descriptor = Object.getOwnPropertyDescriptor(target, key);
                var value;
                if (descriptor && descriptor.get) {
                    value = descriptor.get.call(receiver);
                } else {
                    if (key === '__bindEvents') {
                        value = target[observableSymbol].__bindEvents;
                    } else {
                        value = target[key];
                    }
                }
                if (!symbolLike && key !== '__bindEvents' && !canReflect.isObservableLike(value) && (canReflect.isPlainObject(value) || Array.isArray(value))) {
                    value = target[key] = observe(value);
                }
                if (typeof value === 'function') {
                    if (isArray && arrayMethodInterceptors[key]) {
                        value = arrayMethodInterceptors[key];
                    } else {
                        value = obj[observableSymbol].interceptors[key] || (obj[observableSymbol].interceptors[key] = proxyIntercept(value));
                    }
                }
                if (key !== '_cid' && key !== '__bindEvents' && typeof value !== 'function' && !symbolLike && (hasOwn.call(target, key) || !Object.isSealed(target))) {
                    Observation.add(receiver, key.toString());
                }
                return value;
            },
            set: function (target, key, value, receiver) {
                var old, change;
                var descriptor = Object.getOwnPropertyDescriptor(target, key);
                if (!canReflect.isSymbolLike(key) && !canReflect.isObservableLike(value) && (canReflect.isPlainObject(value) || Array.isArray(value))) {
                    value = observe(value);
                } else if (value && value[observableSymbol]) {
                    value = value[observableSymbol].proxy;
                }
                if (descriptor && descriptor.set) {
                    descriptor.set.call(receiver, value);
                } else {
                    old = target[key];
                    change = old !== value;
                    if (change) {
                        target[key] = value;
                    }
                }
                if (typeof old === 'function') {
                    target[observableSymbol].interceptors[key] = null;
                }
                if (change) {
                    canBatch.start();
                    (target[observableSymbol].handlers[key] || []).forEach(function (handler) {
                        canBatch.queue([
                            handler,
                            receiver,
                            [
                                value,
                                old
                            ]
                        ]);
                    });
                    canBatch.stop();
                }
                return true;
            },
            ownKeys: function (target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target)).concat(Object.getOwnPropertySymbols(proxyOnly));
            },
            deleteProperty: function (target, key) {
                var old = target[key];
                var ret = delete target[key];
                var receiver = target[observableSymbol].proxy;
                if (ret && (!Array.isArray(target) || !isIntegerIndex(key))) {
                    canBatch.start();
                    (target[observableSymbol].handlers[key] || []).forEach(function (handler, i) {
                        if (old !== undefined) {
                            canBatch.queue([
                                handler,
                                receiver,
                                [
                                    undefined,
                                    old
                                ]
                            ]);
                        }
                    });
                    canBatch.stop();
                }
                target[observableSymbol].interceptors[key] = null;
                return ret;
            }
        });
        p[observableSymbol] = {
            handlers: {},
            __bindEvents: {},
            proxy: p,
            interceptors: {}
        };
        return p;
    };
    namespace.observe = observe;
    module.exports = observe;
});
/*can-observe@1.0.1#test*/
define('can-observe@1.0.1#test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-compute',
    'can-observe',
    'can-stache',
    'can-event/batch/batch',
    'can-reflect',
    'can-symbol',
    'can-observation'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var assert = QUnit.assert;
    var compute = require('can-compute');
    var observe = require('can-observe');
    var stache = require('can-stache');
    var canBatch = require('can-event/batch/batch');
    var canReflect = require('can-reflect');
    var canSymbol = require('can-symbol');
    var Observation = require('can-observation');
    var observableSymbol = canSymbol.for('can.meta');
    QUnit.module('basics');
    QUnit.test('basics with object', function () {
        var person = observe({});
        person.first = 'Justin';
        person.last = 'Meyer';
        canReflect.onKeyValue(person, 'first', function (newVal) {
            QUnit.equal(newVal, 'Vyacheslav');
        });
        person.first = 'Vyacheslav';
    });
    QUnit.test('basics with object and compute', function () {
        var person = observe({});
        person.first = 'Justin';
        person.last = 'Meyer';
        var fullName = compute(function () {
            return person.first + ' ' + person.last;
        });
        QUnit.stop();
        canReflect.onValue(fullName, function (newVal) {
            QUnit.start();
            QUnit.equal(newVal, 'Vyacheslav Egorov');
        });
        canBatch.start();
        person.first = 'Vyacheslav';
        person.last = 'Egorov';
        canBatch.stop();
    });
    QUnit.test('basics with array', function () {
        var hobbies = observe([
            'basketball',
            'programming'
        ]);
        var hobbiesList = compute(function () {
            return hobbies.join(',');
        });
        canReflect.onValue(hobbiesList, function (newVal) {
            QUnit.equal(newVal, 'basketball');
        });
        hobbies.pop();
    });
    QUnit.test('compose to stache', function () {
        var person = observe({
            first: 'Marshall',
            last: 'Thompson'
        });
        var hobbies = observe([
            'music',
            'programming'
        ]);
        var fullName = function () {
            return person.first + ' ' + person.last;
        };
        var hobbiesList = function () {
            return hobbies.join(',');
        };
        var info = function () {
            return fullName() + ' likes: ' + hobbiesList();
        };
        var frag = stache('<span>{{info}}</span>')({ info: info });
        QUnit.equal(frag.firstChild.innerHTML, 'Marshall Thompson likes: music,programming');
        hobbies.pop();
        person.first = 'Justin';
        person.last = 'Meyer';
        QUnit.equal(frag.firstChild.innerHTML, 'Justin Meyer likes: music');
    });
    QUnit.test('events aren\'t fired if the value doesn\'t change', function () {
        var dog = observe({ name: 'Wilbur' });
        var events = 0;
        canReflect.onKeyValue(dog, 'name', function () {
            events++;
        });
        dog.name = 'Fido';
        QUnit.equal(events, 1, 'there has been one event');
        dog.name = 'Fido';
        QUnit.equal(events, 1, 'still just one');
        dog.name = 'Wilbur';
        QUnit.equal(events, 2, 'now there is two');
    });
    QUnit.test('Should not duplicate proxies #21', function () {
        var a = { who: 'a' }, b = { who: 'b' }, c = { who: 'c' }, d = { who: 'd' };
        var aproxy = observe(a);
        var cproxy = observe(c);
        aproxy.b = b;
        cproxy.b = b;
        var dproxy = observe(d);
        var dproxy2 = observe(d);
        QUnit.equal(dproxy, dproxy2, 'proxied objects should not be duplicated');
        QUnit.equal(aproxy.b, cproxy.b, 'nested proxied objects should not be duplicated');
    });
    QUnit.test('Should not duplicate proxies in a cycle #21', function () {
        var a = { who: 'a' }, b = { who: 'b' }, c = { who: 'c' };
        a.b = b;
        b.c = c;
        c.a = a;
        observe(a);
        QUnit.equal(c.a, a, 'proxied objects should not be duplicated');
    });
    QUnit.test('Should convert nested objects to observables in a lazy way (get case) #21', function () {
        var nested = {};
        var obj = { nested: nested };
        var obs = observe(obj);
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted before read');
        QUnit.equal(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol), -1, 'nested is not observed');
        QUnit.equal(canReflect.isObservableLike(obs.nested), true, 'nested is converted to a proxy and the proxy returned');
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted after read');
        QUnit.ok(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol) > -1, 'nested is now observed');
    });
    QUnit.test('Should convert nested arrays to observables in a lazy way (get case) #21', function () {
        var nested = [];
        var obj = { nested: nested };
        var obs = observe(obj);
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted before read');
        QUnit.equal(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol), -1, 'nested is not observed');
        QUnit.equal(canReflect.isObservableLike(obs.nested), true, 'nested is converted to a proxy and the proxy returned');
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted after read');
        QUnit.ok(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol) > -1, 'nested is now observed');
    });
    QUnit.test('Should convert nested objects to observables (set case) #21', function () {
        var nested = {};
        var obj = {};
        var obs = observe(obj);
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted before set');
        QUnit.equal(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol), -1, 'nested is not observed');
        obj.nested = nested;
        QUnit.equal(canReflect.isObservableLike(obs.nested), true, 'nested is converted to a proxy and the proxy returned');
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted after set');
        QUnit.ok(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol) > -1, 'nested is now observed');
    });
    QUnit.test('Should convert nested arrays to observables (set case) #21', function () {
        var nested = [];
        var obj = {};
        var obs = observe(obj);
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted before set');
        QUnit.equal(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol), -1, 'nested is not observed');
        obj.nested = nested;
        QUnit.equal(canReflect.isObservableLike(obs.nested), true, 'nested is converted to a proxy and the proxy returned');
        QUnit.ok(!canReflect.isObservableLike(nested), 'nested is not converted after set');
        QUnit.ok(Object.getOwnPropertySymbols(nested).indexOf(observableSymbol) > -1, 'nested is now observed');
    });
    QUnit.test('Should convert properties if bound #21', function () {
        var nested = { nested: 'obj' };
        var obj = { top: 'obj' };
        var obs = observe(obj);
        canReflect.onKeyValue(obs, 'nested', function (newVal) {
            QUnit.ok(Object.getOwnPropertySymbols(newVal).indexOf(observableSymbol) > -1, 'nested is now observed');
        });
        obs.nested = nested;
    });
    QUnit.test('Nested objects should be observables #21', function () {
        expect(1);
        var obj = {
            nested: {},
            primitive: 2
        };
        var obs = observe(obj);
        obs.nested.prop = 1;
        canReflect.onKeyValue(obs.nested, 'prop', function (newVal) {
            assert.ok(newVal === 'abc', 'change is triggered on a nested property');
        });
        var x = obs.nested;
        x.prop = 'abc';
    });
    QUnit.test('not yet defined properties can be observed on read', function () {
        var a = observe({});
        var o = new Observation(function () {
            QUnit.ok(!('foo' in a), 'property is not on the object');
            return a.foo;
        });
        o.start();
        QUnit.equal(canReflect.getValue(o), undefined, 'initial value is undefined');
        QUnit.equal(o.newObserved[a._cid + '|foo'].obj, a, 'observation listened on property');
        o.stop();
    });
    QUnit.test('not yet defined properties cannot be observed on sealed object', function () {
        var b = {};
        var a = observe(b);
        var o = new Observation(function () {
            QUnit.ok(!('foo' in a), 'property is not on the object');
            return a.foo;
        });
        Object.seal(b);
        o.start();
        QUnit.equal(canReflect.getValue(o), undefined, 'initial value is undefined');
        QUnit.deepEqual(o.newObserved, {}, 'observation is empty');
        o.stop();
    });
    QUnit.test('_cid cannot be observed', function () {
        var a = observe({});
        var o = new Observation(function () {
            QUnit.ok('_cid' in a, 'property is on the object');
            return a._cid;
        });
        o.start();
        QUnit.equal(canReflect.getValue(o), a._cid, 'initial value is cid');
        QUnit.deepEqual(o.newObserved, {}, 'observation is empty');
        o.stop();
    });
    QUnit.test('Should remove event handlers #21', function () {
        var result = '';
        var obj = { nested: { prop: '' } };
        var obs = observe(obj);
        var handler1 = function (newVal) {
            result += '1';
        };
        var handler2 = function (newVal) {
            result += '2';
        };
        var handler3 = function (newVal) {
            result += '3';
        };
        var handler4 = function (newVal) {
            result += '4';
        };
        canReflect.onKeyValue(obs.nested, 'prop', handler1);
        canReflect.onKeyValue(obs.nested, 'prop', handler2);
        canReflect.onKeyValue(obs.nested, 'prop', handler3);
        var x = obs.nested;
        x.prop = 'abc';
        canReflect.offKeyValue(obs.nested, 'prop', handler2);
        x.prop = 'xyz';
        canReflect.onKeyValue(obs.nested, 'prop', handler4);
        canReflect.offKeyValue(obs.nested, 'prop', handler1);
        x.prop = 'cba';
        QUnit.equal(result, '1231334', 'Should be able to add and remove handlers');
    });
    QUnit.test('Other can.* symbols should not appear on object', function () {
        var a = {};
        var o = observe(a);
        var objectSymbols = Object.getOwnPropertySymbols(a);
        QUnit.ok(objectSymbols.indexOf(observableSymbol) > -1, 'Observable symbol in object');
        QUnit.deepEqual(objectSymbols.filter(function (sym) {
            return sym !== observableSymbol && canSymbol.keyFor(sym).indexOf('can.') === 0;
        }), [], 'No other can.* symbols on object');
        var observeSymbols = Object.getOwnPropertySymbols(o);
        QUnit.ok(observeSymbols.indexOf(observableSymbol) > -1, 'Observable symbol in observe');
        QUnit.ok(observeSymbols.filter(function (sym) {
            return sym !== observableSymbol && canSymbol.keyFor(sym).indexOf('can.') === 0;
        }).length > 0, 'Some other can.* symbols on observe');
    });
    QUnit.skip('getters can be bound within observes', function () {
        expect(5);
        var count = 0;
        var o = observe({
            get b() {
                QUnit.ok(count <= 4, 'hit the getter ' + ++count + ' of 4');
                return this.c;
            },
            c: 'd'
        });
        var fn;
        canReflect.onKeyValue(o, 'b', fn = function () {
            QUnit.ok(true, 'Hit the updater');
        });
        var d = o.b;
        o.c = 'e';
        canReflect.offKeyValue(o, 'b', fn);
        d = o.b;
        o.c = 'f';
    });
    QUnit.skip('getters can be bound across observes', function () {
        expect(5);
        var count = 0;
        var b = observe({ c: 'd' });
        var o = observe({
            get b() {
                QUnit.ok(count <= 4, 'hit the getter ' + ++count + ' of 4');
                return b.c;
            }
        });
        var fn;
        canReflect.onKeyValue(o, 'b', fn = function () {
            QUnit.ok(true, 'Hit the updater');
        });
        var d = o.b;
        b.c = 'e';
        canReflect.offKeyValue(o, 'b', fn);
        d = o.b;
        b.c = 'f';
    });
    QUnit.skip('getter/setters within observes', function () {
        expect(7);
        var getCount = 0, setCount = 0;
        var o = observe({
            get b() {
                QUnit.ok(getCount <= 4, 'hit the getter ' + ++getCount + ' of 4');
                return this.c;
            },
            set b(val) {
                QUnit.ok(setCount <= 2, 'Setter was called ' + ++setCount + ' of 2');
                this.c = val;
            },
            c: 'd'
        });
        var fn;
        canReflect.onKeyValue(o, 'b', fn = function () {
            QUnit.ok(true, 'Hit the updater');
        });
        var d = o.b;
        o.b = 'e';
        canReflect.offKeyValue(o, 'b', fn);
        d = o.b;
        o.b = 'f';
    });
    QUnit.test('deleting a property', function () {
        expect(3);
        var o = observe({
            get b() {
                QUnit.ok(true, 'hit the getter');
                return this.c;
            },
            set b(val) {
                QUnit.ok(false, 'Setter was called');
                this.c = val;
            },
            c: 'd'
        });
        canReflect.onKeyValue(o, 'b', function (newVal) {
            QUnit.equal(newVal, undefined, 'Hit the updater for getter/setter');
        });
        canReflect.onKeyValue(o, 'c', function (newVal) {
            QUnit.equal(newVal, undefined, 'Hit the updater for value');
        });
        delete o.b;
        delete o.c;
    });
    QUnit.test('add events with addEventListener', function () {
        var o = observe({});
        o.addEventListener('foo', function (ev, newVal) {
            QUnit.ok(true, 'event handler fired');
            QUnit.equal(newVal, 1, 'correct positions');
        });
        o.dispatch('foo', [1]);
        o.foo = 2;
    });
    QUnit.test('remove events with removeEventListener', function () {
        var o = observe({});
        var fn;
        o.addEventListener('foo', fn = function (ev, newVal) {
            QUnit.ok(false, 'event handler fired');
        });
        o.removeEventListener('foo', fn);
        o.dispatch('foo', [1]);
        QUnit.ok(true, 'finished');
    });
    QUnit.test('array events are automatically triggered (push/pop)', function () {
        expect(4);
        var list = observe([
            1,
            2
        ]);
        var newThing = 3;
        function addHandler(ev, items, index) {
            QUnit.deepEqual(items, [newThing], 'new thing added');
            QUnit.equal(index, list.length - 1, 'new thing added at end');
        }
        function removeHandler(ev, items, index) {
            QUnit.deepEqual(items, [newThing], 'new thing removed');
            QUnit.equal(index, list.length, 'new thing removed from end');
        }
        list.addEventListener('add', addHandler);
        list.addEventListener('remove', removeHandler);
        list.push(newThing);
        list.pop();
    });
    QUnit.test('array events are automatically triggered (shift/unshift)', function () {
        expect(4);
        var list = observe([
            1,
            2
        ]);
        var newThing = 3;
        function addHandler(ev, items, index) {
            QUnit.deepEqual(items, [newThing], 'new thing added');
            QUnit.equal(index, 0, 'new thing added at beginning');
        }
        function removeHandler(ev, items, index) {
            QUnit.deepEqual(items, [newThing], 'new thing removed');
            QUnit.equal(index, 0, 'new thing removed from beginning');
        }
        list.addEventListener('add', addHandler);
        list.addEventListener('remove', removeHandler);
        list.unshift(newThing);
        list.shift();
    });
    QUnit.test('array events are automatically triggered (splice)', function () {
        expect(4);
        var list = observe([
            1,
            2,
            3
        ]);
        var newThing = 4;
        var oldThing = list[1];
        function addHandler(ev, items, index) {
            QUnit.deepEqual(items, [newThing], 'new thing added');
            QUnit.equal(index, 1, 'new thing added at index 1');
        }
        function removeHandler(ev, items, index) {
            QUnit.deepEqual(items, [oldThing], 'new thing removed');
            QUnit.equal(index, 1, 'old thing removed from index 1');
        }
        list.addEventListener('add', addHandler);
        list.addEventListener('remove', removeHandler);
        list.splice(1, 1, newThing);
    });
    QUnit.test('array events are automatically triggered (sort)', function () {
        expect(4);
        var list = observe([
            'a',
            'c',
            'b'
        ]);
        var oldList = list.slice(0);
        function addHandler(ev, items, index) {
            QUnit.deepEqual(items, list, 'new list added');
            QUnit.equal(index, 0, 'new list added at index 0');
        }
        function removeHandler(ev, items, index) {
            QUnit.deepEqual(items, oldList, 'all old things removed');
            QUnit.equal(index, 0, 'all old things removed from the beginning');
        }
        list.addEventListener('add', addHandler);
        list.addEventListener('remove', removeHandler);
        list.sort();
    });
    QUnit.test('array events are automatically triggered (reverse)', function () {
        expect(4);
        var list = observe([
            'a',
            'b',
            'c'
        ]);
        var oldList = list.slice(0);
        function addHandler(ev, items, index) {
            QUnit.deepEqual(items, list, 'new list added');
            QUnit.equal(index, 0, 'new list added at index 0');
        }
        function removeHandler(ev, items, index) {
            QUnit.deepEqual(items, oldList, 'all old things removed');
            QUnit.equal(index, 0, 'all old things removed from the beginning');
        }
        list.addEventListener('add', addHandler);
        list.addEventListener('remove', removeHandler);
        list.reverse();
    });
    QUnit.test('non-mutating array -> array functions return proxied arrays', function () {
        var list = observe([
            0,
            2,
            3
        ]);
        QUnit.ok(list.map(function (x) {
            return x + 1;
        })[observableSymbol], 'Map returns proxy');
        QUnit.ok(list.filter(function (x) {
            return x;
        })[observableSymbol], 'Filter returns proxy');
        QUnit.ok(list.slice(0)[observableSymbol], 'Slice returns proxy');
        QUnit.ok(list.concat([
            5,
            6
        ])[observableSymbol], 'Concat returns proxy');
    });
    QUnit.test('non-mutating reduce functions return proxied objects', function () {
        var list = observe([
            0,
            2,
            3
        ]);
        QUnit.ok(list.reduce(function (a, b) {
            a[b] = true;
            return a;
        }, {})[observableSymbol], 'Reduce returns proxy');
        QUnit.ok(list.reduceRight(function (a, b) {
            a[b] = true;
            return a;
        }, {})[observableSymbol], 'ReduceRight returns proxy');
    });
    QUnit.test('custom, non-array functions return proxied objects as well', function () {
        var p = observe({
            foo: function () {
                return {};
            }
        });
        QUnit.ok(p.foo()[observableSymbol], 'Proxied function returns proxy');
    });
    QUnit.test('custom, non-array functions can be redefined', function () {
        expect(1);
        var p = observe({
            foo: function () {
                QUnit.ok(true, 'first function called');
            }
        });
        p.foo();
        p.foo = function () {
        };
        p.foo();
    });
});
/*can-define-stream@0.2.2#can-define-stream*/
define('can-define-stream@0.2.2#can-define-stream', [
    'require',
    'exports',
    'module',
    'can-define',
    'can-util/js/assign/assign',
    'can-util/js/each/each'
], function (require, exports, module) {
    var define = require('can-define');
    var assign = require('can-util/js/assign/assign');
    var each = require('can-util/js/each/each');
    module.exports = function (canStream) {
        return function (DefineMapType) {
            [
                'toStream',
                'toStreamFromProperty',
                'toStreamFromEvent'
            ].forEach(function (name) {
                DefineMapType.prototype[name] = function () {
                    return canStream[name].apply(canStream, [this].concat([].slice.call(arguments)));
                };
            });
            DefineMapType.prototype.stream = DefineMapType.prototype.toStream;
            var definitions = DefineMapType.prototype._define.definitions, dataInitializers = DefineMapType.prototype._define.dataInitializers, computedInitializers = DefineMapType.prototype._define.computedInitializers;
            each(definitions, function (definition, property) {
                var streamDefinition = definition.stream;
                if (streamDefinition) {
                    var newDefinition = assign({
                        value: function () {
                            return canStream.toCompute(streamDefinition, this);
                        }
                    }, define.types.compute);
                    define.property(DefineMapType.prototype, property, newDefinition, dataInitializers, computedInitializers);
                }
            });
        };
    };
});
/*can-define-stream@0.2.2#can-define-stream_test*/
define('can-define-stream@0.2.2#can-define-stream_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define/list/list',
    'can-define-stream',
    'can-compute',
    'can-stream'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var defineStream = require('can-define-stream');
    var compute = require('can-compute');
    var canStream = require('can-stream');
    QUnit.module('can-define-stream');
    var id = 0;
    var canStreamInterface = {
        toStream: function (c) {
            return {
                id: ++id,
                onValue: function (callback) {
                    callback['_computeHandler' + this.id] = function (ev, newVal) {
                        callback(newVal);
                    };
                    c.on('change', callback['_computeHandler' + this.id]);
                    callback(c());
                },
                offValue: function (callback) {
                    c.off('change', callback['_computeHandler' + this.id]);
                }
            };
        },
        toCompute: function (makeStream, context) {
            var lastValue, streamHandler;
            var setCallbacks = [];
            var setterStream = {
                onValue: function (callback) {
                    setCallbacks.push(callback);
                },
                offValue: function (callback) {
                    var index = setCallbacks.indexOf(callback);
                    setCallbacks.splice(index, 1);
                }
            };
            var valueStream = makeStream.call(context, setterStream);
            return compute(undefined, {
                get: function () {
                    return lastValue;
                },
                set: function (val) {
                    setCallbacks.forEach(function (cb) {
                        cb(val);
                    });
                    return val;
                },
                on: function (updated) {
                    streamHandler = function (newVal, oldVal) {
                        lastValue = newVal;
                        updated(lastValue);
                    };
                    valueStream.onValue(streamHandler);
                },
                off: function () {
                    valueStream.offValue(streamHandler);
                }
            });
        }
    };
    var canStreaming = canStream(canStreamInterface);
    test('Stream behavior on multiple properties with merge', 8, function () {
        var expectedNewVal, expectedOldVal, caseName;
        var MyMap = DefineMap.extend('MyMap', {
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (setStream) {
                    var mergedCompute = compute();
                    var mergeValue = function (val) {
                        mergedCompute(val);
                    };
                    this.stream('.foo').onValue(mergeValue);
                    this.stream('.bar').onValue(mergeValue);
                    setStream.onValue(mergeValue);
                    return canStreaming.toStream(mergedCompute);
                }
            }
        });
        defineStream(canStreaming)(MyMap);
        var map = new MyMap();
        map.foo = 'foo-1';
        QUnit.equal(map.baz, undefined, 'read value before binding');
        map.on('baz', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expectedNewVal, caseName + ' newVal');
            QUnit.equal(oldVal, expectedOldVal, caseName + ' oldVal');
        });
        QUnit.equal(map.baz, 'bar', 'read value immediately after binding');
        caseName = 'setting foo';
        expectedOldVal = 'bar';
        expectedNewVal = 'foo-2';
        map.foo = 'foo-2';
        caseName = 'setting bar';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new bar';
        map.bar = 'new bar';
        caseName = 'setting baz setter';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new baz';
        map.baz = 'new baz';
    });
    test('Test if streams are memory safe', function () {
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (setStream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    var lastValue;
                    var UPDATER;
                    var setLastValue = function (value) {
                        lastValue = value;
                        UPDATER(value);
                    };
                    var mergedCompute = compute(undefined, {
                        on: function (updater) {
                            UPDATER = updater;
                            fooStream.onValue(setLastValue);
                            barStream.onValue(setLastValue);
                            setStream.onValue(setLastValue);
                        },
                        off: function () {
                            fooStream.offValue(setLastValue);
                            barStream.offValue(setLastValue);
                            setStream.offValue(setLastValue);
                        },
                        get: function () {
                            return lastValue;
                        }
                    });
                    return canStreaming.toStream(mergedCompute);
                }
            }
        });
        defineStream(canStreaming)(MyMap);
        var map = new MyMap();
        QUnit.equal(map.__bindEvents._lifecycleBindings, undefined, 'Should have no bindings');
        var handler = function (ev, newVal, oldVal) {
        };
        map.on('baz', handler);
        QUnit.equal(map.__bindEvents._lifecycleBindings, 3, 'Should have 3 bindings');
        map.off('baz', handler);
        QUnit.equal(map.__bindEvents._lifecycleBindings, 0, 'Should reset the bindings');
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var PeopleList = DefineList.extend({});
        var canStreamInterface = {
            toStream: function (c) {
                return {
                    onValue: function (callback) {
                        c.on('change', function () {
                            callback.apply(null, arguments);
                        });
                    }
                };
            },
            toCompute: function (makeStream, context) {
            }
        };
        var canStreaming = canStream(canStreamInterface);
        defineStream(canStreaming)(PeopleList);
        var people = new PeopleList([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = people.stream('.length');
        expectedLength = 2;
        stream.onValue(function (ev, val) {
            QUnit.equal(val, expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
});
/*can-define-stream-kefir@0.1.3#can-define-stream-kefir*/
define('can-define-stream-kefir@0.1.3#can-define-stream-kefir', [
    'require',
    'exports',
    'module',
    'can-util/namespace',
    'can-define-stream',
    'can-stream-kefir'
], function (require, exports, module) {
    var namespace = require('can-util/namespace');
    var canDefineStream = require('can-define-stream');
    var canStreamKefir = require('can-stream-kefir');
    module.exports = namespace.defineStreamKefir = canDefineStream(canStreamKefir);
});
/*can-define-stream-kefir@0.1.3#can-define-stream-kefir_test*/
define('can-define-stream-kefir@0.1.3#can-define-stream-kefir_test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-define/map/map',
    'can-define/list/list',
    'can-define-stream-kefir'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var DefineMap = require('can-define/map/map');
    var DefineList = require('can-define/list/list');
    var canDefineStreamKefir = require('can-define-stream-kefir');
    QUnit.module('can-define-stream-kefir');
    test('Stream behavior on multiple properties with merge', 8, function () {
        var expectedNewVal, expectedOldVal, caseName;
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (stream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    return stream.merge(fooStream).merge(barStream);
                }
            }
        });
        canDefineStreamKefir(MyMap);
        var map = new MyMap();
        map.foo = 'foo-1';
        QUnit.equal(map.baz, undefined, 'read value before binding');
        map.on('baz', function (ev, newVal, oldVal) {
            QUnit.equal(newVal, expectedNewVal, caseName + ' newVal');
            QUnit.equal(oldVal, expectedOldVal, caseName + ' oldVal');
        });
        QUnit.equal(map.baz, 'bar', 'read value immediately after binding');
        caseName = 'setting foo';
        expectedOldVal = 'bar';
        expectedNewVal = 'foo-2';
        map.foo = 'foo-2';
        caseName = 'setting bar';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new bar';
        map.bar = 'new bar';
        caseName = 'setting baz setter';
        expectedOldVal = expectedNewVal;
        expectedNewVal = 'new baz';
        map.baz = 'new baz';
    });
    test('Test if streams are memory safe', function () {
        var MyMap = DefineMap.extend({
            foo: 'string',
            bar: {
                type: 'string',
                value: 'bar'
            },
            baz: {
                type: 'string',
                stream: function (stream) {
                    var fooStream = this.stream('.foo');
                    var barStream = this.stream('.bar');
                    return stream.merge(fooStream).merge(barStream);
                }
            }
        });
        canDefineStreamKefir(MyMap);
        var map = new MyMap();
        QUnit.equal(map.__bindEvents._lifecycleBindings, undefined, 'Should have no bindings');
        var handler = function (ev, newVal, oldVal) {
        };
        map.on('baz', handler);
        map.foo = 'obaid';
        QUnit.equal(map.__bindEvents._lifecycleBindings, 3, 'Should have 3 bindings');
        map.off('baz', handler);
        QUnit.equal(map.__bindEvents._lifecycleBindings, 0, 'Should reset the bindings');
    });
    test('Keep track of change counts on stream', function () {
        var count;
        var Person = DefineMap.extend({
            first: 'string',
            last: 'string',
            fullName: {
                get: function () {
                    return this.first + ' ' + this.last;
                }
            },
            fullNameChangeCount: {
                stream: function (setStream) {
                    return this.stream('.fullName').scan(function (last) {
                        return last + 1;
                    }, 0);
                }
            }
        });
        canDefineStreamKefir(Person);
        var me = new Person({
            first: 'Justin',
            last: 'Meyer'
        });
        me.on('fullNameChangeCount', function (ev, newVal) {
            QUnit.equal(newVal, count, 'Count should be ' + count);
        });
        count = 2;
        me.first = 'Obaid';
        count = 3;
        me.last = 'Ahmed';
    });
    test('Update map property based on stream value', function () {
        var expected;
        var Person = DefineMap.extend({
            name: 'string',
            lastValidName: {
                stream: function () {
                    return this.stream('.name').filter(function (name) {
                        return name.indexOf(' ') >= 0;
                    });
                }
            }
        });
        canDefineStreamKefir(Person);
        var me = new Person({ name: 'James' });
        me.on('lastValidName', function (lastValid) {
            QUnit.equal(lastValid.target.name, expected, 'Updated name to ' + expected);
        });
        me.name = 'JamesAtherton';
        expected = 'James Atherton';
        me.name = 'James Atherton';
        me.name = 'JustinMeyer';
        expected = 'Justin Meyer';
        me.name = 'Justin Meyer';
    });
    test('Stream on DefineList', function () {
        var expectedLength;
        var People = DefineList.extend({});
        canDefineStreamKefir(People);
        var people = new People([
            {
                first: 'Justin',
                last: 'Meyer'
            },
            {
                first: 'Paula',
                last: 'Strozak'
            }
        ]);
        var stream = people.stream('length');
        stream.onValue(function (event) {
            QUnit.equal(event.args[0], expectedLength, 'List size changed');
        });
        expectedLength = 3;
        people.push({
            first: 'Obaid',
            last: 'Ahmed'
        });
        expectedLength = 2;
        people.pop();
    });
    test('Can instantiate define-map instances with properties that have stream definitions.', function () {
        var Locator = DefineMap.extend({
            state: 'string',
            city: {
                stream: function (setStream) {
                    return this.stream('.state').map(function () {
                        return null;
                    }).merge(setStream);
                }
            }
        });
        canDefineStreamKefir(Locator);
        var locator = new Locator({
            state: 'IL',
            city: 'Chitown'
        });
        QUnit.equal(locator.state, 'IL', 'State in tact, no errors');
        QUnit.equal(typeof locator.city, 'undefined', 'Derived value ignored until bound.');
        locator.on('city', function () {
        });
        QUnit.equal(locator.city, 'Chitown', 'can still get initial value');
        locator.state = 'FL';
        QUnit.equal(locator.city, null, 'Derived value set.');
    });
});
/*can-zone-storage@1.0.1#can-zone-storage*/
define('can-zone-storage@1.0.1#can-zone-storage', function (require, exports, module) {
    module.exports = {
        data: {},
        getStore: function () {
            var CanZone = window.CanZone || undefined;
            return typeof CanZone === 'undefined' ? this.data : CanZone.current.data;
        },
        setItem: function (prop, value) {
            var store = this.getStore();
            store[prop] = value;
        },
        getItem: function (prop) {
            var store = this.getStore();
            return store[prop];
        },
        removeItem: function (prop) {
            var store = this.getStore();
            delete store[prop];
        }
    };
});
/*can-zone@0.6.22#lib/env*/
define('can-zone@0.6.22#lib/env', function (require, exports, module) {
    (function (global, require, exports, module) {
        var isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
        var nodeRequire = typeof System !== 'undefined' && System._nodeRequire ? System._nodeRequire : typeof require === 'function' ? require : function () {
        };
        var isNW = isNode && function () {
            try {
                var requireAlias = 'require';
                if (typeof System !== 'undefined' && System._nodeRequire) {
                    return System._nodeRequire('nw.gui') !== 'undefined';
                } else if (typeof global === 'object' && global[requireAlias]) {
                    return global[requireAlias]('nw.gui') !== 'undefined';
                } else {
                    return false;
                }
            } catch (e) {
                return false;
            }
        }();
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
        var g = isWorker ? self : isNW ? window : isNode ? global : window;
        exports.isNode = isNode;
        exports.isNW = isNW;
        exports.isWorker = isWorker;
        exports.global = g;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-zone@0.6.22#lib/util*/
define('can-zone@0.6.22#lib/util', function (require, exports, module) {
    exports.forEach = Array.prototype.forEach || function (fn) {
        for (var i = 0, len = this.length; i < len; i++) {
            fn.call(this, this[i], i);
        }
    };
    var supportsSymbol = typeof Symbol === 'function';
    exports.symbol = function (str) {
        return supportsSymbol ? Symbol(str) : str;
    };
    exports.defineProperty = function (obj, prop, defn) {
        if (Object.defineProperty) {
            Object.defineProperty(obj, prop, defn);
        } else {
            obj[prop] = defn.value;
        }
    };
});
/*can-zone@0.6.22#lib/zones/globals*/
define('can-zone@0.6.22#lib/zones/globals', [
    'require',
    'exports',
    'module',
    '../util',
    '../env',
    '../zone'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var util = require('../util');
        var env = require('../env');
        var g = env.global;
        var Zone = require('../zone');
        if (env.isNode) {
            var globalTimeoutId = 1;
        }
        module.exports = function () {
            var globals, overrides = [];
            return {
                name: 'globals',
                plugins: [promiseZone],
                created: function () {
                    var zone = this;
                    globals = this.globals || {};
                    function findObj(name, obj) {
                        var parts = name.split('.');
                        var property = parts.pop();
                        util.forEach.call(parts, function (prop) {
                            var n = obj[prop];
                            if (!n) {
                                n = obj[prop] = {};
                            }
                            obj = n;
                        });
                        return {
                            obj: obj,
                            prop: property
                        };
                    }
                    function addGlobal(name, value) {
                        var info = findObj(name, g);
                        overrides.push(new Override(info.obj, info.prop, function () {
                            return value;
                        }));
                    }
                    for (var name in globals) {
                        addGlobal(name, globals[name]);
                    }
                },
                beforeTask: function (task) {
                    if (task.nestedTask)
                        return;
                    util.forEach.call(overrides, function (o) {
                        o.trap();
                    });
                },
                afterTask: function (task) {
                    if (task.nestedTask)
                        return;
                    util.forEach.call(overrides, function (o) {
                        o.release();
                    });
                }
            };
        };
        function Override(obj, name, fn) {
            this.oldValue = obj[name];
            this.obj = obj;
            this.name = name;
            this.value = fn(this.oldValue, this);
        }
        Override.prototype.trap = function () {
            this.obj[this.name] = this.value;
        };
        Override.prototype.release = function () {
            this.obj[this.name] = this.oldValue;
        };
        function promiseZone() {
            var promiseThen = function () {
                    if (!Zone.current || oldPromiseThen.zoneWrapped) {
                        return oldPromiseThen.apply(this, arguments);
                    }
                    return Zone.tasks.then(oldPromiseThen).apply(this, arguments);
                }, oldPromiseThen;
            return {
                beforeTask: function (task) {
                    if (task.nestedTask)
                        return;
                    oldPromiseThen = Promise.prototype.then;
                    Promise.prototype.then = promiseThen;
                },
                afterTask: function (task) {
                    if (task.nestedTask)
                        return;
                    Promise.prototype.then = oldPromiseThen;
                }
            };
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-zone@0.6.22#register*/
define('can-zone@0.6.22#register', function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        (function () {
            var isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
            var isWorker = typeof WorkerGlobalScope !== 'undefined' && typeof self !== 'undefined' && self instanceof WorkerGlobalScope;
            var g = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : isNode ? global : window;
            if (typeof module !== 'undefined' && !!module.exports) {
                module.exports = wrapAll;
            }
            var forEach = Array.prototype.forEach || function (cb) {
                var i = 0, len = this.length;
                for (; i < len; i++) {
                    cb.call(this, this[i], i);
                }
            };
            var props = Array.prototype.concat.call([
                'setTimeout',
                'clearTimeout',
                'requestAnimationFrame',
                'cancelAnimationFrame',
                'Promise.prototype.then',
                'XMLHttpRequest.prototype.send',
                'Node.prototype.addEventListener',
                'Node.prototype.removeEventListener',
                'process.nextTick',
                'setImmediate',
                'clearImmediate',
                {
                    prop: 'MutationObserver',
                    fn: function (MutationObserver) {
                        return function (fn) {
                            return new MutationObserver(fn);
                        };
                    }
                }
            ], getGlobalEventHandlersNames().map(function (name) {
                return 'HTMLElement.prototype.' + name;
            }));
            wrapAll(g);
            if (g.Promise) {
                monitor(g, 'Promise', 'Promise.prototype.then', g);
            }
            function extract(obj, prop) {
                var parts = prop.split('.');
                while (parts.length > 1) {
                    prop = parts.shift();
                    obj = obj[prop];
                    if (!obj)
                        break;
                    if (parts.length === 1)
                        prop = parts[0];
                }
                return [
                    obj,
                    prop
                ];
            }
            function wrapAll(globalObj) {
                var global = globalObj || g;
                var wrapped = global.__canZoneWrapped;
                if (!wrapped) {
                    wrapped = global.__canZoneWrapped = {};
                }
                forEach.call(props, function (prop) {
                    var fn;
                    if (typeof prop === 'object') {
                        fn = prop.fn;
                        prop = prop.prop;
                    }
                    var key = prop;
                    if (wrapped[key]) {
                        return;
                    }
                    var results = extract(global, prop);
                    var obj = results[0];
                    prop = results[1];
                    if (!isGlobalEventHandler(prop) && (!obj || !obj[prop])) {
                        return;
                    } else {
                        wrapped[key] = true;
                    }
                    wrapInZone(obj, prop, fn, global);
                });
            }
            function wrapInZone(object, property, fn, global) {
                var wrappedFn = function () {
                    var Zone = global.CanZone;
                    if (typeof Zone !== 'undefined' && !!Zone.current) {
                        return Zone.tasks[property](fn, Zone).apply(this, arguments);
                    }
                    return fn.apply(this, arguments);
                };
                var descriptor = Object.getOwnPropertyDescriptor(object, property) || {};
                if (isGlobalEventHandler(property)) {
                    fn = descriptor.set;
                    descriptor.set = wrappedFn;
                } else {
                    fn = fn ? fn(object[property]) : object[property];
                    descriptor.value = wrappedFn;
                    descriptor.writable = true;
                }
                Object.defineProperty(object, property, descriptor);
                wrappedFn.zoneWrapped = true;
            }
            function isGlobalEventHandler(property) {
                return property.substr(0, 2) === 'on';
            }
            function getGlobalEventHandlersNames() {
                var names = [];
                if (!isNode && !isWorker) {
                    names = Object.getOwnPropertyNames(HTMLElement.prototype).filter(isGlobalEventHandler);
                }
                return names;
            }
            function monitor(object, property, thingToRewrap, global) {
                var current = object[property];
                Object.defineProperty(object, property, {
                    get: function () {
                        return current;
                    },
                    set: function (val) {
                        var hasChanged = !val.zoneWrapped && val !== current;
                        current = val;
                        if (hasChanged) {
                            var results = extract(object, thingToRewrap);
                            var localObject = results[0];
                            var localProperty = results[1];
                            wrapInZone(localObject, localProperty, null, global);
                            monitor(object, property, thingToRewrap, global);
                        }
                    }
                });
            }
        }());
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-zone@0.6.22#lib/tasks*/
define('can-zone@0.6.22#lib/tasks', [
    'require',
    'exports',
    'module',
    './env',
    './util'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var env = require('./env');
        var util = require('./util');
        var slice = Array.prototype.slice;
        var isWorker = typeof WorkerGlobalScope !== 'undefined' && typeof self !== 'undefined' && self instanceof WorkerGlobalScope;
        if (env.isNode) {
            var globalTimeoutId = 1;
        }
        var addTimer = function (callback, Zone) {
            var timeoutId = callback();
            var id = timeoutId;
            if (env.isNode && typeof id !== 'number') {
                id = timeoutId.__timeoutId = globalTimeoutId++;
            }
            var zone = Zone.current;
            if (!zone.isResolved) {
                zone.ids[id] = timeoutId;
            }
            return {
                timeoutId: timeoutId,
                id: id
            };
        };
        var removeTimer = function (timeoutId, callback, Zone) {
            if (timeoutId == null) {
                return callback();
            }
            var zone = Zone.current;
            var ids = zone.ids;
            var id = env.isNode && typeof timeoutId !== 'number' ? timeoutId.__timeoutId : timeoutId;
            if (!zone.isResolved && ids[id]) {
                delete ids[id];
                zone.removeWait();
            }
            return callback();
        };
        var getGlobalEventHandlersNames = function getGlobalEventHandlersNames() {
            var names = [];
            if (!env.isNode && !isWorker) {
                names = Object.getOwnPropertyNames(HTMLElement.prototype).filter(function isGlobalEventHandler(name) {
                    return name.substr(0, 2) === 'on';
                });
            }
            return names;
        };
        var defineSetTask = function defineSetTask(set, Zone) {
            return function setTask(newValue) {
                if (newValue) {
                    var outHandler = newValue[EVENT_HANDLER];
                    if (outHandler === undefined) {
                        outHandler = Zone.current.wrap(newValue);
                        newValue[EVENT_HANDLER] = outHandler;
                    }
                    set.call(this, outHandler);
                } else {
                    set.call(this, newValue);
                }
            };
        };
        getGlobalEventHandlersNames().forEach(function (name) {
            exports[name] = defineSetTask;
        });
        exports.setTimeout = function (setTimeout, Zone) {
            return function (fn, timeout) {
                var args = Array.prototype.slice.call(arguments);
                var zone = Zone.current;
                var idInfo;
                args[0] = zone.waitFor(function () {
                    delete zone.ids[idInfo.id];
                    return fn.apply(this, arguments);
                });
                var self = this;
                idInfo = addTimer(function () {
                    return setTimeout.apply(self, args);
                }, Zone);
                return idInfo.timeoutId;
            };
        };
        exports.clearTimeout = function (clearTimeout, Zone) {
            return function (timeoutId) {
                var args = arguments, self = this;
                return removeTimer(timeoutId, function () {
                    return clearTimeout.apply(self, args);
                }, Zone);
            };
        };
        exports.setImmediate = function (setImmediate, Zone) {
            return function (fn) {
                var idInfo;
                var zone = Zone.current;
                var callback = zone.waitFor(function () {
                    delete zone.ids[idInfo.id];
                    return fn.apply(this, arguments);
                });
                var self = this, args = slice.call(arguments, 1);
                idInfo = addTimer(function () {
                    return setImmediate.apply(self, [callback].concat(args));
                }, Zone);
                return idInfo.timeoutId;
            };
        };
        exports.clearImmediate = function (clearImmediate, Zone) {
            return function (immediateId) {
                var args = arguments, self = this;
                return removeTimer(immediateId, function () {
                    return clearImmediate.apply(self, args);
                }, Zone);
            };
        };
        exports.requestAnimationFrame = function (rAF, Zone) {
            return function (fn) {
                var zone = Zone.current;
                var callback = zone.waitFor(fn);
                var id = rAF.call(this, callback);
                zone.rafs[id] = true;
                return id;
            };
        };
        exports.cancelAnimationFrame = function (cAF, Zone) {
            return function (id) {
                var zone = Zone.current;
                var ids = zone.rafs;
                var res = cAF.call(this, id);
                if (!zone.isResolved && ids[id]) {
                    delete ids[id];
                    zone.removeWait();
                }
                return res;
            };
        };
        exports.then = function (then, Zone) {
            return function (onFulfilled, onRejected) {
                var fn;
                var rejected;
                var callback = Zone.current.waitFor(function (val) {
                    if (fn) {
                        return fn.apply(this, arguments);
                    } else if (rejected) {
                        return Promise.reject(val);
                    }
                    return val;
                }, false);
                var callWith = function (cb, isError) {
                    return function () {
                        fn = cb;
                        rejected = !!isError;
                        return callback.apply(this, arguments);
                    };
                };
                return then.call(this, callWith(onFulfilled), callWith(onRejected, true));
            };
        };
        var supportsOnload = undefined;
        exports.send = function (send, Zone) {
            if (typeof supportsOnload === 'undefined') {
                supportsOnload = 'onload' in new XMLHttpRequest();
            }
            return function () {
                var onreadystatechange = this.onreadystatechange, onload = this.onload, onerror = this.onerror, thisXhr = this, zone = Zone.current;
                zone.addWait();
                if (supportsOnload && this.onload) {
                    this.onload = createCallback(onload);
                    this.onerror = createCallback(onerror);
                } else {
                    onreadystatechange = onreadystatechange || function () {
                    };
                    var callback = createCallback(onreadystatechange);
                    this.onreadystatechange = function (ev) {
                        var xhr = ev ? ev.target : thisXhr;
                        if (xhr.readyState === 4) {
                            return callback.apply(this, arguments);
                        } else {
                            return onreadystatechange.apply(this, arguments);
                        }
                    };
                }
                function createCallback(fn) {
                    fn = fn || function () {
                    };
                    return function () {
                        var task = new Zone.Task(zone, fn);
                        var res = task.run(this, arguments);
                        zone.removeWait();
                        return res;
                    };
                }
                return send.apply(this, arguments);
            };
        };
        exports.nextTick = function (nextTick, Zone) {
            return function (fn) {
                var callback = Zone.current.waitFor(fn);
                var args = slice.call(arguments, 1);
                args.unshift(callback);
                return nextTick.apply(process, args);
            };
        };
        exports.MutationObserver = function (MutationObserver, Zone) {
            return function (fn) {
                fn = Zone.current.wrap(fn);
                return new MutationObserver(fn);
            };
        };
        var EVENT_HANDLER = util.symbol('zone-eventhandler');
        exports.addEventListener = function (addEventListener, Zone) {
            return function (eventName, handler, useCapture) {
                var outHandler = handler[EVENT_HANDLER];
                if (outHandler === undefined) {
                    outHandler = Zone.current.wrap(handler);
                    handler[EVENT_HANDLER] = outHandler;
                }
                return addEventListener.call(this, eventName, outHandler, useCapture);
            };
        };
        exports.removeEventListener = function (removeEventListener, Zone) {
            return function (eventName, handler, useCapture) {
                var outHandler = handler && handler[EVENT_HANDLER] || handler;
                return removeEventListener.call(this, eventName, outHandler, useCapture);
            };
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-zone@0.6.22#lib/zone*/
define('can-zone@0.6.22#lib/zone', [
    'require',
    'exports',
    'module',
    './env',
    './zones/globals',
    './util',
    '../register',
    './tasks'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var g = require('./env').global;
        var Promise = g.Promise;
        var globalsZone = require('./zones/globals');
        var forEach = require('./util').forEach;
        var registerZone = require('../register');
        var slice = Array.prototype.slice;
        var noop = function () {
        };
        function Deferred() {
            var dfd = this;
            this.promise = new Promise(function (resolve, reject) {
                dfd.resolve = resolve;
                dfd.reject = reject;
            });
        }
        function Task(zone, fn, catchErrors) {
            this.zone = zone;
            this.fn = fn;
            this.catchErrors = catchErrors;
            this.nestedTask = zone.runningTask;
        }
        Task.prototype.run = function (ctx, args) {
            var Zone = this.zone.constructor;
            var previousZone = Zone.current;
            var zone = Zone.current = this.zone;
            if (!this.nestedTask)
                zone.execHook('beforeTask', this);
            var res;
            try {
                zone.runningTask = true;
                res = this.fn.apply(ctx, args);
                Zone.current = previousZone;
                if (!this.nestedTask)
                    zone.execHookR('afterTask', this);
            } catch (err) {
                Zone.current = previousZone;
                if (!this.nestedTask) {
                    zone.execHookR('afterTask', this);
                }
                if (this.catchErrors !== false && !this.zone.isResolved) {
                    zone.errors.push(err);
                } else {
                    throw err;
                }
            } finally {
                zone.runningTask = this.nestedTask;
            }
            return res;
        };
        var hooks = [
            'beforeTask',
            'afterTask',
            'created',
            'ended',
            'beforeRun',
            'afterRun'
        ];
        var commonGlobals = [
            'document',
            'window',
            'location'
        ];
        function buildZoneSpec(zone, spec, plugins, processedSpecs) {
            spec = spec || {};
            processedSpecs = processedSpecs || [];
            if (processedSpecs.indexOf(spec) !== -1) {
                return;
            } else {
                processedSpecs.push(spec);
            }
            plugins = plugins || [];
            if (typeof spec === 'function') {
                spec = spec(zone.data);
            } else if (Array.isArray(spec)) {
                spec = { plugins: spec };
            }
            if (spec.plugins) {
                plugins = plugins.concat(spec.plugins);
            }
            forEach.call(plugins, function (plugin) {
                buildZoneSpec(zone, plugin, null, processedSpecs);
            });
            if (spec.hooks) {
                zone.hooks = zone.hooks.concat(spec.hooks);
            }
            forEach.call(zone.hooks, function (hook) {
                var propName = hook + 's';
                var array = zone[propName];
                if (!array) {
                    array = zone[propName] = [];
                }
                if (spec[hook]) {
                    array.push(spec[hook]);
                }
            });
            var globals = extend({}, spec.globals || {});
            forEach.call(commonGlobals, function (name) {
                if (spec[name])
                    globals[name] = spec[name];
            });
            for (var p in globals) {
                zone.globals[p] = globals[p];
            }
        }
        function Zone(spec) {
            spec = spec || {};
            this.deferred = new Deferred();
            this.waits = 0;
            this.ids = Object.create(null);
            this.rafs = Object.create(null);
            this.errors = [];
            this.data = {};
            this.globals = {};
            this.parent = this.constructor.current;
            this.hooks = slice.call(hooks);
            buildZoneSpec(this, spec, [globalsZone]);
            this.execHook('created');
        }
        Zone.waitFor = function (fn, catchErrors) {
            var fun = fn || noop;
            var zone = this.current;
            if (!zone)
                return fun;
            return zone.waitFor(fun, catchErrors);
        };
        Zone.error = function (error) {
            var zone = this.current;
            if (!zone)
                return error;
            zone.errors.push(error);
            return error;
        };
        Zone.ignore = function (fn) {
            var Zone = this;
            return function () {
                var zone = Zone.current;
                if (!zone)
                    return fn.apply(this, arguments);
                var task = new Task(zone);
                Zone.current = undefined;
                zone.execHookR('afterTask', task);
                var res = fn.apply(this, arguments);
                zone.execHook('beforeTask', task);
                Zone.current = zone;
                return res;
            };
        };
        Zone.prototype.runTask = function (fn, ctx, args, catchErrors, decrementWaits) {
            var res, error;
            var task = new Task(this, fn, catchErrors);
            try {
                res = task.run(ctx, args);
            } catch (err) {
                error = err;
            }
            if (decrementWaits && this.removeWait)
                this.removeWait();
            if (error)
                throw error;
            return res;
        };
        Zone.prototype.run = function (fn) {
            if (this.isResolved) {
                this.deferred = new Deferred();
                this.isResolved = false;
            } else {
                this.execHook('beforeRun');
            }
            var task = new Task(this, fn);
            this.data.result = task.run();
            if (!this.isResolved) {
                this.execHook('afterRun');
            }
            if (!this.waits || this.errors.length) {
                this.end();
            }
            return this.deferred.promise;
        };
        Zone.prototype.fork = function (zoneSpec) {
            var Zone = this.constructor;
            var plugins = [];
            if (zoneSpec)
                plugins.push(zoneSpec);
            plugins.unshift(this);
            var newZone = new Zone({ plugins: plugins });
            return newZone;
        };
        Zone.prototype.execHook = function (hook) {
            var args = slice.call(arguments, 1);
            var zone = this;
            var prop = hook + 's';
            var array = this[prop];
            if (array) {
                forEach.call(array, function (fn) {
                    fn.apply(zone, args);
                });
            }
        };
        Zone.prototype.execHookR = function (hook) {
            var args = slice.call(arguments, 1);
            var zone = this;
            var prop = hook + 's';
            var array = this[prop];
            if (array) {
                var i = array.length - 1;
                for (; i >= 0; i--) {
                    array[i].apply(zone, args);
                }
            }
        };
        Zone.prototype.wrap = function (fn, catchErrors) {
            var zone = this;
            return function () {
                return zone.runTask(fn, this, arguments, catchErrors);
            };
        };
        Zone.prototype.end = function () {
            if (!this.isResolved) {
                this.execHook('ended');
            }
            var dfd = this.deferred;
            if (this.errors.length) {
                var error = this.errors[0];
                error.errors = this.errors;
                dfd.reject(error);
            } else {
                dfd.resolve(this.data);
            }
            this.isResolved = true;
        };
        Zone.prototype.waitFor = function (fn, catchErrors) {
            this.addWait();
            var zone = this;
            return function () {
                return zone.runTask(fn, this, arguments, catchErrors, true);
            };
        };
        Zone.prototype.addWait = function () {
            this.waits++;
            if (this.parent) {
                this.parent.addWait();
            }
        };
        Zone.prototype.removeWait = function () {
            this.waits--;
            if (this.waits === 0) {
                this.end();
            }
            if (this.parent) {
                this.parent.removeWait();
            }
        };
        Zone.Task = Task;
        Zone.register = registerZone;
        function extend(a, b) {
            if (!b)
                return a;
            for (var p in b) {
                a[p] = b[p];
            }
            return a;
        }
        Zone.tasks = {};
        addTasks(require('./tasks'));
        function addTasks(tasks) {
            for (var p in tasks) {
                Zone.tasks[p] = tasks[p];
            }
        }
        g.CanZone = g.CanZone || Zone;
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = Zone;
        }
    }(function () {
        return this;
    }(), require, exports, module));
});
/*can-zone-storage@1.0.1#test/can-zone-storage_zone-test*/
define('can-zone-storage@1.0.1#test/can-zone-storage_zone-test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'can-zone-storage',
    'can-zone'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var QUnit = require('steal-qunit');
        var zoneStorage = require('can-zone-storage');
        var Zone = require('can-zone');
        QUnit.module('can-zone-storage with can-zone');
        QUnit.test('Works in a Zone', function (assert) {
            var done = assert.async();
            new Zone().run(function () {
                assert.ok(CanZone.current.data.hasOwnProperty, 'CanZone.current.data is an object');
                var key = 'key';
                var val = 'Write to the CanZone.current.data store!';
                var store = zoneStorage.getStore();
                assert.ok(CanZone.current.data === store, 'getStore returns the CanZone.current.data store when inside a zone.');
                zoneStorage.setItem(key, val);
                assert.equal(CanZone.current.data[key], val, 'Data was written to CanZone.current.data store.');
                assert.equal(store[key], val, 'getStore returns the CanZone.current.data store when outside a Zone.');
                var retrievedVal = zoneStorage.getItem(key);
                assert.equal(val, retrievedVal, 'getVal properly retrieves the setVal');
                zoneStorage.removeItem(key);
                assert.equal(zoneStorage.data.hasOwnProperty(key), false, 'Data was removed from the CanZone.current.data store.');
                done();
            });
        });
    }(function () {
        return this;
    }(), require, exports, module));
});
/*funcunit@3.6.3#browser/jquery*/
define('funcunit@3.6.3#browser/jquery', function (require, exports, module) {
    (function (global, require, exports, module) {
        'format cjs';
        (function (global, factory) {
            if (typeof module === 'object' && typeof module.exports === 'object') {
                module.exports = global.document ? factory(global, true) : function (w) {
                    if (!w.document) {
                        throw new Error('jQuery requires a window with a document');
                    }
                    return factory(w);
                };
                module.exports = module.exports.noConflict(true);
            } else {
                factory(global);
            }
        }(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
            var deletedIds = [];
            var slice = deletedIds.slice;
            var concat = deletedIds.concat;
            var push = deletedIds.push;
            var indexOf = deletedIds.indexOf;
            var class2type = {};
            var toString = class2type.toString;
            var hasOwn = class2type.hasOwnProperty;
            var trim = ''.trim;
            var support = {};
            var version = '1.11.0', jQuery = function (selector, context) {
                    return new jQuery.fn.init(selector, context);
                }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
                    return letter.toUpperCase();
                };
            jQuery.fn = jQuery.prototype = {
                jquery: version,
                constructor: jQuery,
                selector: '',
                length: 0,
                toArray: function () {
                    return slice.call(this);
                },
                get: function (num) {
                    return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
                },
                pushStack: function (elems) {
                    var ret = jQuery.merge(this.constructor(), elems);
                    ret.prevObject = this;
                    ret.context = this.context;
                    return ret;
                },
                each: function (callback, args) {
                    return jQuery.each(this, callback, args);
                },
                map: function (callback) {
                    return this.pushStack(jQuery.map(this, function (elem, i) {
                        return callback.call(elem, i, elem);
                    }));
                },
                slice: function () {
                    return this.pushStack(slice.apply(this, arguments));
                },
                first: function () {
                    return this.eq(0);
                },
                last: function () {
                    return this.eq(-1);
                },
                eq: function (i) {
                    var len = this.length, j = +i + (i < 0 ? len : 0);
                    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                },
                end: function () {
                    return this.prevObject || this.constructor(null);
                },
                push: push,
                sort: deletedIds.sort,
                splice: deletedIds.splice
            };
            jQuery.extend = jQuery.fn.extend = function () {
                var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
                if (typeof target === 'boolean') {
                    deep = target;
                    target = arguments[i] || {};
                    i++;
                }
                if (typeof target !== 'object' && !jQuery.isFunction(target)) {
                    target = {};
                }
                if (i === length) {
                    target = this;
                    i--;
                }
                for (; i < length; i++) {
                    if ((options = arguments[i]) != null) {
                        for (name in options) {
                            src = target[name];
                            copy = options[name];
                            if (target === copy) {
                                continue;
                            }
                            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && jQuery.isArray(src) ? src : [];
                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }
                                target[name] = jQuery.extend(deep, clone, copy);
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }
                return target;
            };
            jQuery.extend({
                expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
                isReady: true,
                error: function (msg) {
                    throw new Error(msg);
                },
                noop: function () {
                },
                isFunction: function (obj) {
                    return jQuery.type(obj) === 'function';
                },
                isArray: Array.isArray || function (obj) {
                    return jQuery.type(obj) === 'array';
                },
                isWindow: function (obj) {
                    return obj != null && obj == obj.window;
                },
                isNumeric: function (obj) {
                    return obj - parseFloat(obj) >= 0;
                },
                isEmptyObject: function (obj) {
                    var name;
                    for (name in obj) {
                        return false;
                    }
                    return true;
                },
                isPlainObject: function (obj) {
                    var key;
                    if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                        return false;
                    }
                    try {
                        if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
                            return false;
                        }
                    } catch (e) {
                        return false;
                    }
                    if (support.ownLast) {
                        for (key in obj) {
                            return hasOwn.call(obj, key);
                        }
                    }
                    for (key in obj) {
                    }
                    return key === undefined || hasOwn.call(obj, key);
                },
                type: function (obj) {
                    if (obj == null) {
                        return obj + '';
                    }
                    return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
                },
                globalEval: function (data) {
                    if (data && jQuery.trim(data)) {
                        (window.execScript || function (data) {
                            window['eval'].call(window, data);
                        })(data);
                    }
                },
                camelCase: function (string) {
                    return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
                },
                nodeName: function (elem, name) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                },
                each: function (obj, callback, args) {
                    var value, i = 0, length = obj.length, isArray = isArraylike(obj);
                    if (args) {
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback.apply(obj[i], args);
                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.apply(obj[i], args);
                                if (value === false) {
                                    break;
                                }
                            }
                        }
                    } else {
                        if (isArray) {
                            for (; i < length; i++) {
                                value = callback.call(obj[i], i, obj[i]);
                                if (value === false) {
                                    break;
                                }
                            }
                        } else {
                            for (i in obj) {
                                value = callback.call(obj[i], i, obj[i]);
                                if (value === false) {
                                    break;
                                }
                            }
                        }
                    }
                    return obj;
                },
                trim: trim && !trim.call('\uFEFF\xA0') ? function (text) {
                    return text == null ? '' : trim.call(text);
                } : function (text) {
                    return text == null ? '' : (text + '').replace(rtrim, '');
                },
                makeArray: function (arr, results) {
                    var ret = results || [];
                    if (arr != null) {
                        if (isArraylike(Object(arr))) {
                            jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                        } else {
                            push.call(ret, arr);
                        }
                    }
                    return ret;
                },
                inArray: function (elem, arr, i) {
                    var len;
                    if (arr) {
                        if (indexOf) {
                            return indexOf.call(arr, elem, i);
                        }
                        len = arr.length;
                        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                        for (; i < len; i++) {
                            if (i in arr && arr[i] === elem) {
                                return i;
                            }
                        }
                    }
                    return -1;
                },
                merge: function (first, second) {
                    var len = +second.length, j = 0, i = first.length;
                    while (j < len) {
                        first[i++] = second[j++];
                    }
                    if (len !== len) {
                        while (second[j] !== undefined) {
                            first[i++] = second[j++];
                        }
                    }
                    first.length = i;
                    return first;
                },
                grep: function (elems, callback, invert) {
                    var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
                    for (; i < length; i++) {
                        callbackInverse = !callback(elems[i], i);
                        if (callbackInverse !== callbackExpect) {
                            matches.push(elems[i]);
                        }
                    }
                    return matches;
                },
                map: function (elems, callback, arg) {
                    var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
                    if (isArray) {
                        for (; i < length; i++) {
                            value = callback(elems[i], i, arg);
                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    } else {
                        for (i in elems) {
                            value = callback(elems[i], i, arg);
                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    }
                    return concat.apply([], ret);
                },
                guid: 1,
                proxy: function (fn, context) {
                    var args, proxy, tmp;
                    if (typeof context === 'string') {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }
                    if (!jQuery.isFunction(fn)) {
                        return undefined;
                    }
                    args = slice.call(arguments, 2);
                    proxy = function () {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                    return proxy;
                },
                now: function () {
                    return +new Date();
                },
                support: support
            });
            jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
                class2type['[object ' + name + ']'] = name.toLowerCase();
            });
            function isArraylike(obj) {
                var length = obj.length, type = jQuery.type(obj);
                if (type === 'function' || jQuery.isWindow(obj)) {
                    return false;
                }
                if (obj.nodeType === 1 && length) {
                    return true;
                }
                return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
            }
            var Sizzle = function (window) {
                var i, support, Expr, getText, isXML, compile, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                        }
                        return 0;
                    }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
                        var i = 0, len = this.length;
                        for (; i < len; i++) {
                            if (this[i] === elem) {
                                return i;
                            }
                        }
                        return -1;
                    }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                        'ID': new RegExp('^#(' + characterEncoding + ')'),
                        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
                        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
                        'ATTR': new RegExp('^' + attributes),
                        'PSEUDO': new RegExp('^' + pseudos),
                        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
                    }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                        var high = '0x' + escaped - 65536;
                        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
                    };
                try {
                    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                    arr[preferredDoc.childNodes.length].nodeType;
                } catch (e) {
                    push = {
                        apply: arr.length ? function (target, els) {
                            push_native.apply(target, slice.call(els));
                        } : function (target, els) {
                            var j = target.length, i = 0;
                            while (target[j++] = els[i++]) {
                            }
                            target.length = j - 1;
                        }
                    };
                }
                function Sizzle(selector, context, results, seed) {
                    var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                        setDocument(context);
                    }
                    context = context || document;
                    results = results || [];
                    if (!selector || typeof selector !== 'string') {
                        return results;
                    }
                    if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
                        return [];
                    }
                    if (documentIsHTML && !seed) {
                        if (match = rquickExpr.exec(selector)) {
                            if (m = match[1]) {
                                if (nodeType === 9) {
                                    elem = context.getElementById(m);
                                    if (elem && elem.parentNode) {
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }
                                } else {
                                    if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                }
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;
                            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }
                        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                            nid = old = expando;
                            newContext = context;
                            newSelector = nodeType === 9 && selector;
                            if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
                                groups = tokenize(selector);
                                if (old = context.getAttribute('id')) {
                                    nid = old.replace(rescape, '\\$&');
                                } else {
                                    context.setAttribute('id', nid);
                                }
                                nid = '[id=\'' + nid + '\'] ';
                                i = groups.length;
                                while (i--) {
                                    groups[i] = nid + toSelector(groups[i]);
                                }
                                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                newSelector = groups.join(',');
                            }
                            if (newSelector) {
                                try {
                                    push.apply(results, newContext.querySelectorAll(newSelector));
                                    return results;
                                } catch (qsaError) {
                                } finally {
                                    if (!old) {
                                        context.removeAttribute('id');
                                    }
                                }
                            }
                        }
                    }
                    return select(selector.replace(rtrim, '$1'), context, results, seed);
                }
                function createCache() {
                    var keys = [];
                    function cache(key, value) {
                        if (keys.push(key + ' ') > Expr.cacheLength) {
                            delete cache[keys.shift()];
                        }
                        return cache[key + ' '] = value;
                    }
                    return cache;
                }
                function markFunction(fn) {
                    fn[expando] = true;
                    return fn;
                }
                function assert(fn) {
                    var div = document.createElement('div');
                    try {
                        return !!fn(div);
                    } catch (e) {
                        return false;
                    } finally {
                        if (div.parentNode) {
                            div.parentNode.removeChild(div);
                        }
                        div = null;
                    }
                }
                function addHandle(attrs, handler) {
                    var arr = attrs.split('|'), i = attrs.length;
                    while (i--) {
                        Expr.attrHandle[arr[i]] = handler;
                    }
                }
                function siblingCheck(a, b) {
                    var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                    if (diff) {
                        return diff;
                    }
                    if (cur) {
                        while (cur = cur.nextSibling) {
                            if (cur === b) {
                                return -1;
                            }
                        }
                    }
                    return a ? 1 : -1;
                }
                function createInputPseudo(type) {
                    return function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === 'input' && elem.type === type;
                    };
                }
                function createButtonPseudo(type) {
                    return function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === 'input' || name === 'button') && elem.type === type;
                    };
                }
                function createPositionalPseudo(fn) {
                    return markFunction(function (argument) {
                        argument = +argument;
                        return markFunction(function (seed, matches) {
                            var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                            while (i--) {
                                if (seed[j = matchIndexes[i]]) {
                                    seed[j] = !(matches[j] = seed[j]);
                                }
                            }
                        });
                    });
                }
                function testContext(context) {
                    return context && typeof context.getElementsByTagName !== strundefined && context;
                }
                support = Sizzle.support = {};
                isXML = Sizzle.isXML = function (elem) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return documentElement ? documentElement.nodeName !== 'HTML' : false;
                };
                setDocument = Sizzle.setDocument = function (node) {
                    var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
                    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                        return document;
                    }
                    document = doc;
                    docElem = doc.documentElement;
                    documentIsHTML = !isXML(doc);
                    if (parent && parent !== parent.top) {
                        if (parent.addEventListener) {
                            parent.addEventListener('unload', function () {
                                setDocument();
                            }, false);
                        } else if (parent.attachEvent) {
                            parent.attachEvent('onunload', function () {
                                setDocument();
                            });
                        }
                    }
                    support.attributes = assert(function (div) {
                        div.className = 'i';
                        return !div.getAttribute('className');
                    });
                    support.getElementsByTagName = assert(function (div) {
                        div.appendChild(doc.createComment(''));
                        return !div.getElementsByTagName('*').length;
                    });
                    support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
                        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
                        div.firstChild.className = 'i';
                        return div.getElementsByClassName('i').length === 2;
                    });
                    support.getById = assert(function (div) {
                        docElem.appendChild(div).id = expando;
                        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
                    });
                    if (support.getById) {
                        Expr.find['ID'] = function (id, context) {
                            if (typeof context.getElementById !== strundefined && documentIsHTML) {
                                var m = context.getElementById(id);
                                return m && m.parentNode ? [m] : [];
                            }
                        };
                        Expr.filter['ID'] = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                return elem.getAttribute('id') === attrId;
                            };
                        };
                    } else {
                        delete Expr.find['ID'];
                        Expr.filter['ID'] = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
                                return node && node.value === attrId;
                            };
                        };
                    }
                    Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                        if (typeof context.getElementsByTagName !== strundefined) {
                            return context.getElementsByTagName(tag);
                        }
                    } : function (tag, context) {
                        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                        if (tag === '*') {
                            while (elem = results[i++]) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }
                            return tmp;
                        }
                        return results;
                    };
                    Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
                            return context.getElementsByClassName(className);
                        }
                    };
                    rbuggyMatches = [];
                    rbuggyQSA = [];
                    if (support.qsa = rnative.test(doc.querySelectorAll)) {
                        assert(function (div) {
                            div.innerHTML = '<select t=\'\'><option selected=\'\'></option></select>';
                            if (div.querySelectorAll('[t^=\'\']').length) {
                                rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                            }
                            if (!div.querySelectorAll('[selected]').length) {
                                rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                            }
                            if (!div.querySelectorAll(':checked').length) {
                                rbuggyQSA.push(':checked');
                            }
                        });
                        assert(function (div) {
                            var input = doc.createElement('input');
                            input.setAttribute('type', 'hidden');
                            div.appendChild(input).setAttribute('name', 'D');
                            if (div.querySelectorAll('[name=d]').length) {
                                rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                            }
                            if (!div.querySelectorAll(':enabled').length) {
                                rbuggyQSA.push(':enabled', ':disabled');
                            }
                            div.querySelectorAll('*,:x');
                            rbuggyQSA.push(',.*:');
                        });
                    }
                    if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                        assert(function (div) {
                            support.disconnectedMatch = matches.call(div, 'div');
                            matches.call(div, '[s!=\'\']:x');
                            rbuggyMatches.push('!=', pseudos);
                        });
                    }
                    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
                    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
                    hasCompare = rnative.test(docElem.compareDocumentPosition);
                    contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                    } : function (a, b) {
                        if (b) {
                            while (b = b.parentNode) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };
                    sortOrder = hasCompare ? function (a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }
                        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                            if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                return -1;
                            }
                            if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                return 1;
                            }
                            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                        }
                        return compare & 4 ? -1 : 1;
                    } : function (a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }
                        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                        if (!aup || !bup) {
                            return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }
                        cur = a;
                        while (cur = cur.parentNode) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while (cur = cur.parentNode) {
                            bp.unshift(cur);
                        }
                        while (ap[i] === bp[i]) {
                            i++;
                        }
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                    };
                    return doc;
                };
                Sizzle.matches = function (expr, elements) {
                    return Sizzle(expr, null, null, elements);
                };
                Sizzle.matchesSelector = function (elem, expr) {
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
                    expr = expr.replace(rattributeQuotes, '=\'$1\']');
                    if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                        try {
                            var ret = matches.call(elem, expr);
                            if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                                return ret;
                            }
                        } catch (e) {
                        }
                    }
                    return Sizzle(expr, document, null, [elem]).length > 0;
                };
                Sizzle.contains = function (context, elem) {
                    if ((context.ownerDocument || context) !== document) {
                        setDocument(context);
                    }
                    return contains(context, elem);
                };
                Sizzle.attr = function (elem, name) {
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
                    var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                };
                Sizzle.error = function (msg) {
                    throw new Error('Syntax error, unrecognized expression: ' + msg);
                };
                Sizzle.uniqueSort = function (results) {
                    var elem, duplicates = [], j = 0, i = 0;
                    hasDuplicate = !support.detectDuplicates;
                    sortInput = !support.sortStable && results.slice(0);
                    results.sort(sortOrder);
                    if (hasDuplicate) {
                        while (elem = results[i++]) {
                            if (elem === results[i]) {
                                j = duplicates.push(i);
                            }
                        }
                        while (j--) {
                            results.splice(duplicates[j], 1);
                        }
                    }
                    sortInput = null;
                    return results;
                };
                getText = Sizzle.getText = function (elem) {
                    var node, ret = '', i = 0, nodeType = elem.nodeType;
                    if (!nodeType) {
                        while (node = elem[i++]) {
                            ret += getText(node);
                        }
                    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                        if (typeof elem.textContent === 'string') {
                            return elem.textContent;
                        } else {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                ret += getText(elem);
                            }
                        }
                    } else if (nodeType === 3 || nodeType === 4) {
                        return elem.nodeValue;
                    }
                    return ret;
                };
                Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        '>': {
                            dir: 'parentNode',
                            first: true
                        },
                        ' ': { dir: 'parentNode' },
                        '+': {
                            dir: 'previousSibling',
                            first: true
                        },
                        '~': { dir: 'previousSibling' }
                    },
                    preFilter: {
                        'ATTR': function (match) {
                            match[1] = match[1].replace(runescape, funescape);
                            match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
                            if (match[2] === '~=') {
                                match[3] = ' ' + match[3] + ' ';
                            }
                            return match.slice(0, 4);
                        },
                        'CHILD': function (match) {
                            match[1] = match[1].toLowerCase();
                            if (match[1].slice(0, 3) === 'nth') {
                                if (!match[3]) {
                                    Sizzle.error(match[0]);
                                }
                                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                                match[5] = +(match[7] + match[8] || match[3] === 'odd');
                            } else if (match[3]) {
                                Sizzle.error(match[0]);
                            }
                            return match;
                        },
                        'PSEUDO': function (match) {
                            var excess, unquoted = !match[5] && match[2];
                            if (matchExpr['CHILD'].test(match[0])) {
                                return null;
                            }
                            if (match[3] && match[4] !== undefined) {
                                match[2] = match[4];
                            } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                                match[0] = match[0].slice(0, excess);
                                match[2] = unquoted.slice(0, excess);
                            }
                            return match.slice(0, 3);
                        }
                    },
                    filter: {
                        'TAG': function (nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return nodeNameSelector === '*' ? function () {
                                return true;
                            } : function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                        },
                        'CLASS': function (className) {
                            var pattern = classCache[className + ' '];
                            return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                                return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
                            });
                        },
                        'ATTR': function (name, operator, check) {
                            return function (elem) {
                                var result = Sizzle.attr(elem, name);
                                if (result == null) {
                                    return operator === '!=';
                                }
                                if (!operator) {
                                    return true;
                                }
                                result += '';
                                return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                            };
                        },
                        'CHILD': function (type, what, argument, first, last) {
                            var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                            return first === 1 && last === 0 ? function (elem) {
                                return !!elem.parentNode;
                            } : function (elem, context, xml) {
                                var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                                if (parent) {
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while (node = node[dir]) {
                                                if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                    return false;
                                                }
                                            }
                                            start = dir = type === 'only' && !start && 'nextSibling';
                                        }
                                        return true;
                                    }
                                    start = [forward ? parent.firstChild : parent.lastChild];
                                    if (forward && useCache) {
                                        outerCache = parent[expando] || (parent[expando] = {});
                                        cache = outerCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = cache[0] === dirruns && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];
                                        while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                outerCache[type] = [
                                                    dirruns,
                                                    nodeIndex,
                                                    diff
                                                ];
                                                break;
                                            }
                                        }
                                    } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                        diff = cache[1];
                                    } else {
                                        while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                            if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                if (useCache) {
                                                    (node[expando] || (node[expando] = {}))[type] = [
                                                        dirruns,
                                                        diff
                                                    ];
                                                }
                                                if (node === elem) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    diff -= last;
                                    return diff === first || diff % first === 0 && diff / first >= 0;
                                }
                            };
                        },
                        'PSEUDO': function (pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                            if (fn[expando]) {
                                return fn(argument);
                            }
                            if (fn.length > 1) {
                                args = [
                                    pseudo,
                                    pseudo,
                                    '',
                                    argument
                                ];
                                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                    var idx, matched = fn(seed, argument), i = matched.length;
                                    while (i--) {
                                        idx = indexOf.call(seed, matched[i]);
                                        seed[idx] = !(matches[idx] = matched[i]);
                                    }
                                }) : function (elem) {
                                    return fn(elem, 0, args);
                                };
                            }
                            return fn;
                        }
                    },
                    pseudos: {
                        'not': markFunction(function (selector) {
                            var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                                var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                                while (i--) {
                                    if (elem = unmatched[i]) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) : function (elem, context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);
                                return !results.pop();
                            };
                        }),
                        'has': markFunction(function (selector) {
                            return function (elem) {
                                return Sizzle(selector, elem).length > 0;
                            };
                        }),
                        'contains': markFunction(function (text) {
                            return function (elem) {
                                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                            };
                        }),
                        'lang': markFunction(function (lang) {
                            if (!ridentifier.test(lang || '')) {
                                Sizzle.error('unsupported lang: ' + lang);
                            }
                            lang = lang.replace(runescape, funescape).toLowerCase();
                            return function (elem) {
                                var elemLang;
                                do {
                                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                                    }
                                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                return false;
                            };
                        }),
                        'target': function (elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id;
                        },
                        'root': function (elem) {
                            return elem === docElem;
                        },
                        'focus': function (elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                        },
                        'enabled': function (elem) {
                            return elem.disabled === false;
                        },
                        'disabled': function (elem) {
                            return elem.disabled === true;
                        },
                        'checked': function (elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                        },
                        'selected': function (elem) {
                            if (elem.parentNode) {
                                elem.parentNode.selectedIndex;
                            }
                            return elem.selected === true;
                        },
                        'empty': function (elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                if (elem.nodeType < 6) {
                                    return false;
                                }
                            }
                            return true;
                        },
                        'parent': function (elem) {
                            return !Expr.pseudos['empty'](elem);
                        },
                        'header': function (elem) {
                            return rheader.test(elem.nodeName);
                        },
                        'input': function (elem) {
                            return rinputs.test(elem.nodeName);
                        },
                        'button': function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === 'input' && elem.type === 'button' || name === 'button';
                        },
                        'text': function (elem) {
                            var attr;
                            return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                        },
                        'first': createPositionalPseudo(function () {
                            return [0];
                        }),
                        'last': createPositionalPseudo(function (matchIndexes, length) {
                            return [length - 1];
                        }),
                        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                            return [argument < 0 ? argument + length : argument];
                        }),
                        'even': createPositionalPseudo(function (matchIndexes, length) {
                            var i = 0;
                            for (; i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        'odd': createPositionalPseudo(function (matchIndexes, length) {
                            var i = 1;
                            for (; i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (; --i >= 0;) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
                        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (; ++i < length;) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        })
                    }
                };
                Expr.pseudos['nth'] = Expr.pseudos['eq'];
                for (i in {
                        radio: true,
                        checkbox: true,
                        file: true,
                        password: true,
                        image: true
                    }) {
                    Expr.pseudos[i] = createInputPseudo(i);
                }
                for (i in {
                        submit: true,
                        reset: true
                    }) {
                    Expr.pseudos[i] = createButtonPseudo(i);
                }
                function setFilters() {
                }
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();
                function tokenize(selector, parseOnly) {
                    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
                    if (cached) {
                        return parseOnly ? 0 : cached.slice(0);
                    }
                    soFar = selector;
                    groups = [];
                    preFilters = Expr.preFilter;
                    while (soFar) {
                        if (!matched || (match = rcomma.exec(soFar))) {
                            if (match) {
                                soFar = soFar.slice(match[0].length) || soFar;
                            }
                            groups.push(tokens = []);
                        }
                        matched = false;
                        if (match = rcombinators.exec(soFar)) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: match[0].replace(rtrim, ' ')
                            });
                            soFar = soFar.slice(matched.length);
                        }
                        for (type in Expr.filter) {
                            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice(matched.length);
                            }
                        }
                        if (!matched) {
                            break;
                        }
                    }
                    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
                }
                function toSelector(tokens) {
                    var i = 0, len = tokens.length, selector = '';
                    for (; i < len; i++) {
                        selector += tokens[i].value;
                    }
                    return selector;
                }
                function addCombinator(matcher, combinator, base) {
                    var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
                    return combinator.first ? function (elem, context, xml) {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                    } : function (elem, context, xml) {
                        var oldCache, outerCache, newCache = [
                                dirruns,
                                doneName
                            ];
                        if (xml) {
                            while (elem = elem[dir]) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while (elem = elem[dir]) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});
                                    if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                        return newCache[2] = oldCache[2];
                                    } else {
                                        outerCache[dir] = newCache;
                                        if (newCache[2] = matcher(elem, context, xml)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    };
                }
                function elementMatcher(matchers) {
                    return matchers.length > 1 ? function (elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } : matchers[0];
                }
                function condense(unmatched, map, filter, context, xml) {
                    var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                    for (; i < len; i++) {
                        if (elem = unmatched[i]) {
                            if (!filter || filter(elem, context, xml)) {
                                newUnmatched.push(elem);
                                if (mapped) {
                                    map.push(i);
                                }
                            }
                        }
                    }
                    return newUnmatched;
                }
                function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                    if (postFilter && !postFilter[expando]) {
                        postFilter = setMatcher(postFilter);
                    }
                    if (postFinder && !postFinder[expando]) {
                        postFinder = setMatcher(postFinder, postSelector);
                    }
                    return markFunction(function (seed, results, context, xml) {
                        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                        if (matcher) {
                            matcher(matcherIn, matcherOut, context, xml);
                        }
                        if (postFilter) {
                            temp = condense(matcherOut, postMap);
                            postFilter(temp, [], context, xml);
                            i = temp.length;
                            while (i--) {
                                if (elem = temp[i]) {
                                    matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                }
                            }
                        }
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    temp = [];
                                    i = matcherOut.length;
                                    while (i--) {
                                        if (elem = matcherOut[i]) {
                                            temp.push(matcherIn[i] = elem);
                                        }
                                    }
                                    postFinder(null, matcherOut = [], temp, xml);
                                }
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                                        seed[temp] = !(results[temp] = elem);
                                    }
                                }
                            }
                        } else {
                            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                            if (postFinder) {
                                postFinder(null, results, matcherOut, xml);
                            } else {
                                push.apply(results, matcherOut);
                            }
                        }
                    });
                }
                function matcherFromTokens(tokens) {
                    var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                            return elem === checkContext;
                        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                            return indexOf.call(checkContext, elem) > -1;
                        }, implicitRelative, true), matchers = [function (elem, context, xml) {
                                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                            }];
                    for (; i < len; i++) {
                        if (matcher = Expr.relative[tokens[i].type]) {
                            matchers = [addCombinator(elementMatcher(matchers), matcher)];
                        } else {
                            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                            if (matcher[expando]) {
                                j = ++i;
                                for (; j < len; j++) {
                                    if (Expr.relative[tokens[j].type]) {
                                        break;
                                    }
                                }
                                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                            }
                            matchers.push(matcher);
                        }
                    }
                    return elementMatcher(matchers);
                }
                function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                    var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                            var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                            if (outermost) {
                                outermostContext = context !== document && context;
                            }
                            for (; i !== len && (elem = elems[i]) != null; i++) {
                                if (byElement && elem) {
                                    j = 0;
                                    while (matcher = elementMatchers[j++]) {
                                        if (matcher(elem, context, xml)) {
                                            results.push(elem);
                                            break;
                                        }
                                    }
                                    if (outermost) {
                                        dirruns = dirrunsUnique;
                                    }
                                }
                                if (bySet) {
                                    if (elem = !matcher && elem) {
                                        matchedCount--;
                                    }
                                    if (seed) {
                                        unmatched.push(elem);
                                    }
                                }
                            }
                            matchedCount += i;
                            if (bySet && i !== matchedCount) {
                                j = 0;
                                while (matcher = setMatchers[j++]) {
                                    matcher(unmatched, setMatched, context, xml);
                                }
                                if (seed) {
                                    if (matchedCount > 0) {
                                        while (i--) {
                                            if (!(unmatched[i] || setMatched[i])) {
                                                setMatched[i] = pop.call(results);
                                            }
                                        }
                                    }
                                    setMatched = condense(setMatched);
                                }
                                push.apply(results, setMatched);
                                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                                    Sizzle.uniqueSort(results);
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                                outermostContext = contextBackup;
                            }
                            return unmatched;
                        };
                    return bySet ? markFunction(superMatcher) : superMatcher;
                }
                compile = Sizzle.compile = function (selector, group) {
                    var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
                    if (!cached) {
                        if (!group) {
                            group = tokenize(selector);
                        }
                        i = group.length;
                        while (i--) {
                            cached = matcherFromTokens(group[i]);
                            if (cached[expando]) {
                                setMatchers.push(cached);
                            } else {
                                elementMatchers.push(cached);
                            }
                        }
                        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                    }
                    return cached;
                };
                function multipleContexts(selector, contexts, results) {
                    var i = 0, len = contexts.length;
                    for (; i < len; i++) {
                        Sizzle(selector, contexts[i], results);
                    }
                    return results;
                }
                function select(selector, context, results, seed) {
                    var i, tokens, token, type, find, match = tokenize(selector);
                    if (!seed) {
                        if (match.length === 1) {
                            tokens = match[0] = match[0].slice(0);
                            if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                                context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                                if (!context) {
                                    return results;
                                }
                                selector = selector.slice(tokens.shift().value.length);
                            }
                            i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                            while (i--) {
                                token = tokens[i];
                                if (Expr.relative[type = token.type]) {
                                    break;
                                }
                                if (find = Expr.find[type]) {
                                    if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                        tokens.splice(i, 1);
                                        selector = seed.length && toSelector(tokens);
                                        if (!selector) {
                                            push.apply(results, seed);
                                            return results;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
                    return results;
                }
                support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
                support.detectDuplicates = !!hasDuplicate;
                setDocument();
                support.sortDetached = assert(function (div1) {
                    return div1.compareDocumentPosition(document.createElement('div')) & 1;
                });
                if (!assert(function (div) {
                        div.innerHTML = '<a href=\'#\'></a>';
                        return div.firstChild.getAttribute('href') === '#';
                    })) {
                    addHandle('type|href|height|width', function (elem, name, isXML) {
                        if (!isXML) {
                            return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                        }
                    });
                }
                if (!support.attributes || !assert(function (div) {
                        div.innerHTML = '<input/>';
                        div.firstChild.setAttribute('value', '');
                        return div.firstChild.getAttribute('value') === '';
                    })) {
                    addHandle('value', function (elem, name, isXML) {
                        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                            return elem.defaultValue;
                        }
                    });
                }
                if (!assert(function (div) {
                        return div.getAttribute('disabled') == null;
                    })) {
                    addHandle(booleans, function (elem, name, isXML) {
                        var val;
                        if (!isXML) {
                            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                        }
                    });
                }
                return Sizzle;
            }(window);
            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;
            jQuery.expr[':'] = jQuery.expr.pseudos;
            jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;
            var rneedsContext = jQuery.expr.match.needsContext;
            var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
            var risSimple = /^.[^:#\[\.,]*$/;
            function winnow(elements, qualifier, not) {
                if (jQuery.isFunction(qualifier)) {
                    return jQuery.grep(elements, function (elem, i) {
                        return !!qualifier.call(elem, i, elem) !== not;
                    });
                }
                if (qualifier.nodeType) {
                    return jQuery.grep(elements, function (elem) {
                        return elem === qualifier !== not;
                    });
                }
                if (typeof qualifier === 'string') {
                    if (risSimple.test(qualifier)) {
                        return jQuery.filter(qualifier, elements, not);
                    }
                    qualifier = jQuery.filter(qualifier, elements);
                }
                return jQuery.grep(elements, function (elem) {
                    return jQuery.inArray(elem, qualifier) >= 0 !== not;
                });
            }
            jQuery.filter = function (expr, elems, not) {
                var elem = elems[0];
                if (not) {
                    expr = ':not(' + expr + ')';
                }
                return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                    return elem.nodeType === 1;
                }));
            };
            jQuery.fn.extend({
                find: function (selector) {
                    var i, ret = [], self = this, len = self.length;
                    if (typeof selector !== 'string') {
                        return this.pushStack(jQuery(selector).filter(function () {
                            for (i = 0; i < len; i++) {
                                if (jQuery.contains(self[i], this)) {
                                    return true;
                                }
                            }
                        }));
                    }
                    for (i = 0; i < len; i++) {
                        jQuery.find(selector, self[i], ret);
                    }
                    ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                    ret.selector = this.selector ? this.selector + ' ' + selector : selector;
                    return ret;
                },
                filter: function (selector) {
                    return this.pushStack(winnow(this, selector || [], false));
                },
                not: function (selector) {
                    return this.pushStack(winnow(this, selector || [], true));
                },
                is: function (selector) {
                    return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
                }
            });
            var rootjQuery, document = window.document, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context) {
                    var match, elem;
                    if (!selector) {
                        return this;
                    }
                    if (typeof selector === 'string') {
                        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
                            match = [
                                null,
                                selector,
                                null
                            ];
                        } else {
                            match = rquickExpr.exec(selector);
                        }
                        if (match && (match[1] || !context)) {
                            if (match[1]) {
                                context = context instanceof jQuery ? context[0] : context;
                                jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                    for (match in context) {
                                        if (jQuery.isFunction(this[match])) {
                                            this[match](context[match]);
                                        } else {
                                            this.attr(match, context[match]);
                                        }
                                    }
                                }
                                return this;
                            } else {
                                elem = document.getElementById(match[2]);
                                if (elem && elem.parentNode) {
                                    if (elem.id !== match[2]) {
                                        return rootjQuery.find(selector);
                                    }
                                    this.length = 1;
                                    this[0] = elem;
                                }
                                this.context = document;
                                this.selector = selector;
                                return this;
                            }
                        } else if (!context || context.jquery) {
                            return (context || rootjQuery).find(selector);
                        } else {
                            return this.constructor(context).find(selector);
                        }
                    } else if (selector.nodeType) {
                        this.context = this[0] = selector;
                        this.length = 1;
                        return this;
                    } else if (jQuery.isFunction(selector)) {
                        return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
                    }
                    if (selector.selector !== undefined) {
                        this.selector = selector.selector;
                        this.context = selector.context;
                    }
                    return jQuery.makeArray(selector, this);
                };
            init.prototype = jQuery.fn;
            rootjQuery = jQuery(document);
            var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };
            jQuery.extend({
                dir: function (elem, dir, until) {
                    var matched = [], cur = elem[dir];
                    while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                        if (cur.nodeType === 1) {
                            matched.push(cur);
                        }
                        cur = cur[dir];
                    }
                    return matched;
                },
                sibling: function (n, elem) {
                    var r = [];
                    for (; n; n = n.nextSibling) {
                        if (n.nodeType === 1 && n !== elem) {
                            r.push(n);
                        }
                    }
                    return r;
                }
            });
            jQuery.fn.extend({
                has: function (target) {
                    var i, targets = jQuery(target, this), len = targets.length;
                    return this.filter(function () {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(this, targets[i])) {
                                return true;
                            }
                        }
                    });
                },
                closest: function (selectors, context) {
                    var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
                    for (; i < l; i++) {
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                            if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                                matched.push(cur);
                                break;
                            }
                        }
                    }
                    return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
                },
                index: function (elem) {
                    if (!elem) {
                        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                    }
                    if (typeof elem === 'string') {
                        return jQuery.inArray(this[0], jQuery(elem));
                    }
                    return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
                },
                add: function (selector, context) {
                    return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
                },
                addBack: function (selector) {
                    return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
                }
            });
            function sibling(cur, dir) {
                do {
                    cur = cur[dir];
                } while (cur && cur.nodeType !== 1);
                return cur;
            }
            jQuery.each({
                parent: function (elem) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function (elem) {
                    return jQuery.dir(elem, 'parentNode');
                },
                parentsUntil: function (elem, i, until) {
                    return jQuery.dir(elem, 'parentNode', until);
                },
                next: function (elem) {
                    return sibling(elem, 'nextSibling');
                },
                prev: function (elem) {
                    return sibling(elem, 'previousSibling');
                },
                nextAll: function (elem) {
                    return jQuery.dir(elem, 'nextSibling');
                },
                prevAll: function (elem) {
                    return jQuery.dir(elem, 'previousSibling');
                },
                nextUntil: function (elem, i, until) {
                    return jQuery.dir(elem, 'nextSibling', until);
                },
                prevUntil: function (elem, i, until) {
                    return jQuery.dir(elem, 'previousSibling', until);
                },
                siblings: function (elem) {
                    return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
                },
                children: function (elem) {
                    return jQuery.sibling(elem.firstChild);
                },
                contents: function (elem) {
                    return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
                }
            }, function (name, fn) {
                jQuery.fn[name] = function (until, selector) {
                    var ret = jQuery.map(this, fn, until);
                    if (name.slice(-5) !== 'Until') {
                        selector = until;
                    }
                    if (selector && typeof selector === 'string') {
                        ret = jQuery.filter(selector, ret);
                    }
                    if (this.length > 1) {
                        if (!guaranteedUnique[name]) {
                            ret = jQuery.unique(ret);
                        }
                        if (rparentsprev.test(name)) {
                            ret = ret.reverse();
                        }
                    }
                    return this.pushStack(ret);
                };
            });
            var rnotwhite = /\S+/g;
            var optionsCache = {};
            function createOptions(options) {
                var object = optionsCache[options] = {};
                jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                    object[flag] = true;
                });
                return object;
            }
            jQuery.Callbacks = function (options) {
                options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
                var firing, memory, fired, firingLength, firingIndex, firingStart, list = [], stack = !options.once && [], fire = function (data) {
                        memory = options.memory && data;
                        fired = true;
                        firingIndex = firingStart || 0;
                        firingStart = 0;
                        firingLength = list.length;
                        firing = true;
                        for (; list && firingIndex < firingLength; firingIndex++) {
                            if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                                memory = false;
                                break;
                            }
                        }
                        firing = false;
                        if (list) {
                            if (stack) {
                                if (stack.length) {
                                    fire(stack.shift());
                                }
                            } else if (memory) {
                                list = [];
                            } else {
                                self.disable();
                            }
                        }
                    }, self = {
                        add: function () {
                            if (list) {
                                var start = list.length;
                                (function add(args) {
                                    jQuery.each(args, function (_, arg) {
                                        var type = jQuery.type(arg);
                                        if (type === 'function') {
                                            if (!options.unique || !self.has(arg)) {
                                                list.push(arg);
                                            }
                                        } else if (arg && arg.length && type !== 'string') {
                                            add(arg);
                                        }
                                    });
                                }(arguments));
                                if (firing) {
                                    firingLength = list.length;
                                } else if (memory) {
                                    firingStart = start;
                                    fire(memory);
                                }
                            }
                            return this;
                        },
                        remove: function () {
                            if (list) {
                                jQuery.each(arguments, function (_, arg) {
                                    var index;
                                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                        list.splice(index, 1);
                                        if (firing) {
                                            if (index <= firingLength) {
                                                firingLength--;
                                            }
                                            if (index <= firingIndex) {
                                                firingIndex--;
                                            }
                                        }
                                    }
                                });
                            }
                            return this;
                        },
                        has: function (fn) {
                            return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
                        },
                        empty: function () {
                            list = [];
                            firingLength = 0;
                            return this;
                        },
                        disable: function () {
                            list = stack = memory = undefined;
                            return this;
                        },
                        disabled: function () {
                            return !list;
                        },
                        lock: function () {
                            stack = undefined;
                            if (!memory) {
                                self.disable();
                            }
                            return this;
                        },
                        locked: function () {
                            return !stack;
                        },
                        fireWith: function (context, args) {
                            if (list && (!fired || stack)) {
                                args = args || [];
                                args = [
                                    context,
                                    args.slice ? args.slice() : args
                                ];
                                if (firing) {
                                    stack.push(args);
                                } else {
                                    fire(args);
                                }
                            }
                            return this;
                        },
                        fire: function () {
                            self.fireWith(this, arguments);
                            return this;
                        },
                        fired: function () {
                            return !!fired;
                        }
                    };
                return self;
            };
            jQuery.extend({
                Deferred: function (func) {
                    var tuples = [
                            [
                                'resolve',
                                'done',
                                jQuery.Callbacks('once memory'),
                                'resolved'
                            ],
                            [
                                'reject',
                                'fail',
                                jQuery.Callbacks('once memory'),
                                'rejected'
                            ],
                            [
                                'notify',
                                'progress',
                                jQuery.Callbacks('memory')
                            ]
                        ], state = 'pending', promise = {
                            state: function () {
                                return state;
                            },
                            always: function () {
                                deferred.done(arguments).fail(arguments);
                                return this;
                            },
                            then: function () {
                                var fns = arguments;
                                return jQuery.Deferred(function (newDefer) {
                                    jQuery.each(tuples, function (i, tuple) {
                                        var fn = jQuery.isFunction(fns[i]) && fns[i];
                                        deferred[tuple[1]](function () {
                                            var returned = fn && fn.apply(this, arguments);
                                            if (returned && jQuery.isFunction(returned.promise)) {
                                                returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                                            } else {
                                                newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                            }
                                        });
                                    });
                                    fns = null;
                                }).promise();
                            },
                            promise: function (obj) {
                                return obj != null ? jQuery.extend(obj, promise) : promise;
                            }
                        }, deferred = {};
                    promise.pipe = promise.then;
                    jQuery.each(tuples, function (i, tuple) {
                        var list = tuple[2], stateString = tuple[3];
                        promise[tuple[1]] = list.add;
                        if (stateString) {
                            list.add(function () {
                                state = stateString;
                            }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                        }
                        deferred[tuple[0]] = function () {
                            deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                            return this;
                        };
                        deferred[tuple[0] + 'With'] = list.fireWith;
                    });
                    promise.promise(deferred);
                    if (func) {
                        func.call(deferred, deferred);
                    }
                    return deferred;
                },
                when: function (subordinate) {
                    var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                            return function (value) {
                                contexts[i] = this;
                                values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                if (values === progressValues) {
                                    deferred.notifyWith(contexts, values);
                                } else if (!--remaining) {
                                    deferred.resolveWith(contexts, values);
                                }
                            };
                        }, progressValues, progressContexts, resolveContexts;
                    if (length > 1) {
                        progressValues = new Array(length);
                        progressContexts = new Array(length);
                        resolveContexts = new Array(length);
                        for (; i < length; i++) {
                            if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                                resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
                            } else {
                                --remaining;
                            }
                        }
                    }
                    if (!remaining) {
                        deferred.resolveWith(resolveContexts, resolveValues);
                    }
                    return deferred.promise();
                }
            });
            var readyList;
            jQuery.fn.ready = function (fn) {
                jQuery.ready.promise().done(fn);
                return this;
            };
            jQuery.extend({
                isReady: false,
                readyWait: 1,
                holdReady: function (hold) {
                    if (hold) {
                        jQuery.readyWait++;
                    } else {
                        jQuery.ready(true);
                    }
                },
                ready: function (wait) {
                    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                        return;
                    }
                    if (!document.body) {
                        return setTimeout(jQuery.ready);
                    }
                    jQuery.isReady = true;
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }
                    readyList.resolveWith(document, [jQuery]);
                    if (jQuery.fn.trigger) {
                        jQuery(document).trigger('ready').off('ready');
                    }
                }
            });
            function detach() {
                if (document.addEventListener) {
                    document.removeEventListener('DOMContentLoaded', completed, false);
                    window.removeEventListener('load', completed, false);
                } else {
                    document.detachEvent('onreadystatechange', completed);
                    window.detachEvent('onload', completed);
                }
            }
            function completed() {
                if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
                    detach();
                    jQuery.ready();
                }
            }
            jQuery.ready.promise = function (obj) {
                if (!readyList) {
                    readyList = jQuery.Deferred();
                    if (document.readyState === 'complete') {
                        setTimeout(jQuery.ready);
                    } else if (document.addEventListener) {
                        document.addEventListener('DOMContentLoaded', completed, false);
                        window.addEventListener('load', completed, false);
                    } else {
                        document.attachEvent('onreadystatechange', completed);
                        window.attachEvent('onload', completed);
                        var top = false;
                        try {
                            top = window.frameElement == null && document.documentElement;
                        } catch (e) {
                        }
                        if (top && top.doScroll) {
                            (function doScrollCheck() {
                                if (!jQuery.isReady) {
                                    try {
                                        top.doScroll('left');
                                    } catch (e) {
                                        return setTimeout(doScrollCheck, 50);
                                    }
                                    detach();
                                    jQuery.ready();
                                }
                            }());
                        }
                    }
                }
                return readyList.promise(obj);
            };
            var strundefined = typeof undefined;
            var i;
            for (i in jQuery(support)) {
                break;
            }
            support.ownLast = i !== '0';
            support.inlineBlockNeedsLayout = false;
            jQuery(function () {
                var container, div, body = document.getElementsByTagName('body')[0];
                if (!body) {
                    return;
                }
                container = document.createElement('div');
                container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
                div = document.createElement('div');
                body.appendChild(container).appendChild(div);
                if (typeof div.style.zoom !== strundefined) {
                    div.style.cssText = 'border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1';
                    if (support.inlineBlockNeedsLayout = div.offsetWidth === 3) {
                        body.style.zoom = 1;
                    }
                }
                body.removeChild(container);
                container = div = null;
            });
            (function () {
                var div = document.createElement('div');
                if (support.deleteExpando == null) {
                    support.deleteExpando = true;
                    try {
                        delete div.test;
                    } catch (e) {
                        support.deleteExpando = false;
                    }
                }
                div = null;
            }());
            jQuery.acceptData = function (elem) {
                var noData = jQuery.noData[(elem.nodeName + ' ').toLowerCase()], nodeType = +elem.nodeType || 1;
                return nodeType !== 1 && nodeType !== 9 ? false : !noData || noData !== true && elem.getAttribute('classid') === noData;
            };
            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
            function dataAttr(elem, key, data) {
                if (data === undefined && elem.nodeType === 1) {
                    var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
                    data = elem.getAttribute(name);
                    if (typeof data === 'string') {
                        try {
                            data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                        } catch (e) {
                        }
                        jQuery.data(elem, key, data);
                    } else {
                        data = undefined;
                    }
                }
                return data;
            }
            function isEmptyDataObject(obj) {
                var name;
                for (name in obj) {
                    if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
                        continue;
                    }
                    if (name !== 'toJSON') {
                        return false;
                    }
                }
                return true;
            }
            function internalData(elem, name, data, pvt) {
                if (!jQuery.acceptData(elem)) {
                    return;
                }
                var ret, thisCache, internalKey = jQuery.expando, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
                if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === 'string') {
                    return;
                }
                if (!id) {
                    if (isNode) {
                        id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
                    } else {
                        id = internalKey;
                    }
                }
                if (!cache[id]) {
                    cache[id] = isNode ? {} : { toJSON: jQuery.noop };
                }
                if (typeof name === 'object' || typeof name === 'function') {
                    if (pvt) {
                        cache[id] = jQuery.extend(cache[id], name);
                    } else {
                        cache[id].data = jQuery.extend(cache[id].data, name);
                    }
                }
                thisCache = cache[id];
                if (!pvt) {
                    if (!thisCache.data) {
                        thisCache.data = {};
                    }
                    thisCache = thisCache.data;
                }
                if (data !== undefined) {
                    thisCache[jQuery.camelCase(name)] = data;
                }
                if (typeof name === 'string') {
                    ret = thisCache[name];
                    if (ret == null) {
                        ret = thisCache[jQuery.camelCase(name)];
                    }
                } else {
                    ret = thisCache;
                }
                return ret;
            }
            function internalRemoveData(elem, name, pvt) {
                if (!jQuery.acceptData(elem)) {
                    return;
                }
                var thisCache, i, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
                if (!cache[id]) {
                    return;
                }
                if (name) {
                    thisCache = pvt ? cache[id] : cache[id].data;
                    if (thisCache) {
                        if (!jQuery.isArray(name)) {
                            if (name in thisCache) {
                                name = [name];
                            } else {
                                name = jQuery.camelCase(name);
                                if (name in thisCache) {
                                    name = [name];
                                } else {
                                    name = name.split(' ');
                                }
                            }
                        } else {
                            name = name.concat(jQuery.map(name, jQuery.camelCase));
                        }
                        i = name.length;
                        while (i--) {
                            delete thisCache[name[i]];
                        }
                        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
                            return;
                        }
                    }
                }
                if (!pvt) {
                    delete cache[id].data;
                    if (!isEmptyDataObject(cache[id])) {
                        return;
                    }
                }
                if (isNode) {
                    jQuery.cleanData([elem], true);
                } else if (support.deleteExpando || cache != cache.window) {
                    delete cache[id];
                } else {
                    cache[id] = null;
                }
            }
            jQuery.extend({
                cache: {},
                noData: {
                    'applet ': true,
                    'embed ': true,
                    'object ': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'
                },
                hasData: function (elem) {
                    elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
                    return !!elem && !isEmptyDataObject(elem);
                },
                data: function (elem, name, data) {
                    return internalData(elem, name, data);
                },
                removeData: function (elem, name) {
                    return internalRemoveData(elem, name);
                },
                _data: function (elem, name, data) {
                    return internalData(elem, name, data, true);
                },
                _removeData: function (elem, name) {
                    return internalRemoveData(elem, name, true);
                }
            });
            jQuery.fn.extend({
                data: function (key, value) {
                    var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                    if (key === undefined) {
                        if (this.length) {
                            data = jQuery.data(elem);
                            if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
                                i = attrs.length;
                                while (i--) {
                                    name = attrs[i].name;
                                    if (name.indexOf('data-') === 0) {
                                        name = jQuery.camelCase(name.slice(5));
                                        dataAttr(elem, name, data[name]);
                                    }
                                }
                                jQuery._data(elem, 'parsedAttrs', true);
                            }
                        }
                        return data;
                    }
                    if (typeof key === 'object') {
                        return this.each(function () {
                            jQuery.data(this, key);
                        });
                    }
                    return arguments.length > 1 ? this.each(function () {
                        jQuery.data(this, key, value);
                    }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
                },
                removeData: function (key) {
                    return this.each(function () {
                        jQuery.removeData(this, key);
                    });
                }
            });
            jQuery.extend({
                queue: function (elem, type, data) {
                    var queue;
                    if (elem) {
                        type = (type || 'fx') + 'queue';
                        queue = jQuery._data(elem, type);
                        if (data) {
                            if (!queue || jQuery.isArray(data)) {
                                queue = jQuery._data(elem, type, jQuery.makeArray(data));
                            } else {
                                queue.push(data);
                            }
                        }
                        return queue || [];
                    }
                },
                dequeue: function (elem, type) {
                    type = type || 'fx';
                    var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                            jQuery.dequeue(elem, type);
                        };
                    if (fn === 'inprogress') {
                        fn = queue.shift();
                        startLength--;
                    }
                    if (fn) {
                        if (type === 'fx') {
                            queue.unshift('inprogress');
                        }
                        delete hooks.stop;
                        fn.call(elem, next, hooks);
                    }
                    if (!startLength && hooks) {
                        hooks.empty.fire();
                    }
                },
                _queueHooks: function (elem, type) {
                    var key = type + 'queueHooks';
                    return jQuery._data(elem, key) || jQuery._data(elem, key, {
                        empty: jQuery.Callbacks('once memory').add(function () {
                            jQuery._removeData(elem, type + 'queue');
                            jQuery._removeData(elem, key);
                        })
                    });
                }
            });
            jQuery.fn.extend({
                queue: function (type, data) {
                    var setter = 2;
                    if (typeof type !== 'string') {
                        data = type;
                        type = 'fx';
                        setter--;
                    }
                    if (arguments.length < setter) {
                        return jQuery.queue(this[0], type);
                    }
                    return data === undefined ? this : this.each(function () {
                        var queue = jQuery.queue(this, type, data);
                        jQuery._queueHooks(this, type);
                        if (type === 'fx' && queue[0] !== 'inprogress') {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                dequeue: function (type) {
                    return this.each(function () {
                        jQuery.dequeue(this, type);
                    });
                },
                clearQueue: function (type) {
                    return this.queue(type || 'fx', []);
                },
                promise: function (type, obj) {
                    var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                            if (!--count) {
                                defer.resolveWith(elements, [elements]);
                            }
                        };
                    if (typeof type !== 'string') {
                        obj = type;
                        type = undefined;
                    }
                    type = type || 'fx';
                    while (i--) {
                        tmp = jQuery._data(elements[i], type + 'queueHooks');
                        if (tmp && tmp.empty) {
                            count++;
                            tmp.empty.add(resolve);
                        }
                    }
                    resolve();
                    return defer.promise(obj);
                }
            });
            var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
            var cssExpand = [
                'Top',
                'Right',
                'Bottom',
                'Left'
            ];
            var isHidden = function (elem, el) {
                elem = el || elem;
                return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
            };
            var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0, length = elems.length, bulk = key == null;
                if (jQuery.type(key) === 'object') {
                    chainable = true;
                    for (i in key) {
                        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
                    }
                } else if (value !== undefined) {
                    chainable = true;
                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }
                    if (bulk) {
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;
                        } else {
                            bulk = fn;
                            fn = function (elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }
                    if (fn) {
                        for (; i < length; i++) {
                            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                        }
                    }
                }
                return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
            };
            var rcheckableType = /^(?:checkbox|radio)$/i;
            (function () {
                var fragment = document.createDocumentFragment(), div = document.createElement('div'), input = document.createElement('input');
                div.setAttribute('className', 't');
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a>';
                support.leadingWhitespace = div.firstChild.nodeType === 3;
                support.tbody = !div.getElementsByTagName('tbody').length;
                support.htmlSerialize = !!div.getElementsByTagName('link').length;
                support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '<:nav></:nav>';
                input.type = 'checkbox';
                input.checked = true;
                fragment.appendChild(input);
                support.appendChecked = input.checked;
                div.innerHTML = '<textarea>x</textarea>';
                support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
                fragment.appendChild(div);
                div.innerHTML = '<input type=\'radio\' checked=\'checked\' name=\'t\'/>';
                support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
                support.noCloneEvent = true;
                if (div.attachEvent) {
                    div.attachEvent('onclick', function () {
                        support.noCloneEvent = false;
                    });
                    div.cloneNode(true).click();
                }
                if (support.deleteExpando == null) {
                    support.deleteExpando = true;
                    try {
                        delete div.test;
                    } catch (e) {
                        support.deleteExpando = false;
                    }
                }
                fragment = div = input = null;
            }());
            (function () {
                var i, eventName, div = document.createElement('div');
                for (i in {
                        submit: true,
                        change: true,
                        focusin: true
                    }) {
                    eventName = 'on' + i;
                    if (!(support[i + 'Bubbles'] = eventName in window)) {
                        div.setAttribute(eventName, 't');
                        support[i + 'Bubbles'] = div.attributes[eventName].expando === false;
                    }
                }
                div = null;
            }());
            var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
            function returnTrue() {
                return true;
            }
            function returnFalse() {
                return false;
            }
            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch (err) {
                }
            }
            jQuery.event = {
                global: {},
                add: function (elem, types, handler, data, selector) {
                    var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
                    if (!elemData) {
                        return;
                    }
                    if (handler.handler) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }
                    if (!handler.guid) {
                        handler.guid = jQuery.guid++;
                    }
                    if (!(events = elemData.events)) {
                        events = elemData.events = {};
                    }
                    if (!(eventHandle = elemData.handle)) {
                        eventHandle = elemData.handle = function (e) {
                            return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
                        };
                        eventHandle.elem = elem;
                    }
                    types = (types || '').match(rnotwhite) || [''];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || '').split('.').sort();
                        if (!type) {
                            continue;
                        }
                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        special = jQuery.event.special[type] || {};
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                            namespace: namespaces.join('.')
                        }, handleObjIn);
                        if (!(handlers = events[type])) {
                            handlers = events[type] = [];
                            handlers.delegateCount = 0;
                            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                if (elem.addEventListener) {
                                    elem.addEventListener(type, eventHandle, false);
                                } else if (elem.attachEvent) {
                                    elem.attachEvent('on' + type, eventHandle);
                                }
                            }
                        }
                        if (special.add) {
                            special.add.call(elem, handleObj);
                            if (!handleObj.handler.guid) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }
                        if (selector) {
                            handlers.splice(handlers.delegateCount++, 0, handleObj);
                        } else {
                            handlers.push(handleObj);
                        }
                        jQuery.event.global[type] = true;
                    }
                    elem = null;
                },
                remove: function (elem, types, handler, selector, mappedTypes) {
                    var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
                    if (!elemData || !(events = elemData.events)) {
                        return;
                    }
                    types = (types || '').match(rnotwhite) || [''];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || '').split('.').sort();
                        if (!type) {
                            for (type in events) {
                                jQuery.event.remove(elem, type + types[t], handler, selector, true);
                            }
                            continue;
                        }
                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        handlers = events[type] || [];
                        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                        origCount = j = handlers.length;
                        while (j--) {
                            handleObj = handlers[j];
                            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                                handlers.splice(j, 1);
                                if (handleObj.selector) {
                                    handlers.delegateCount--;
                                }
                                if (special.remove) {
                                    special.remove.call(elem, handleObj);
                                }
                            }
                        }
                        if (origCount && !handlers.length) {
                            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                                jQuery.removeEvent(elem, type, elemData.handle);
                            }
                            delete events[type];
                        }
                    }
                    if (jQuery.isEmptyObject(events)) {
                        delete elemData.handle;
                        jQuery._removeData(elem, 'events');
                    }
                },
                trigger: function (event, data, elem, onlyHandlers) {
                    var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
                    cur = tmp = elem = elem || document;
                    if (elem.nodeType === 3 || elem.nodeType === 8) {
                        return;
                    }
                    if (rfocusMorph.test(type + jQuery.event.triggered)) {
                        return;
                    }
                    if (type.indexOf('.') >= 0) {
                        namespaces = type.split('.');
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(':') < 0 && 'on' + type;
                    event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join('.');
                    event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
                    event.result = undefined;
                    if (!event.target) {
                        event.target = elem;
                    }
                    data = data == null ? [event] : jQuery.makeArray(data, [event]);
                    special = jQuery.event.special[type] || {};
                    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                        return;
                    }
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                        bubbleType = special.delegateType || type;
                        if (!rfocusMorph.test(bubbleType + type)) {
                            cur = cur.parentNode;
                        }
                        for (; cur; cur = cur.parentNode) {
                            eventPath.push(cur);
                            tmp = cur;
                        }
                        if (tmp === (elem.ownerDocument || document)) {
                            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                        }
                    }
                    i = 0;
                    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                        event.type = i > 1 ? bubbleType : special.bindType || type;
                        handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
                        if (handle) {
                            handle.apply(cur, data);
                        }
                        handle = ontype && cur[ontype];
                        if (handle && handle.apply && jQuery.acceptData(cur)) {
                            event.result = handle.apply(cur, data);
                            if (event.result === false) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;
                    if (!onlyHandlers && !event.isDefaultPrevented()) {
                        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                            if (ontype && elem[type] && !jQuery.isWindow(elem)) {
                                tmp = elem[ontype];
                                if (tmp) {
                                    elem[ontype] = null;
                                }
                                jQuery.event.triggered = type;
                                try {
                                    elem[type]();
                                } catch (e) {
                                }
                                jQuery.event.triggered = undefined;
                                if (tmp) {
                                    elem[ontype] = tmp;
                                }
                            }
                        }
                    }
                    return event.result;
                },
                dispatch: function (event) {
                    event = jQuery.event.fix(event);
                    var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                    args[0] = event;
                    event.delegateTarget = this;
                    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                        return;
                    }
                    handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                    i = 0;
                    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                        event.currentTarget = matched.elem;
                        j = 0;
                        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                            if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                                event.handleObj = handleObj;
                                event.data = handleObj.data;
                                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }
                    if (special.postDispatch) {
                        special.postDispatch.call(this, event);
                    }
                    return event.result;
                },
                handlers: function (event, handlers) {
                    var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                    if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
                        for (; cur != this; cur = cur.parentNode || this) {
                            if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                                matches = [];
                                for (i = 0; i < delegateCount; i++) {
                                    handleObj = handlers[i];
                                    sel = handleObj.selector + ' ';
                                    if (matches[sel] === undefined) {
                                        matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                                    }
                                    if (matches[sel]) {
                                        matches.push(handleObj);
                                    }
                                }
                                if (matches.length) {
                                    handlerQueue.push({
                                        elem: cur,
                                        handlers: matches
                                    });
                                }
                            }
                        }
                    }
                    if (delegateCount < handlers.length) {
                        handlerQueue.push({
                            elem: this,
                            handlers: handlers.slice(delegateCount)
                        });
                    }
                    return handlerQueue;
                },
                fix: function (event) {
                    if (event[jQuery.expando]) {
                        return event;
                    }
                    var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
                    if (!fixHook) {
                        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
                    }
                    copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
                    event = new jQuery.Event(originalEvent);
                    i = copy.length;
                    while (i--) {
                        prop = copy[i];
                        event[prop] = originalEvent[prop];
                    }
                    if (!event.target) {
                        event.target = originalEvent.srcElement || document;
                    }
                    if (event.target.nodeType === 3) {
                        event.target = event.target.parentNode;
                    }
                    event.metaKey = !!event.metaKey;
                    return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
                },
                props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
                fixHooks: {},
                keyHooks: {
                    props: 'char charCode key keyCode'.split(' '),
                    filter: function (event, original) {
                        if (event.which == null) {
                            event.which = original.charCode != null ? original.charCode : original.keyCode;
                        }
                        return event;
                    }
                },
                mouseHooks: {
                    props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
                    filter: function (event, original) {
                        var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
                        if (event.pageX == null && original.clientX != null) {
                            eventDoc = event.target.ownerDocument || document;
                            doc = eventDoc.documentElement;
                            body = eventDoc.body;
                            event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                            event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                        }
                        if (!event.relatedTarget && fromElement) {
                            event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                        }
                        if (!event.which && button !== undefined) {
                            event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                        }
                        return event;
                    }
                },
                special: {
                    load: { noBubble: true },
                    focus: {
                        trigger: function () {
                            if (this !== safeActiveElement() && this.focus) {
                                try {
                                    this.focus();
                                    return false;
                                } catch (e) {
                                }
                            }
                        },
                        delegateType: 'focusin'
                    },
                    blur: {
                        trigger: function () {
                            if (this === safeActiveElement() && this.blur) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: 'focusout'
                    },
                    click: {
                        trigger: function () {
                            if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
                                this.click();
                                return false;
                            }
                        },
                        _default: function (event) {
                            return jQuery.nodeName(event.target, 'a');
                        }
                    },
                    beforeunload: {
                        postDispatch: function (event) {
                            if (event.result !== undefined) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                },
                simulate: function (type, elem, event, bubble) {
                    var e = jQuery.extend(new jQuery.Event(), event, {
                        type: type,
                        isSimulated: true,
                        originalEvent: {}
                    });
                    if (bubble) {
                        jQuery.event.trigger(e, null, elem);
                    } else {
                        jQuery.event.dispatch.call(elem, e);
                    }
                    if (e.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                }
            };
            jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
                if (elem.removeEventListener) {
                    elem.removeEventListener(type, handle, false);
                }
            } : function (elem, type, handle) {
                var name = 'on' + type;
                if (elem.detachEvent) {
                    if (typeof elem[name] === strundefined) {
                        elem[name] = null;
                    }
                    elem.detachEvent(name, handle);
                }
            };
            jQuery.Event = function (src, props) {
                if (!(this instanceof jQuery.Event)) {
                    return new jQuery.Event(src, props);
                }
                if (src && src.type) {
                    this.originalEvent = src;
                    this.type = src.type;
                    this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && (src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;
                } else {
                    this.type = src;
                }
                if (props) {
                    jQuery.extend(this, props);
                }
                this.timeStamp = src && src.timeStamp || jQuery.now();
                this[jQuery.expando] = true;
            };
            jQuery.Event.prototype = {
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,
                preventDefault: function () {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = returnTrue;
                    if (!e) {
                        return;
                    }
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                },
                stopPropagation: function () {
                    var e = this.originalEvent;
                    this.isPropagationStopped = returnTrue;
                    if (!e) {
                        return;
                    }
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }
                    e.cancelBubble = true;
                },
                stopImmediatePropagation: function () {
                    this.isImmediatePropagationStopped = returnTrue;
                    this.stopPropagation();
                }
            };
            jQuery.each({
                mouseenter: 'mouseover',
                mouseleave: 'mouseout'
            }, function (orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,
                    handle: function (event) {
                        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                        if (!related || related !== target && !jQuery.contains(target, related)) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply(this, arguments);
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });
            if (!support.submitBubbles) {
                jQuery.event.special.submit = {
                    setup: function () {
                        if (jQuery.nodeName(this, 'form')) {
                            return false;
                        }
                        jQuery.event.add(this, 'click._submit keypress._submit', function (e) {
                            var elem = e.target, form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
                            if (form && !jQuery._data(form, 'submitBubbles')) {
                                jQuery.event.add(form, 'submit._submit', function (event) {
                                    event._submit_bubble = true;
                                });
                                jQuery._data(form, 'submitBubbles', true);
                            }
                        });
                    },
                    postDispatch: function (event) {
                        if (event._submit_bubble) {
                            delete event._submit_bubble;
                            if (this.parentNode && !event.isTrigger) {
                                jQuery.event.simulate('submit', this.parentNode, event, true);
                            }
                        }
                    },
                    teardown: function () {
                        if (jQuery.nodeName(this, 'form')) {
                            return false;
                        }
                        jQuery.event.remove(this, '._submit');
                    }
                };
            }
            if (!support.changeBubbles) {
                jQuery.event.special.change = {
                    setup: function () {
                        if (rformElems.test(this.nodeName)) {
                            if (this.type === 'checkbox' || this.type === 'radio') {
                                jQuery.event.add(this, 'propertychange._change', function (event) {
                                    if (event.originalEvent.propertyName === 'checked') {
                                        this._just_changed = true;
                                    }
                                });
                                jQuery.event.add(this, 'click._change', function (event) {
                                    if (this._just_changed && !event.isTrigger) {
                                        this._just_changed = false;
                                    }
                                    jQuery.event.simulate('change', this, event, true);
                                });
                            }
                            return false;
                        }
                        jQuery.event.add(this, 'beforeactivate._change', function (e) {
                            var elem = e.target;
                            if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
                                jQuery.event.add(elem, 'change._change', function (event) {
                                    if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                        jQuery.event.simulate('change', this.parentNode, event, true);
                                    }
                                });
                                jQuery._data(elem, 'changeBubbles', true);
                            }
                        });
                    },
                    handle: function (event) {
                        var elem = event.target;
                        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== 'radio' && elem.type !== 'checkbox') {
                            return event.handleObj.handler.apply(this, arguments);
                        }
                    },
                    teardown: function () {
                        jQuery.event.remove(this, '._change');
                        return !rformElems.test(this.nodeName);
                    }
                };
            }
            if (!support.focusinBubbles) {
                jQuery.each({
                    focus: 'focusin',
                    blur: 'focusout'
                }, function (orig, fix) {
                    var handler = function (event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                    };
                    jQuery.event.special[fix] = {
                        setup: function () {
                            var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
                            if (!attaches) {
                                doc.addEventListener(orig, handler, true);
                            }
                            jQuery._data(doc, fix, (attaches || 0) + 1);
                        },
                        teardown: function () {
                            var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
                            if (!attaches) {
                                doc.removeEventListener(orig, handler, true);
                                jQuery._removeData(doc, fix);
                            } else {
                                jQuery._data(doc, fix, attaches);
                            }
                        }
                    };
                });
            }
            jQuery.fn.extend({
                on: function (types, selector, data, fn, one) {
                    var type, origFn;
                    if (typeof types === 'object') {
                        if (typeof selector !== 'string') {
                            data = data || selector;
                            selector = undefined;
                        }
                        for (type in types) {
                            this.on(type, selector, data, types[type], one);
                        }
                        return this;
                    }
                    if (data == null && fn == null) {
                        fn = selector;
                        data = selector = undefined;
                    } else if (fn == null) {
                        if (typeof selector === 'string') {
                            fn = data;
                            data = undefined;
                        } else {
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    } else if (!fn) {
                        return this;
                    }
                    if (one === 1) {
                        origFn = fn;
                        fn = function (event) {
                            jQuery().off(event);
                            return origFn.apply(this, arguments);
                        };
                        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                    }
                    return this.each(function () {
                        jQuery.event.add(this, types, fn, data, selector);
                    });
                },
                one: function (types, selector, data, fn) {
                    return this.on(types, selector, data, fn, 1);
                },
                off: function (types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj) {
                        handleObj = types.handleObj;
                        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                        return this;
                    }
                    if (typeof types === 'object') {
                        for (type in types) {
                            this.off(type, selector, types[type]);
                        }
                        return this;
                    }
                    if (selector === false || typeof selector === 'function') {
                        fn = selector;
                        selector = undefined;
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    }
                    return this.each(function () {
                        jQuery.event.remove(this, types, fn, selector);
                    });
                },
                trigger: function (type, data) {
                    return this.each(function () {
                        jQuery.event.trigger(type, data, this);
                    });
                },
                triggerHandler: function (type, data) {
                    var elem = this[0];
                    if (elem) {
                        return jQuery.event.trigger(type, data, elem, true);
                    }
                }
            });
            function createSafeFragment(document) {
                var list = nodeNames.split('|'), safeFrag = document.createDocumentFragment();
                if (safeFrag.createElement) {
                    while (list.length) {
                        safeFrag.createElement(list.pop());
                    }
                }
                return safeFrag;
            }
            var nodeNames = 'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video', rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp('<(?:' + nodeNames + ')[\\s/>]', 'i'), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
                    option: [
                        1,
                        '<select multiple=\'multiple\'>',
                        '</select>'
                    ],
                    legend: [
                        1,
                        '<fieldset>',
                        '</fieldset>'
                    ],
                    area: [
                        1,
                        '<map>',
                        '</map>'
                    ],
                    param: [
                        1,
                        '<object>',
                        '</object>'
                    ],
                    thead: [
                        1,
                        '<table>',
                        '</table>'
                    ],
                    tr: [
                        2,
                        '<table><tbody>',
                        '</tbody></table>'
                    ],
                    col: [
                        2,
                        '<table><tbody></tbody><colgroup>',
                        '</colgroup></table>'
                    ],
                    td: [
                        3,
                        '<table><tbody><tr>',
                        '</tr></tbody></table>'
                    ],
                    _default: support.htmlSerialize ? [
                        0,
                        '',
                        ''
                    ] : [
                        1,
                        'X<div>',
                        '</div>'
                    ]
                }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement('div'));
            wrapMap.optgroup = wrapMap.option;
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;
            function getAll(context, tag) {
                var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || '*') : undefined;
                if (!found) {
                    for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
                        if (!tag || jQuery.nodeName(elem, tag)) {
                            found.push(elem);
                        } else {
                            jQuery.merge(found, getAll(elem, tag));
                        }
                    }
                }
                return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
            }
            function fixDefaultChecked(elem) {
                if (rcheckableType.test(elem.type)) {
                    elem.defaultChecked = elem.checked;
                }
            }
            function manipulationTarget(elem, content) {
                return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
            }
            function disableScript(elem) {
                elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
                return elem;
            }
            function restoreScript(elem) {
                var match = rscriptTypeMasked.exec(elem.type);
                if (match) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute('type');
                }
                return elem;
            }
            function setGlobalEval(elems, refElements) {
                var elem, i = 0;
                for (; (elem = elems[i]) != null; i++) {
                    jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
                }
            }
            function cloneCopyEvent(src, dest) {
                if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
                    return;
                }
                var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
                if (events) {
                    delete curData.handle;
                    curData.events = {};
                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i]);
                        }
                    }
                }
                if (curData.data) {
                    curData.data = jQuery.extend({}, curData.data);
                }
            }
            function fixCloneNodeIssues(src, dest) {
                var nodeName, e, data;
                if (dest.nodeType !== 1) {
                    return;
                }
                nodeName = dest.nodeName.toLowerCase();
                if (!support.noCloneEvent && dest[jQuery.expando]) {
                    data = jQuery._data(dest);
                    for (e in data.events) {
                        jQuery.removeEvent(dest, e, data.handle);
                    }
                    dest.removeAttribute(jQuery.expando);
                }
                if (nodeName === 'script' && dest.text !== src.text) {
                    disableScript(dest).text = src.text;
                    restoreScript(dest);
                } else if (nodeName === 'object') {
                    if (dest.parentNode) {
                        dest.outerHTML = src.outerHTML;
                    }
                    if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                        dest.innerHTML = src.innerHTML;
                    }
                } else if (nodeName === 'input' && rcheckableType.test(src.type)) {
                    dest.defaultChecked = dest.checked = src.checked;
                    if (dest.value !== src.value) {
                        dest.value = src.value;
                    }
                } else if (nodeName === 'option') {
                    dest.defaultSelected = dest.selected = src.defaultSelected;
                } else if (nodeName === 'input' || nodeName === 'textarea') {
                    dest.defaultValue = src.defaultValue;
                }
            }
            jQuery.extend({
                clone: function (elem, dataAndEvents, deepDataAndEvents) {
                    var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
                    if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('<' + elem.nodeName + '>')) {
                        clone = elem.cloneNode(true);
                    } else {
                        fragmentDiv.innerHTML = elem.outerHTML;
                        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
                    }
                    if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                        destElements = getAll(clone);
                        srcElements = getAll(elem);
                        for (i = 0; (node = srcElements[i]) != null; ++i) {
                            if (destElements[i]) {
                                fixCloneNodeIssues(node, destElements[i]);
                            }
                        }
                    }
                    if (dataAndEvents) {
                        if (deepDataAndEvents) {
                            srcElements = srcElements || getAll(elem);
                            destElements = destElements || getAll(clone);
                            for (i = 0; (node = srcElements[i]) != null; i++) {
                                cloneCopyEvent(node, destElements[i]);
                            }
                        } else {
                            cloneCopyEvent(elem, clone);
                        }
                    }
                    destElements = getAll(clone, 'script');
                    if (destElements.length > 0) {
                        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
                    }
                    destElements = srcElements = node = null;
                    return clone;
                },
                buildFragment: function (elems, context, scripts, selection) {
                    var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, safe = createSafeFragment(context), nodes = [], i = 0;
                    for (; i < l; i++) {
                        elem = elems[i];
                        if (elem || elem === 0) {
                            if (jQuery.type(elem) === 'object') {
                                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                            } else if (!rhtml.test(elem)) {
                                nodes.push(context.createTextNode(elem));
                            } else {
                                tmp = tmp || safe.appendChild(context.createElement('div'));
                                tag = (rtagName.exec(elem) || [
                                    '',
                                    ''
                                ])[1].toLowerCase();
                                wrap = wrapMap[tag] || wrapMap._default;
                                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
                                j = wrap[0];
                                while (j--) {
                                    tmp = tmp.lastChild;
                                }
                                if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                                    nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
                                }
                                if (!support.tbody) {
                                    elem = tag === 'table' && !rtbody.test(elem) ? tmp.firstChild : wrap[1] === '<table>' && !rtbody.test(elem) ? tmp : 0;
                                    j = elem && elem.childNodes.length;
                                    while (j--) {
                                        if (jQuery.nodeName(tbody = elem.childNodes[j], 'tbody') && !tbody.childNodes.length) {
                                            elem.removeChild(tbody);
                                        }
                                    }
                                }
                                jQuery.merge(nodes, tmp.childNodes);
                                tmp.textContent = '';
                                while (tmp.firstChild) {
                                    tmp.removeChild(tmp.firstChild);
                                }
                                tmp = safe.lastChild;
                            }
                        }
                    }
                    if (tmp) {
                        safe.removeChild(tmp);
                    }
                    if (!support.appendChecked) {
                        jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
                    }
                    i = 0;
                    while (elem = nodes[i++]) {
                        if (selection && jQuery.inArray(elem, selection) !== -1) {
                            continue;
                        }
                        contains = jQuery.contains(elem.ownerDocument, elem);
                        tmp = getAll(safe.appendChild(elem), 'script');
                        if (contains) {
                            setGlobalEval(tmp);
                        }
                        if (scripts) {
                            j = 0;
                            while (elem = tmp[j++]) {
                                if (rscriptType.test(elem.type || '')) {
                                    scripts.push(elem);
                                }
                            }
                        }
                    }
                    tmp = null;
                    return safe;
                },
                cleanData: function (elems, acceptData) {
                    var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special;
                    for (; (elem = elems[i]) != null; i++) {
                        if (acceptData || jQuery.acceptData(elem)) {
                            id = elem[internalKey];
                            data = id && cache[id];
                            if (data) {
                                if (data.events) {
                                    for (type in data.events) {
                                        if (special[type]) {
                                            jQuery.event.remove(elem, type);
                                        } else {
                                            jQuery.removeEvent(elem, type, data.handle);
                                        }
                                    }
                                }
                                if (cache[id]) {
                                    delete cache[id];
                                    if (deleteExpando) {
                                        delete elem[internalKey];
                                    } else if (typeof elem.removeAttribute !== strundefined) {
                                        elem.removeAttribute(internalKey);
                                    } else {
                                        elem[internalKey] = null;
                                    }
                                    deletedIds.push(id);
                                }
                            }
                        }
                    }
                }
            });
            jQuery.fn.extend({
                text: function (value) {
                    return access(this, function (value) {
                        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
                    }, null, value, arguments.length);
                },
                append: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem);
                        }
                    });
                },
                prepend: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild);
                        }
                    });
                },
                before: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this);
                        }
                    });
                },
                after: function () {
                    return this.domManip(arguments, function (elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this.nextSibling);
                        }
                    });
                },
                remove: function (selector, keepData) {
                    var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
                    for (; (elem = elems[i]) != null; i++) {
                        if (!keepData && elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem));
                        }
                        if (elem.parentNode) {
                            if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                                setGlobalEval(getAll(elem, 'script'));
                            }
                            elem.parentNode.removeChild(elem);
                        }
                    }
                    return this;
                },
                empty: function () {
                    var elem, i = 0;
                    for (; (elem = this[i]) != null; i++) {
                        if (elem.nodeType === 1) {
                            jQuery.cleanData(getAll(elem, false));
                        }
                        while (elem.firstChild) {
                            elem.removeChild(elem.firstChild);
                        }
                        if (elem.options && jQuery.nodeName(elem, 'select')) {
                            elem.options.length = 0;
                        }
                    }
                    return this;
                },
                clone: function (dataAndEvents, deepDataAndEvents) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                    return this.map(function () {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                    });
                },
                html: function (value) {
                    return access(this, function (value) {
                        var elem = this[0] || {}, i = 0, l = this.length;
                        if (value === undefined) {
                            return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
                        }
                        if (typeof value === 'string' && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [
                                '',
                                ''
                            ])[1].toLowerCase()]) {
                            value = value.replace(rxhtmlTag, '<$1></$2>');
                            try {
                                for (; i < l; i++) {
                                    elem = this[i] || {};
                                    if (elem.nodeType === 1) {
                                        jQuery.cleanData(getAll(elem, false));
                                        elem.innerHTML = value;
                                    }
                                }
                                elem = 0;
                            } catch (e) {
                            }
                        }
                        if (elem) {
                            this.empty().append(value);
                        }
                    }, null, value, arguments.length);
                },
                replaceWith: function () {
                    var arg = arguments[0];
                    this.domManip(arguments, function (elem) {
                        arg = this.parentNode;
                        jQuery.cleanData(getAll(this));
                        if (arg) {
                            arg.replaceChild(elem, this);
                        }
                    });
                    return arg && (arg.length || arg.nodeType) ? this : this.remove();
                },
                detach: function (selector) {
                    return this.remove(selector, true);
                },
                domManip: function (args, callback) {
                    args = concat.apply([], args);
                    var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
                    if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                        return this.each(function (index) {
                            var self = set.eq(index);
                            if (isFunction) {
                                args[0] = value.call(this, index, self.html());
                            }
                            self.domManip(args, callback);
                        });
                    }
                    if (l) {
                        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
                        first = fragment.firstChild;
                        if (fragment.childNodes.length === 1) {
                            fragment = first;
                        }
                        if (first) {
                            scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                            hasScripts = scripts.length;
                            for (; i < l; i++) {
                                node = fragment;
                                if (i !== iNoClone) {
                                    node = jQuery.clone(node, true, true);
                                    if (hasScripts) {
                                        jQuery.merge(scripts, getAll(node, 'script'));
                                    }
                                }
                                callback.call(this[i], node, i);
                            }
                            if (hasScripts) {
                                doc = scripts[scripts.length - 1].ownerDocument;
                                jQuery.map(scripts, restoreScript);
                                for (i = 0; i < hasScripts; i++) {
                                    node = scripts[i];
                                    if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
                                        if (node.src) {
                                            if (jQuery._evalUrl) {
                                                jQuery._evalUrl(node.src);
                                            }
                                        } else {
                                            jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
                                        }
                                    }
                                }
                            }
                            fragment = first = null;
                        }
                    }
                    return this;
                }
            });
            jQuery.each({
                appendTo: 'append',
                prependTo: 'prepend',
                insertBefore: 'before',
                insertAfter: 'after',
                replaceAll: 'replaceWith'
            }, function (name, original) {
                jQuery.fn[name] = function (selector) {
                    var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
                    for (; i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        jQuery(insert[i])[original](elems);
                        push.apply(ret, elems.get());
                    }
                    return this.pushStack(ret);
                };
            });
            var iframe, elemdisplay = {};
            function actualDisplay(name, doc) {
                var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle ? window.getDefaultComputedStyle(elem[0]).display : jQuery.css(elem[0], 'display');
                elem.detach();
                return display;
            }
            function defaultDisplay(nodeName) {
                var doc = document, display = elemdisplay[nodeName];
                if (!display) {
                    display = actualDisplay(nodeName, doc);
                    if (display === 'none' || !display) {
                        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
                        doc.write();
                        doc.close();
                        display = actualDisplay(nodeName, doc);
                        iframe.detach();
                    }
                    elemdisplay[nodeName] = display;
                }
                return display;
            }
            (function () {
                var a, shrinkWrapBlocksVal, div = document.createElement('div'), divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                a = div.getElementsByTagName('a')[0];
                a.style.cssText = 'float:left;opacity:.5';
                support.opacity = /^0.5/.test(a.style.opacity);
                support.cssFloat = !!a.style.cssFloat;
                div.style.backgroundClip = 'content-box';
                div.cloneNode(true).style.backgroundClip = '';
                support.clearCloneStyle = div.style.backgroundClip === 'content-box';
                a = div = null;
                support.shrinkWrapBlocks = function () {
                    var body, container, div, containerStyles;
                    if (shrinkWrapBlocksVal == null) {
                        body = document.getElementsByTagName('body')[0];
                        if (!body) {
                            return;
                        }
                        containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px';
                        container = document.createElement('div');
                        div = document.createElement('div');
                        body.appendChild(container).appendChild(div);
                        shrinkWrapBlocksVal = false;
                        if (typeof div.style.zoom !== strundefined) {
                            div.style.cssText = divReset + ';width:1px;padding:1px;zoom:1';
                            div.innerHTML = '<div></div>';
                            div.firstChild.style.width = '5px';
                            shrinkWrapBlocksVal = div.offsetWidth !== 3;
                        }
                        body.removeChild(container);
                        body = container = div = null;
                    }
                    return shrinkWrapBlocksVal;
                };
            }());
            var rmargin = /^margin/;
            var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
            var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
            if (window.getComputedStyle) {
                getStyles = function (elem) {
                    return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
                };
                curCSS = function (elem, name, computed) {
                    var width, minWidth, maxWidth, ret, style = elem.style;
                    computed = computed || getStyles(elem);
                    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
                    if (computed) {
                        if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
                            ret = jQuery.style(elem, name);
                        }
                        if (rnumnonpx.test(ret) && rmargin.test(name)) {
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }
                    return ret === undefined ? ret : ret + '';
                };
            } else if (document.documentElement.currentStyle) {
                getStyles = function (elem) {
                    return elem.currentStyle;
                };
                curCSS = function (elem, name, computed) {
                    var left, rs, rsLeft, ret, style = elem.style;
                    computed = computed || getStyles(elem);
                    ret = computed ? computed[name] : undefined;
                    if (ret == null && style && style[name]) {
                        ret = style[name];
                    }
                    if (rnumnonpx.test(ret) && !rposition.test(name)) {
                        left = style.left;
                        rs = elem.runtimeStyle;
                        rsLeft = rs && rs.left;
                        if (rsLeft) {
                            rs.left = elem.currentStyle.left;
                        }
                        style.left = name === 'fontSize' ? '1em' : ret;
                        ret = style.pixelLeft + 'px';
                        style.left = left;
                        if (rsLeft) {
                            rs.left = rsLeft;
                        }
                    }
                    return ret === undefined ? ret : ret + '' || 'auto';
                };
            }
            function addGetHookIf(conditionFn, hookFn) {
                return {
                    get: function () {
                        var condition = conditionFn();
                        if (condition == null) {
                            return;
                        }
                        if (condition) {
                            delete this.get;
                            return;
                        }
                        return (this.get = hookFn).apply(this, arguments);
                    }
                };
            }
            (function () {
                var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal, pixelPositionVal, reliableMarginRightVal, div = document.createElement('div'), containerStyles = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px', divReset = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;' + 'display:block;padding:0;margin:0;border:0';
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                a = div.getElementsByTagName('a')[0];
                a.style.cssText = 'float:left;opacity:.5';
                support.opacity = /^0.5/.test(a.style.opacity);
                support.cssFloat = !!a.style.cssFloat;
                div.style.backgroundClip = 'content-box';
                div.cloneNode(true).style.backgroundClip = '';
                support.clearCloneStyle = div.style.backgroundClip === 'content-box';
                a = div = null;
                jQuery.extend(support, {
                    reliableHiddenOffsets: function () {
                        if (reliableHiddenOffsetsVal != null) {
                            return reliableHiddenOffsetsVal;
                        }
                        var container, tds, isSupported, div = document.createElement('div'), body = document.getElementsByTagName('body')[0];
                        if (!body) {
                            return;
                        }
                        div.setAttribute('className', 't');
                        div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                        container = document.createElement('div');
                        container.style.cssText = containerStyles;
                        body.appendChild(container).appendChild(div);
                        div.innerHTML = '<table><tr><td></td><td>t</td></tr></table>';
                        tds = div.getElementsByTagName('td');
                        tds[0].style.cssText = 'padding:0;margin:0;border:0;display:none';
                        isSupported = tds[0].offsetHeight === 0;
                        tds[0].style.display = '';
                        tds[1].style.display = 'none';
                        reliableHiddenOffsetsVal = isSupported && tds[0].offsetHeight === 0;
                        body.removeChild(container);
                        div = body = null;
                        return reliableHiddenOffsetsVal;
                    },
                    boxSizing: function () {
                        if (boxSizingVal == null) {
                            computeStyleTests();
                        }
                        return boxSizingVal;
                    },
                    boxSizingReliable: function () {
                        if (boxSizingReliableVal == null) {
                            computeStyleTests();
                        }
                        return boxSizingReliableVal;
                    },
                    pixelPosition: function () {
                        if (pixelPositionVal == null) {
                            computeStyleTests();
                        }
                        return pixelPositionVal;
                    },
                    reliableMarginRight: function () {
                        var body, container, div, marginDiv;
                        if (reliableMarginRightVal == null && window.getComputedStyle) {
                            body = document.getElementsByTagName('body')[0];
                            if (!body) {
                                return;
                            }
                            container = document.createElement('div');
                            div = document.createElement('div');
                            container.style.cssText = containerStyles;
                            body.appendChild(container).appendChild(div);
                            marginDiv = div.appendChild(document.createElement('div'));
                            marginDiv.style.cssText = div.style.cssText = divReset;
                            marginDiv.style.marginRight = marginDiv.style.width = '0';
                            div.style.width = '1px';
                            reliableMarginRightVal = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
                            body.removeChild(container);
                        }
                        return reliableMarginRightVal;
                    }
                });
                function computeStyleTests() {
                    var container, div, body = document.getElementsByTagName('body')[0];
                    if (!body) {
                        return;
                    }
                    container = document.createElement('div');
                    div = document.createElement('div');
                    container.style.cssText = containerStyles;
                    body.appendChild(container).appendChild(div);
                    div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' + 'position:absolute;display:block;padding:1px;border:1px;width:4px;' + 'margin-top:1%;top:1%';
                    jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
                        boxSizingVal = div.offsetWidth === 4;
                    });
                    boxSizingReliableVal = true;
                    pixelPositionVal = false;
                    reliableMarginRightVal = true;
                    if (window.getComputedStyle) {
                        pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== '1%';
                        boxSizingReliableVal = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
                    }
                    body.removeChild(container);
                    div = body = null;
                }
            }());
            jQuery.swap = function (elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }
                ret = callback.apply(elem, args || []);
                for (name in options) {
                    elem.style[name] = old[name];
                }
                return ret;
            };
            var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])=(' + pnum + ')', 'i'), cssShow = {
                    position: 'absolute',
                    visibility: 'hidden',
                    display: 'block'
                }, cssNormalTransform = {
                    letterSpacing: 0,
                    fontWeight: 400
                }, cssPrefixes = [
                    'Webkit',
                    'O',
                    'Moz',
                    'ms'
                ];
            function vendorPropName(style, name) {
                if (name in style) {
                    return name;
                }
                var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
                while (i--) {
                    name = cssPrefixes[i] + capName;
                    if (name in style) {
                        return name;
                    }
                }
                return origName;
            }
            function showHide(elements, show) {
                var display, elem, hidden, values = [], index = 0, length = elements.length;
                for (; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    values[index] = jQuery._data(elem, 'olddisplay');
                    display = elem.style.display;
                    if (show) {
                        if (!values[index] && display === 'none') {
                            elem.style.display = '';
                        }
                        if (elem.style.display === '' && isHidden(elem)) {
                            values[index] = jQuery._data(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                        }
                    } else {
                        if (!values[index]) {
                            hidden = isHidden(elem);
                            if (display && display !== 'none' || !hidden) {
                                jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                            }
                        }
                    }
                }
                for (index = 0; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }
                    if (!show || elem.style.display === 'none' || elem.style.display === '') {
                        elem.style.display = show ? values[index] || '' : 'none';
                    }
                }
                return elements;
            }
            function setPositiveNumber(elem, value, subtract) {
                var matches = rnumsplit.exec(value);
                return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
            }
            function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
                for (; i < 4; i += 2) {
                    if (extra === 'margin') {
                        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                    }
                    if (isBorderBox) {
                        if (extra === 'content') {
                            val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                        }
                        if (extra !== 'margin') {
                            val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                        }
                    } else {
                        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                        if (extra !== 'padding') {
                            val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                        }
                    }
                }
                return val;
            }
            function getWidthOrHeight(elem, name, extra) {
                var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
                if (val <= 0 || val == null) {
                    val = curCSS(elem, name, styles);
                    if (val < 0 || val == null) {
                        val = elem.style[name];
                    }
                    if (rnumnonpx.test(val)) {
                        return val;
                    }
                    valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
                    val = parseFloat(val) || 0;
                }
                return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
            }
            jQuery.extend({
                cssHooks: {
                    opacity: {
                        get: function (elem, computed) {
                            if (computed) {
                                var ret = curCSS(elem, 'opacity');
                                return ret === '' ? '1' : ret;
                            }
                        }
                    }
                },
                cssNumber: {
                    'columnCount': true,
                    'fillOpacity': true,
                    'fontWeight': true,
                    'lineHeight': true,
                    'opacity': true,
                    'order': true,
                    'orphans': true,
                    'widows': true,
                    'zIndex': true,
                    'zoom': true
                },
                cssProps: { 'float': support.cssFloat ? 'cssFloat' : 'styleFloat' },
                style: function (elem, name, value, extra) {
                    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                        return;
                    }
                    var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                    if (value !== undefined) {
                        type = typeof value;
                        if (type === 'string' && (ret = rrelNum.exec(value))) {
                            value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                            type = 'number';
                        }
                        if (value == null || value !== value) {
                            return;
                        }
                        if (type === 'number' && !jQuery.cssNumber[origName]) {
                            value += 'px';
                        }
                        if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                            style[name] = 'inherit';
                        }
                        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                            try {
                                style[name] = '';
                                style[name] = value;
                            } catch (e) {
                            }
                        }
                    } else {
                        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                            return ret;
                        }
                        return style[name];
                    }
                },
                css: function (elem, name, extra, styles) {
                    var num, val, hooks, origName = jQuery.camelCase(name);
                    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                    if (hooks && 'get' in hooks) {
                        val = hooks.get(elem, true, extra);
                    }
                    if (val === undefined) {
                        val = curCSS(elem, name, styles);
                    }
                    if (val === 'normal' && name in cssNormalTransform) {
                        val = cssNormalTransform[name];
                    }
                    if (extra === '' || extra) {
                        num = parseFloat(val);
                        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
                    }
                    return val;
                }
            });
            jQuery.each([
                'height',
                'width'
            ], function (i, name) {
                jQuery.cssHooks[name] = {
                    get: function (elem, computed, extra) {
                        if (computed) {
                            return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
                                return getWidthOrHeight(elem, name, extra);
                            }) : getWidthOrHeight(elem, name, extra);
                        }
                    },
                    set: function (elem, value, extra) {
                        var styles = extra && getStyles(elem);
                        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing() && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
                    }
                };
            });
            if (!support.opacity) {
                jQuery.cssHooks.opacity = {
                    get: function (elem, computed) {
                        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '') ? 0.01 * parseFloat(RegExp.$1) + '' : computed ? '1' : '';
                    },
                    set: function (elem, value) {
                        var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? 'alpha(opacity=' + value * 100 + ')' : '', filter = currentStyle && currentStyle.filter || style.filter || '';
                        style.zoom = 1;
                        if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
                            style.removeAttribute('filter');
                            if (value === '' || currentStyle && !currentStyle.filter) {
                                return;
                            }
                        }
                        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
                    }
                };
            }
            jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
                if (computed) {
                    return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
                        elem,
                        'marginRight'
                    ]);
                }
            });
            jQuery.each({
                margin: '',
                padding: '',
                border: 'Width'
            }, function (prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function (value) {
                        var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                        for (; i < 4; i++) {
                            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                        }
                        return expanded;
                    }
                };
                if (!rmargin.test(prefix)) {
                    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
            });
            jQuery.fn.extend({
                css: function (name, value) {
                    return access(this, function (elem, name, value) {
                        var styles, len, map = {}, i = 0;
                        if (jQuery.isArray(name)) {
                            styles = getStyles(elem);
                            len = name.length;
                            for (; i < len; i++) {
                                map[name[i]] = jQuery.css(elem, name[i], false, styles);
                            }
                            return map;
                        }
                        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                    }, name, value, arguments.length > 1);
                },
                show: function () {
                    return showHide(this, true);
                },
                hide: function () {
                    return showHide(this);
                },
                toggle: function (state) {
                    if (typeof state === 'boolean') {
                        return state ? this.show() : this.hide();
                    }
                    return this.each(function () {
                        if (isHidden(this)) {
                            jQuery(this).show();
                        } else {
                            jQuery(this).hide();
                        }
                    });
                }
            });
            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem, options, prop, end, easing);
            }
            jQuery.Tween = Tween;
            Tween.prototype = {
                constructor: Tween,
                init: function (elem, options, prop, end, easing, unit) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || 'swing';
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
                },
                cur: function () {
                    var hooks = Tween.propHooks[this.prop];
                    return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
                },
                run: function (percent) {
                    var eased, hooks = Tween.propHooks[this.prop];
                    if (this.options.duration) {
                        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = (this.end - this.start) * eased + this.start;
                    if (this.options.step) {
                        this.options.step.call(this.elem, this.now, this);
                    }
                    if (hooks && hooks.set) {
                        hooks.set(this);
                    } else {
                        Tween.propHooks._default.set(this);
                    }
                    return this;
                }
            };
            Tween.prototype.init.prototype = Tween.prototype;
            Tween.propHooks = {
                _default: {
                    get: function (tween) {
                        var result;
                        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                            return tween.elem[tween.prop];
                        }
                        result = jQuery.css(tween.elem, tween.prop, '');
                        return !result || result === 'auto' ? 0 : result;
                    },
                    set: function (tween) {
                        if (jQuery.fx.step[tween.prop]) {
                            jQuery.fx.step[tween.prop](tween);
                        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                        } else {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                }
            };
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function (tween) {
                    if (tween.elem.nodeType && tween.elem.parentNode) {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            };
            jQuery.easing = {
                linear: function (p) {
                    return p;
                },
                swing: function (p) {
                    return 0.5 - Math.cos(p * Math.PI) / 2;
                }
            };
            jQuery.fx = Tween.prototype.init;
            jQuery.fx.step = {};
            var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
                    '*': [function (prop, value) {
                            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
                            if (start && start[3] !== unit) {
                                unit = unit || start[3];
                                parts = parts || [];
                                start = +target || 1;
                                do {
                                    scale = scale || '.5';
                                    start = start / scale;
                                    jQuery.style(tween.elem, prop, start + unit);
                                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                            }
                            if (parts) {
                                start = tween.start = +start || +target || 0;
                                tween.unit = unit;
                                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
                            }
                            return tween;
                        }]
                };
            function createFxNow() {
                setTimeout(function () {
                    fxNow = undefined;
                });
                return fxNow = jQuery.now();
            }
            function genFx(type, includeWidth) {
                var which, attrs = { height: type }, i = 0;
                includeWidth = includeWidth ? 1 : 0;
                for (; i < 4; i += 2 - includeWidth) {
                    which = cssExpand[i];
                    attrs['margin' + which] = attrs['padding' + which] = type;
                }
                if (includeWidth) {
                    attrs.opacity = attrs.width = type;
                }
                return attrs;
            }
            function createTween(value, prop, animation) {
                var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
                for (; index < length; index++) {
                    if (tween = collection[index].call(animation, prop, value)) {
                        return tween;
                    }
                }
            }
            function defaultPrefilter(elem, props, opts) {
                var prop, value, toggle, tween, hooks, oldfire, display, dDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, 'fxshow');
                if (!opts.queue) {
                    hooks = jQuery._queueHooks(elem, 'fx');
                    if (hooks.unqueued == null) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function () {
                            if (!hooks.unqueued) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;
                    anim.always(function () {
                        anim.always(function () {
                            hooks.unqueued--;
                            if (!jQuery.queue(elem, 'fx').length) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }
                if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
                    opts.overflow = [
                        style.overflow,
                        style.overflowX,
                        style.overflowY
                    ];
                    display = jQuery.css(elem, 'display');
                    dDisplay = defaultDisplay(elem.nodeName);
                    if (display === 'none') {
                        display = dDisplay;
                    }
                    if (display === 'inline' && jQuery.css(elem, 'float') === 'none') {
                        if (!support.inlineBlockNeedsLayout || dDisplay === 'inline') {
                            style.display = 'inline-block';
                        } else {
                            style.zoom = 1;
                        }
                    }
                }
                if (opts.overflow) {
                    style.overflow = 'hidden';
                    if (!support.shrinkWrapBlocks()) {
                        anim.always(function () {
                            style.overflow = opts.overflow[0];
                            style.overflowX = opts.overflow[1];
                            style.overflowY = opts.overflow[2];
                        });
                    }
                }
                for (prop in props) {
                    value = props[prop];
                    if (rfxtypes.exec(value)) {
                        delete props[prop];
                        toggle = toggle || value === 'toggle';
                        if (value === (hidden ? 'hide' : 'show')) {
                            if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                                hidden = true;
                            } else {
                                continue;
                            }
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                    }
                }
                if (!jQuery.isEmptyObject(orig)) {
                    if (dataShow) {
                        if ('hidden' in dataShow) {
                            hidden = dataShow.hidden;
                        }
                    } else {
                        dataShow = jQuery._data(elem, 'fxshow', {});
                    }
                    if (toggle) {
                        dataShow.hidden = !hidden;
                    }
                    if (hidden) {
                        jQuery(elem).show();
                    } else {
                        anim.done(function () {
                            jQuery(elem).hide();
                        });
                    }
                    anim.done(function () {
                        var prop;
                        jQuery._removeData(elem, 'fxshow');
                        for (prop in orig) {
                            jQuery.style(elem, prop, orig[prop]);
                        }
                    });
                    for (prop in orig) {
                        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                        if (!(prop in dataShow)) {
                            dataShow[prop] = tween.start;
                            if (hidden) {
                                tween.end = tween.start;
                                tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                            }
                        }
                    }
                }
            }
            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;
                for (index in props) {
                    name = jQuery.camelCase(index);
                    easing = specialEasing[name];
                    value = props[index];
                    if (jQuery.isArray(value)) {
                        easing = value[1];
                        value = props[index] = value[0];
                    }
                    if (index !== name) {
                        props[name] = value;
                        delete props[index];
                    }
                    hooks = jQuery.cssHooks[name];
                    if (hooks && 'expand' in hooks) {
                        value = hooks.expand(value);
                        delete props[name];
                        for (index in value) {
                            if (!(index in props)) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        }
                    } else {
                        specialEasing[name] = easing;
                    }
                }
            }
            function Animation(elem, properties, options) {
                var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
                        delete tick.elem;
                    }), tick = function () {
                        if (stopped) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                        for (; index < length; index++) {
                            animation.tweens[index].run(percent);
                        }
                        deferred.notifyWith(elem, [
                            animation,
                            percent,
                            remaining
                        ]);
                        if (percent < 1 && length) {
                            return remaining;
                        } else {
                            deferred.resolveWith(elem, [animation]);
                            return false;
                        }
                    }, animation = deferred.promise({
                        elem: elem,
                        props: jQuery.extend({}, properties),
                        opts: jQuery.extend(true, { specialEasing: {} }, options),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function (prop, end) {
                            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                            animation.tweens.push(tween);
                            return tween;
                        },
                        stop: function (gotoEnd) {
                            var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                            if (stopped) {
                                return this;
                            }
                            stopped = true;
                            for (; index < length; index++) {
                                animation.tweens[index].run(1);
                            }
                            if (gotoEnd) {
                                deferred.resolveWith(elem, [
                                    animation,
                                    gotoEnd
                                ]);
                            } else {
                                deferred.rejectWith(elem, [
                                    animation,
                                    gotoEnd
                                ]);
                            }
                            return this;
                        }
                    }), props = animation.props;
                propFilter(props, animation.opts.specialEasing);
                for (; index < length; index++) {
                    result = animationPrefilters[index].call(animation, elem, props, animation.opts);
                    if (result) {
                        return result;
                    }
                }
                jQuery.map(props, createTween, animation);
                if (jQuery.isFunction(animation.opts.start)) {
                    animation.opts.start.call(elem, animation);
                }
                jQuery.fx.timer(jQuery.extend(tick, {
                    elem: elem,
                    anim: animation,
                    queue: animation.opts.queue
                }));
                return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
            }
            jQuery.Animation = jQuery.extend(Animation, {
                tweener: function (props, callback) {
                    if (jQuery.isFunction(props)) {
                        callback = props;
                        props = ['*'];
                    } else {
                        props = props.split(' ');
                    }
                    var prop, index = 0, length = props.length;
                    for (; index < length; index++) {
                        prop = props[index];
                        tweeners[prop] = tweeners[prop] || [];
                        tweeners[prop].unshift(callback);
                    }
                },
                prefilter: function (callback, prepend) {
                    if (prepend) {
                        animationPrefilters.unshift(callback);
                    } else {
                        animationPrefilters.push(callback);
                    }
                }
            });
            jQuery.speed = function (speed, easing, fn) {
                var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };
                opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
                if (opt.queue == null || opt.queue === true) {
                    opt.queue = 'fx';
                }
                opt.old = opt.complete;
                opt.complete = function () {
                    if (jQuery.isFunction(opt.old)) {
                        opt.old.call(this);
                    }
                    if (opt.queue) {
                        jQuery.dequeue(this, opt.queue);
                    }
                };
                return opt;
            };
            jQuery.fn.extend({
                fadeTo: function (speed, to, easing, callback) {
                    return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
                },
                animate: function (prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                            var anim = Animation(this, jQuery.extend({}, prop), optall);
                            if (empty || jQuery._data(this, 'finish')) {
                                anim.stop(true);
                            }
                        };
                    doAnimation.finish = doAnimation;
                    return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
                },
                stop: function (type, clearQueue, gotoEnd) {
                    var stopQueue = function (hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop(gotoEnd);
                    };
                    if (typeof type !== 'string') {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if (clearQueue && type !== false) {
                        this.queue(type || 'fx', []);
                    }
                    return this.each(function () {
                        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = jQuery._data(this);
                        if (index) {
                            if (data[index] && data[index].stop) {
                                stopQueue(data[index]);
                            }
                        } else {
                            for (index in data) {
                                if (data[index] && data[index].stop && rrun.test(index)) {
                                    stopQueue(data[index]);
                                }
                            }
                        }
                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                        }
                        if (dequeue || !gotoEnd) {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                finish: function (type) {
                    if (type !== false) {
                        type = type || 'fx';
                    }
                    return this.each(function () {
                        var index, data = jQuery._data(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                        data.finish = true;
                        jQuery.queue(this, type, []);
                        if (hooks && hooks.stop) {
                            hooks.stop.call(this, true);
                        }
                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                        }
                        for (index = 0; index < length; index++) {
                            if (queue[index] && queue[index].finish) {
                                queue[index].finish.call(this);
                            }
                        }
                        delete data.finish;
                    });
                }
            });
            jQuery.each([
                'toggle',
                'show',
                'hide'
            ], function (i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function (speed, easing, callback) {
                    return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
                };
            });
            jQuery.each({
                slideDown: genFx('show'),
                slideUp: genFx('hide'),
                slideToggle: genFx('toggle'),
                fadeIn: { opacity: 'show' },
                fadeOut: { opacity: 'hide' },
                fadeToggle: { opacity: 'toggle' }
            }, function (name, props) {
                jQuery.fn[name] = function (speed, easing, callback) {
                    return this.animate(props, speed, easing, callback);
                };
            });
            jQuery.timers = [];
            jQuery.fx.tick = function () {
                var timer, timers = jQuery.timers, i = 0;
                fxNow = jQuery.now();
                for (; i < timers.length; i++) {
                    timer = timers[i];
                    if (!timer() && timers[i] === timer) {
                        timers.splice(i--, 1);
                    }
                }
                if (!timers.length) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };
            jQuery.fx.timer = function (timer) {
                jQuery.timers.push(timer);
                if (timer()) {
                    jQuery.fx.start();
                } else {
                    jQuery.timers.pop();
                }
            };
            jQuery.fx.interval = 13;
            jQuery.fx.start = function () {
                if (!timerId) {
                    timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
                }
            };
            jQuery.fx.stop = function () {
                clearInterval(timerId);
                timerId = null;
            };
            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            };
            jQuery.fn.delay = function (time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || 'fx';
                return this.queue(type, function (next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function () {
                        clearTimeout(timeout);
                    };
                });
            };
            (function () {
                var a, input, select, opt, div = document.createElement('div');
                div.setAttribute('className', 't');
                div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
                a = div.getElementsByTagName('a')[0];
                select = document.createElement('select');
                opt = select.appendChild(document.createElement('option'));
                input = div.getElementsByTagName('input')[0];
                a.style.cssText = 'top:1px';
                support.getSetAttribute = div.className !== 't';
                support.style = /top/.test(a.getAttribute('style'));
                support.hrefNormalized = a.getAttribute('href') === '/a';
                support.checkOn = !!input.value;
                support.optSelected = opt.selected;
                support.enctype = !!document.createElement('form').enctype;
                select.disabled = true;
                support.optDisabled = !opt.disabled;
                input = document.createElement('input');
                input.setAttribute('value', '');
                support.input = input.getAttribute('value') === '';
                input.value = 't';
                input.setAttribute('type', 'radio');
                support.radioValue = input.value === 't';
                a = input = select = opt = div = null;
            }());
            var rreturn = /\r/g;
            jQuery.fn.extend({
                val: function (value) {
                    var hooks, ret, isFunction, elem = this[0];
                    if (!arguments.length) {
                        if (elem) {
                            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                            if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                                return ret;
                            }
                            ret = elem.value;
                            return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                        }
                        return;
                    }
                    isFunction = jQuery.isFunction(value);
                    return this.each(function (i) {
                        var val;
                        if (this.nodeType !== 1) {
                            return;
                        }
                        if (isFunction) {
                            val = value.call(this, i, jQuery(this).val());
                        } else {
                            val = value;
                        }
                        if (val == null) {
                            val = '';
                        } else if (typeof val === 'number') {
                            val += '';
                        } else if (jQuery.isArray(val)) {
                            val = jQuery.map(val, function (value) {
                                return value == null ? '' : value + '';
                            });
                        }
                        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                            this.value = val;
                        }
                    });
                }
            });
            jQuery.extend({
                valHooks: {
                    option: {
                        get: function (elem) {
                            var val = jQuery.find.attr(elem, 'value');
                            return val != null ? val : jQuery.text(elem);
                        }
                    },
                    select: {
                        get: function (elem) {
                            var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                            for (; i < max; i++) {
                                option = options[i];
                                if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                                    value = jQuery(option).val();
                                    if (one) {
                                        return value;
                                    }
                                    values.push(value);
                                }
                            }
                            return values;
                        },
                        set: function (elem, value) {
                            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                            while (i--) {
                                option = options[i];
                                if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
                                    try {
                                        option.selected = optionSet = true;
                                    } catch (_) {
                                        option.scrollHeight;
                                    }
                                } else {
                                    option.selected = false;
                                }
                            }
                            if (!optionSet) {
                                elem.selectedIndex = -1;
                            }
                            return options;
                        }
                    }
                }
            });
            jQuery.each([
                'radio',
                'checkbox'
            ], function () {
                jQuery.valHooks[this] = {
                    set: function (elem, value) {
                        if (jQuery.isArray(value)) {
                            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
                        }
                    }
                };
                if (!support.checkOn) {
                    jQuery.valHooks[this].get = function (elem) {
                        return elem.getAttribute('value') === null ? 'on' : elem.value;
                    };
                }
            });
            var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
            jQuery.fn.extend({
                attr: function (name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1);
                },
                removeAttr: function (name) {
                    return this.each(function () {
                        jQuery.removeAttr(this, name);
                    });
                }
            });
            jQuery.extend({
                attr: function (elem, name, value) {
                    var hooks, ret, nType = elem.nodeType;
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }
                    if (typeof elem.getAttribute === strundefined) {
                        return jQuery.prop(elem, name, value);
                    }
                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                        name = name.toLowerCase();
                        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
                    }
                    if (value !== undefined) {
                        if (value === null) {
                            jQuery.removeAttr(elem, name);
                        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;
                        } else {
                            elem.setAttribute(name, value + '');
                            return value;
                        }
                    } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;
                    } else {
                        ret = jQuery.find.attr(elem, name);
                        return ret == null ? undefined : ret;
                    }
                },
                removeAttr: function (elem, value) {
                    var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
                    if (attrNames && elem.nodeType === 1) {
                        while (name = attrNames[i++]) {
                            propName = jQuery.propFix[name] || name;
                            if (jQuery.expr.match.bool.test(name)) {
                                if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                                    elem[propName] = false;
                                } else {
                                    elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
                                }
                            } else {
                                jQuery.attr(elem, name, '');
                            }
                            elem.removeAttribute(getSetAttribute ? name : propName);
                        }
                    }
                },
                attrHooks: {
                    type: {
                        set: function (elem, value) {
                            if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                                var val = elem.value;
                                elem.setAttribute('type', value);
                                if (val) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                }
            });
            boolHook = {
                set: function (elem, value, name) {
                    if (value === false) {
                        jQuery.removeAttr(elem, name);
                    } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
                        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);
                    } else {
                        elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
                    }
                    return name;
                }
            };
            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;
                attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {
                    var ret, handle;
                    if (!isXML) {
                        handle = attrHandle[name];
                        attrHandle[name] = ret;
                        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                        attrHandle[name] = handle;
                    }
                    return ret;
                } : function (elem, name, isXML) {
                    if (!isXML) {
                        return elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
                    }
                };
            });
            if (!getSetInput || !getSetAttribute) {
                jQuery.attrHooks.value = {
                    set: function (elem, value, name) {
                        if (jQuery.nodeName(elem, 'input')) {
                            elem.defaultValue = value;
                        } else {
                            return nodeHook && nodeHook.set(elem, value, name);
                        }
                    }
                };
            }
            if (!getSetAttribute) {
                nodeHook = {
                    set: function (elem, value, name) {
                        var ret = elem.getAttributeNode(name);
                        if (!ret) {
                            elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
                        }
                        ret.value = value += '';
                        if (name === 'value' || value === elem.getAttribute(name)) {
                            return value;
                        }
                    }
                };
                attrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {
                    var ret;
                    if (!isXML) {
                        return (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
                    }
                };
                jQuery.valHooks.button = {
                    get: function (elem, name) {
                        var ret = elem.getAttributeNode(name);
                        if (ret && ret.specified) {
                            return ret.value;
                        }
                    },
                    set: nodeHook.set
                };
                jQuery.attrHooks.contenteditable = {
                    set: function (elem, value, name) {
                        nodeHook.set(elem, value === '' ? false : value, name);
                    }
                };
                jQuery.each([
                    'width',
                    'height'
                ], function (i, name) {
                    jQuery.attrHooks[name] = {
                        set: function (elem, value) {
                            if (value === '') {
                                elem.setAttribute(name, 'auto');
                                return value;
                            }
                        }
                    };
                });
            }
            if (!support.style) {
                jQuery.attrHooks.style = {
                    get: function (elem) {
                        return elem.style.cssText || undefined;
                    },
                    set: function (elem, value) {
                        return elem.style.cssText = value + '';
                    }
                };
            }
            var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
            jQuery.fn.extend({
                prop: function (name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1);
                },
                removeProp: function (name) {
                    name = jQuery.propFix[name] || name;
                    return this.each(function () {
                        try {
                            this[name] = undefined;
                            delete this[name];
                        } catch (e) {
                        }
                    });
                }
            });
            jQuery.extend({
                propFix: {
                    'for': 'htmlFor',
                    'class': 'className'
                },
                prop: function (elem, name, value) {
                    var ret, hooks, notxml, nType = elem.nodeType;
                    if (!elem || nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }
                    notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
                    if (notxml) {
                        name = jQuery.propFix[name] || name;
                        hooks = jQuery.propHooks[name];
                    }
                    if (value !== undefined) {
                        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
                    } else {
                        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
                    }
                },
                propHooks: {
                    tabIndex: {
                        get: function (elem) {
                            var tabindex = jQuery.find.attr(elem, 'tabindex');
                            return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                        }
                    }
                }
            });
            if (!support.hrefNormalized) {
                jQuery.each([
                    'href',
                    'src'
                ], function (i, name) {
                    jQuery.propHooks[name] = {
                        get: function (elem) {
                            return elem.getAttribute(name, 4);
                        }
                    };
                });
            }
            if (!support.optSelected) {
                jQuery.propHooks.selected = {
                    get: function (elem) {
                        var parent = elem.parentNode;
                        if (parent) {
                            parent.selectedIndex;
                            if (parent.parentNode) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                        return null;
                    }
                };
            }
            jQuery.each([
                'tabIndex',
                'readOnly',
                'maxLength',
                'cellSpacing',
                'cellPadding',
                'rowSpan',
                'colSpan',
                'useMap',
                'frameBorder',
                'contentEditable'
            ], function () {
                jQuery.propFix[this.toLowerCase()] = this;
            });
            if (!support.enctype) {
                jQuery.propFix.enctype = 'encoding';
            }
            var rclass = /[\t\r\n\f]/g;
            jQuery.fn.extend({
                addClass: function (value) {
                    var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === 'string' && value;
                    if (jQuery.isFunction(value)) {
                        return this.each(function (j) {
                            jQuery(this).addClass(value.call(this, j, this.className));
                        });
                    }
                    if (proceed) {
                        classes = (value || '').match(rnotwhite) || [];
                        for (; i < len; i++) {
                            elem = this[i];
                            cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
                            if (cur) {
                                j = 0;
                                while (clazz = classes[j++]) {
                                    if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                        cur += clazz + ' ';
                                    }
                                }
                                finalValue = jQuery.trim(cur);
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }
                    return this;
                },
                removeClass: function (value) {
                    var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
                    if (jQuery.isFunction(value)) {
                        return this.each(function (j) {
                            jQuery(this).removeClass(value.call(this, j, this.className));
                        });
                    }
                    if (proceed) {
                        classes = (value || '').match(rnotwhite) || [];
                        for (; i < len; i++) {
                            elem = this[i];
                            cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
                            if (cur) {
                                j = 0;
                                while (clazz = classes[j++]) {
                                    while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                                        cur = cur.replace(' ' + clazz + ' ', ' ');
                                    }
                                }
                                finalValue = value ? jQuery.trim(cur) : '';
                                if (elem.className !== finalValue) {
                                    elem.className = finalValue;
                                }
                            }
                        }
                    }
                    return this;
                },
                toggleClass: function (value, stateVal) {
                    var type = typeof value;
                    if (typeof stateVal === 'boolean' && type === 'string') {
                        return stateVal ? this.addClass(value) : this.removeClass(value);
                    }
                    if (jQuery.isFunction(value)) {
                        return this.each(function (i) {
                            jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                        });
                    }
                    return this.each(function () {
                        if (type === 'string') {
                            var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
                            while (className = classNames[i++]) {
                                if (self.hasClass(className)) {
                                    self.removeClass(className);
                                } else {
                                    self.addClass(className);
                                }
                            }
                        } else if (type === strundefined || type === 'boolean') {
                            if (this.className) {
                                jQuery._data(this, '__className__', this.className);
                            }
                            this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
                        }
                    });
                },
                hasClass: function (selector) {
                    var className = ' ' + selector + ' ', i = 0, l = this.length;
                    for (; i < l; i++) {
                        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
                            return true;
                        }
                    }
                    return false;
                }
            });
            jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
                jQuery.fn[name] = function (data, fn) {
                    return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
                };
            });
            jQuery.fn.extend({
                hover: function (fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                },
                bind: function (types, data, fn) {
                    return this.on(types, null, data, fn);
                },
                unbind: function (types, fn) {
                    return this.off(types, null, fn);
                },
                delegate: function (selector, types, data, fn) {
                    return this.on(types, selector, data, fn);
                },
                undelegate: function (selector, types, fn) {
                    return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
                }
            });
            var nonce = jQuery.now();
            var rquery = /\?/;
            var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
            jQuery.parseJSON = function (data) {
                if (window.JSON && window.JSON.parse) {
                    return window.JSON.parse(data + '');
                }
                var requireNonComma, depth = null, str = jQuery.trim(data + '');
                return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {
                    if (requireNonComma && comma) {
                        depth = 0;
                    }
                    if (depth === 0) {
                        return token;
                    }
                    requireNonComma = open || comma;
                    depth += !close - !open;
                    return '';
                })) ? Function('return ' + str)() : jQuery.error('Invalid JSON: ' + data);
            };
            jQuery.parseXML = function (data) {
                var xml, tmp;
                if (!data || typeof data !== 'string') {
                    return null;
                }
                try {
                    if (window.DOMParser) {
                        tmp = new DOMParser();
                        xml = tmp.parseFromString(data, 'text/xml');
                    } else {
                        xml = new ActiveXObject('Microsoft.XMLDOM');
                        xml.async = 'false';
                        xml.loadXML(data);
                    }
                } catch (e) {
                    xml = undefined;
                }
                if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
                    jQuery.error('Invalid XML: ' + data);
                }
                return xml;
            };
            var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
            try {
                ajaxLocation = location.href;
            } catch (e) {
                ajaxLocation = document.createElement('a');
                ajaxLocation.href = '';
                ajaxLocation = ajaxLocation.href;
            }
            ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
            function addToPrefiltersOrTransports(structure) {
                return function (dataTypeExpression, func) {
                    if (typeof dataTypeExpression !== 'string') {
                        func = dataTypeExpression;
                        dataTypeExpression = '*';
                    }
                    var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                    if (jQuery.isFunction(func)) {
                        while (dataType = dataTypes[i++]) {
                            if (dataType.charAt(0) === '+') {
                                dataType = dataType.slice(1) || '*';
                                (structure[dataType] = structure[dataType] || []).unshift(func);
                            } else {
                                (structure[dataType] = structure[dataType] || []).push(func);
                            }
                        }
                    }
                };
            }
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
                var inspected = {}, seekingTransport = structure === transports;
                function inspect(dataType) {
                    var selected;
                    inspected[dataType] = true;
                    jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                            options.dataTypes.unshift(dataTypeOrTransport);
                            inspect(dataTypeOrTransport);
                            return false;
                        } else if (seekingTransport) {
                            return !(selected = dataTypeOrTransport);
                        }
                    });
                    return selected;
                }
                return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
            }
            function ajaxExtend(target, src) {
                var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
                for (key in src) {
                    if (src[key] !== undefined) {
                        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
                    }
                }
                if (deep) {
                    jQuery.extend(true, target, deep);
                }
                return target;
            }
            function ajaxHandleResponses(s, jqXHR, responses) {
                var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
                while (dataTypes[0] === '*') {
                    dataTypes.shift();
                    if (ct === undefined) {
                        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
                    }
                }
                if (ct) {
                    for (type in contents) {
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                }
                if (dataTypes[0] in responses) {
                    finalDataType = dataTypes[0];
                } else {
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                            finalDataType = type;
                            break;
                        }
                        if (!firstDataType) {
                            firstDataType = type;
                        }
                    }
                    finalDataType = finalDataType || firstDataType;
                }
                if (finalDataType) {
                    if (finalDataType !== dataTypes[0]) {
                        dataTypes.unshift(finalDataType);
                    }
                    return responses[finalDataType];
                }
            }
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
                if (dataTypes[1]) {
                    for (conv in s.converters) {
                        converters[conv.toLowerCase()] = s.converters[conv];
                    }
                }
                current = dataTypes.shift();
                while (current) {
                    if (s.responseFields[current]) {
                        jqXHR[s.responseFields[current]] = response;
                    }
                    if (!prev && isSuccess && s.dataFilter) {
                        response = s.dataFilter(response, s.dataType);
                    }
                    prev = current;
                    current = dataTypes.shift();
                    if (current) {
                        if (current === '*') {
                            current = prev;
                        } else if (prev !== '*' && prev !== current) {
                            conv = converters[prev + ' ' + current] || converters['* ' + current];
                            if (!conv) {
                                for (conv2 in converters) {
                                    tmp = conv2.split(' ');
                                    if (tmp[1] === current) {
                                        conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                        if (conv) {
                                            if (conv === true) {
                                                conv = converters[conv2];
                                            } else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                            if (conv !== true) {
                                if (conv && s['throws']) {
                                    response = conv(response);
                                } else {
                                    try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: 'parsererror',
                                            error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                return {
                    state: 'success',
                    data: response
                };
            }
            jQuery.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: ajaxLocation,
                    type: 'GET',
                    isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                    accepts: {
                        '*': allTypes,
                        text: 'text/plain',
                        html: 'text/html',
                        xml: 'application/xml, text/xml',
                        json: 'application/json, text/javascript'
                    },
                    contents: {
                        xml: /xml/,
                        html: /html/,
                        json: /json/
                    },
                    responseFields: {
                        xml: 'responseXML',
                        text: 'responseText',
                        json: 'responseJSON'
                    },
                    converters: {
                        '* text': String,
                        'text html': true,
                        'text json': jQuery.parseJSON,
                        'text xml': jQuery.parseXML
                    },
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },
                ajaxSetup: function (target, settings) {
                    return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
                },
                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),
                ajax: function (url, options) {
                    if (typeof url === 'object') {
                        options = url;
                        url = undefined;
                    }
                    options = options || {};
                    var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                            readyState: 0,
                            getResponseHeader: function (key) {
                                var match;
                                if (state === 2) {
                                    if (!responseHeaders) {
                                        responseHeaders = {};
                                        while (match = rheaders.exec(responseHeadersString)) {
                                            responseHeaders[match[1].toLowerCase()] = match[2];
                                        }
                                    }
                                    match = responseHeaders[key.toLowerCase()];
                                }
                                return match == null ? null : match;
                            },
                            getAllResponseHeaders: function () {
                                return state === 2 ? responseHeadersString : null;
                            },
                            setRequestHeader: function (name, value) {
                                var lname = name.toLowerCase();
                                if (!state) {
                                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                    requestHeaders[name] = value;
                                }
                                return this;
                            },
                            overrideMimeType: function (type) {
                                if (!state) {
                                    s.mimeType = type;
                                }
                                return this;
                            },
                            statusCode: function (map) {
                                var code;
                                if (map) {
                                    if (state < 2) {
                                        for (code in map) {
                                            statusCode[code] = [
                                                statusCode[code],
                                                map[code]
                                            ];
                                        }
                                    } else {
                                        jqXHR.always(map[jqXHR.status]);
                                    }
                                }
                                return this;
                            },
                            abort: function (statusText) {
                                var finalText = statusText || strAbort;
                                if (transport) {
                                    transport.abort(finalText);
                                }
                                done(0, finalText);
                                return this;
                            }
                        };
                    deferred.promise(jqXHR).complete = completeDeferred.add;
                    jqXHR.success = jqXHR.done;
                    jqXHR.error = jqXHR.fail;
                    s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
                    s.type = options.method || options.type || s.method || s.type;
                    s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
                    if (s.crossDomain == null) {
                        parts = rurl.exec(s.url.toLowerCase());
                        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
                    }
                    if (s.data && s.processData && typeof s.data !== 'string') {
                        s.data = jQuery.param(s.data, s.traditional);
                    }
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                    if (state === 2) {
                        return jqXHR;
                    }
                    fireGlobals = s.global;
                    if (fireGlobals && jQuery.active++ === 0) {
                        jQuery.event.trigger('ajaxStart');
                    }
                    s.type = s.type.toUpperCase();
                    s.hasContent = !rnoContent.test(s.type);
                    cacheURL = s.url;
                    if (!s.hasContent) {
                        if (s.data) {
                            cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                            delete s.data;
                        }
                        if (s.cache === false) {
                            s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                        }
                    }
                    if (s.ifModified) {
                        if (jQuery.lastModified[cacheURL]) {
                            jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                        }
                        if (jQuery.etag[cacheURL]) {
                            jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                        }
                    }
                    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                        jqXHR.setRequestHeader('Content-Type', s.contentType);
                    }
                    jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
                    for (i in s.headers) {
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    }
                    if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                        return jqXHR.abort();
                    }
                    strAbort = 'abort';
                    for (i in {
                            success: 1,
                            error: 1,
                            complete: 1
                        }) {
                        jqXHR[i](s[i]);
                    }
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                    if (!transport) {
                        done(-1, 'No Transport');
                    } else {
                        jqXHR.readyState = 1;
                        if (fireGlobals) {
                            globalEventContext.trigger('ajaxSend', [
                                jqXHR,
                                s
                            ]);
                        }
                        if (s.async && s.timeout > 0) {
                            timeoutTimer = setTimeout(function () {
                                jqXHR.abort('timeout');
                            }, s.timeout);
                        }
                        try {
                            state = 1;
                            transport.send(requestHeaders, done);
                        } catch (e) {
                            if (state < 2) {
                                done(-1, e);
                            } else {
                                throw e;
                            }
                        }
                    }
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                        if (state === 2) {
                            return;
                        }
                        state = 2;
                        if (timeoutTimer) {
                            clearTimeout(timeoutTimer);
                        }
                        transport = undefined;
                        responseHeadersString = headers || '';
                        jqXHR.readyState = status > 0 ? 4 : 0;
                        isSuccess = status >= 200 && status < 300 || status === 304;
                        if (responses) {
                            response = ajaxHandleResponses(s, jqXHR, responses);
                        }
                        response = ajaxConvert(s, response, jqXHR, isSuccess);
                        if (isSuccess) {
                            if (s.ifModified) {
                                modified = jqXHR.getResponseHeader('Last-Modified');
                                if (modified) {
                                    jQuery.lastModified[cacheURL] = modified;
                                }
                                modified = jqXHR.getResponseHeader('etag');
                                if (modified) {
                                    jQuery.etag[cacheURL] = modified;
                                }
                            }
                            if (status === 204 || s.type === 'HEAD') {
                                statusText = 'nocontent';
                            } else if (status === 304) {
                                statusText = 'notmodified';
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {
                            error = statusText;
                            if (status || !statusText) {
                                statusText = 'error';
                                if (status < 0) {
                                    status = 0;
                                }
                            }
                        }
                        jqXHR.status = status;
                        jqXHR.statusText = (nativeStatusText || statusText) + '';
                        if (isSuccess) {
                            deferred.resolveWith(callbackContext, [
                                success,
                                statusText,
                                jqXHR
                            ]);
                        } else {
                            deferred.rejectWith(callbackContext, [
                                jqXHR,
                                statusText,
                                error
                            ]);
                        }
                        jqXHR.statusCode(statusCode);
                        statusCode = undefined;
                        if (fireGlobals) {
                            globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                                jqXHR,
                                s,
                                isSuccess ? success : error
                            ]);
                        }
                        completeDeferred.fireWith(callbackContext, [
                            jqXHR,
                            statusText
                        ]);
                        if (fireGlobals) {
                            globalEventContext.trigger('ajaxComplete', [
                                jqXHR,
                                s
                            ]);
                            if (!--jQuery.active) {
                                jQuery.event.trigger('ajaxStop');
                            }
                        }
                    }
                    return jqXHR;
                },
                getJSON: function (url, data, callback) {
                    return jQuery.get(url, data, callback, 'json');
                },
                getScript: function (url, callback) {
                    return jQuery.get(url, undefined, callback, 'script');
                }
            });
            jQuery.each([
                'get',
                'post'
            ], function (i, method) {
                jQuery[method] = function (url, data, callback, type) {
                    if (jQuery.isFunction(data)) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }
                    return jQuery.ajax({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    });
                };
            });
            jQuery.each([
                'ajaxStart',
                'ajaxStop',
                'ajaxComplete',
                'ajaxError',
                'ajaxSuccess',
                'ajaxSend'
            ], function (i, type) {
                jQuery.fn[type] = function (fn) {
                    return this.on(type, fn);
                };
            });
            jQuery._evalUrl = function (url) {
                return jQuery.ajax({
                    url: url,
                    type: 'GET',
                    dataType: 'script',
                    async: false,
                    global: false,
                    'throws': true
                });
            };
            jQuery.fn.extend({
                wrapAll: function (html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function (i) {
                            jQuery(this).wrapAll(html.call(this, i));
                        });
                    }
                    if (this[0]) {
                        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                        if (this[0].parentNode) {
                            wrap.insertBefore(this[0]);
                        }
                        wrap.map(function () {
                            var elem = this;
                            while (elem.firstChild && elem.firstChild.nodeType === 1) {
                                elem = elem.firstChild;
                            }
                            return elem;
                        }).append(this);
                    }
                    return this;
                },
                wrapInner: function (html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function (i) {
                            jQuery(this).wrapInner(html.call(this, i));
                        });
                    }
                    return this.each(function () {
                        var self = jQuery(this), contents = self.contents();
                        if (contents.length) {
                            contents.wrapAll(html);
                        } else {
                            self.append(html);
                        }
                    });
                },
                wrap: function (html) {
                    var isFunction = jQuery.isFunction(html);
                    return this.each(function (i) {
                        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                    });
                },
                unwrap: function () {
                    return this.parent().each(function () {
                        if (!jQuery.nodeName(this, 'body')) {
                            jQuery(this).replaceWith(this.childNodes);
                        }
                    }).end();
                }
            });
            jQuery.expr.filters.hidden = function (elem) {
                return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, 'display')) === 'none';
            };
            jQuery.expr.filters.visible = function (elem) {
                return !jQuery.expr.filters.hidden(elem);
            };
            var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
            function buildParams(prefix, obj, traditional, add) {
                var name;
                if (jQuery.isArray(obj)) {
                    jQuery.each(obj, function (i, v) {
                        if (traditional || rbracket.test(prefix)) {
                            add(prefix, v);
                        } else {
                            buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
                        }
                    });
                } else if (!traditional && jQuery.type(obj) === 'object') {
                    for (name in obj) {
                        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                    }
                } else {
                    add(prefix, obj);
                }
            }
            jQuery.param = function (a, traditional) {
                var prefix, s = [], add = function (key, value) {
                        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
                    };
                if (traditional === undefined) {
                    traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
                }
                if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
                    jQuery.each(a, function () {
                        add(this.name, this.value);
                    });
                } else {
                    for (prefix in a) {
                        buildParams(prefix, a[prefix], traditional, add);
                    }
                }
                return s.join('&').replace(r20, '+');
            };
            jQuery.fn.extend({
                serialize: function () {
                    return jQuery.param(this.serializeArray());
                },
                serializeArray: function () {
                    return this.map(function () {
                        var elements = jQuery.prop(this, 'elements');
                        return elements ? jQuery.makeArray(elements) : this;
                    }).filter(function () {
                        var type = this.type;
                        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                    }).map(function (i, elem) {
                        var val = jQuery(this).val();
                        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, '\r\n')
                            };
                        }) : {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    }).get();
                }
            });
            jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? function () {
                return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
            } : createStandardXHR;
            var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
            if (window.ActiveXObject) {
                jQuery(window).on('unload', function () {
                    for (var key in xhrCallbacks) {
                        xhrCallbacks[key](undefined, true);
                    }
                });
            }
            support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
            xhrSupported = support.ajax = !!xhrSupported;
            if (xhrSupported) {
                jQuery.ajaxTransport(function (options) {
                    if (!options.crossDomain || support.cors) {
                        var callback;
                        return {
                            send: function (headers, complete) {
                                var i, xhr = options.xhr(), id = ++xhrId;
                                xhr.open(options.type, options.url, options.async, options.username, options.password);
                                if (options.xhrFields) {
                                    for (i in options.xhrFields) {
                                        xhr[i] = options.xhrFields[i];
                                    }
                                }
                                if (options.mimeType && xhr.overrideMimeType) {
                                    xhr.overrideMimeType(options.mimeType);
                                }
                                if (!options.crossDomain && !headers['X-Requested-With']) {
                                    headers['X-Requested-With'] = 'XMLHttpRequest';
                                }
                                for (i in headers) {
                                    if (headers[i] !== undefined) {
                                        xhr.setRequestHeader(i, headers[i] + '');
                                    }
                                }
                                xhr.send(options.hasContent && options.data || null);
                                callback = function (_, isAbort) {
                                    var status, statusText, responses;
                                    if (callback && (isAbort || xhr.readyState === 4)) {
                                        delete xhrCallbacks[id];
                                        callback = undefined;
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (isAbort) {
                                            if (xhr.readyState !== 4) {
                                                xhr.abort();
                                            }
                                        } else {
                                            responses = {};
                                            status = xhr.status;
                                            if (typeof xhr.responseText === 'string') {
                                                responses.text = xhr.responseText;
                                            }
                                            try {
                                                statusText = xhr.statusText;
                                            } catch (e) {
                                                statusText = '';
                                            }
                                            if (!status && options.isLocal && !options.crossDomain) {
                                                status = responses.text ? 200 : 404;
                                            } else if (status === 1223) {
                                                status = 204;
                                            }
                                        }
                                    }
                                    if (responses) {
                                        complete(status, statusText, responses, xhr.getAllResponseHeaders());
                                    }
                                };
                                if (!options.async) {
                                    callback();
                                } else if (xhr.readyState === 4) {
                                    setTimeout(callback);
                                } else {
                                    xhr.onreadystatechange = xhrCallbacks[id] = callback;
                                }
                            },
                            abort: function () {
                                if (callback) {
                                    callback(undefined, true);
                                }
                            }
                        };
                    }
                });
            }
            function createStandardXHR() {
                try {
                    return new window.XMLHttpRequest();
                } catch (e) {
                }
            }
            function createActiveXHR() {
                try {
                    return new window.ActiveXObject('Microsoft.XMLHTTP');
                } catch (e) {
                }
            }
            jQuery.ajaxSetup({
                accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
                contents: { script: /(?:java|ecma)script/ },
                converters: {
                    'text script': function (text) {
                        jQuery.globalEval(text);
                        return text;
                    }
                }
            });
            jQuery.ajaxPrefilter('script', function (s) {
                if (s.cache === undefined) {
                    s.cache = false;
                }
                if (s.crossDomain) {
                    s.type = 'GET';
                    s.global = false;
                }
            });
            jQuery.ajaxTransport('script', function (s) {
                if (s.crossDomain) {
                    var script, head = document.head || jQuery('head')[0] || document.documentElement;
                    return {
                        send: function (_, callback) {
                            script = document.createElement('script');
                            script.async = true;
                            if (s.scriptCharset) {
                                script.charset = s.scriptCharset;
                            }
                            script.src = s.url;
                            script.onload = script.onreadystatechange = function (_, isAbort) {
                                if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                                    script.onload = script.onreadystatechange = null;
                                    if (script.parentNode) {
                                        script.parentNode.removeChild(script);
                                    }
                                    script = null;
                                    if (!isAbort) {
                                        callback(200, 'success');
                                    }
                                }
                            };
                            head.insertBefore(script, head.firstChild);
                        },
                        abort: function () {
                            if (script) {
                                script.onload(undefined, true);
                            }
                        }
                    };
                }
            });
            var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
            jQuery.ajaxSetup({
                jsonp: 'callback',
                jsonpCallback: function () {
                    var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
                    this[callback] = true;
                    return callback;
                }
            });
            jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
                var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
                if (jsonProp || s.dataTypes[0] === 'jsonp') {
                    callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                    if (jsonProp) {
                        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
                    } else if (s.jsonp !== false) {
                        s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
                    }
                    s.converters['script json'] = function () {
                        if (!responseContainer) {
                            jQuery.error(callbackName + ' was not called');
                        }
                        return responseContainer[0];
                    };
                    s.dataTypes[0] = 'json';
                    overwritten = window[callbackName];
                    window[callbackName] = function () {
                        responseContainer = arguments;
                    };
                    jqXHR.always(function () {
                        window[callbackName] = overwritten;
                        if (s[callbackName]) {
                            s.jsonpCallback = originalSettings.jsonpCallback;
                            oldCallbacks.push(callbackName);
                        }
                        if (responseContainer && jQuery.isFunction(overwritten)) {
                            overwritten(responseContainer[0]);
                        }
                        responseContainer = overwritten = undefined;
                    });
                    return 'script';
                }
            });
            jQuery.parseHTML = function (data, context, keepScripts) {
                if (!data || typeof data !== 'string') {
                    return null;
                }
                if (typeof context === 'boolean') {
                    keepScripts = context;
                    context = false;
                }
                context = context || document;
                var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }
                parsed = jQuery.buildFragment([data], context, scripts);
                if (scripts && scripts.length) {
                    jQuery(scripts).remove();
                }
                return jQuery.merge([], parsed.childNodes);
            };
            var _load = jQuery.fn.load;
            jQuery.fn.load = function (url, params, callback) {
                if (typeof url !== 'string' && _load) {
                    return _load.apply(this, arguments);
                }
                var selector, response, type, self = this, off = url.indexOf(' ');
                if (off >= 0) {
                    selector = url.slice(off, url.length);
                    url = url.slice(0, off);
                }
                if (jQuery.isFunction(params)) {
                    callback = params;
                    params = undefined;
                } else if (params && typeof params === 'object') {
                    type = 'POST';
                }
                if (self.length > 0) {
                    jQuery.ajax({
                        url: url,
                        type: type,
                        dataType: 'html',
                        data: params
                    }).done(function (responseText) {
                        response = arguments;
                        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                    }).complete(callback && function (jqXHR, status) {
                        self.each(callback, response || [
                            jqXHR.responseText,
                            status,
                            jqXHR
                        ]);
                    });
                }
                return this;
            };
            jQuery.expr.filters.animated = function (elem) {
                return jQuery.grep(jQuery.timers, function (fn) {
                    return elem === fn.elem;
                }).length;
            };
            var docElem = window.document.documentElement;
            function getWindow(elem) {
                return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
            }
            jQuery.offset = {
                setOffset: function (elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
                    if (position === 'static') {
                        elem.style.position = 'relative';
                    }
                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css(elem, 'top');
                    curCSSLeft = jQuery.css(elem, 'left');
                    calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [
                        curCSSTop,
                        curCSSLeft
                    ]) > -1;
                    if (calculatePosition) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;
                    } else {
                        curTop = parseFloat(curCSSTop) || 0;
                        curLeft = parseFloat(curCSSLeft) || 0;
                    }
                    if (jQuery.isFunction(options)) {
                        options = options.call(elem, i, curOffset);
                    }
                    if (options.top != null) {
                        props.top = options.top - curOffset.top + curTop;
                    }
                    if (options.left != null) {
                        props.left = options.left - curOffset.left + curLeft;
                    }
                    if ('using' in options) {
                        options.using.call(elem, props);
                    } else {
                        curElem.css(props);
                    }
                }
            };
            jQuery.fn.extend({
                offset: function (options) {
                    if (arguments.length) {
                        return options === undefined ? this : this.each(function (i) {
                            jQuery.offset.setOffset(this, options, i);
                        });
                    }
                    var docElem, win, box = {
                            top: 0,
                            left: 0
                        }, elem = this[0], doc = elem && elem.ownerDocument;
                    if (!doc) {
                        return;
                    }
                    docElem = doc.documentElement;
                    if (!jQuery.contains(docElem, elem)) {
                        return box;
                    }
                    if (typeof elem.getBoundingClientRect !== strundefined) {
                        box = elem.getBoundingClientRect();
                    }
                    win = getWindow(doc);
                    return {
                        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                    };
                },
                position: function () {
                    if (!this[0]) {
                        return;
                    }
                    var offsetParent, offset, parentOffset = {
                            top: 0,
                            left: 0
                        }, elem = this[0];
                    if (jQuery.css(elem, 'position') === 'fixed') {
                        offset = elem.getBoundingClientRect();
                    } else {
                        offsetParent = this.offsetParent();
                        offset = this.offset();
                        if (!jQuery.nodeName(offsetParent[0], 'html')) {
                            parentOffset = offsetParent.offset();
                        }
                        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
                    }
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
                    };
                },
                offsetParent: function () {
                    return this.map(function () {
                        var offsetParent = this.offsetParent || docElem;
                        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
                            offsetParent = offsetParent.offsetParent;
                        }
                        return offsetParent || docElem;
                    });
                }
            });
            jQuery.each({
                scrollLeft: 'pageXOffset',
                scrollTop: 'pageYOffset'
            }, function (method, prop) {
                var top = /Y/.test(prop);
                jQuery.fn[method] = function (val) {
                    return access(this, function (elem, method, val) {
                        var win = getWindow(elem);
                        if (val === undefined) {
                            return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
                        }
                        if (win) {
                            win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
                        } else {
                            elem[method] = val;
                        }
                    }, method, val, arguments.length, null);
                };
            });
            jQuery.each([
                'top',
                'left'
            ], function (i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
                    if (computed) {
                        computed = curCSS(elem, prop);
                        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
                    }
                });
            });
            jQuery.each({
                Height: 'height',
                Width: 'width'
            }, function (name, type) {
                jQuery.each({
                    padding: 'inner' + name,
                    content: type,
                    '': 'outer' + name
                }, function (defaultExtra, funcName) {
                    jQuery.fn[funcName] = function (margin, value) {
                        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                        return access(this, function (elem, type, value) {
                            var doc;
                            if (jQuery.isWindow(elem)) {
                                return elem.document.documentElement['client' + name];
                            }
                            if (elem.nodeType === 9) {
                                doc = elem.documentElement;
                                return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                            }
                            return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                        }, type, chainable ? margin : undefined, chainable, null);
                    };
                });
            });
            jQuery.fn.size = function () {
                return this.length;
            };
            jQuery.fn.andSelf = jQuery.fn.addBack;
            if (typeof define === 'function' && define.amd) {
                define('jquery', [], function () {
                    return jQuery;
                });
            }
            var _jQuery = window.jQuery, _$ = window.$;
            jQuery.noConflict = function (deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }
                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }
                return jQuery;
            };
            if (typeof noGlobal === strundefined) {
                window.jQuery = window.$ = jQuery;
            }
            return jQuery;
        }));
    }(function () {
        return this;
    }(), require, exports, module));
});
/*funcunit@3.6.3#browser/init*/
define('funcunit@3.6.3#browser/init', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery'
], function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var FuncUnit = window.FuncUnit || {};
    jQuery.sub = function () {
        function jQuerySub(selector, context) {
            return new jQuerySub.fn.init(selector, context);
        }
        jQuery.extend(true, jQuerySub, this);
        jQuerySub.superclass = this;
        jQuerySub.fn = jQuerySub.prototype = this();
        jQuerySub.fn.constructor = jQuerySub;
        jQuerySub.sub = this.sub;
        jQuerySub.fn.init = function init(selector, context) {
            if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                context = jQuerySub(context);
            }
            return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
        };
        jQuerySub.fn.init.prototype = jQuerySub.fn;
        var rootjQuerySub = jQuerySub(document);
        return jQuerySub;
    };
    FuncUnit.jQuery = jQuery;
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#browser/core*/
define('funcunit@3.6.3#browser/core', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/init'
], function (require, exports, module) {
    var jQuery = require('funcunit/browser/jquery');
    var oldFuncUnit = require('funcunit/browser/init');
    var FuncUnit = oldFuncUnit.jQuery.sub();
    var origFuncUnit = FuncUnit;
    FuncUnit = function (selector, frame) {
        var frame, forceSync, isSyncOnly = false;
        if (frame && frame.forceSync) {
            forceSync = frame.forceSync;
        }
        if (frame && typeof frame.frame !== 'undefined') {
            frame = frame.frame;
        }
        isSyncOnly = typeof forceSync === 'boolean' ? forceSync : isSyncOnly;
        if (typeof selector == 'function') {
            return FuncUnit.wait(0, selector);
        }
        this.selector = selector;
        if (isSyncOnly === true) {
            var collection = performSyncQuery(selector, frame);
            return collection;
        } else {
            performAsyncQuery(selector, frame, this);
            var collection = performSyncQuery(selector, frame);
            return collection;
        }
    };
    var getContext = function (context) {
            if (typeof context === 'number' || typeof context === 'string') {
                var sel = typeof context === 'number' ? 'iframe:eq(' + context + ')' : 'iframe[name=\'' + context + '\']', frames = new origFuncUnit.fn.init(sel, FuncUnit.win.document.documentElement, true);
                var frame = (frames.length ? frames.get(0).contentWindow : FuncUnit.win).document.documentElement;
            } else {
                frame = FuncUnit.win.document.documentElement;
            }
            return frame;
        }, performAsyncQuery = function (selector, frame, self) {
            FuncUnit.add({
                method: function (success, error) {
                    this.frame = frame;
                    if (FuncUnit.win) {
                        frame = getContext(frame);
                    }
                    this.selector = selector;
                    this.bind = new origFuncUnit.fn.init(selector, frame, true);
                    success();
                    return this;
                },
                error: 'selector failed: ' + selector,
                type: 'query'
            });
        }, performSyncQuery = function (selector, frame) {
            var origFrame = frame;
            if (FuncUnit.win) {
                frame = getContext(frame);
            }
            var obj = new origFuncUnit.fn.init(selector, frame, true);
            obj.frame = origFrame;
            return obj;
        };
    oldFuncUnit.jQuery.extend(FuncUnit, oldFuncUnit, origFuncUnit);
    FuncUnit.prototype = origFuncUnit.prototype;
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#browser/adapters/jasmine*/
define('funcunit@3.6.3#browser/adapters/jasmine', function (require, exports, module) {
    module.exports = function (jasmine) {
        var paused = false;
        return {
            pauseTest: function () {
                paused = true;
                waitsFor(function () {
                    return paused === false;
                }, 60000);
            },
            resumeTest: function () {
                paused = false;
            },
            assertOK: function (assertion) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return jasmine.getEnv().equals_(expected, actual);
            }
        };
    };
});
/*funcunit@3.6.3#browser/adapters/jasmine2*/
define('funcunit@3.6.3#browser/adapters/jasmine2', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    module.exports = function () {
        FuncUnit.timeout = 4900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion) {
                expect(assertion).toBeTruthy();
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.6.3#browser/adapters/qunit*/
define('funcunit@3.6.3#browser/adapters/qunit', function (require, exports, module) {
    module.exports = function (QUnit) {
        return {
            pauseTest: function () {
                QUnit.stop();
            },
            resumeTest: function () {
                QUnit.start();
            },
            assertOK: function (assertion, message) {
                QUnit.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return QUnit.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.6.3#browser/adapters/qunit2*/
define('funcunit@3.6.3#browser/adapters/qunit2', function (require, exports, module) {
    module.exports = function (runner) {
        var done;
        var currentTestAssert;
        var originalTest = runner.test;
        runner.test = function funcunitTest(title, test) {
            return originalTest(title, function (assert) {
                currentTestAssert = assert;
                return test.apply(this, arguments);
            });
        };
        return {
            pauseTest: function () {
                done = currentTestAssert.async();
            },
            resumeTest: function () {
                done();
            },
            assertOK: function (assertion, message) {
                currentTestAssert.ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return runner.equiv(expected, actual);
            }
        };
    };
});
/*funcunit@3.6.3#browser/adapters/mocha*/
define('funcunit@3.6.3#browser/adapters/mocha', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    var ok = function (expr, msg) {
        if (!expr)
            throw new Error(msg);
    };
    module.exports = function () {
        FuncUnit.timeout = 1900;
        return {
            pauseTest: function () {
            },
            resumeTest: function () {
            },
            assertOK: function (assertion, message) {
                ok(assertion, message);
            },
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
    };
});
/*funcunit@3.6.3#browser/adapters/adapters*/
define('funcunit@3.6.3#browser/adapters/adapters', [
    'require',
    'exports',
    'module',
    'funcunit/browser/adapters/jasmine',
    'funcunit/browser/adapters/jasmine2',
    'funcunit/browser/adapters/qunit',
    'funcunit/browser/adapters/qunit2',
    'funcunit/browser/adapters/mocha',
    'funcunit/browser/core'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var jasmineAdapter = require('funcunit/browser/adapters/jasmine');
        var jasmine2Adapter = require('funcunit/browser/adapters/jasmine2');
        var qunitAdapter = require('funcunit/browser/adapters/qunit');
        var qunit2Adapter = require('funcunit/browser/adapters/qunit2');
        var mochaAdapter = require('funcunit/browser/adapters/mocha');
        var FuncUnit = require('funcunit/browser/core');
        var noop = function () {
        };
        var defaultAdapter = {
            pauseTest: noop,
            resumeTest: noop,
            assertOK: noop,
            equiv: function (expected, actual) {
                return expected == actual;
            }
        };
        FuncUnit.unit = defaultAdapter;
        FuncUnit.attach = function (runner) {
            var unit;
            if (isQUnit(runner)) {
                unit = qunitAdapter(runner);
            } else if (isQUnit2(runner)) {
                unit = qunit2Adapter(runner);
            } else if (isMocha(runner)) {
                unit = mochaAdapter(runner);
            } else if (isJasmine(runner)) {
                unit = jasmineAdapter(runner);
            } else if (isJasmine2(runner)) {
                unit = jasmine2Adapter(runner);
            } else {
                unit = defaultAdapter;
            }
            FuncUnit.unit = unit;
        };
        function isQUnit(runner) {
            return !!(runner.ok && runner.start && runner.stop);
        }
        function isQUnit2(runner) {
            return !!(runner.assert && runner.assert.ok && runner.assert.async);
        }
        function isMocha(runner) {
            return !!(runner.setup && runner.globals && runner.reporter);
        }
        function isJasmine(runner) {
            return !!(runner.getEnv && typeof window.waitsFor === 'function');
        }
        function isJasmine2(runner) {
            return !!(runner.getEnv && typeof runner.clock === 'function' && !window.waitsFor);
        }
        FuncUnit.detach = function () {
            FuncUnit.unit = defaultAdapter;
        };
    }(function () {
        return this;
    }(), require, exports, module));
});
/*syn@0.13.0#synthetic*/
define('syn@0.13.0#synthetic', function (require, exports, module) {
    var opts = window.syn ? window.syn : {};
    var extend = function (d, s) {
            var p;
            for (p in s) {
                d[p] = s[p];
            }
            return d;
        }, browser = {
            msie: !!(window.attachEvent && !window.opera) || navigator.userAgent.indexOf('Trident/') > -1,
            opera: !!window.opera,
            webkit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
            safari: navigator.userAgent.indexOf('AppleWebKit/') > -1 && navigator.userAgent.indexOf('Chrome/') === -1,
            gecko: navigator.userAgent.indexOf('Gecko') > -1,
            mobilesafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/),
            rhino: navigator.userAgent.match(/Rhino/) && true
        }, createEventObject = function (type, options, element) {
            var event = element.ownerDocument.createEventObject();
            return extend(event, options);
        }, data = {}, id = 1, expando = '_synthetic' + new Date().getTime(), bind, unbind, schedule, key = /keypress|keyup|keydown/, page = /load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll/, activeElement, syn = function (type, element, options, callback) {
            return new syn.init(type, element, options, callback);
        };
    syn.config = opts;
    syn.__tryFocus = function tryFocus(element) {
        try {
            element.focus();
        } catch (e) {
        }
    };
    bind = function (el, ev, f) {
        return el.addEventListener ? el.addEventListener(ev, f, false) : el.attachEvent('on' + ev, f);
    };
    unbind = function (el, ev, f) {
        return el.addEventListener ? el.removeEventListener(ev, f, false) : el.detachEvent('on' + ev, f);
    };
    schedule = syn.config.schedule || function (fn, ms) {
        setTimeout(fn, ms);
    };
    extend(syn, {
        init: function (type, element, options, callback) {
            var args = syn.args(options, element, callback), self = this;
            this.queue = [];
            this.element = args.element;
            if (typeof this[type] === 'function') {
                this[type](args.element, args.options, function (defaults, el) {
                    if (args.callback) {
                        args.callback.apply(self, arguments);
                    }
                    self.done.apply(self, arguments);
                });
            } else {
                this.result = syn.trigger(args.element, type, args.options);
                if (args.callback) {
                    args.callback.call(this, args.element, this.result);
                }
            }
        },
        jquery: function (el, fast) {
            if (window.FuncUnit && window.FuncUnit.jQuery) {
                return window.FuncUnit.jQuery;
            }
            if (el) {
                return syn.helpers.getWindow(el).jQuery || window.jQuery;
            } else {
                return window.jQuery;
            }
        },
        args: function () {
            var res = {}, i = 0;
            for (; i < arguments.length; i++) {
                if (typeof arguments[i] === 'function') {
                    res.callback = arguments[i];
                } else if (arguments[i] && arguments[i].jquery) {
                    res.element = arguments[i][0];
                } else if (arguments[i] && arguments[i].nodeName) {
                    res.element = arguments[i];
                } else if (res.options && typeof arguments[i] === 'string') {
                    res.element = document.getElementById(arguments[i]);
                } else if (arguments[i]) {
                    res.options = arguments[i];
                }
            }
            return res;
        },
        click: function (element, options, callback) {
            syn('click!', element, options, callback);
        },
        defaults: {
            focus: function focus() {
                if (!syn.support.focusChanges) {
                    var element = this, nodeName = element.nodeName.toLowerCase();
                    syn.data(element, 'syntheticvalue', element.value);
                    if (nodeName === 'input' || nodeName === 'textarea') {
                        bind(element, 'blur', function blur() {
                            if (syn.data(element, 'syntheticvalue') !== element.value) {
                                syn.trigger(element, 'change', {});
                            }
                            unbind(element, 'blur', blur);
                        });
                    }
                }
            },
            submit: function () {
                syn.onParents(this, function (el) {
                    if (el.nodeName.toLowerCase() === 'form') {
                        el.submit();
                        return false;
                    }
                });
            }
        },
        changeOnBlur: function (element, prop, value) {
            bind(element, 'blur', function onblur() {
                if (value !== element[prop]) {
                    syn.trigger(element, 'change', {});
                }
                unbind(element, 'blur', onblur);
            });
        },
        closest: function (el, type) {
            while (el && el.nodeName.toLowerCase() !== type.toLowerCase()) {
                el = el.parentNode;
            }
            return el;
        },
        data: function (el, key, value) {
            var d;
            if (!el[expando]) {
                el[expando] = id++;
            }
            if (!data[el[expando]]) {
                data[el[expando]] = {};
            }
            d = data[el[expando]];
            if (value) {
                data[el[expando]][key] = value;
            } else {
                return data[el[expando]][key];
            }
        },
        onParents: function (el, func) {
            var res;
            while (el && res !== false) {
                res = func(el);
                el = el.parentNode;
            }
            return el;
        },
        focusable: /^(a|area|frame|iframe|label|input|select|textarea|button|html|object)$/i,
        isFocusable: function (elem) {
            var attributeNode;
            if (elem.getAttributeNode) {
                attributeNode = elem.getAttributeNode('tabIndex');
            }
            return this.focusable.test(elem.nodeName) || attributeNode && attributeNode.specified && syn.isVisible(elem);
        },
        isVisible: function (elem) {
            return elem.offsetWidth && elem.offsetHeight || elem.clientWidth && elem.clientHeight;
        },
        tabIndex: function (elem) {
            var attributeNode = elem.getAttributeNode('tabIndex');
            return attributeNode && attributeNode.specified && (parseInt(elem.getAttribute('tabIndex')) || 0);
        },
        bind: bind,
        unbind: unbind,
        schedule: schedule,
        browser: browser,
        helpers: {
            createEventObject: createEventObject,
            createBasicStandardEvent: function (type, defaults, doc) {
                var event;
                try {
                    event = doc.createEvent('Events');
                } catch (e2) {
                    event = doc.createEvent('UIEvents');
                } finally {
                    event.initEvent(type, true, true);
                    extend(event, defaults);
                }
                return event;
            },
            inArray: function (item, array) {
                var i = 0;
                for (; i < array.length; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            },
            getWindow: function (element) {
                if (element.ownerDocument) {
                    return element.ownerDocument.defaultView || element.ownerDocument.parentWindow;
                }
            },
            extend: extend,
            scrollOffset: function (win, set) {
                var doc = win.document.documentElement, body = win.document.body;
                if (set) {
                    window.scrollTo(set.left, set.top);
                } else {
                    return {
                        left: (doc && doc.scrollLeft || body && body.scrollLeft || 0) + (doc.clientLeft || 0),
                        top: (doc && doc.scrollTop || body && body.scrollTop || 0) + (doc.clientTop || 0)
                    };
                }
            },
            scrollDimensions: function (win) {
                var doc = win.document.documentElement, body = win.document.body, docWidth = doc.clientWidth, docHeight = doc.clientHeight, compat = win.document.compatMode === 'CSS1Compat';
                return {
                    height: compat && docHeight || body.clientHeight || docHeight,
                    width: compat && docWidth || body.clientWidth || docWidth
                };
            },
            addOffset: function (options, el) {
                var jq = syn.jquery(el), off;
                if (typeof options === 'object' && options.clientX === undefined && options.clientY === undefined && options.pageX === undefined && options.pageY === undefined && jq) {
                    el = jq(el);
                    off = el.offset();
                    options.pageX = off.left + el.width() / 2;
                    options.pageY = off.top + el.height() / 2;
                }
            }
        },
        key: {
            ctrlKey: null,
            altKey: null,
            shiftKey: null,
            metaKey: null
        },
        dispatch: function (event, element, type, autoPrevent) {
            if (element.dispatchEvent && event) {
                var preventDefault = event.preventDefault, prevents = autoPrevent ? -1 : 0;
                if (autoPrevent) {
                    bind(element, type, function ontype(ev) {
                        ev.preventDefault();
                        unbind(this, type, ontype);
                    });
                }
                event.preventDefault = function () {
                    prevents++;
                    if (++prevents > 0) {
                        preventDefault.apply(this, []);
                    }
                };
                element.dispatchEvent(event);
                return prevents <= 0;
            } else {
                try {
                    window.event = event;
                } catch (e) {
                }
                return element.sourceIndex <= 0 || element.fireEvent && element.fireEvent('on' + type, event);
            }
        },
        create: {
            page: {
                event: function (type, options, element) {
                    var doc = syn.helpers.getWindow(element).document || document, event;
                    if (doc.createEvent) {
                        event = doc.createEvent('Events');
                        event.initEvent(type, true, true);
                        return event;
                    } else {
                        try {
                            event = createEventObject(type, options, element);
                        } catch (e) {
                        }
                        return event;
                    }
                }
            },
            focus: {
                event: function (type, options, element) {
                    syn.onParents(element, function (el) {
                        if (syn.isFocusable(el)) {
                            if (el.nodeName.toLowerCase() !== 'html') {
                                syn.__tryFocus(el);
                                activeElement = el;
                            } else if (activeElement) {
                                var doc = syn.helpers.getWindow(element).document;
                                if (doc !== window.document) {
                                    return false;
                                } else if (doc.activeElement) {
                                    doc.activeElement.blur();
                                    activeElement = null;
                                } else {
                                    activeElement.blur();
                                    activeElement = null;
                                }
                            }
                            return false;
                        }
                    });
                    return true;
                }
            }
        },
        support: {
            clickChanges: false,
            clickSubmits: false,
            keypressSubmits: false,
            mouseupSubmits: false,
            radioClickChanges: false,
            focusChanges: false,
            linkHrefJS: false,
            keyCharacters: false,
            backspaceWorks: false,
            mouseDownUpClicks: false,
            tabKeyTabs: false,
            keypressOnAnchorClicks: false,
            optionClickBubbles: false,
            pointerEvents: false,
            touchEvents: false,
            ready: 0
        },
        trigger: function (element, type, options) {
            if (!options) {
                options = {};
            }
            var create = syn.create, setup = create[type] && create[type].setup, kind = key.test(type) ? 'key' : page.test(type) ? 'page' : 'mouse', createType = create[type] || {}, createKind = create[kind], event, ret, autoPrevent, dispatchEl = element;
            if (syn.support.ready === 2 && setup) {
                setup(type, options, element);
            }
            autoPrevent = options._autoPrevent;
            delete options._autoPrevent;
            if (createType.event) {
                ret = createType.event(type, options, element);
            } else {
                options = createKind.options ? createKind.options(type, options, element) : options;
                if (!syn.support.changeBubbles && /option/i.test(element.nodeName)) {
                    dispatchEl = element.parentNode;
                }
                event = createKind.event(type, options, dispatchEl);
                ret = syn.dispatch(event, dispatchEl, type, autoPrevent);
            }
            if (ret && syn.support.ready === 2 && syn.defaults[type]) {
                syn.defaults[type].call(element, options, autoPrevent);
            }
            return ret;
        },
        eventSupported: function (eventName) {
            var el = document.createElement('div');
            eventName = 'on' + eventName;
            var isSupported = eventName in el;
            if (!isSupported) {
                el.setAttribute(eventName, 'return;');
                isSupported = typeof el[eventName] === 'function';
            }
            el = null;
            return isSupported;
        }
    });
    extend(syn.init.prototype, {
        then: function (type, element, options, callback) {
            if (syn.autoDelay) {
                this.delay();
            }
            var args = syn.args(options, element, callback), self = this;
            this.queue.unshift(function (el, prevented) {
                if (typeof this[type] === 'function') {
                    this.element = args.element || el;
                    this[type](this.element, args.options, function (defaults, el) {
                        if (args.callback) {
                            args.callback.apply(self, arguments);
                        }
                        self.done.apply(self, arguments);
                    });
                } else {
                    this.result = syn.trigger(args.element, type, args.options);
                    if (args.callback) {
                        args.callback.call(this, args.element, this.result);
                    }
                    return this;
                }
            });
            return this;
        },
        delay: function (timeout, callback) {
            if (typeof timeout === 'function') {
                callback = timeout;
                timeout = null;
            }
            timeout = timeout || 600;
            var self = this;
            this.queue.unshift(function () {
                schedule(function () {
                    if (callback) {
                        callback.apply(self, []);
                    }
                    self.done.apply(self, arguments);
                }, timeout);
            });
            return this;
        },
        done: function (defaults, el) {
            if (el) {
                this.element = el;
            }
            if (this.queue.length) {
                this.queue.pop().call(this, this.element, defaults);
            }
        },
        '_click': function (element, options, callback, force) {
            syn.helpers.addOffset(options, element);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', options);
            }
            if (syn.support.touchEvents) {
                syn.trigger(element, 'touchstart', options);
            }
            syn.trigger(element, 'mousedown', options);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', options);
                }
                if (syn.support.touchEvents) {
                    syn.trigger(element, 'touchend', options);
                }
                syn.trigger(element, 'mouseup', options);
                if (!syn.support.mouseDownUpClicks || force) {
                    syn.trigger(element, 'click', options);
                    callback(true);
                } else {
                    syn.create.click.setup('click', options, element);
                    syn.defaults.click.call(element);
                    schedule(function () {
                        callback(true);
                    }, 1);
                }
            }, 1);
        },
        '_rightClick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var mouseopts = extend(extend({}, syn.mouse.browser.right.mouseup), options);
            if (syn.support.pointerEvents) {
                syn.trigger(element, 'pointerdown', mouseopts);
            }
            syn.trigger(element, 'mousedown', mouseopts);
            schedule(function () {
                if (syn.support.pointerEvents) {
                    syn.trigger(element, 'pointerup', mouseopts);
                }
                syn.trigger(element, 'mouseup', mouseopts);
                if (syn.mouse.browser.right.contextmenu) {
                    syn.trigger(element, 'contextmenu', extend(extend({}, syn.mouse.browser.right.contextmenu), options));
                }
                callback(true);
            }, 1);
        },
        '_dblclick': function (element, options, callback) {
            syn.helpers.addOffset(options, element);
            var self = this;
            this._click(element, options, function () {
                schedule(function () {
                    self._click(element, options, function () {
                        syn.trigger(element, 'dblclick', options);
                        callback(true);
                    }, true);
                }, 2);
            });
        }
    });
    var actions = [
            'click',
            'dblclick',
            'move',
            'drag',
            'key',
            'type',
            'rightClick'
        ], makeAction = function (name) {
            syn[name] = function (element, options, callback) {
                return syn('_' + name, element, options, callback);
            };
            syn.init.prototype[name] = function (element, options, callback) {
                return this.then('_' + name, element, options, callback);
            };
        }, i = 0;
    for (; i < actions.length; i++) {
        makeAction(actions[i]);
    }
    module.exports = syn;
});
/*syn@0.13.0#mouse*/
define('syn@0.13.0#mouse', [
    'require',
    'exports',
    'module',
    './synthetic'
], function (require, exports, module) {
    var syn = require('./synthetic');
    var h = syn.helpers, getWin = h.getWindow;
    syn.mouse = {};
    h.extend(syn.defaults, {
        mousedown: function (options) {
            syn.trigger(this, 'focus', {});
        },
        click: function () {
            var element = this, href, type, createChange, radioChanged, nodeName, scope;
            try {
                href = element.href;
                type = element.type;
                createChange = syn.data(element, 'createChange');
                radioChanged = syn.data(element, 'radioChanged');
                scope = getWin(element);
                nodeName = element.nodeName.toLowerCase();
            } catch (e) {
                return;
            }
            if (!syn.support.linkHrefJS && /^\s*javascript:/.test(href)) {
                var code = href.replace(/^\s*javascript:/, '');
                if (code !== '//' && code.indexOf('void(0)') === -1) {
                    if (window.selenium) {
                        eval('with(selenium.browserbot.getCurrentWindow()){' + code + '}');
                    } else {
                        eval('with(scope){' + code + '}');
                    }
                }
            }
            if (!syn.support.clickSubmits && ((nodeName === 'input' || nodeName === 'button') && type === 'submit')) {
                var form = syn.closest(element, 'form');
                if (form) {
                    syn.trigger(form, 'submit', {});
                }
            }
            if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(href)) {
                scope.location.href = href;
            }
            if (nodeName === 'input' && type === 'checkbox') {
                if (!syn.support.clickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'input' && type === 'radio') {
                if (radioChanged && !syn.support.radioClickChanges) {
                    syn.trigger(element, 'change', {});
                }
            }
            if (nodeName === 'option' && createChange) {
                syn.trigger(element.parentNode, 'change', {});
                syn.data(element, 'createChange', false);
            }
        }
    });
    h.extend(syn.create, {
        mouse: {
            options: function (type, options, element) {
                var doc = document.documentElement, body = document.body, center = [
                        options.pageX || 0,
                        options.pageY || 0
                    ], left = syn.mouse.browser && syn.mouse.browser.left[type], right = syn.mouse.browser && syn.mouse.browser.right[type];
                return h.extend({
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    detail: 1,
                    screenX: 1,
                    screenY: 1,
                    clientX: options.clientX || center[0] - (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0),
                    clientY: options.clientY || center[1] - (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0),
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey,
                    button: left && left.button !== null ? left.button : right && right.button || (type === 'contextmenu' ? 2 : 0),
                    relatedTarget: document.documentElement
                }, options);
            },
            event: function (type, defaults, element) {
                var doc = getWin(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('MouseEvents');
                        event.initMouseEvent(type, defaults.bubbles, defaults.cancelable, defaults.view, defaults.detail, defaults.screenX, defaults.screenY, defaults.clientX, defaults.clientY, defaults.ctrlKey, defaults.altKey, defaults.shiftKey, defaults.metaKey, defaults.button, defaults.relatedTarget);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, defaults, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject(type, defaults, element);
                    } catch (e) {
                    }
                    return event;
                }
            }
        },
        click: {
            setup: function (type, options, element) {
                var nodeName = element.nodeName.toLowerCase();
                if (!syn.support.clickChecks && !syn.support.changeChecks && nodeName === 'input') {
                    type = element.type.toLowerCase();
                    if (type === 'checkbox') {
                        element.checked = !element.checked;
                    }
                    if (type === 'radio') {
                        if (!element.checked) {
                            try {
                                syn.data(element, 'radioChanged', true);
                            } catch (e) {
                            }
                            element.checked = true;
                        }
                    }
                }
                if (nodeName === 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
                    syn.data(element, 'href', element.href);
                }
                if (/option/i.test(element.nodeName)) {
                    var child = element.parentNode.firstChild, i = -1;
                    while (child) {
                        if (child.nodeType === 1) {
                            i++;
                            if (child === element) {
                                break;
                            }
                        }
                        child = child.nextSibling;
                    }
                    if (i !== element.parentNode.selectedIndex) {
                        element.parentNode.selectedIndex = i;
                        syn.data(element, 'createChange', true);
                    }
                }
            }
        },
        mousedown: {
            setup: function (type, options, element) {
                var nn = element.nodeName.toLowerCase();
                if (syn.browser.safari && (nn === 'select' || nn === 'option')) {
                    options._autoPrevent = true;
                }
            }
        }
    });
});
/*syn@0.13.0#mouse.support*/
define('syn@0.13.0#mouse.support', [
    'require',
    'exports',
    'module',
    './synthetic',
    './mouse'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse');
    (function checkSupport() {
        if (!document.body) {
            return syn.schedule(checkSupport, 1);
        }
        window.__synthTest = function () {
            syn.support.linkHrefJS = true;
        };
        var div = document.createElement('div'), checkbox, submit, form, select;
        div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'javascript:__synthTest()\' id=\'synlink\'></a>' + '<select><option></option></select>' + '</form>';
        document.documentElement.appendChild(div);
        form = div.firstChild;
        checkbox = form.childNodes[0];
        submit = form.childNodes[2];
        select = form.getElementsByTagName('select')[0];
        syn.trigger(form.childNodes[6], 'click', {});
        checkbox.checked = false;
        checkbox.onchange = function () {
            syn.support.clickChanges = true;
        };
        syn.trigger(checkbox, 'click', {});
        syn.support.clickChecks = checkbox.checked;
        checkbox.checked = false;
        syn.trigger(checkbox, 'change', {});
        syn.support.changeChecks = checkbox.checked;
        form.onsubmit = function (ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            syn.support.clickSubmits = true;
            return false;
        };
        syn.trigger(submit, 'click', {});
        form.childNodes[1].onchange = function () {
            syn.support.radioClickChanges = true;
        };
        syn.trigger(form.childNodes[1], 'click', {});
        syn.bind(div, 'click', function onclick() {
            syn.support.optionClickBubbles = true;
            syn.unbind(div, 'click', onclick);
        });
        syn.trigger(select.firstChild, 'click', {});
        syn.support.changeBubbles = syn.eventSupported('change');
        div.onclick = function () {
            syn.support.mouseDownUpClicks = true;
        };
        syn.trigger(div, 'mousedown', {});
        syn.trigger(div, 'mouseup', {});
        document.documentElement.removeChild(div);
        syn.support.pointerEvents = syn.eventSupported('pointerdown');
        syn.support.touchEvents = syn.eventSupported('touchstart');
        syn.support.ready++;
    }());
});
/*syn@0.13.0#browsers*/
define('syn@0.13.0#browsers', [
    'require',
    'exports',
    'module',
    './synthetic',
    './mouse'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse');
    syn.key.browsers = {
        webkit: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'char'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    0,
                    'char'
                ],
                'keyup': [
                    0,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        gecko: {
            'prevent': {
                'keyup': [],
                'keydown': ['char'],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    'char',
                    0
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'navigation': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\t': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'pause-break': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    0,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    0,
                    'key'
                ],
                'keypress': [
                    0,
                    'key'
                ],
                'keyup': [
                    0,
                    'key'
                ]
            }
        },
        msie: {
            'prevent': {
                'keyup': [],
                'keydown': [
                    'char',
                    'keypress'
                ],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {
                'keyup': [
                    null,
                    'key'
                ]
            },
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        },
        opera: {
            'prevent': {
                'keyup': [],
                'keydown': [],
                'keypress': ['char']
            },
            'character': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'specialChars': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'navigation': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'special': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'tab': {
                'keydown': [
                    null,
                    'char'
                ],
                'keypress': [
                    null,
                    'char'
                ],
                'keyup': [
                    null,
                    'char'
                ]
            },
            'pause-break': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'caps': {
                'keydown': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'escape': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'num-lock': {
                'keyup': [
                    null,
                    'key'
                ],
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ]
            },
            'scroll-lock': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            'print': {},
            'function': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            },
            '\r': {
                'keydown': [
                    null,
                    'key'
                ],
                'keypress': [
                    null,
                    'key'
                ],
                'keyup': [
                    null,
                    'key'
                ]
            }
        }
    };
    syn.mouse.browsers = {
        webkit: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        opera: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        msie: {
            'right': {
                'mousedown': { 'button': 2 },
                'mouseup': { 'button': 2 },
                'contextmenu': { 'button': 0 }
            },
            'left': {
                'mousedown': { 'button': 1 },
                'mouseup': { 'button': 1 },
                'click': { 'button': 0 }
            }
        },
        chrome: {
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            },
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            }
        },
        gecko: {
            'left': {
                'mousedown': {
                    'button': 0,
                    'which': 1
                },
                'mouseup': {
                    'button': 0,
                    'which': 1
                },
                'click': {
                    'button': 0,
                    'which': 1
                }
            },
            'right': {
                'mousedown': {
                    'button': 2,
                    'which': 3
                },
                'mouseup': {
                    'button': 2,
                    'which': 3
                },
                'contextmenu': {
                    'button': 2,
                    'which': 3
                }
            }
        }
    };
    syn.key.browser = function () {
        if (syn.key.browsers[window.navigator.userAgent]) {
            return syn.key.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.key.browsers[browser]) {
                return syn.key.browsers[browser];
            }
        }
        return syn.key.browsers.gecko;
    }();
    syn.mouse.browser = function () {
        if (syn.mouse.browsers[window.navigator.userAgent]) {
            return syn.mouse.browsers[window.navigator.userAgent];
        }
        for (var browser in syn.browser) {
            if (syn.browser[browser] && syn.mouse.browsers[browser]) {
                return syn.mouse.browsers[browser];
            }
        }
        return syn.mouse.browsers.gecko;
    }();
});
/*syn@0.13.0#typeable*/
define('syn@0.13.0#typeable', [
    'require',
    'exports',
    'module',
    './synthetic'
], function (require, exports, module) {
    var syn = require('./synthetic');
    var typeables = [];
    var __indexOf = [].indexOf || function (item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item) {
                return i;
            }
        }
        return -1;
    };
    syn.typeable = function (fn) {
        if (__indexOf.call(typeables, fn) === -1) {
            typeables.push(fn);
        }
    };
    syn.typeable.test = function (el) {
        for (var i = 0, len = typeables.length; i < len; i++) {
            if (typeables[i](el)) {
                return true;
            }
        }
        return false;
    };
    var type = syn.typeable;
    var typeableExp = /input|textarea/i;
    type(function (el) {
        return typeableExp.test(el.nodeName);
    });
    type(function (el) {
        return __indexOf.call([
            '',
            'true'
        ], el.getAttribute('contenteditable')) !== -1;
    });
});
/*syn@0.13.0#key*/
define('syn@0.13.0#key', [
    'require',
    'exports',
    'module',
    './synthetic',
    './typeable',
    './browsers'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./typeable');
    require('./browsers');
    var h = syn.helpers, formElExp = /input|textarea/i, supportsSelection = function (el) {
            var result;
            try {
                result = el.selectionStart !== undefined && el.selectionStart !== null;
            } catch (e) {
                result = false;
            }
            return result;
        }, getSelection = function (el) {
            var real, r, start;
            if (supportsSelection(el)) {
                if (document.activeElement && document.activeElement !== el && el.selectionStart === el.selectionEnd && el.selectionStart === 0) {
                    return {
                        start: el.value.length,
                        end: el.value.length
                    };
                }
                return {
                    start: el.selectionStart,
                    end: el.selectionEnd
                };
            } else {
                try {
                    if (el.nodeName.toLowerCase() === 'input') {
                        real = h.getWindow(el).document.selection.createRange();
                        r = el.createTextRange();
                        r.setEndPoint('EndToStart', real);
                        start = r.text.length;
                        return {
                            start: start,
                            end: start + real.text.length
                        };
                    } else {
                        real = h.getWindow(el).document.selection.createRange();
                        r = real.duplicate();
                        var r2 = real.duplicate(), r3 = real.duplicate();
                        r2.collapse();
                        r3.collapse(false);
                        r2.moveStart('character', -1);
                        r3.moveStart('character', -1);
                        r.moveToElementText(el);
                        r.setEndPoint('EndToEnd', real);
                        start = r.text.length - real.text.length;
                        var end = r.text.length;
                        if (start !== 0 && r2.text === '') {
                            start += 2;
                        }
                        if (end !== 0 && r3.text === '') {
                            end += 2;
                        }
                        return {
                            start: start,
                            end: end
                        };
                    }
                } catch (e) {
                    var prop = formElExp.test(el.nodeName) ? 'value' : 'textContent';
                    return {
                        start: el[prop].length,
                        end: el[prop].length
                    };
                }
            }
        }, getFocusable = function (el) {
            var document = h.getWindow(el).document, res = [];
            var els = document.getElementsByTagName('*'), len = els.length;
            for (var i = 0; i < len; i++) {
                if (syn.isFocusable(els[i]) && els[i] !== document.documentElement) {
                    res.push(els[i]);
                }
            }
            return res;
        }, textProperty = function () {
            var el = document.createElement('span');
            return el.textContent != null ? 'textContent' : 'innerText';
        }(), getText = function (el) {
            if (formElExp.test(el.nodeName)) {
                return el.value;
            }
            return el[textProperty];
        }, setText = function (el, value) {
            if (formElExp.test(el.nodeName)) {
                el.value = value;
            } else {
                el[textProperty] = value;
            }
        };
    h.extend(syn, {
        keycodes: {
            '\b': 8,
            '\t': 9,
            '\r': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'meta': 91,
            'pause-break': 19,
            'caps': 20,
            'escape': 27,
            'num-lock': 144,
            'scroll-lock': 145,
            'print': 44,
            'page-up': 33,
            'page-down': 34,
            'end': 35,
            'home': 36,
            'left': 37,
            'up': 38,
            'right': 39,
            'down': 40,
            'insert': 45,
            'delete': 46,
            ' ': 32,
            '0': 48,
            '1': 49,
            '2': 50,
            '3': 51,
            '4': 52,
            '5': 53,
            '6': 54,
            '7': 55,
            '8': 56,
            '9': 57,
            'a': 65,
            'b': 66,
            'c': 67,
            'd': 68,
            'e': 69,
            'f': 70,
            'g': 71,
            'h': 72,
            'i': 73,
            'j': 74,
            'k': 75,
            'l': 76,
            'm': 77,
            'n': 78,
            'o': 79,
            'p': 80,
            'q': 81,
            'r': 82,
            's': 83,
            't': 84,
            'u': 85,
            'v': 86,
            'w': 87,
            'x': 88,
            'y': 89,
            'z': 90,
            'num0': 96,
            'num1': 97,
            'num2': 98,
            'num3': 99,
            'num4': 100,
            'num5': 101,
            'num6': 102,
            'num7': 103,
            'num8': 104,
            'num9': 105,
            '*': 106,
            '+': 107,
            'subtract': 109,
            'decimal': 110,
            'divide': 111,
            ';': 186,
            '=': 187,
            ',': 188,
            'dash': 189,
            '-': 189,
            'period': 190,
            '.': 190,
            'forward-slash': 191,
            '/': 191,
            '`': 192,
            '[': 219,
            '\\': 220,
            ']': 221,
            '\'': 222,
            'left window key': 91,
            'right window key': 92,
            'select key': 93,
            'f1': 112,
            'f2': 113,
            'f3': 114,
            'f4': 115,
            'f5': 116,
            'f6': 117,
            'f7': 118,
            'f8': 119,
            'f9': 120,
            'f10': 121,
            'f11': 122,
            'f12': 123
        },
        selectText: function (el, start, end) {
            if (supportsSelection(el)) {
                if (!end) {
                    syn.__tryFocus(el);
                    el.setSelectionRange(start, start);
                } else {
                    el.selectionStart = start;
                    el.selectionEnd = end;
                }
            } else if (el.createTextRange) {
                var r = el.createTextRange();
                r.moveStart('character', start);
                end = end || start;
                r.moveEnd('character', end - el.value.length);
                r.select();
            }
        },
        getText: function (el) {
            if (syn.typeable.test(el)) {
                var sel = getSelection(el);
                return el.value.substring(sel.start, sel.end);
            }
            var win = syn.helpers.getWindow(el);
            if (win.getSelection) {
                return win.getSelection().toString();
            } else if (win.document.getSelection) {
                return win.document.getSelection().toString();
            } else {
                return win.document.selection.createRange().text;
            }
        },
        getSelection: getSelection
    });
    h.extend(syn.key, {
        data: function (key) {
            if (syn.key.browser[key]) {
                return syn.key.browser[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1) {
                    return syn.key.browser[kind];
                }
            }
            return syn.key.browser.character;
        },
        isSpecial: function (keyCode) {
            var specials = syn.key.kinds.special;
            for (var i = 0; i < specials.length; i++) {
                if (syn.keycodes[specials[i]] === keyCode) {
                    return specials[i];
                }
            }
        },
        options: function (key, event) {
            var keyData = syn.key.data(key);
            if (!keyData[event]) {
                return null;
            }
            var charCode = keyData[event][0], keyCode = keyData[event][1], result = {};
            if (keyCode === 'key') {
                result.keyCode = syn.keycodes[key];
            } else if (keyCode === 'char') {
                result.keyCode = key.charCodeAt(0);
            } else {
                result.keyCode = keyCode;
            }
            if (charCode === 'char') {
                result.charCode = key.charCodeAt(0);
            } else if (charCode !== null) {
                result.charCode = charCode;
            }
            if (result.keyCode) {
                result.which = result.keyCode;
            } else {
                result.which = result.charCode;
            }
            return result;
        },
        kinds: {
            special: [
                'shift',
                'ctrl',
                'alt',
                'meta',
                'caps'
            ],
            specialChars: ['\b'],
            navigation: [
                'page-up',
                'page-down',
                'end',
                'home',
                'left',
                'up',
                'right',
                'down',
                'insert',
                'delete'
            ],
            'function': [
                'f1',
                'f2',
                'f3',
                'f4',
                'f5',
                'f6',
                'f7',
                'f8',
                'f9',
                'f10',
                'f11',
                'f12'
            ]
        },
        getDefault: function (key) {
            if (syn.key.defaults[key]) {
                return syn.key.defaults[key];
            }
            for (var kind in syn.key.kinds) {
                if (h.inArray(key, syn.key.kinds[kind]) > -1 && syn.key.defaults[kind]) {
                    return syn.key.defaults[kind];
                }
            }
            return syn.key.defaults.character;
        },
        defaults: {
            'character': function (options, scope, key, force, sel) {
                if (/num\d+/.test(key)) {
                    key = key.match(/\d+/)[0];
                }
                if (force || !syn.support.keyCharacters && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end), character = key;
                    setText(this, before + character + after);
                    var charLength = character === '\n' && syn.support.textareaCarriage ? 2 : character.length;
                    syn.selectText(this, before.length + charLength);
                }
            },
            'c': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.clipboard = syn.getText(this);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'v': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.key.defaults.character.call(this, options, scope, syn.key.clipboard, true, sel);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'a': function (options, scope, key, force, sel) {
                if (syn.key.ctrlKey) {
                    syn.selectText(this, 0, getText(this).length);
                } else {
                    syn.key.defaults.character.apply(this, arguments);
                }
            },
            'home': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = 0;
                        return false;
                    }
                });
            },
            'end': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        el.scrollTop = el.scrollHeight;
                        return false;
                    }
                });
            },
            'page-down': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop += ch;
                        return false;
                    }
                });
            },
            'page-up': function () {
                syn.onParents(this, function (el) {
                    if (el.scrollHeight !== el.clientHeight) {
                        var ch = el.clientHeight;
                        el.scrollTop -= ch;
                        return false;
                    }
                });
            },
            '\b': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start > 0) {
                        setText(this, before.substring(0, before.length - 1) + after);
                        syn.selectText(this, sel.start - 1);
                    } else {
                        setText(this, before + after);
                        syn.selectText(this, sel.start);
                    }
                }
            },
            'delete': function (options, scope, key, force, sel) {
                if (!syn.support.backspaceWorks && syn.typeable.test(this)) {
                    var current = getText(this), before = current.substr(0, sel.start), after = current.substr(sel.end);
                    if (sel.start === sel.end && sel.start <= getText(this).length - 1) {
                        setText(this, before + after.substring(1));
                    } else {
                        setText(this, before + after);
                    }
                    syn.selectText(this, sel.start);
                }
            },
            '\r': function (options, scope, key, force, sel) {
                var nodeName = this.nodeName.toLowerCase();
                if (nodeName === 'input') {
                    syn.trigger(this, 'change', {});
                }
                if (!syn.support.keypressSubmits && nodeName === 'input') {
                    var form = syn.closest(this, 'form');
                    if (form) {
                        syn.trigger(form, 'submit', {});
                    }
                }
                if (!syn.support.keyCharacters && nodeName === 'textarea') {
                    syn.key.defaults.character.call(this, options, scope, '\n', undefined, sel);
                }
                if (!syn.support.keypressOnAnchorClicks && nodeName === 'a') {
                    syn.trigger(this, 'click', {});
                }
            },
            '\t': function (options, scope) {
                var focusEls = getFocusable(this), current = null, i = 0, el, firstNotIndexed, orders = [];
                for (; i < focusEls.length; i++) {
                    orders.push([
                        focusEls[i],
                        i
                    ]);
                }
                var sort = function (order1, order2) {
                    var el1 = order1[0], el2 = order2[0], tab1 = syn.tabIndex(el1) || 0, tab2 = syn.tabIndex(el2) || 0;
                    if (tab1 === tab2) {
                        return order1[1] - order2[1];
                    } else {
                        if (tab1 === 0) {
                            return 1;
                        } else if (tab2 === 0) {
                            return -1;
                        } else {
                            return tab1 - tab2;
                        }
                    }
                };
                orders.sort(sort);
                var ordersLength = orders.length;
                for (i = 0; i < ordersLength; i++) {
                    el = orders[i][0];
                    if (this === el) {
                        var nextIndex = i;
                        if (syn.key.shiftKey) {
                            nextIndex--;
                            current = nextIndex >= 0 && orders[nextIndex][0] || orders[ordersLength - 1][0];
                        } else {
                            nextIndex++;
                            current = nextIndex < ordersLength && orders[nextIndex][0] || orders[0][0];
                        }
                    }
                }
                if (!current) {
                    current = firstNotIndexed;
                } else {
                    syn.__tryFocus(current);
                }
                return current;
            },
            'left': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1, sel.end);
                    } else {
                        syn.selectText(this, sel.start === 0 ? 0 : sel.start - 1);
                    }
                }
            },
            'right': function (options, scope, key, force, sel) {
                if (syn.typeable.test(this)) {
                    if (syn.key.shiftKey) {
                        syn.selectText(this, sel.start, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    } else {
                        syn.selectText(this, sel.end + 1 > getText(this).length ? getText(this).length : sel.end + 1);
                    }
                }
            },
            'up': function () {
                if (/select/i.test(this.nodeName)) {
                    this.selectedIndex = this.selectedIndex ? this.selectedIndex - 1 : 0;
                }
            },
            'down': function () {
                if (/select/i.test(this.nodeName)) {
                    syn.changeOnBlur(this, 'selectedIndex', this.selectedIndex);
                    this.selectedIndex = this.selectedIndex + 1;
                }
            },
            'shift': function () {
                return null;
            },
            'ctrl': function () {
                return null;
            },
            'alt': function () {
                return null;
            },
            'meta': function () {
                return null;
            }
        }
    });
    h.extend(syn.create, {
        keydown: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = element;
                }
            }
        },
        keypress: {
            setup: function (type, options, element) {
                if (syn.support.keyCharacters && !syn.support.keysOnNotFocused) {
                    syn.__tryFocus(element);
                }
            }
        },
        keyup: {
            setup: function (type, options, element) {
                if (h.inArray(options, syn.key.kinds.special) !== -1) {
                    syn.key[options + 'Key'] = null;
                }
            }
        },
        key: {
            options: function (type, options, element) {
                options = typeof options !== 'object' ? { character: options } : options;
                options = h.extend({}, options);
                if (options.character) {
                    h.extend(options, syn.key.options(options.character, type));
                    delete options.character;
                }
                options = h.extend({
                    ctrlKey: !!syn.key.ctrlKey,
                    altKey: !!syn.key.altKey,
                    shiftKey: !!syn.key.shiftKey,
                    metaKey: !!syn.key.metaKey
                }, options);
                return options;
            },
            event: function (type, options, element) {
                var doc = h.getWindow(element).document || document, event;
                if (doc.createEvent) {
                    try {
                        event = doc.createEvent('KeyEvents');
                        event.initKeyEvent(type, true, true, window, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.keyCode, options.charCode);
                    } catch (e) {
                        event = h.createBasicStandardEvent(type, options, doc);
                    }
                    event.synthetic = true;
                    return event;
                } else {
                    try {
                        event = h.createEventObject.apply(this, arguments);
                        h.extend(event, options);
                    } catch (e) {
                    }
                    return event;
                }
            }
        }
    });
    var convert = {
        'enter': '\r',
        'backspace': '\b',
        'tab': '\t',
        'space': ' '
    };
    h.extend(syn.init.prototype, {
        _key: function (element, options, callback) {
            if (/-up$/.test(options) && h.inArray(options.replace('-up', ''), syn.key.kinds.special) !== -1) {
                syn.trigger(element, 'keyup', options.replace('-up', ''));
                return callback(true, element);
            }
            var activeElement = h.getWindow(element).document.activeElement, caret = syn.typeable.test(element) && getSelection(element), key = convert[options] || options, runDefaults = syn.trigger(element, 'keydown', key), getDefault = syn.key.getDefault, prevent = syn.key.browser.prevent, defaultResult, keypressOptions = syn.key.options(key, 'keypress');
            if (runDefaults) {
                if (!keypressOptions) {
                    defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                } else {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    runDefaults = syn.trigger(element, 'keypress', keypressOptions);
                    if (runDefaults) {
                        defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
                    }
                }
            } else {
                if (keypressOptions && h.inArray('keypress', prevent.keydown) === -1) {
                    if (activeElement !== h.getWindow(element).document.activeElement) {
                        element = h.getWindow(element).document.activeElement;
                    }
                    syn.trigger(element, 'keypress', keypressOptions);
                }
            }
            if (defaultResult && defaultResult.nodeName) {
                element = defaultResult;
            }
            if (defaultResult !== null) {
                syn.schedule(function () {
                    if (syn.support.oninput) {
                        syn.trigger(element, 'input', syn.key.options(key, 'input'));
                    }
                    syn.trigger(element, 'keyup', syn.key.options(key, 'keyup'));
                    callback(runDefaults, element);
                }, 1);
            } else {
                callback(runDefaults, element);
            }
            return element;
        },
        _type: function (element, options, callback) {
            var parts = (options + '').match(/(\[[^\]]+\])|([^\[])/g), self = this, runNextPart = function (runDefaults, el) {
                    var part = parts.shift();
                    if (!part) {
                        callback(runDefaults, el);
                        return;
                    }
                    el = el || element;
                    if (part.length > 1) {
                        part = part.substr(1, part.length - 2);
                    }
                    self._key(el, part, runNextPart);
                };
            runNextPart();
        }
    });
});
/*syn@0.13.0#key.support*/
define('syn@0.13.0#key.support', [
    'require',
    'exports',
    'module',
    './synthetic',
    './key'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./key');
    if (!syn.config.support) {
        (function checkForSupport() {
            if (!document.body) {
                return syn.schedule(checkForSupport, 1);
            }
            var div = document.createElement('div'), checkbox, submit, form, anchor, textarea, inputter, one, doc;
            doc = document.documentElement;
            div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'#abc\'></a>' + '<textarea>1\n2</textarea>' + '</form>';
            doc.insertBefore(div, doc.firstElementChild || doc.children[0]);
            form = div.firstChild;
            checkbox = form.childNodes[0];
            submit = form.childNodes[2];
            anchor = form.getElementsByTagName('a')[0];
            textarea = form.getElementsByTagName('textarea')[0];
            inputter = form.childNodes[3];
            one = form.childNodes[4];
            form.onsubmit = function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressSubmits = true;
                ev.returnValue = false;
                return false;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', '\r');
            syn.trigger(inputter, 'keypress', 'a');
            syn.support.keyCharacters = inputter.value === 'a';
            inputter.value = 'a';
            syn.trigger(inputter, 'keypress', '\b');
            syn.support.backspaceWorks = inputter.value === '';
            inputter.onchange = function () {
                syn.support.focusChanges = true;
            };
            syn.__tryFocus(inputter);
            syn.trigger(inputter, 'keypress', 'a');
            syn.__tryFocus(form.childNodes[5]);
            syn.trigger(inputter, 'keypress', 'b');
            syn.support.keysOnNotFocused = inputter.value === 'ab';
            syn.bind(anchor, 'click', function (ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                }
                syn.support.keypressOnAnchorClicks = true;
                ev.returnValue = false;
                return false;
            });
            syn.trigger(anchor, 'keypress', '\r');
            syn.support.textareaCarriage = textarea.value.length === 4;
            syn.support.oninput = 'oninput' in one;
            doc.removeChild(div);
            syn.support.ready++;
        }());
    } else {
        syn.helpers.extend(syn.support, syn.config.support);
    }
});
/*syn@0.13.0#drag*/
define('syn@0.13.0#drag', [
    'require',
    'exports',
    'module',
    './synthetic'
], function (require, exports, module) {
    var syn = require('./synthetic');
    var elementFromPoint = function (point, win) {
        var clientX = point.clientX;
        var clientY = point.clientY;
        if (point == null) {
            return null;
        }
        if (syn.support.elementFromPage) {
            var off = syn.helpers.scrollOffset(win);
            clientX = clientX + off.left;
            clientY = clientY + off.top;
        }
        return win.document.elementFromPoint(Math.round(clientX), Math.round(clientY));
    };
    var DragonDrop = {
        focusWindow: null,
        dragAndDrop: function (focusWindow, fromPoint, toPoint, duration, callback) {
            this.currentDataTransferItem = null;
            this.focusWindow = focusWindow;
            this._mouseOver(fromPoint);
            this._mouseEnter(fromPoint);
            this._mouseMove(fromPoint);
            this._mouseDown(fromPoint);
            this._dragStart(fromPoint);
            this._drag(fromPoint);
            this._dragEnter(fromPoint);
            this._dragOver(fromPoint);
            DragonDrop.startMove(fromPoint, toPoint, duration, function () {
                DragonDrop._dragLeave(fromPoint);
                DragonDrop._dragEnd(fromPoint);
                DragonDrop._mouseOut(fromPoint);
                DragonDrop._mouseLeave(fromPoint);
                DragonDrop._drop(toPoint);
                DragonDrop._dragEnd(toPoint);
                DragonDrop._mouseOver(toPoint);
                DragonDrop._mouseEnter(toPoint);
                DragonDrop._mouseMove(toPoint);
                DragonDrop._mouseOut(toPoint);
                DragonDrop._mouseLeave(toPoint);
                callback();
                DragonDrop.cleanup();
            });
        },
        _dragStart: function (node, options) {
            this.createAndDispatchEvent(node, 'dragstart', options);
        },
        _drag: function (node, options) {
            this.createAndDispatchEvent(node, 'drag', options);
        },
        _dragEnter: function (node, options) {
            this.createAndDispatchEvent(node, 'dragenter', options);
        },
        _dragOver: function (node, options) {
            this.createAndDispatchEvent(node, 'dragover', options);
        },
        _dragLeave: function (node, options) {
            this.createAndDispatchEvent(node, 'dragleave', options);
        },
        _drop: function (node, options) {
            this.createAndDispatchEvent(node, 'drop', options);
        },
        _dragEnd: function (node, options) {
            this.createAndDispatchEvent(node, 'dragend', options);
        },
        _mouseDown: function (node, options) {
            this.createAndDispatchEvent(node, 'mousedown', options);
        },
        _mouseMove: function (node, options) {
            this.createAndDispatchEvent(node, 'mousemove', options);
        },
        _mouseEnter: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseenter', options);
        },
        _mouseOver: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseover', options);
        },
        _mouseOut: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseout', options);
        },
        _mouseLeave: function (node, options) {
            this.createAndDispatchEvent(node, 'mouseleave', options);
        },
        createAndDispatchEvent: function (point, eventName, options) {
            if (point) {
                var targetElement = elementFromPoint(point, this.focusWindow);
                syn.trigger(targetElement, eventName, options);
            }
        },
        getDataTransferObject: function () {
            if (!this.currentDataTransferItem) {
                return this.currentDataTransferItem = this.createDataTransferObject();
            } else {
                return this.currentDataTransferItem;
            }
        },
        cleanup: function () {
            this.currentDataTransferItem = null;
            this.focusWindow = null;
        },
        createDataTransferObject: function () {
            var dataTransfer = {
                dropEffect: 'none',
                effectAllowed: 'uninitialized',
                files: [],
                items: [],
                types: [],
                data: [],
                setData: function (dataFlavor, value) {
                    var tempdata = {};
                    tempdata.dataFlavor = dataFlavor;
                    tempdata.val = value;
                    this.data.push(tempdata);
                },
                getData: function (dataFlavor) {
                    for (var i = 0; i < this.data.length; i++) {
                        var tempdata = this.data[i];
                        if (tempdata.dataFlavor === dataFlavor) {
                            return tempdata.val;
                        }
                    }
                }
            };
            return dataTransfer;
        },
        startMove: function (start, end, duration, callback) {
            var startTime = new Date();
            var distX = end.clientX - start.clientX;
            var distY = end.clientY - start.clientY;
            var win = this.focusWindow;
            var current = start;
            var cursor = win.document.createElement('div');
            var calls = 0;
            var move;
            move = function onmove() {
                var now = new Date();
                var scrollOffset = syn.helpers.scrollOffset(win);
                var fraction = (calls === 0 ? 0 : now - startTime) / duration;
                var options = {
                    clientX: distX * fraction + start.clientX,
                    clientY: distY * fraction + start.clientY
                };
                calls++;
                if (fraction < 1) {
                    syn.helpers.extend(cursor.style, {
                        left: options.clientX + scrollOffset.left + 2 + 'px',
                        top: options.clientY + scrollOffset.top + 2 + 'px'
                    });
                    current = DragonDrop.mouseMove(options, current);
                    syn.schedule(onmove, 15);
                } else {
                    current = DragonDrop.mouseMove(end, current);
                    win.document.body.removeChild(cursor);
                    callback();
                }
            };
            syn.helpers.extend(cursor.style, {
                height: '5px',
                width: '5px',
                backgroundColor: 'red',
                position: 'absolute',
                zIndex: 19999,
                fontSize: '1px'
            });
            win.document.body.appendChild(cursor);
            move();
        },
        mouseMove: function (thisPoint, previousPoint) {
            var thisElement = elementFromPoint(thisPoint, this.focusWindow);
            var previousElement = elementFromPoint(previousPoint, this.focusWindow);
            var options = syn.helpers.extend({}, thisPoint);
            if (thisElement !== previousElement) {
                options.relatedTarget = thisElement;
                this._dragLeave(previousPoint, options);
                options.relatedTarget = previousElement;
                this._dragEnter(thisPoint, options);
            }
            this._dragOver(thisPoint, options);
            return thisPoint;
        }
    };
    function createDragEvent(eventName, options, element) {
        var dragEvent = syn.create.mouse.event(eventName, options, element);
        dragEvent.dataTransfer = DragonDrop.getDataTransferObject();
        return syn.dispatch(dragEvent, element, eventName, false);
    }
    syn.create.dragstart = { event: createDragEvent };
    syn.create.dragenter = { event: createDragEvent };
    syn.create.dragover = { event: createDragEvent };
    syn.create.dragleave = { event: createDragEvent };
    syn.create.drag = { event: createDragEvent };
    syn.create.drop = { event: createDragEvent };
    syn.create.dragend = { event: createDragEvent };
    (function dragSupport() {
        if (!document.body) {
            syn.schedule(dragSupport, 1);
            return;
        }
        var div = document.createElement('div');
        document.body.appendChild(div);
        syn.helpers.extend(div.style, {
            width: '100px',
            height: '10000px',
            backgroundColor: 'blue',
            position: 'absolute',
            top: '10px',
            left: '0px',
            zIndex: 19999
        });
        document.body.scrollTop = 11;
        if (!document.elementFromPoint) {
            return;
        }
        var el = document.elementFromPoint(3, 1);
        if (el === div) {
            syn.support.elementFromClient = true;
        } else {
            syn.support.elementFromPage = true;
        }
        document.body.removeChild(div);
        document.body.scrollTop = 0;
    }());
    var mouseMove = function (point, win, last) {
            var el = elementFromPoint(point, win);
            if (last !== el && el && last) {
                var options = syn.helpers.extend({}, point);
                options.relatedTarget = el;
                if (syn.support.pointerEvents) {
                    syn.trigger(last, 'pointerout', options);
                }
                syn.trigger(last, 'mouseout', options);
                options.relatedTarget = last;
                if (syn.support.pointerEvents) {
                    syn.trigger(el, 'pointerover', options);
                }
                syn.trigger(el, 'mouseover', options);
            }
            if (syn.support.pointerEvents) {
                syn.trigger(el || win, 'pointermove', point);
            }
            if (syn.support.touchEvents) {
                syn.trigger(el || win, 'touchmove', point);
            }
            syn.trigger(el || win, 'mousemove', point);
            return el;
        }, createEventAtPoint = function (event, point, win) {
            var el = elementFromPoint(point, win);
            syn.trigger(el || win, event, point);
            return el;
        }, startMove = function (win, start, end, duration, callback) {
            var startTime = new Date(), distX = end.clientX - start.clientX, distY = end.clientY - start.clientY, current = elementFromPoint(start, win), cursor = win.document.createElement('div'), calls = 0, move;
            move = function onmove() {
                var now = new Date(), scrollOffset = syn.helpers.scrollOffset(win), fraction = (calls === 0 ? 0 : now - startTime) / duration, options = {
                        clientX: distX * fraction + start.clientX,
                        clientY: distY * fraction + start.clientY
                    };
                calls++;
                if (fraction < 1) {
                    syn.helpers.extend(cursor.style, {
                        left: options.clientX + scrollOffset.left + 2 + 'px',
                        top: options.clientY + scrollOffset.top + 2 + 'px'
                    });
                    current = mouseMove(options, win, current);
                    syn.schedule(onmove, 15);
                } else {
                    current = mouseMove(end, win, current);
                    win.document.body.removeChild(cursor);
                    callback();
                }
            };
            syn.helpers.extend(cursor.style, {
                height: '5px',
                width: '5px',
                backgroundColor: 'red',
                position: 'absolute',
                zIndex: 19999,
                fontSize: '1px'
            });
            win.document.body.appendChild(cursor);
            move();
        }, startDrag = function (win, fromPoint, toPoint, duration, callback) {
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointerover', fromPoint, win);
                createEventAtPoint('pointerenter', fromPoint, win);
            }
            createEventAtPoint('mouseover', fromPoint, win);
            createEventAtPoint('mouseenter', fromPoint, win);
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointermove', fromPoint, win);
            }
            createEventAtPoint('mousemove', fromPoint, win);
            if (syn.support.pointerEvents) {
                createEventAtPoint('pointerdown', fromPoint, win);
            }
            if (syn.support.touchEvents) {
                createEventAtPoint('touchstart', fromPoint, win);
            }
            createEventAtPoint('mousedown', fromPoint, win);
            startMove(win, fromPoint, toPoint, duration, function () {
                if (syn.support.pointerEvents) {
                    createEventAtPoint('pointerup', toPoint, win);
                }
                if (syn.support.touchEvents) {
                    createEventAtPoint('touchend', toPoint, win);
                }
                createEventAtPoint('mouseup', toPoint, win);
                if (syn.support.pointerEvents) {
                    createEventAtPoint('pointerleave', toPoint, win);
                }
                createEventAtPoint('mouseleave', toPoint, win);
                callback();
            });
        }, center = function (el) {
            var j = syn.jquery()(el), o = j.offset();
            return {
                pageX: o.left + j.outerWidth() / 2,
                pageY: o.top + j.outerHeight() / 2
            };
        }, convertOption = function (option, win, from) {
            var page = /(\d+)[x ](\d+)/, client = /(\d+)X(\d+)/, relative = /([+-]\d+)[xX ]([+-]\d+)/, parts;
            if (typeof option === 'string' && relative.test(option) && from) {
                var cent = center(from);
                parts = option.match(relative);
                option = {
                    pageX: cent.pageX + parseInt(parts[1]),
                    pageY: cent.pageY + parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && page.test(option)) {
                parts = option.match(page);
                option = {
                    pageX: parseInt(parts[1]),
                    pageY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string' && client.test(option)) {
                parts = option.match(client);
                option = {
                    clientX: parseInt(parts[1]),
                    clientY: parseInt(parts[2])
                };
            }
            if (typeof option === 'string') {
                option = syn.jquery()(option, win.document)[0];
            }
            if (option.nodeName) {
                option = center(option);
            }
            if (option.pageX != null) {
                var off = syn.helpers.scrollOffset(win);
                option = {
                    clientX: option.pageX - off.left,
                    clientY: option.pageY - off.top
                };
            }
            return option;
        }, adjust = function (from, to, win) {
            if (from.clientY < 0) {
                var off = syn.helpers.scrollOffset(win);
                var top = off.top + from.clientY - 100, diff = top - off.top;
                if (top > 0) {
                } else {
                    top = 0;
                    diff = -off.top;
                }
                from.clientY = from.clientY - diff;
                to.clientY = to.clientY - diff;
                syn.helpers.scrollOffset(win, {
                    top: top,
                    left: off.left
                });
            }
        };
    syn.helpers.extend(syn.init.prototype, {
        _move: function (from, options, callback) {
            var win = syn.helpers.getWindow(from);
            var sourceCoordinates = convertOption(options.from || from, win, from);
            var destinationCoordinates = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(sourceCoordinates, destinationCoordinates, win);
            }
            startMove(win, sourceCoordinates, destinationCoordinates, options.duration || 500, callback);
        },
        _drag: function (from, options, callback) {
            var win = syn.helpers.getWindow(from);
            var sourceCoordinates = convertOption(options.from || from, win, from);
            var destinationCoordinates = convertOption(options.to || options, win, from);
            if (options.adjust !== false) {
                adjust(sourceCoordinates, destinationCoordinates, win);
            }
            var html5draggable = from.draggable;
            if (html5draggable) {
                DragonDrop.dragAndDrop(win, sourceCoordinates, destinationCoordinates, options.duration || 500, callback);
            } else {
                startDrag(win, sourceCoordinates, destinationCoordinates, options.duration || 500, callback);
            }
        }
    });
});
/*syn@0.13.0#syn*/
define('syn@0.13.0#syn', [
    'require',
    'exports',
    'module',
    './synthetic',
    './mouse.support',
    './browsers',
    './key.support',
    './drag'
], function (require, exports, module) {
    var syn = require('./synthetic');
    require('./mouse.support');
    require('./browsers');
    require('./key.support');
    require('./drag');
    window.syn = syn;
    module.exports = syn;
});
/*funcunit@3.6.3#browser/open*/
define('funcunit@3.6.3#browser/open', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core',
    'syn'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = require('syn');
    if (FuncUnit.frameMode) {
        var ifrm = document.createElement('iframe');
        ifrm.id = 'funcunit_app';
        document.body.insertBefore(ifrm, document.body.firstChild);
    }
    var confirms = [], prompts = [], currentDocument, currentHref, appWin, lookingForNewDocument = false, urlWithoutHash = function (url) {
            return url.replace(/\#.*$/, '');
        }, isCurrentPage = function (url) {
            var pathname = urlWithoutHash(FuncUnit.win.location.pathname), href = urlWithoutHash(FuncUnit.win.location.href), url = urlWithoutHash(url);
            if (pathname === url || href === url) {
                return true;
            }
            return false;
        };
    $.extend(FuncUnit, {
        open: function (path, success, timeout) {
            if (typeof success != 'function') {
                timeout = success;
                success = undefined;
            }
            FuncUnit.add({
                method: function (success, error) {
                    if (typeof path === 'string') {
                        var fullPath = FuncUnit.getAbsolutePath(path);
                        FuncUnit._open(fullPath, error);
                        FuncUnit._onload(function () {
                            success();
                        }, error);
                    } else {
                        FuncUnit.win = path;
                        success();
                    }
                },
                success: success,
                error: 'Page ' + path + ' not loaded in time!',
                timeout: timeout || 30000
            });
        },
        _open: function (url) {
            FuncUnit.win = appWin;
            hasSteal = false;
            FuncUnit.frame = $('#funcunit_app').length ? $('#funcunit_app')[0] : null;
            if (newPage) {
                if (FuncUnit.frame) {
                    FuncUnit.win = FuncUnit.frame.contentWindow;
                    FuncUnit.win.location = url;
                } else {
                    var width = $(window).width();
                    FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,width=' + width / 2 + ',left=' + width / 2);
                    if (FuncUnit.win && FuncUnit.win.___FUNCUNIT_OPENED) {
                        FuncUnit.win.close();
                        FuncUnit.win = window.open(url, 'funcunit', 'height=1000,toolbar=yes,status=yes,left=' + width / 2);
                    }
                    if (!FuncUnit.win) {
                        throw 'Could not open a popup window.  Your popup blocker is probably on.  Please turn it off and try again';
                    }
                }
                appWin = FuncUnit.win;
            } else {
                lookingForNewDocument = true;
                if (isCurrentPage(url)) {
                    FuncUnit.win.document.body.parentNode.removeChild(FuncUnit.win.document.body);
                    FuncUnit.win.location.hash = url.split('#')[1] || '';
                    FuncUnit.win.location.reload(true);
                } else {
                    FuncUnit.win.location = url;
                }
                currentDocument = null;
            }
            lookingForNewDocument = true;
        },
        confirm: function (answer) {
            confirms.push(!!answer);
        },
        prompt: function (answer) {
            prompts.push(answer);
        },
        _opened: function () {
            if (!this._isOverridden('alert')) {
                FuncUnit.win.alert = function () {
                };
            }
            if (!this._isOverridden('confirm')) {
                FuncUnit.win.confirm = function () {
                    var res = confirms.shift();
                    return res;
                };
            }
            if (!this._isOverridden('prompt')) {
                FuncUnit.win.prompt = function () {
                    return prompts.shift();
                };
            }
        },
        _isOverridden: function (type) {
            return !/(native code)|(source code not available)/.test(FuncUnit.win[type]);
        },
        _onload: function (success, error) {
            loadSuccess = function () {
                if (FuncUnit.win.steal) {
                    hasSteal = true;
                }
                if (!hasSteal) {
                    return success();
                }
                FuncUnit.win.steal.done().then(success);
            };
            if (!newPage) {
                return;
            }
            newPage = false;
            if (FuncUnit.support.readystate) {
                poller();
            } else {
                unloadLoader();
            }
        },
        getAbsolutePath: function (path) {
            if (/^\/\//.test(path)) {
                path = path.substr(2);
            }
            return path;
        },
        win: window,
        support: { readystate: 'readyState' in document },
        eval: function (str) {
            return FuncUnit.win.eval(str);
        },
        documentLoaded: function () {
            var loaded = FuncUnit.win.document.readyState === 'complete' && FuncUnit.win.location.href != 'about:blank' && FuncUnit.win.document.body;
            return loaded;
        },
        checkForNewDocument: function () {
            var documentFound = false;
            try {
                documentFound = (FuncUnit.win.document !== currentDocument && !FuncUnit.win.___FUNCUNIT_OPENED || currentHref != FuncUnit.win.location.href) && FuncUnit.documentLoaded();
            } catch (e) {
            }
            if (documentFound) {
                lookingForNewDocument = false;
                currentDocument = FuncUnit.win.document;
                currentHref = FuncUnit.win.location.href;
                FuncUnit.win.___FUNCUNIT_OPENED = true;
                FuncUnit._opened();
            }
            return documentFound;
        }
    });
    var newPage = true, hasSteal = false, unloadLoader, loadSuccess, firstLoad = true, onload = function () {
            FuncUnit.win.document.documentElement.tabIndex = 0;
            setTimeout(function () {
                FuncUnit.win.focus();
                var ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    ls();
                }
            }, 0);
            syn.unbind(FuncUnit.win, 'load', onload);
        }, onunload = function () {
            FuncUnit.stop = true;
            removeListeners();
            setTimeout(unloadLoader, 0);
        }, removeListeners = function () {
            syn.unbind(FuncUnit.win, 'unload', onunload);
            Syn.unbind(FuncUnit.win, 'load', onload);
        };
    unloadLoader = function () {
        if (!firstLoad)
            removeListeners();
        syn.bind(FuncUnit.win, 'load', onload);
        syn.bind(FuncUnit.win, 'unload', onunload);
    };
    var newDocument = false, poller = function () {
            var ls;
            if (lookingForNewDocument && FuncUnit.checkForNewDocument()) {
                ls = loadSuccess;
                loadSuccess = null;
                if (ls) {
                    FuncUnit.win.focus();
                    FuncUnit.win.document.documentElement.tabIndex = 0;
                    ls();
                }
            }
            setTimeout(arguments.callee, 500);
        };
    $(window).unload(function () {
        if (FuncUnit.win && FuncUnit.win !== window.top) {
            FuncUnit.win.close();
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#browser/actions*/
define('funcunit@3.6.3#browser/actions', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core',
    'syn'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var syn = window.syn = require('syn');
    var clicks = [
            'click',
            'dblclick',
            'rightClick'
        ], makeClick = function (name) {
            FuncUnit.prototype[name] = function (options, success) {
                this._addExists();
                if (typeof options == 'function') {
                    success = options;
                    options = {};
                }
                var selector = this.selector;
                FuncUnit.add({
                    method: function (success, error) {
                        options = options || {};
                        syn('_' + name, this.bind[0], options, success);
                    },
                    success: success,
                    error: 'Could not ' + name + ' \'' + this.selector + '\'',
                    bind: this,
                    type: 'action'
                });
                return this;
            };
        };
    for (var i = 0; i < clicks.length; i++) {
        makeClick(clicks[i]);
    }
    $.extend(FuncUnit.prototype, {
        _addExists: function () {
            this.exists(false);
        },
        type: function (text, success) {
            this._addExists();
            this.click();
            var selector = this.selector;
            if (text === '') {
                text = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], text, success);
                },
                success: success,
                error: 'Could not type ' + text + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        sendKeys: function (keys, success) {
            this._addExists();
            var selector = this.selector;
            if (keys === '') {
                keys = '[ctrl]a[ctrl-up]\b';
            }
            FuncUnit.add({
                method: function (success, error) {
                    syn('_type', this.bind[0], keys, success);
                },
                success: success,
                error: 'Could not send the keys ' + keys + ' into ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        trigger: function (evName, success) {
            this._addExists();
            FuncUnit.add({
                method: function (success, error) {
                    if (!FuncUnit.win.jQuery) {
                        throw 'Can not trigger custom event, no jQuery found on target page.';
                    }
                    FuncUnit.win.jQuery(this.bind.selector).trigger(evName);
                    success();
                },
                success: success,
                error: 'Could not trigger ' + evName,
                bind: this,
                type: 'action'
            });
            return this;
        },
        drag: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_drag', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not drag ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        move: function (options, success) {
            this._addExists();
            if (typeof options == 'string') {
                options = { to: options };
            }
            options.from = this.selector;
            var selector = this.selector;
            FuncUnit.add({
                method: function (success, error) {
                    syn('_move', this.bind[0], options, success);
                },
                success: success,
                error: 'Could not move ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        },
        scroll: function (direction, amount, success) {
            this._addExists();
            var selector = this.selector, direction;
            if (direction == 'left' || direction == 'right') {
                direction = 'Left';
            } else if (direction == 'top' || direction == 'bottom') {
                direction = 'Top';
            }
            FuncUnit.add({
                method: function (success, error) {
                    this.bind.each(function (i, el) {
                        this['scroll' + direction] = amount;
                    });
                    success();
                },
                success: success,
                error: 'Could not scroll ' + this.selector,
                bind: this,
                type: 'action'
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#browser/getters*/
define('funcunit@3.6.3#browser/getters', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.funcs = {
        'size': 0,
        'attr': 1,
        'hasClass': 1,
        'html': 0,
        'text': 0,
        'val': 0,
        'css': 1,
        'prop': 1,
        'offset': 0,
        'position': 0,
        'scrollTop': 0,
        'scrollLeft': 0,
        'height': 0,
        'width': 0,
        'innerHeight': 0,
        'innerWidth': 0,
        'outerHeight': 0,
        'outerWidth': 0
    };
    FuncUnit.makeFunc = function (fname, argIndex) {
        var orig = FuncUnit.fn[fname];
        FuncUnit.prototype[fname] = function () {
            var args = FuncUnit.makeArray(arguments), isWait = args.length > argIndex, success, self = this;
            args.unshift(this.selector, this.frame, fname);
            if (isWait) {
                var tester = args[argIndex + 3], timeout = args[argIndex + 4], success = args[argIndex + 5], message = args[argIndex + 6], testVal = tester, errorMessage = 'waiting for ' + fname + ' on ' + this.selector, frame = this.frame, logMessage = 'Checking ' + fname + ' on \'' + this.selector + '\'', ret;
                if (typeof tester == 'object' && !(tester instanceof RegExp)) {
                    timeout = tester.timeout;
                    success = tester.success;
                    message = tester.message;
                    if (tester.errorMessage) {
                        errorMessage = tester.errorMessage;
                    }
                    if (typeof tester.logMessage !== 'undefined') {
                        logMessage = tester.logMessage;
                    }
                    tester = tester.condition;
                }
                if (typeof timeout == 'function') {
                    message = success;
                    success = timeout;
                    timeout = undefined;
                }
                if (typeof timeout == 'string') {
                    message = timeout;
                    timeout = undefined;
                    success = undefined;
                }
                if (typeof message !== 'string') {
                    message = undefined;
                }
                args.splice(argIndex + 3, args.length - argIndex - 3);
                if (typeof tester != 'function') {
                    errorMessage += ' !== ' + testVal;
                    tester = function (val) {
                        return FuncUnit.unit.equiv(val, testVal) || testVal instanceof RegExp && testVal.test(val);
                    };
                }
                if (message) {
                    errorMessage = message;
                }
                FuncUnit.repeat({
                    method: function (print) {
                        if (this.bind.prevObject && this.bind.prevTraverser) {
                            var prev = this.bind;
                            this.bind = this.bind.prevObject[this.bind.prevTraverser](this.bind.prevTraverserSelector);
                            this.bind.prevTraverser = prev.prevTraverser;
                            this.bind.prevTraverserSelector = prev.prevTraverserSelector;
                        } else {
                            this.bind = F(this.selector, {
                                frame: frame,
                                forceSync: true
                            });
                        }
                        if (logMessage) {
                            print(logMessage);
                        }
                        var methodArgs = [];
                        if (argIndex > 0) {
                            methodArgs.push(args[3]);
                        }
                        FuncUnit._ignoreGetterError = true;
                        ret = this.bind[fname].apply(this.bind, methodArgs);
                        FuncUnit._ignoreGetterError = false;
                        var passed = tester.call(this.bind, ret);
                        if (this.bind.length === 0 && fname !== 'size') {
                            passed = false;
                        }
                        if (passed) {
                            if (!FuncUnit.documentLoaded()) {
                                passed = false;
                            } else {
                                FuncUnit.checkForNewDocument();
                            }
                        }
                        return passed;
                    },
                    success: function () {
                        if (message) {
                            FuncUnit.unit.assertOK(true, message);
                        }
                        success && success.apply(this, arguments);
                    },
                    error: function () {
                        var msg = errorMessage;
                        if (ret) {
                            msg += ', actual value: ' + ret;
                        }
                        FuncUnit.unit.assertOK(false, msg);
                    },
                    timeout: timeout,
                    bind: this,
                    type: 'wait'
                });
                return this;
            } else {
                if (!FuncUnit._ignoreGetterError && !FuncUnit._incallback && FuncUnit._haveAsyncQueries()) {
                    console && console.error('You can\'t run getters after actions and waits. Please put your getters in a callback or at the beginning of the test.');
                }
                var methodArgs = [];
                if (argIndex > 0) {
                    methodArgs.push(args[3]);
                }
                return orig.apply(this, methodArgs);
            }
        };
    };
    for (var prop in FuncUnit.funcs) {
        FuncUnit.makeFunc(prop, FuncUnit.funcs[prop]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#browser/traversers*/
define('funcunit@3.6.3#browser/traversers', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    var traversers = [
            'closest',
            'next',
            'prev',
            'siblings',
            'last',
            'first',
            'find'
        ], makeTraverser = function (name) {
            var orig = FuncUnit.prototype[name];
            FuncUnit.prototype[name] = function (selector) {
                var args = arguments;
                if (FuncUnit.win && this[0] && this[0].parentNode && this[0].parentNode.nodeType !== 9) {
                    FuncUnit.add({
                        method: function (success, error) {
                            var newBind = orig.apply(this.bind, args);
                            newBind.prevTraverser = name;
                            newBind.prevTraverserSelector = selector;
                            success(newBind);
                        },
                        error: 'Could not traverse: ' + name + ' ' + selector,
                        bind: this
                    });
                }
                return orig.apply(this, arguments);
            };
        };
    for (var i = 0; i < traversers.length; i++) {
        makeTraverser(traversers[i]);
    }
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#browser/queue*/
define('funcunit@3.6.3#browser/queue', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        var FuncUnit = require('funcunit/browser/core');
        FuncUnit._incallback = false;
        var currentPosition = 0, startedQueue = false;
        FuncUnit.speed = 0;
        FuncUnit.timeout = 10000;
        FuncUnit._queue = [];
        FuncUnit._needSyncQuery = function () {
            if (FuncUnit._queue.length === 1) {
                if (FuncUnit._queue[0].type === 'query') {
                    FuncUnit._queue = [];
                    return true;
                }
            }
            if (FuncUnit._queue.length === 0) {
                return true;
            }
            return false;
        };
        FuncUnit._lastQueuedItem = function () {
            if (!FuncUnit._queue.length) {
                return null;
            }
            return FuncUnit._queue[FuncUnit._queue.length - 1];
        };
        FuncUnit._haveAsyncQueries = function () {
            for (var i = 0; i < FuncUnit._queue.length; i++) {
                if (FuncUnit._queue[i].type === 'action' || FuncUnit._queue[i].type === 'wait')
                    return true;
            }
            return false;
        };
        FuncUnit.add = function (handler, error, context) {
            if (handler instanceof Function) {
                if (typeof error === 'object') {
                    context = error;
                    delete error;
                }
                error = error && error.toString() || 'Custom method has failed.';
                var cb = handler;
                handler = {
                    method: function (success, error) {
                        success();
                    },
                    success: cb,
                    error: error,
                    bind: context
                };
            }
            if (FuncUnit._incallback) {
                FuncUnit._queue.splice(currentPosition, 0, handler);
                currentPosition++;
            } else {
                FuncUnit._queue.push(handler);
            }
            if (FuncUnit._queue.length == 1 && !FuncUnit._incallback) {
                FuncUnit.unit.pauseTest();
                setTimeout(FuncUnit._done, 13);
            }
        };
        var currentEl;
        FuncUnit._done = function (el, selector) {
            var next, timer, speed = FuncUnit.speed || 0;
            if (FuncUnit.speed === 'slow') {
                speed = 500;
            }
            if (FuncUnit._queue.length > 0) {
                next = FuncUnit._queue.shift();
                currentPosition = 0;
                setTimeout(function () {
                    timer = setTimeout(function () {
                        next.stop && next.stop();
                        if (typeof next.error === 'function') {
                            next.error();
                        } else {
                            FuncUnit.unit.assertOK(false, next.error);
                        }
                        FuncUnit._done();
                    }, (next.timeout || FuncUnit.timeout) + speed);
                    if (el && el.jquery) {
                        currentEl = el;
                    }
                    if (currentEl) {
                        next.bind = currentEl;
                    }
                    next.selector = selector;
                    next.method(function (el) {
                        if (el && el.jquery) {
                            next.bind = el;
                        }
                        clearTimeout(timer);
                        FuncUnit._incallback = true;
                        if (next.success) {
                            next.success.apply(next.bind, arguments);
                        }
                        FuncUnit._incallback = false;
                        FuncUnit._done(next.bind, next.selector);
                    }, function (message) {
                        clearTimeout(timer);
                        FuncUnit.unit.assertOK(false, message);
                        FuncUnit._done();
                    });
                }, speed);
            } else {
                FuncUnit.unit.resumeTest();
            }
        };
        module.exports = FuncUnit;
    }(function () {
        return this;
    }(), require, exports, module));
});
/*funcunit@3.6.3#browser/waits*/
define('funcunit@3.6.3#browser/waits', [
    'require',
    'exports',
    'module',
    'funcunit/browser/jquery',
    'funcunit/browser/core'
], function (require, exports, module) {
    var $ = require('funcunit/browser/jquery');
    var FuncUnit = require('funcunit/browser/core');
    FuncUnit.wait = function (time, success) {
        if (typeof time == 'function') {
            success = time;
            time = undefined;
        }
        time = time != null ? time : 5000;
        FuncUnit.add({
            method: function (success, error) {
                setTimeout(success, time);
            },
            success: success,
            error: 'Couldn\'t wait!',
            timeout: time + 1000
        });
        return this;
    };
    FuncUnit.branch = function (check1, success1, check2, success2, timeout) {
        FuncUnit.repeat({
            method: function (print) {
                print('Running a branch statement');
                if (check1()) {
                    success1();
                    return true;
                }
                if (check2()) {
                    success2();
                    return true;
                }
            },
            error: 'no branch condition was ever true',
            timeout: timeout,
            type: 'branch'
        });
    };
    FuncUnit.repeat = function (options) {
        var interval, stopped = false, stop = function () {
                clearTimeout(interval);
                stopped = true;
            };
        FuncUnit.add({
            method: function (success, error) {
                options.bind = this.bind;
                options.selector = this.selector;
                var printed = false, print = function (msg) {
                        if (!printed) {
                            printed = true;
                        }
                    };
                interval = setTimeout(function () {
                    var result = null;
                    try {
                        result = options.method(print);
                    } catch (e) {
                    }
                    if (result) {
                        success(options.bind);
                    } else if (!stopped) {
                        interval = setTimeout(arguments.callee, 10);
                    }
                }, 10);
            },
            success: options.success,
            error: options.error,
            timeout: options.timeout,
            stop: stop,
            bind: options.bind,
            type: options.type
        });
    };
    FuncUnit.animationEnd = function () {
        F('body').wait(200).size(function () {
            return F.win.$(':animated').length === 0;
        });
    };
    FuncUnit.animationsDone = FuncUnit.animationEnd;
    $.extend(FuncUnit.prototype, {
        exists: function (timeout, success, message) {
            var logMessage = 'Waiting for \'' + this.selector + '\' to exist';
            if (timeout === false) {
                logMessage = false;
            }
            return this.size({
                condition: function (size) {
                    return size > 0;
                },
                timeout: timeout,
                success: success,
                message: message,
                errorMessage: 'Exist failed: element with selector \'' + this.selector + '\' not found',
                logMessage: logMessage
            });
        },
        missing: function (timeout, success, message) {
            return this.size(0, timeout, success, message);
        },
        visible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === true;
            }, timeout, success, message);
        },
        invisible: function (timeout, success, message) {
            var self = this, sel = this.selector, ret;
            return this.size(function (size) {
                return this.is(':visible') === false;
            }, timeout, success, message);
        },
        wait: function (checker, timeout, success, message) {
            if (typeof checker === 'number') {
                timeout = checker;
                FuncUnit.wait(timeout, success);
                return this;
            } else {
                return this.size(checker, timeout, success, message);
            }
        },
        then: function (success) {
            var self = this;
            FuncUnit.wait(0, function () {
                success.call(this, this);
            });
            return this;
        }
    });
    module.exports = FuncUnit;
});
/*funcunit@3.6.3#funcunit*/
define('funcunit@3.6.3#funcunit', [
    'require',
    'exports',
    'module',
    'funcunit/browser/core',
    'funcunit/browser/adapters/',
    'funcunit/browser/open',
    'funcunit/browser/actions',
    'funcunit/browser/getters',
    'funcunit/browser/traversers',
    'funcunit/browser/queue',
    'funcunit/browser/waits'
], function (require, exports, module) {
    var FuncUnit = require('funcunit/browser/core');
    require('funcunit/browser/adapters/');
    require('funcunit/browser/open');
    require('funcunit/browser/actions');
    require('funcunit/browser/getters');
    require('funcunit/browser/traversers');
    require('funcunit/browser/queue');
    require('funcunit/browser/waits');
    window.FuncUnit = window.S = window.F = FuncUnit;
    module.exports = FuncUnit;
});
/*can@3.14.0#docs/can-guides/experiment/todomvc/test*/
define('can@3.14.0#docs/can-guides/experiment/todomvc/test', [
    'require',
    'exports',
    'module',
    'steal-qunit',
    'funcunit'
], function (require, exports, module) {
    var QUnit = require('steal-qunit');
    var F = require('funcunit');
    F.attach(QUnit);
    QUnit.module('todomvc', {
        beforeEach: function (assert) {
            localStorage.clear();
        }
    });
    QUnit.test('basics work', function () {
        F('li.todo', 0).size(3, 'there are 3 todos');
        F('#new-todo', 0).type('new thing\r');
        F('li.todo', 0).size(4, 'new todo added');
    });
});
/*can@3.14.0#test/integration/all/test*/
define('can@3.14.0#test/integration/all/test', [
    'require',
    'exports',
    'module',
    'steal-qunit'
], function (require, exports, module) {
    (function (__dirname, require, exports, module) {
        var QUnit = require('steal-qunit');
        var makeIframe = function (src) {
            var iframe = document.createElement('iframe');
            window.removeMyself = function () {
                delete window.removeMyself;
                document.body.removeChild(iframe);
                QUnit.start();
            };
            document.body.appendChild(iframe);
            iframe.src = src;
        };
        QUnit.module('can.all.js');
        if (__dirname !== '/') {
            QUnit.asyncTest('works without jquery', function () {
                makeIframe(__dirname + '/no-jquery.html?' + Math.random());
            });
        }
    }('/', require, exports, module));
});
/*can@3.14.0#test/test*/
define('can@3.14.0#test/test', [
    'require',
    'exports',
    'module',
    '../component/component_test',
    '../compute/compute_test',
    '../construct/construct_test',
    'can-construct-super/test/can-construct-super_test',
    'can-define/test/test',
    'can-set/test/test',
    'can-stache-bindings/test/bindings-test',
    'can-stache-converters/test/test',
    'can-deparam/can-deparam-test',
    'can-param/can-param-test',
    '../event/event_test',
    '../util/util_test',
    '../view/import/import_test',
    '../view/live/live_test',
    'can-view-model/test/test',
    '../view/node_lists/node_lists_test',
    '../view/parser/parser_test',
    '../view/scope/scope_test',
    '../view/autorender/autorender_test',
    'can-view-target/test/test',
    'can-simple-dom/test/test',
    'can-simple-observable/can-simple-observable-test',
    'can-symbol/can-symbol-test',
    'can-reflect/can-reflect-test',
    'can-reflect-promise/test/can-reflect-promise_test',
    'can-ajax/can-ajax-test',
    'can-globals/can-globals-test',
    'can-define-lazy-value/define-lazy-value-test',
    'can-assign/can-assign-test',
    'can-dom-events/can-dom-events-test',
    'can-event-dom-enter/can-event-dom-enter-test',
    'can-event-dom-radiochange/can-event-dom-radiochange-test',
    'can-parse-uri/can-parse-uri-test',
    'can-validate-interface/test',
    '../control/control_test',
    '../list/list_test',
    '../map/map_test',
    'can-map-define/can-map-define_test',
    'can-view-href/test/test',
    'can-map-backup/can-map-backup_test',
    'can-validate-legacy/can-validate-test',
    '../view/ejs/ejs_test',
    'can-fixture/test/fixture_test',
    'can-connect-signalr/test',
    'can-connect-cloneable/test/test',
    'can-kefir/can-kefir-test',
    'can-stream/can-stream_test',
    'can-stream-kefir/can-stream-kefir_test',
    'can-ndjson-stream/can-ndjson-stream-test',
    'can-connect-ndjson/test/can-connect-ndjson-test',
    'can-observe/test',
    'can-define-stream/can-define-stream_test',
    'can-define-stream-kefir/can-define-stream-kefir_test',
    'react-view-model/test/test#?can/test/browser-supports-react',
    'can-react-component/test/test#?can/test/browser-supports-react',
    'can-zone-storage/test/can-zone-storage_zone-test',
    '../docs/can-guides/experiment/todomvc/test',
    './integration/all/test'
], function (require, exports, module) {
    (function (global, require, exports, module) {
        require('../component/component_test');
        require('../compute/compute_test');
        require('../construct/construct_test');
        require('can-construct-super/test/can-construct-super_test');
        require('can-define/test/test');
        require('can-set/test/test');
        require('can-stache-bindings/test/bindings-test');
        require('can-stache-converters/test/test');
        require('can-deparam/can-deparam-test');
        require('can-param/can-param-test');
        require('../event/event_test');
        require('../util/util_test');
        require('../view/import/import_test');
        require('../view/live/live_test');
        require('can-view-model/test/test');
        require('../view/node_lists/node_lists_test');
        require('../view/parser/parser_test');
        require('../view/scope/scope_test');
        require('../view/autorender/autorender_test');
        require('can-view-target/test/test');
        require('can-simple-dom/test/test');
        require('can-simple-observable/can-simple-observable-test');
        require('can-symbol/can-symbol-test');
        require('can-reflect/can-reflect-test');
        require('can-reflect-promise/test/can-reflect-promise_test');
        require('can-ajax/can-ajax-test');
        require('can-globals/can-globals-test');
        require('can-define-lazy-value/define-lazy-value-test');
        require('can-assign/can-assign-test');
        require('can-dom-events/can-dom-events-test');
        require('can-event-dom-enter/can-event-dom-enter-test');
        require('can-event-dom-radiochange/can-event-dom-radiochange-test');
        require('can-parse-uri/can-parse-uri-test');
        require('can-validate-interface/test');
        require('../control/control_test');
        require('../list/list_test');
        require('../map/map_test');
        require('can-map-define/can-map-define_test');
        require('can-view-href/test/test');
        require('can-map-backup/can-map-backup_test');
        require('can-validate-legacy/can-validate-test');
        require('../view/ejs/ejs_test');
        require('can-fixture/test/fixture_test');
        require('can-connect-signalr/test');
        require('can-connect-cloneable/test/test');
        require('can-kefir/can-kefir-test');
        require('can-stream/can-stream_test');
        require('can-stream-kefir/can-stream-kefir_test');
        require('can-ndjson-stream/can-ndjson-stream-test');
        require('can-connect-ndjson/test/can-connect-ndjson-test');
        if (typeof Proxy === 'function') {
            require('can-observe/test');
        }
        require('can-define-stream/can-define-stream_test');
        require('can-define-stream-kefir/can-define-stream-kefir_test');
        require('react-view-model/test/test#?can/test/browser-supports-react');
        require('can-react-component/test/test#?can/test/browser-supports-react');
        require('can-zone-storage/test/can-zone-storage_zone-test');
        require('../docs/can-guides/experiment/todomvc/test');
        require('./integration/all/test');
    }(function () {
        return this;
    }(), require, exports, module));
});